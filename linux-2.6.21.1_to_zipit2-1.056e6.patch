Index: build_tree/linux/.config
diff -u /dev/null build_tree/linux/.config:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:40 2008
+++ build_tree/linux/.config	Fri Nov  9 13:47:41 2007
@@ -0,0 +1,1173 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.21.1
+# Wed Sep 19 09:53:50 2007
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+CONFIG_AUDIT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rfs"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
+CONFIG_ARCH_PXA=y
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Intel PXA2xx Implementations
+#
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_MACH_LOGICPD_PXA270 is not set
+CONFIG_MACH_MAINSTONE=y
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_PXA_SHARPSL is not set
+# CONFIG_MACH_TRIZEPS4 is not set
+CONFIG_PXA27x=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+CONFIG_IWMMXT=y
+CONFIG_XSCALE_PMU=y
+
+#
+# Bus support
+#
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyS2,115200"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=m
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_LEGACY is not set
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+# CONFIG_APM_EMULATION is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_FIB_RULES=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=m
+CONFIG_MTD_ROM=m
+CONFIG_MTD_ABSENT=m
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_MAINSTONE=y
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_SHARP_SL is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_IPMI_WATCHDOG=m
+# CONFIG_IPMI_POWEROFF is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=m
+# CONFIG_SA1100_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_PXA=m
+# CONFIG_I2C_PXA_SLAVE is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_PXA2XX=m
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_PXA=y
+# CONFIG_FB_PXA_PARAMETERS is not set
+# CONFIG_FB_MBX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+CONFIG_LOGO_ZIPIT=y
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+# CONFIG_SND_PXA2XX_AC97 is not set
+
+#
+# SoC audio support
+#
+CONFIG_SND_SOC=m
+
+#
+# SoC Platforms
+#
+
+#
+# SoC Audio for the Atmel AT91
+#
+
+#
+# SoC Audio for the Intel PXA2xx
+#
+CONFIG_SND_PXA2XX_SOC=m
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID Devices
+#
+# CONFIG_HID is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_PXA=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# PXA gpio driver
+#
+CONFIG_GPIO=m
+
+#
+# PXA audio driver
+#
+CONFIG_AUDIODRV=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
Index: build_tree/linux/.config.old
diff -u /dev/null build_tree/linux/.config.old:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:40 2008
+++ build_tree/linux/.config.old	Fri Nov  9 13:47:41 2007
@@ -0,0 +1,1172 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.21.1
+# Fri Sep 14 16:45:22 2007
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+CONFIG_AUDIT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rfs"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
+CONFIG_ARCH_PXA=y
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Intel PXA2xx Implementations
+#
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_MACH_LOGICPD_PXA270 is not set
+CONFIG_MACH_MAINSTONE=y
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_PXA_SHARPSL is not set
+# CONFIG_MACH_TRIZEPS4 is not set
+CONFIG_PXA27x=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+CONFIG_IWMMXT=y
+CONFIG_XSCALE_PMU=y
+
+#
+# Bus support
+#
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyS2,115200"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=m
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_LEGACY is not set
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+# CONFIG_APM_EMULATION is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_FIB_RULES=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=m
+CONFIG_MTD_ROM=m
+CONFIG_MTD_ABSENT=m
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_MAINSTONE=y
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_SHARP_SL is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_IPMI_WATCHDOG=m
+# CONFIG_IPMI_POWEROFF is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=m
+# CONFIG_SA1100_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_PXA=m
+# CONFIG_I2C_PXA_SLAVE is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_PXA2XX=m
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_PXA=y
+# CONFIG_FB_PXA_PARAMETERS is not set
+# CONFIG_FB_MBX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+# CONFIG_SND_PXA2XX_AC97 is not set
+
+#
+# SoC audio support
+#
+CONFIG_SND_SOC=m
+
+#
+# SoC Platforms
+#
+
+#
+# SoC Audio for the Atmel AT91
+#
+
+#
+# SoC Audio for the Intel PXA2xx
+#
+CONFIG_SND_PXA2XX_SOC=m
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID Devices
+#
+# CONFIG_HID is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_PXA=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# PXA gpio driver
+#
+CONFIG_GPIO=m
+
+#
+# PXA audio driver
+#
+CONFIG_AUDIODRV=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
Index: build_tree/linux/.version
diff -u /dev/null build_tree/linux/.version:1.4
--- /dev/null	Tue Jan  8 14:21:40 2008
+++ build_tree/linux/.version	Tue Nov 20 17:09:59 2007
@@ -0,0 +1 @@
+165
Index: build_tree/linux/arch/arm/Kconfig
diff -u build_tree/linux/arch/arm/Kconfig:1.1.1.1 build_tree/linux/arch/arm/Kconfig:1.1.1.2
--- build_tree/linux/arch/arm/Kconfig:1.1.1.1	Thu Nov  8 14:26:38 2007
+++ build_tree/linux/arch/arm/Kconfig	Fri Nov  9 13:47:43 2007
@@ -997,6 +997,10 @@
 
 source "drivers/rtc/Kconfig"
 
+source "drivers/gpio/Kconfig"
+
+source "drivers/audiodrv/Kconfig"
+
 endmenu
 
 source "fs/Kconfig"
Index: build_tree/linux/arch/arm/Makefile
diff -u build_tree/linux/arch/arm/Makefile:1.1.1.1 build_tree/linux/arch/arm/Makefile:1.1.1.2
--- build_tree/linux/arch/arm/Makefile:1.1.1.1	Thu Nov  8 14:26:38 2007
+++ build_tree/linux/arch/arm/Makefile	Fri Nov  9 13:47:43 2007
@@ -180,6 +180,8 @@
 drivers-$(CONFIG_OPROFILE)      += arch/arm/oprofile/
 drivers-$(CONFIG_ARCH_CLPS7500)	+= drivers/acorn/char/
 drivers-$(CONFIG_ARCH_L7200)	+= drivers/acorn/char/
+drivers-$(CONFIG_GPIO)          += drivers/gpio/ 
+drivers-$(CONFIG_AUDIODRV)      += drivers/audiodrv/
 
 libs-y				:= arch/arm/lib/ $(libs-y)
 
Index: build_tree/linux/arch/arm/boot/compressed/vmlinux.lds
diff -u /dev/null build_tree/linux/arch/arm/boot/compressed/vmlinux.lds:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:40 2008
+++ build_tree/linux/arch/arm/boot/compressed/vmlinux.lds	Fri Nov  9 13:47:44 2007
@@ -0,0 +1,56 @@
+/*
+ *  linux/arch/arm/boot/compressed/vmlinux.lds.in
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0;
+  _text = .;
+
+  .text : {
+    _start = .;
+    *(.start)
+    *(.text)
+    *(.text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata)
+    *(.rodata.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.piggydata)
+    . = ALIGN(4);
+  }
+
+  _etext = .;
+
+  _got_start = .;
+  .got			: { *(.got) }
+  _got_end = .;
+  .got.plt		: { *(.got.plt) }
+  .data			: { *(.data) }
+  _edata = .;
+
+  . = ALIGN(4);
+  __bss_start = .;
+  .bss			: { *(.bss) }
+  _end = .;
+
+  .stack (NOLOAD)	: { *(.stack) }
+
+  .stab 0		: { *(.stab) }
+  .stabstr 0		: { *(.stabstr) }
+  .stab.excl 0		: { *(.stab.excl) }
+  .stab.exclstr 0	: { *(.stab.exclstr) }
+  .stab.index 0		: { *(.stab.index) }
+  .stab.indexstr 0	: { *(.stab.indexstr) }
+  .comment 0		: { *(.comment) }
+}
+
Index: build_tree/linux/arch/arm/kernel/process.c
diff -u build_tree/linux/arch/arm/kernel/process.c:1.1.1.1 build_tree/linux/arch/arm/kernel/process.c:1.1.1.2
--- build_tree/linux/arch/arm/kernel/process.c:1.1.1.1	Thu Nov  8 14:26:38 2007
+++ build_tree/linux/arch/arm/kernel/process.c	Fri Nov  9 13:47:43 2007
@@ -131,7 +131,9 @@
 		local_irq_disable();
 		if (!need_resched()) {
 			timer_dyn_reprogram();
+			//GPSR2 = 0x02000000;
 			arch_idle();
+			//GPCR2 = 0x02000000;
 		}
 		local_irq_enable();
 	}
Index: build_tree/linux/arch/arm/kernel/vmlinux.lds
diff -u /dev/null build_tree/linux/arch/arm/kernel/vmlinux.lds:1.2
--- /dev/null	Tue Jan  8 14:21:40 2008
+++ build_tree/linux/arch/arm/kernel/vmlinux.lds	Fri Nov 16 16:37:12 2007
@@ -0,0 +1,436 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.21.1
+ * Wed Sep 19 09:53:53 2007
+ */
+/* ld script to make ARM Linux kernel
+ * taken from the i386 version by Russell King
+ * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>
+ */
+/* Align . to a 8 byte boundary equals to maximum function alignment. */
+/* sched.text is aling to function alignment to secure we have same
+ * address even at second ld pass when generating System.map */
+
+
+
+
+
+
+/* spinlock.text is aling to function alignment to secure we have same
+ * address even at second ld pass when generating System.map */
+  /* DWARF debug sections.
+		Symbols in the DWARF debugging sections are relative to
+		the beginning of the section so we begin them at 0.  */
+  /* Stabs debugging sections.  */
+/*
+ *  linux/include/asm-arm/thread_info.h
+ *
+ *  Copyright (C) 2002 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/*
+ * Allow us to mark functions as 'deprecated' and have gcc emit a nice
+ * warning for each use, in hopes of speeding the functions removal.
+ * Usage is:
+ * 		int __deprecated foo(void)
+ */
+/*
+ * Allow us to avoid 'defined but not used' warnings on functions and data,
+ * as well as force them to be emitted to the assembly file.
+ *
+ * As of gcc 3.3, static functions that are not marked with attribute((used))
+ * may be elided from the assembly file.  As of gcc 3.3, static data not so
+ * marked will not be elided, but this may change in a future gcc version.
+ *
+ * In prior versions of gcc, such functions and data would be emitted, but
+ * would be warned about except with attribute((unused)).
+ */
+
+
+
+
+/*
+ * From the GCC manual:
+ *
+ * Many functions have no effects except the return value and their
+ * return value depends only on the parameters and/or global
+ * variables.  Such a function can be subject to common subexpression
+ * elimination and loop optimization just as an arithmetic operator
+ * would be.
+ * [...]
+ */
+/*
+ * From the GCC manual:
+ *
+ * Many functions do not examine any values except their arguments,
+ * and have no effects except the return value.  Basically this is
+ * just slightly more strict class than the `pure' attribute above,
+ * since function is not allowed to read global memory.
+ *
+ * Note that a function that has pointer arguments and examines the
+ * data pointed to must _not_ be declared `const'.  Likewise, a
+ * function that calls a non-`const' function usually must not be
+ * `const'.  It does not make sense for a `const' function to return
+ * `void'.
+ */
+
+
+
+
+
+
+/*
+ *  linux/include/asm-arm/fpstate.h
+ *
+ *  Copyright (C) 1995 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/*
+ * We use bit 30 of the preempt_count to indicate that kernel
+ * preemption is occurring.  See include/asm-arm/hardirq.h.
+ */
+
+
+/*
+ * thread information flags:
+ *  TIF_SYSCALL_TRACE	- syscall trace active
+ *  TIF_NOTIFY_RESUME	- resumption notification requested
+ *  TIF_SIGPENDING	- signal pending
+ *  TIF_NEED_RESCHED	- rescheduling necessary
+ *  TIF_USEDFPU		- FPU was used by this task this quantum (SMP)
+ *  TIF_POLLING_NRFLAG	- true if poll_idle() is polling TIF_NEED_RESCHED
+ */
+/*
+ * Change these and you break ASM code in entry-common.S
+ */
+
+
+
+
+
+/*
+ *  linux/include/asm-arm/memory.h
+ *
+ *  Copyright (C) 2000-2002 Russell King
+ *  modification for nommu, Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Note: this file should not be included by non-asm/.h files
+ */
+
+
+
+/*
+ * Allow for constants defined here to be used from assembly code
+ * by prepending the UL suffix only with actual C code compilation.
+ */
+/*
+ *  linux/include/asm-arm/arch-pxa/memory.h
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+
+
+/*
+ * Physical DRAM offset.
+ */
+
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+
+
+
+/*
+ * The nodes are matched with the physical SDRAM banks as follows:
+ *
+ * 	node 0:  0xa0000000-0xa3ffffff	-->  0xc0000000-0xc3ffffff
+ * 	node 1:  0xa4000000-0xa7ffffff	-->  0xc4000000-0xc7ffffff
+ * 	node 2:  0xa8000000-0xabffffff	-->  0xc8000000-0xcbffffff
+ * 	node 3:  0xac000000-0xafffffff	-->  0xcc000000-0xcfffffff
+ *
+ * This needs a node mem size of 26 bits.
+ */
+
+
+
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+
+
+
+/* handy sizes */
+/*         END */
+
+
+
+
+/*
+ * TASK_SIZE - the maximum size of a user space task.
+ * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area
+ */
+
+
+
+
+/*
+ * The maximum size of a 26-bit user space task.
+ */
+
+
+/*
+ * Page offset: 3GB
+ */
+
+
+
+
+/*
+ * The module space lives between the addresses given by TASK_SIZE
+ * and PAGE_OFFSET - it must be within 32MB of the kernel text.
+ */
+
+
+
+
+
+
+
+/*
+ * The XIP kernel gets mapped at the bottom of the module vm area.
+ * Since we use sections to map it, this macro replaces the physical address
+ * with its virtual address while keeping offset from the base section.
+ */
+
+
+/*
+ * Allow 16MB-aligned ioremap pages
+ */
+/*
+ * Size of DMA-consistent memory region.  Must be multiple of 2M,
+ * between 2MB and 14MB inclusive.
+ */
+
+
+
+
+/*
+ * Physical vs virtual RAM address space conversion.  These are
+ * private definitions which should NOT be used outside memory.h
+ * files.  Use virt_to_phys/phys_to_virt/__pa/__va instead.
+ */
+
+
+
+
+
+/*
+ * Convert a physical address to a Page Frame Number and back
+ */
+OUTPUT_ARCH(arm)
+ENTRY(stext)
+
+
+jiffies = jiffies_64;
+
+
+
+
+SECTIONS
+{
+
+
+
+ . = (0xc0000000) + 0x00008000;
+
+ .init : { /* Init code and data		*/
+  _stext = .;
+   _sinittext = .;
+   *(.init.text)
+   _einittext = .;
+  __proc_info_begin = .;
+   *(.proc.info.init)
+  __proc_info_end = .;
+  __arch_info_begin = .;
+   *(.arch.info.init)
+  __arch_info_end = .;
+  __tagtable_begin = .;
+   *(.taglist.init)
+  __tagtable_end = .;
+  . = ALIGN(16);
+  __setup_start = .;
+   *(.init.setup)
+  __setup_end = .;
+  __early_begin = .;
+   *(.early_param.init)
+  __early_end = .;
+  __initcall_start = .;
+   *(.initcall0.init) *(.initcall0s.init) *(.initcall1.init) *(.initcall1s.init) *(.initcall2.init) *(.initcall2s.init) *(.initcall3.init) *(.initcall3s.init) *(.initcall4.init) *(.initcall4s.init) *(.initcall5.init) *(.initcall5s.init) *(.initcallrootfs.init) *(.initcall6.init) *(.initcall6s.init) *(.initcall7.init) *(.initcall7s.init)
+  __initcall_end = .;
+  __con_initcall_start = .;
+   *(.con_initcall.init)
+  __con_initcall_end = .;
+  __security_initcall_start = .;
+   *(.security_initcall.init)
+  __security_initcall_end = .;
+
+  . = ALIGN(32);
+  __initramfs_start = .;
+   usr/built-in.o(.init.ramfs)
+  __initramfs_end = .;
+
+  . = ALIGN(64);
+  __per_cpu_start = .;
+   *(.data.percpu)
+  __per_cpu_end = .;
+
+  __init_begin = _stext;
+  *(.init.data)
+  . = ALIGN(4096);
+  __init_end = .;
+
+ }
+
+ /DISCARD/ : { /* Exit code and data		*/
+  *(.exit.text)
+  *(.exit.data)
+  *(.exitcall.exit)
+
+
+
+
+ }
+
+ .text : { /* Real text segment		*/
+  _text = .; /* Text and read-only data	*/
+   *(.text)
+   . = ALIGN(8); __sched_text_start = .; *(.sched.text) __sched_text_end = .;
+   . = ALIGN(8); __lock_text_start = .; *(.spinlock.text) __lock_text_end = .;
+
+   *(.fixup)
+
+   *(.gnu.warning)
+   *(.rodata)
+   *(.rodata.*)
+   *(.glue_7)
+   *(.glue_7t)
+  *(.got) /* Global offset table		*/
+ }
+
+ . = ALIGN(4096); .rodata : AT(ADDR(.rodata) - 0) { __start_rodata = .; *(.rodata) *(.rodata.*) *(__vermagic) } .rodata1 : AT(ADDR(.rodata1) - 0) { *(.rodata1) } .pci_fixup : AT(ADDR(.pci_fixup) - 0) { __start_pci_fixups_early = .; *(.pci_fixup_early) __end_pci_fixups_early = .; __start_pci_fixups_header = .; *(.pci_fixup_header) __end_pci_fixups_header = .; __start_pci_fixups_final = .; *(.pci_fixup_final) __end_pci_fixups_final = .; __start_pci_fixups_enable = .; *(.pci_fixup_enable) __end_pci_fixups_enable = .; __start_pci_fixups_resume = .; *(.pci_fixup_resume) __end_pci_fixups_resume = .; } .rio_route : AT(ADDR(.rio_route) - 0) { __start_rio_route_ops = .; *(.rio_route_ops) __end_rio_route_ops = .; } __ksymtab : AT(ADDR(__ksymtab) - 0) { __start___ksymtab = .; *(__ksymtab) __stop___ksymtab = .; } __ksymtab_gpl : AT(ADDR(__ksymtab_gpl) - 0) { __start___ksymtab_gpl = .; *(__ksymtab_gpl) __stop___ksymtab_gpl = .; } __ksymtab_unused : AT(ADDR(__ksymtab_unused) - 0) { __start___ksymtab_unused = .; *(__ksymtab_unused) __stop___ksymtab_unused = .; } __ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - 0) { __start___ksymtab_unused_gpl = .; *(__ksymtab_unused_gpl) __stop___ksymtab_unused_gpl = .; } __ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - 0) { __start___ksymtab_gpl_future = .; *(__ksymtab_gpl_future) __stop___ksymtab_gpl_future = .; } __kcrctab : AT(ADDR(__kcrctab) - 0) { __start___kcrctab = .; *(__kcrctab) __stop___kcrctab = .; } __kcrctab_gpl : AT(ADDR(__kcrctab_gpl) - 0) { __start___kcrctab_gpl = .; *(__kcrctab_gpl) __stop___kcrctab_gpl = .; } __kcrctab_unused : AT(ADDR(__kcrctab_unused) - 0) { __start___kcrctab_unused = .; *(__kcrctab_unused) __stop___kcrctab_unused = .; } __kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - 0) { __start___kcrctab_unused_gpl = .; *(__kcrctab_unused_gpl) __stop___kcrctab_unused_gpl = .; } __kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - 0) { __start___kcrctab_gpl_future = .; *(__kcrctab_gpl_future) __stop___kcrctab_gpl_future = .; } __ksymtab_strings : AT(ADDR(__ksymtab_strings) - 0) { *(__ksymtab_strings) } __param : AT(ADDR(__param) - 0) { __start___param = .; *(__param) __stop___param = .; __end_rodata = .; } . = ALIGN(4096);
+
+ _etext = .; /* End of text and rodata section */
+
+
+
+
+
+ . = ALIGN(8192);
+ __data_loc = .;
+
+
+ .data : AT(__data_loc) {
+  __data_start = .; /* address in memory */
+
+  /*
+		 * first, the init task union, aligned
+		 * to an 8192 byte boundary.
+		 */
+  *(.init.task)
+  . = ALIGN(4096);
+  __nosave_begin = .;
+  *(.data.nosave)
+  . = ALIGN(4096);
+  __nosave_end = .;
+
+  /*
+		 * then the cacheline aligned data
+		 */
+  . = ALIGN(32);
+  *(.data.cacheline_aligned)
+
+  /*
+		 * The exception fixup table (might need resorting at runtime)
+		 */
+  . = ALIGN(32);
+  __start___ex_table = .;
+
+  *(__ex_table)
+
+  __stop___ex_table = .;
+
+  /*
+		 * and the usual data section
+		 */
+  *(.data)
+  CONSTRUCTORS
+
+  _edata = .;
+ }
+ _edata_loc = __data_loc + SIZEOF(.data);
+
+ .bss : {
+  __bss_start = .; /* BSS				*/
+  *(.bss)
+  *(COMMON)
+  _end = .;
+ }
+     /* Stabs debugging sections.	*/
+ .stab 0 : { *(.stab) }
+ .stabstr 0 : { *(.stabstr) }
+ .stab.excl 0 : { *(.stab.excl) }
+ .stab.exclstr 0 : { *(.stab.exclstr) }
+ .stab.index 0 : { *(.stab.index) }
+ .stab.indexstr 0 : { *(.stab.indexstr) }
+ .comment 0 : { *(.comment) }
+}
+
+/*
+ * These must never be empty
+ * If you have to comment these two assert statements out, your
+ * binutils is too old (for other reasons as well)
+ */
+ASSERT((__proc_info_end - __proc_info_begin), "missing CPU support")
+ASSERT((__arch_info_end - __arch_info_begin), "no machine record defined")
Index: build_tree/linux/arch/arm/mach-pxa/mainstone.c
diff -u build_tree/linux/arch/arm/mach-pxa/mainstone.c:1.1.1.1 build_tree/linux/arch/arm/mach-pxa/mainstone.c:1.1.1.2
--- build_tree/linux/arch/arm/mach-pxa/mainstone.c:1.1.1.1	Thu Nov  8 14:26:38 2007
+++ build_tree/linux/arch/arm/mach-pxa/mainstone.c	Fri Nov  9 13:47:43 2007
@@ -108,6 +108,7 @@
 
 	set_irq_chained_handler(IRQ_GPIO(0), mainstone_irq_handler);
 	set_irq_type(IRQ_GPIO(0), IRQT_FALLING);
+
 }
 
 #ifdef CONFIG_PM
@@ -262,6 +263,69 @@
 	},
 };
 
+
+#ifdef ZIPIT2
+static void Zipit2_lcd_power(int on, struct fb_var_screeninfo *var)
+{
+	printk(KERN_NOTICE "Set Zipit2 lcd power %d...\n",on);
+#if 0
+	if (on) {
+		IDP_CPLD_LCD |= (1<<0);
+	} else {
+		IDP_CPLD_LCD &= ~(1<<0);
+	}
+
+	/* call idp_vlcd for now as core driver does not support
+	 * both power and vlcd hooks.  Note, this is not technically
+	 * the correct sequence, but seems to work.  Disclaimer:
+	 * this may eventually damage the display.
+	 */
+
+	idp_vlcd(on);
+#endif
+}
+
+static void Zipit2_backlight_power(int on)
+{
+	printk(KERN_NOTICE "Set Zipit2 backlight %d...\n",on);
+#if 0
+	if (on) {
+		pxa_gpio_mode(GPIO16_PWM0_MD);
+		pxa_set_cken(CKEN0_PWM0, 1);
+		PWM_CTRL0 = 0x30;
+		PWM_PWDUTY0 = (0x80 << 2);
+		PWM_PERVAL0 = 0x3FC;
+	} else {
+		PWM_CTRL0 = 0;
+		PWM_PWDUTY0 = 0x0;
+		PWM_PERVAL0 = 0x3FF;
+		pxa_set_cken(CKEN0_PWM0, 0);
+	}
+#endif
+}
+
+static struct pxafb_mode_info Zipit2_lcd_mode = {
+	.pixclock		= LCD_PIXCLOCK,
+	.xres			= LCD_XRES,
+	.yres			= LCD_YRES,
+	.bpp			= LCD_BPP,
+	.hsync_len		= LCD_HORIZONTAL_SYNC_PULSE_WIDTH,
+	.left_margin	= LCD_BEGIN_OF_LINE_WAIT_COUNT,
+	.right_margin	= LCD_END_OF_LINE_WAIT_COUNT,
+	.vsync_len		= LCD_VERTICAL_SYNC_PULSE_WIDTH,
+	.upper_margin	= LCD_BEGIN_FRAME_WAIT_COUNT,
+	.lower_margin	= LCD_END_OF_FRAME_WAIT_COUNT,
+	.sync			= LCD_SYNC,
+};
+
+static struct pxafb_mach_info Zipit2_pxafb_info = {
+	.num_modes      	= 1,
+	.lccr0			= LCD_LCCR0,
+	.lccr3			= LCD_LCCR3,
+	.pxafb_backlight_power	= Zipit2_backlight_power,
+	.pxafb_lcd_power = &Zipit2_lcd_power
+};
+#else
 static void mainstone_backlight_power(int on)
 {
 	if (on) {
@@ -277,7 +341,6 @@
 		pxa_set_cken(CKEN0_PWM0, 0);
 	}
 }
-
 static struct pxafb_mode_info toshiba_ltm04c380k_mode = {
 	.pixclock		= 50000,
 	.xres			= 640,
@@ -311,7 +374,9 @@
 	.lccr0			= LCCR0_Act,
 	.lccr3			= LCCR3_PCP,
 	.pxafb_backlight_power	= mainstone_backlight_power,
+
 };
+#endif //end check for ZIPIT2
 
 static int mainstone_mci_init(struct device *dev, irq_handler_t mstone_detect_int, void *data)
 {
@@ -332,8 +397,10 @@
 	 */
 	MST_MSCWR1 &= ~MST_MSCWR1_MS_SEL;
 
-	err = request_irq(MAINSTONE_MMC_IRQ, mstone_detect_int, IRQF_DISABLED,
-			     "MMC card detect", data);
+	set_irq_type(IRQ_GPIO(96), IRQT_BOTHEDGE);
+
+	err = request_irq(IRQ_GPIO(96), mstone_detect_int, IRQF_DISABLED,"MMC card detect", data);
+
 	if (err) {
 		printk(KERN_ERR "mainstone_mci_init: MMC/SD: can't request MMC card detect IRQ\n");
 		return -1;
@@ -366,6 +433,7 @@
 	.init 		= mainstone_mci_init,
 	.setpower 	= mainstone_mci_setpower,
 	.exit		= mainstone_mci_exit,
+	.detect_delay = 100,
 };
 
 static void mainstone_irda_transceiver_mode(struct device *dev, int mode)
@@ -417,6 +485,17 @@
 	.init		= mainstone_ohci_init,
 };
 
+static void mainstone_poweroff(void)
+{
+	int nUserArg = 7;		// deep sleep
+	asm( "mcr p14, 0, %0, c7, c0, 0" :: "r" (nUserArg) );
+}
+
+static void mainstone_restart(char mode)
+{
+	// write the PMSR with a special value to make BLOB come on up
+	arm_machine_restart('h');
+}
 static void __init mainstone_init(void)
 {
 	int SW7 = 0;  /* FIXME: get from SCR (Mst doc section 3.2.1.1) */
@@ -441,10 +520,18 @@
 	 * On Mainstone, we route AC97_SYSCLK via GPIO45 to
 	 * the audio daughter card
 	 */
+#ifndef ZIPIT2
 	pxa_gpio_mode(GPIO45_SYSCLK_AC97_MD);
-
+#endif
 	platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
 
+#ifdef ZIPIT2
+	printk(KERN_NOTICE "Set Zipit2 lcd paramaters...\n");
+
+	Zipit2_pxafb_info.modes = &Zipit2_lcd_mode;
+
+	set_pxa_fb_info(&Zipit2_pxafb_info);
+#else
 	/* reading Mainstone's "Virtual Configuration Register"
 	   might be handy to select LCD type here */
 	if (0)
@@ -453,10 +540,15 @@
 		mainstone_pxafb_info.modes = &toshiba_ltm035a776c_mode;
 
 	set_pxa_fb_info(&mainstone_pxafb_info);
+#endif
 
 	pxa_set_mci_info(&mainstone_mci_platform_data);
 	pxa_set_ficp_info(&mainstone_ficp_platform_data);
 	pxa_set_ohci_info(&mainstone_ohci_platform_data);
+
+	pm_power_off = mainstone_poweroff;
+	arm_pm_restart = mainstone_restart;
+
 }
 
 
@@ -474,6 +566,7 @@
 	pxa_map_io();
 	iotable_init(mainstone_io_desc, ARRAY_SIZE(mainstone_io_desc));
 
+#ifdef JWK
 	/* initialize sleep mode regs (wake-up sources, etc) */
 	PGSR0 = 0x00008800;
 	PGSR1 = 0x00000002;
@@ -491,6 +584,7 @@
  	PKWR  = 0x000FD000;
  	/*	Need read PKWR back after set it.	*/
  	PKWR;
+#endif
 }
 
 MACHINE_START(MAINSTONE, "Intel HCDDBBVA0 Development Platform (aka Mainstone)")
Index: build_tree/linux/drivers/Makefile
diff -u build_tree/linux/drivers/Makefile:1.1.1.1 build_tree/linux/drivers/Makefile:1.1.1.2
--- build_tree/linux/drivers/Makefile:1.1.1.1	Thu Nov  8 14:26:56 2007
+++ build_tree/linux/drivers/Makefile	Fri Nov  9 13:48:02 2007
@@ -4,7 +4,6 @@
 # 15 Sep 2000, Christoph Hellwig <hch@infradead.org>
 # Rewritten to use lists instead of if-statements.
 #
-
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
@@ -81,3 +80,4 @@
 obj-$(CONFIG_DMA_ENGINE)	+= dma/
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
+
Index: build_tree/linux/drivers/audiodrv/Kconfig
diff -u /dev/null build_tree/linux/drivers/audiodrv/Kconfig:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/audiodrv/Kconfig	Fri Nov  9 13:48:09 2007
@@ -0,0 +1,15 @@
+#
+# Misc strange devices
+#
+
+menu "PXA audio driver"
+
+config AUDIODRV
+	tristate "Device driver for PXA audio"
+	depends on ARCH_PXA
+	---help---
+	  This option enables device driver support for PXA gpio.
+
+	  If unsure, say N.
+
+endmenu
Index: build_tree/linux/drivers/audiodrv/Makefile
diff -u /dev/null build_tree/linux/drivers/audiodrv/Makefile:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/audiodrv/Makefile	Fri Nov  9 13:48:09 2007
@@ -0,0 +1,5 @@
+#
+# Makefile for gpio driver.
+#
+
+obj-$(CONFIG_AUDIODRV)	:= audio_pxa.o
Index: build_tree/linux/drivers/audiodrv/audio_pxa.c
diff -u /dev/null build_tree/linux/drivers/audiodrv/audio_pxa.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/audiodrv/audio_pxa.c	Fri Nov  9 13:48:10 2007
@@ -0,0 +1,290 @@
+/*
+ *	PXA Audio Driver
+ *
+ *	Copyright (C) 2007 Aeronix
+ *
+ *	This driver allows controls the audio on the PXA processor
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/arch/pxa-regs.h>
+#include "audio_pxa.h"
+
+extern void* dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp);
+extern void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle);
+
+static struct file_operations audio_driver_fops = {
+		owner:			THIS_MODULE,
+		llseek:			no_llseek,
+		read:			audio_read_method,
+		write:          audio_write_method,
+        ioctl:          audio_ioctl_method,
+        open:           audio_open_method,
+        release:        audio_release_method,
+};
+
+
+static void mcp_enable(void)
+{
+	int i;
+	int nGpioMode;
+
+	pBuffer = (char *) dma_alloc_coherent(NULL, BUFFSIZE, (dma_addr_t *)&pBufferPhys,GFP_KERNEL);
+
+	pDescs = (char *) dma_alloc_coherent(NULL, sizeof(DmaDesc) * 16, (dma_addr_t *)&pDescsPhys,GFP_KERNEL);
+
+	memset(pBuffer, 0, BUFFSIZE);
+
+//	printk(KERN_INFO "Buffer Address: virt(0x%08lX), phys(0x%08lX)\n", (long unsigned int)pBuffer, (long unsigned int)pBufferPhys);
+//	printk(KERN_INFO  "Descriptor Address: virt(0x%08lX), phys(0x%08lX)\n", (long unsigned int)pDescs, (long unsigned int)pDescsPhys);
+
+	// configure the descriptors
+	for(i = 0; i < 16; i++)
+	{
+		pDescs[i].DDADR = &pDescsPhys[i + 1];
+		pDescs[i].DSADR = &pBufferPhys[i * 6 * 1024];
+		pDescs[i].DTADR = 0x40400080;
+		pDescs[i].DCMD = 0x9003D800;		// src inc, target flow, size 32 bytes, width 4 bytes, 6K length
+
+	}
+
+	pDescs[15].DDADR = &pDescsPhys[0];		// reloop DMA descriptors
+
+#if 0
+	for(i = 0; i < 16; i++)
+	{
+		printk(KERN_INFO "DDADR[%d]: 0x%08lX\n", i, pDescs[i].DDADR);
+		printk(KERN_INFO "DSADR[%d]: 0x%08lX\n", i, pDescs[i].DSADR);
+		printk(KERN_INFO "DTADR[%d]: 0x%08lX\n", i, pDescs[i].DTADR);
+		printk(KERN_INFO " DCMD[%d]: 0x%08lX\n", i, pDescs[i].DCMD);
+		printk(KERN_INFO "\n");
+	}
+#endif
+	// configure the DMA channel
+
+	DRCMR3 = 0x8F;		// I2S DMA Channel Map (Channel 15)
+	DCSR15 = 0x00000000;	// DMA Control/Status15 (Descriptors used)
+
+	DDADR15 = &pDescsPhys[0];	// DMA Descriptor Address (Channel 15)
+	DCSR15 = 0x80000000;		// DMA Control/Status15 (Start the DMA)
+
+	// configure I2S
+    nGpioMode = 113 | GPIO_ALT_FN_1_OUT;
+	pxa_gpio_mode(nGpioMode);
+
+    nGpioMode = 28 | GPIO_ALT_FN_1_OUT;
+	pxa_gpio_mode(nGpioMode);
+
+    nGpioMode = 29 | GPIO_ALT_FN_1_IN;
+	pxa_gpio_mode(nGpioMode);
+
+    nGpioMode = 30 | GPIO_ALT_FN_1_OUT;
+	pxa_gpio_mode(nGpioMode);
+
+    nGpioMode = 31 | GPIO_ALT_FN_1_OUT;
+	pxa_gpio_mode(nGpioMode);
+
+    nGpioMode = 37 | GPIO_IN;
+    pxa_gpio_mode(nGpioMode);
+
+//	printk(KERN_INFO "CKEN: 0x%08lX\n", CKEN);
+	CKEN |= 0x100;			// clk to I2S
+//	printk(KERN_INFO "CKEN: 0x%08lX\n", CKEN);
+	SACR1 |= 0x9;				// Disable record and MSB format
+	SADIV = 0xD;				// BITCLK divisor to 44.1KHz
+	SACR0 |= 0x7705;			// BITCLK output and Enable I2S
+
+	pWriteAddress = pBuffer;
+
+//	printk(KERN_INFO "mcp_enable - exit\n");
+}
+
+static int __init audio_driver_init(void)
+{
+	int rc;
+
+	if ( (rc = register_chrdev(MCP_MAJOR,"audio",&audio_driver_fops)) )
+		printk(KERN_WARNING "DAI: Unable to get major %d for MCP\n",MCP_MAJOR);
+	else
+		printk(KERN_INFO "DAI: DAI Enable with major = %d\n", MCP_MAJOR);
+	
+	return rc;
+}
+
+static void __exit audio_driver_exit(void)
+{
+	printk(KERN_NOTICE "Remove Audio driver...\n");
+	unregister_chrdev(MCP_MAJOR, "audio");
+
+
+}
+
+/* FILE FOPS */
+static ssize_t audio_read_method (struct file *file, char *buf, size_t count, loff_t *offset)
+{
+  int ret = 0;
+
+  return ret;
+}
+
+static ssize_t audio_write_method (struct file *file, const char *buf, size_t count, loff_t *offset)
+{
+	char *pFirstWrite;
+	char *pSecondWrite;
+	unsigned long ulFirstAmount;
+	unsigned long ulSecondAmount;
+	unsigned long ulAvailable;
+	unsigned long ulWritten;
+	unsigned long ulToWrite;
+
+	char * pReadAddress = (char *) DSADR15 - pBufferPhys + pBuffer;		// get current processing address
+
+//	printk(KERN_INFO "count: 0x%08lX, pRead: 0x%08lX, pWrite: 0x%08lX\n", count, pReadAddress, pWriteAddress );
+	if(buf == 0)
+	{
+//		printk(KERN_INFO "count: 0x%08lX, buf: 0x%08lX\n", count, buf );
+
+		if(count == 0)
+		{
+//			printk(KERN_INFO "Initialize playback\n");
+
+			DCSR15 = 0x00000000;						// DMA Control/Status15 (Stop the DMA)
+
+			memset(pBuffer, 0, BUFFSIZE);
+
+			DDADR15 = DDADR15;
+			DCSR15 = 0x80000000;						// DMA Control/Status15 (Start the DMA)
+		}
+		else
+		if(count == 1)
+		{
+//			printk(KERN_INFO "Stop playback\n");
+
+			DCSR15 = 0x00000000;						// DMA Control/Status15 (Stop the DMA)
+		}
+		else
+		if(count == 2)
+		{
+//			printk(KERN_INFO "Resume playback: 0x%08lX, 0x%08lX\n", AccessReg(0x03C), AccessReg(0x2F0));
+
+			DDADR15 = DDADR15;
+			DCSR15 = 0x80000000;						// DMA Control/Status15 (Start the DMA)
+		}
+
+		return 0;
+	}
+
+	if(pWriteAddress > pReadAddress)
+	{
+		ulAvailable = BUFFSIZE - (pWriteAddress - pReadAddress);
+
+		pFirstWrite = pWriteAddress;
+		ulFirstAmount = BUFFSIZE - (pWriteAddress - &pBuffer[0]);
+
+		ulSecondAmount = ulAvailable - ulFirstAmount;
+		pSecondWrite = &pBuffer[0];
+	}
+	else
+	{
+		ulAvailable = pReadAddress - pWriteAddress;
+
+		pFirstWrite = pWriteAddress;
+		ulFirstAmount = ulAvailable;
+
+		pSecondWrite = 0;
+		ulSecondAmount = 0;
+	}
+
+//	printk(KERN_INFO "1st: 0x%08lX, 0x%08lX, 2nd: 0x%08lX, 0x%08lX\n", pFirstWrite, ulFirstAmount, pSecondWrite, ulSecondAmount );
+
+	if((ulAvailable < count) && (ulAvailable < (BUFFSIZE / 2)))
+	{
+//		printk(KERN_INFO "mcp_write:QUEUE_FULL\n");
+		return 0;
+	}
+
+	ulWritten = 0;
+	ulToWrite = count - ulWritten;
+	if (ulToWrite > ulFirstAmount)
+		ulToWrite = ulFirstAmount;
+
+//	printk(KERN_INFO "1st: 0x%08lX, 0x%08lX\n", pFirstWrite, ulToWrite );
+	copy_from_user(pFirstWrite, buf, ulToWrite);
+	pWriteAddress += ulToWrite;
+	ulWritten += ulToWrite;
+
+	if(pWriteAddress >= (&pBuffer[0] + BUFFSIZE))
+	{
+		pWriteAddress = &pBuffer[0];
+	}
+	
+	if((ulWritten < count) && pSecondWrite)
+	{
+		ulToWrite = count - ulWritten;
+
+		if (ulToWrite > ulSecondAmount)
+			ulToWrite = ulSecondAmount;
+
+//		printk(KERN_INFO "2nd: 0x%08lX, 0x%08lX\n", pSecondWrite, ulToWrite );
+		copy_from_user(pSecondWrite, &buf[ulWritten], ulToWrite);
+		pWriteAddress = pSecondWrite + ulToWrite;
+		ulWritten += ulToWrite;
+	}
+
+	if(pWriteAddress >= (&pBuffer[0] + BUFFSIZE))
+	{
+		pWriteAddress = &pBuffer[0];
+	}
+	
+	return (ssize_t)ulWritten;
+}
+
+static int audio_ioctl_method (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static int audio_open_method (struct inode *inode, struct file *file)
+{
+	int nRtnValue = 0;
+	int minor;
+	dev_t device = inode->i_rdev;
+
+	minor = MINOR(device);
+	printk(KERN_INFO "audio_open_method: MINOR=%d\n", minor);
+
+	mcp_enable();
+
+	return nRtnValue;
+}
+
+static int audio_release_method (struct inode *inode, struct file *file)
+{
+	DCSR15 = 0x00000000;						// DMA Control/Status15 (Stop the DMA)
+
+	printk(KERN_INFO "audio_release\n");
+
+
+	dma_free_coherent(NULL, sizeof(DmaDesc) * 16, (void*)pDescs, (dma_addr_t)pDescsPhys);
+	dma_free_coherent(NULL, BUFFSIZE, (void*)pBuffer, (dma_addr_t)pBufferPhys);
+
+	return 0;
+}
+
+module_init(audio_driver_init);
+module_exit(audio_driver_exit);
+
+MODULE_AUTHOR("Aeronix");
+MODULE_LICENSE("GPL");
Index: build_tree/linux/drivers/audiodrv/audio_pxa.h
diff -u /dev/null build_tree/linux/drivers/audiodrv/audio_pxa.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/audiodrv/audio_pxa.h	Fri Nov  9 13:48:09 2007
@@ -0,0 +1,40 @@
+#ifndef __AUDIO_PXA_H_
+#define __AUDIO_PXA_H_
+
+
+#define MCP_MAJOR 14
+
+static void mcp_enable(void);
+
+const unsigned long PxaRegsOffset = 0x40000000;
+
+#define AccessReg(offset) *((volatile unsigned long *)(PxaRegsOffset + offset))
+
+char * pWriteAddress;
+
+typedef struct tagDmaDesc
+{
+	unsigned long DDADR;
+	unsigned long DSADR;
+	unsigned long DTADR;
+	unsigned long DCMD;
+} DmaDesc;
+
+#define BUFFSIZE (16 * 6 * 1024)
+
+char *pBuffer;
+char *pBufferPhys;
+
+DmaDesc *pDescs;
+DmaDesc * pDescsPhys;
+
+/* FILE FOPS */
+static ssize_t audio_read_method (struct file *file, char *buf, size_t count, loff_t *offset);
+static ssize_t audio_write_method (struct file *file, const char *buf, size_t count, loff_t *offset);
+static int audio_ioctl_method (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int audio_open_method (struct inode *inode, struct file *file);
+static int audio_release_method (struct inode *inode, struct file *file);
+
+ 
+#endif //__AUDIO_PXA_H_
+
Index: build_tree/linux/drivers/gpio/Kconfig
diff -u /dev/null build_tree/linux/drivers/gpio/Kconfig:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/gpio/Kconfig	Fri Nov  9 13:48:27 2007
@@ -0,0 +1,15 @@
+#
+# Misc strange devices
+#
+
+menu "PXA gpio driver"
+
+config GPIO
+	tristate "Device driver for PXA gpio"
+	depends on ARCH_PXA
+	---help---
+	  This option enables device driver support for PXA gpio.
+
+	  If unsure, say N.
+
+endmenu
Index: build_tree/linux/drivers/gpio/Makefile
diff -u /dev/null build_tree/linux/drivers/gpio/Makefile:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/gpio/Makefile	Fri Nov  9 13:48:27 2007
@@ -0,0 +1,5 @@
+#
+# Makefile for gpio driver.
+#
+
+obj-$(CONFIG_GPIO)	:= gpio_driver.o
Index: build_tree/linux/drivers/gpio/gpio_driver.c
diff -u /dev/null build_tree/linux/drivers/gpio/gpio_driver.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/gpio/gpio_driver.c	Fri Nov  9 13:48:27 2007
@@ -0,0 +1,479 @@
+/*
+ *	PXA GPIO Driver
+ *
+ *	Copyright (C) 2007 Aeronix
+ *
+ *	This driver allows controls the gpios on the PXA processor
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/gpio-ioctl.h>
+#include <asm/uaccess.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/arch/pxa-regs.h>
+#include "gpio_driver.h"
+
+extern void kernel_restart(char *cmd);
+
+extern int pxa_gpio_mode( int gpio_mode );
+extern int pxa_gpio_get_value(unsigned gpio);
+extern void pxa_gpio_set_value(unsigned gpio, int value);
+//extern void pxa_set_pwrmode(unsigned int nPwrMode);
+
+static void HandleWriteCameraFrameData(int nFrameBufferAddress)
+{
+	unsigned long * pulStartOfFrameBufferLine = (unsigned long*)nFrameBufferAddress;
+	unsigned long * pulCurrentFrameBufferPosistion = pulStartOfFrameBufferLine;
+
+	unsigned long ulCICR0data = CICR0;
+	unsigned long ulCISRdata;
+	unsigned long ulCIBR0data;
+	unsigned long ulCIFRdata;
+
+	unsigned long ulPixelData;
+	unsigned int ulPrintCount = 0;
+
+	int nIgnore;
+
+	int nNumberOfLines = 0;
+	int nNumberOfPixels = 0;
+
+	printk(KERN_INFO "HandleWriteCameraFrameData 0x%lX:0x%lX\n",(unsigned long) pulStartOfFrameBufferLine,(unsigned long) CICR1);
+	ulCICR0data |= 0x10000000;
+
+	CICR0 = ulCICR0data;
+	
+	//find start of frame
+	do
+	{
+		ulCISRdata = CISR;
+
+	}while((ulCISRdata & 0x10) == 0);
+
+	//writeback to clear sticky bit
+	CISR = ulCISRdata;
+
+
+	//find start of frame
+	do
+	{
+		ulCISRdata = CISR;
+
+		ulCIBR0data = CIBR0;
+
+	}while((ulCISRdata & 0x1000) == 0);
+
+	//writeback to clear sticky bit
+	CISR = ulCISRdata;
+
+
+	printk(KERN_INFO "Camera get frame data.\n");
+
+
+	do
+	{
+		nNumberOfPixels = 0;
+
+		do
+		{
+			do
+			{
+				ulCIFRdata = CIFR;
+
+			}while((ulCIFRdata & 0xfc00) == 0);
+
+
+			ulCIBR0data = CIBR0;
+
+			ulPixelData = ((ulCIBR0data & 0xffff0000) >> 16) | ((ulCIBR0data & 0x0000ffff) << 16);
+
+			ulPrintCount++;
+
+			nIgnore = copy_to_user((u32 *) pulCurrentFrameBufferPosistion, &ulPixelData, sizeof(u32));
+			pulCurrentFrameBufferPosistion++;
+
+			nNumberOfPixels += 2;
+
+			ulCISRdata = CISR;
+
+		}while((ulCISRdata & 0x100) == 0);
+		
+		//writeback to clear sticky bit
+		CISR = ulCISRdata & 0x100;
+
+		ulCISRdata = CISR;
+
+		nNumberOfLines++;
+
+	}while((ulCISRdata & 0x8) == 0);
+
+	printk(KERN_INFO "Camera %d:%d \n",nNumberOfPixels,nNumberOfLines);
+
+}
+
+static void SetPwmClockEnable(int nEnable)
+{
+  pxa_set_cken(CKEN0_PWM0, nEnable);
+}
+                
+static void SetPwmPrescale(int nPWM, int nPrescaleValue)
+{
+   switch(nPWM)
+   {
+      case 0:
+       PWM_CTRL0 = (nPrescaleValue & 0x7F);
+       break;
+      case 1:
+       PWM_CTRL1 = (nPrescaleValue & 0x7F);
+       break;
+      case 2:
+       PWM_CTRL2 = (nPrescaleValue & 0x7F);
+       break;
+   }  
+}
+
+static void SetPwmDutyCycle(int nPWM, int nDutyCycle)
+{
+   switch(nPWM)
+   {
+     case 0:
+      PWM_PWDUTY0 = nDutyCycle & 0x7FF;
+      break;
+     case 1:
+      PWM_PWDUTY1 = nDutyCycle & 0x7FF;
+      break;
+     case 2:
+      PWM_PWDUTY2 = nDutyCycle & 0x7FF;
+      break;
+   }
+}
+
+static void SetPwmPeriod(int nPWM, int nPeriod)
+{
+  switch(nPWM)
+  {
+    case 0:
+     PWM_PERVAL0 = nPeriod & 0x3FF;
+     break;
+    case 1:
+     PWM_PERVAL1 = nPeriod & 0x3FF;
+     break;
+    case 2:
+     PWM_PERVAL2 = nPeriod & 0x3FF;
+     break;
+  }
+}
+
+static void SetGpioMode(int nGpio, gpioMode gmMode)
+{
+     int nGpioMode = nGpio;
+     
+     switch(gmMode)
+     {
+       case GPIO_MODE_INPUT:
+		    nGpioMode |= GPIO_IN;
+		    pxa_gpio_mode(nGpioMode);
+
+		    if(nGpio < 32)
+				GPDR0 &= ~GPIO_bit(nGpio);
+			else if(nGpio < 64)
+				GPDR1 &= ~GPIO_bit(nGpio);
+			else if(nGpio < 96)
+				GPDR2 &= ~GPIO_bit(nGpio);
+			else if(nGpio < 128)
+				GPDR3 &= ~GPIO_bit(nGpio);
+
+            break;
+       
+       case GPIO_MODE_OUTPUT:
+		    nGpioMode |= GPIO_OUT;
+		    pxa_gpio_mode(nGpioMode);
+
+		    if(nGpio < 32)
+				GPDR0 |= GPIO_bit(nGpio);
+			else if(nGpio < 64)
+				GPDR1 |= GPIO_bit(nGpio);
+			else if(nGpio < 96)
+				GPDR2 |= GPIO_bit(nGpio);
+			else if(nGpio < 128)
+				GPDR3 |= GPIO_bit(nGpio);
+
+            break;
+       
+       case GPIO_MODE_ALT_FUNC_1_IN:
+            nGpioMode |= GPIO_ALT_FN_1_IN;
+			pxa_gpio_mode(nGpioMode);
+            break;
+  
+       case GPIO_MODE_ALT_FUNC_1_OUT:
+            nGpioMode |= GPIO_ALT_FN_1_OUT;
+			pxa_gpio_mode(nGpioMode);
+            break;
+
+       case GPIO_MODE_ALT_FUNC_2_IN:
+            nGpioMode |= GPIO_ALT_FN_2_IN;
+			pxa_gpio_mode(nGpioMode);
+            break;
+
+       case GPIO_MODE_ALT_FUNC_2_OUT:
+            nGpioMode |= GPIO_ALT_FN_2_OUT;
+			pxa_gpio_mode(nGpioMode);
+            break;
+
+       case GPIO_MODE_ALT_FUNC_3_IN:
+            nGpioMode |= GPIO_ALT_FN_3_IN;
+			pxa_gpio_mode(nGpioMode);
+            break;
+
+       case GPIO_MODE_ALT_FUNC_3_OUT:
+            nGpioMode |= GPIO_ALT_FN_3_OUT;
+			pxa_gpio_mode(nGpioMode);
+          break;
+     }//end switch statement
+#if 0
+	 printk(KERN_NOTICE "nGpioMode 0x%x \n",nGpioMode);
+
+	 nRegData = GAFR0_L;
+	 printk(KERN_NOTICE "GAFR0_L 0x%x \n",nRegData);
+	 nRegData = GAFR0_U;
+	 printk(KERN_NOTICE "GAFR0_U 0x%x \n",nRegData);
+
+	 nRegData = GAFR1_L;
+	 printk(KERN_NOTICE "GAFR1_L 0x%x \n",nRegData);
+	 nRegData = GAFR1_U;
+	 printk(KERN_NOTICE "GAFR1_U 0x%x \n",nRegData);
+
+	 nRegData = GAFR2_L;
+	 printk(KERN_NOTICE "GAFR2_L 0x%x \n",nRegData);
+	 nRegData = GAFR2_U;
+	 printk(KERN_NOTICE "GAFR2_U 0x%x \n",nRegData);
+
+	 nRegData = GAFR3_L;
+	 printk(KERN_NOTICE "GAFR3_L 0x%x \n",nRegData);
+	 nRegData = GAFR3_U;
+	 printk(KERN_NOTICE "GAFR3_U 0x%x \n",nRegData);
+
+     nRegData = GPDR0;
+	 printk(KERN_NOTICE "GPDR0 0x%x \n",nRegData);
+
+     nRegData = GPDR1;
+	 printk(KERN_NOTICE "GPDR1 0x%x \n",nRegData);
+     
+	 nRegData = GPDR2;
+	 printk(KERN_NOTICE "GPDR2 0x%x \n",nRegData);
+     
+	 nRegData = GPDR3;
+	 printk(KERN_NOTICE "GPDR3 0x%x \n",nRegData);
+#endif
+}
+
+
+static struct file_operations gpio_driver_fops = {
+		owner:			THIS_MODULE,
+		llseek:			no_llseek,
+		read:			gpio_read_method,
+		write:          gpio_write_method,
+        ioctl:          gpio_ioctl_method,
+        open:           gpio_open_method,
+        release:        gpio_release_method,
+};
+
+
+static int __init gpio_driver_init(void)
+{
+	int rc;
+	
+	printk(KERN_NOTICE "Register GPIO driver...\n");
+	rc = register_chrdev(GPIO_MAJOR,"gpio",&gpio_driver_fops);
+
+	return rc;
+}
+
+static void __exit gpio_driver_exit(void)
+{
+	printk(KERN_NOTICE "Remove GPIO driver...\n");
+    unregister_chrdev(GPIO_MAJOR,"gpio");
+
+
+}
+
+/* FILE FOPS */
+static ssize_t gpio_read_method (struct file *file, char *buf, size_t count, loff_t *offset)
+{
+  int ret = 0;
+
+  return ret;
+}
+
+static ssize_t gpio_write_method (struct file *file, const char *buf, size_t count, loff_t *offset)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static unsigned long ulIoWriteAddress = 0;
+
+static int gpio_ioctl_method (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int nRtnValue = 0;
+	int nVersion = GPIO_IOCTL_API_VERSION;
+	int nUserArg;
+
+	int nGpio;
+	int nValue;
+
+	int nIgnore;
+
+	nIgnore = copy_from_user(&nUserArg, (u32 *) arg, sizeof(int));
+
+	switch(cmd)
+	{
+		case GPIO_DRV_GETVERSION:
+			nIgnore = copy_to_user((u32 *) arg, &nVersion, sizeof(u32));
+			break;
+
+		case GPIO_DRV_SET_GPIO:
+			nGpio = (nUserArg & 0xffff0000) >> 16;
+			nValue  = (nUserArg & 0x00000001);
+
+			//printk(KERN_NOTICE "gpio_ioctl_method pxa_gpio_set_value GPIO=%d, Value=0x%x...\n",nGpio,nValue);
+
+			pxa_gpio_set_value(nGpio,nValue);
+
+			break;
+		case GPIO_DRV_GET_GPIO:
+			nGpio = (nUserArg & 0xffff0000) >> 16;
+
+			nUserArg = (int)pxa_gpio_get_value(nGpio);
+			
+//			printk(KERN_NOTICE "gpio_ioctl_method pxa_gpio_get_value GPIO=%d, Value=0x%x...\n",nGpio,nUserArg);
+
+			nIgnore = copy_to_user((u32 *) arg, &nUserArg, sizeof(u32));
+			break;
+
+		case GPIO_DRV_SET_MODE:
+			nGpio = (nUserArg & 0xffff0000) >> 16;
+			nValue  = (nUserArg & 0x0000ffff);
+
+			//printk(KERN_NOTICE "gpio_ioctl_method pxa_gpio_mode GPIO=%d, Value=0x%x...\n",nGpio,nValue);
+
+			SetGpioMode(nGpio, (gpioMode)nValue);
+			break;
+
+        case GPIO_DRV_SET_PWM_PRESCALE:
+            nGpio = (nUserArg & 0xffff0000) >> 16;
+            nValue = (nUserArg & 0x0000ffff);
+            SetPwmPrescale(nGpio, nValue);
+            break;
+  
+        case GPIO_DRV_SET_PWM_DUTYCYCLE:
+            nGpio = (nUserArg & 0xffff0000) >> 16;
+            nValue = (nUserArg & 0x0000ffff);
+            SetPwmDutyCycle(nGpio, nValue);
+            break;
+
+        case GPIO_DRV_SET_PWM_PERIOD:
+            nGpio = (nUserArg & 0xffff0000) >> 16;
+            nValue = (nUserArg & 0x0000ffff);
+            SetPwmPeriod(nGpio, nValue);
+            break;
+
+        case GPIO_DRV_SET_PWM_CLK_ENABLE:
+            SetPwmClockEnable(nUserArg);
+             break;
+
+		case GPIO_DRV_SET_PWRMODE:
+			nUserArg &= 0x0f;
+			
+			printk(KERN_NOTICE "gpio_ioctl_method GPIO_DRV_SET_PWRMODE mode=0x%x...\n",nUserArg);
+
+			asm( "mcr p14, 0, %0, c7, c0, 0" :: "r" (nUserArg) );
+			break;
+
+		case GPIO_DRV_SET_CLKCFG:
+			nUserArg &= 0x0f;
+			
+			printk(KERN_NOTICE "gpio_ioctl_method GPIO_DRV_SET_CLKCFG mode=0x%x...\n",nUserArg);
+
+			asm( "mcr p14, 0, %0, c6, c0, 0" :: "r" (nUserArg) );
+			break;
+
+		case GPIO_DRV_IO_READ:
+			
+			if(nUserArg < 0x80000000)
+				nUserArg = __REG(nUserArg);
+
+			nIgnore = copy_to_user((u32 *) arg, &nUserArg, sizeof(u32));
+			break;
+
+		case GPIO_DRV_SET_IO_WRITE_ADDRESS:
+			if(nUserArg < 0x80000000)
+				ulIoWriteAddress = (unsigned long)nUserArg;
+			break;
+
+		case GPIO_DRV_IO_WRITE:
+
+			if((ulIoWriteAddress > 0) && (ulIoWriteAddress < 0x80000000))
+				 __REG(ulIoWriteAddress) = nUserArg;
+
+			break;
+
+		case GPIO_DRV_GET_CAMERA_FRAME:
+			HandleWriteCameraFrameData(nUserArg);
+			break;
+
+		case GPIO_DRV_RESET_SYSTEM:
+			kernel_restart(NULL);
+
+			break;
+
+		default:
+			printk(KERN_NOTICE "gpio_ioctl_method cmd=0x%x, arg=0x%x...\n",cmd,nUserArg);
+			break;
+	}
+
+	return nRtnValue;
+}
+
+static int gpio_open_method (struct inode *inode, struct file *file)
+{
+	int nRtnValue = 0;
+
+	return nRtnValue;
+}
+
+static int gpio_release_method (struct inode *inode, struct file *file)
+{
+	int nRtnValue = 0;
+
+	return nRtnValue;
+}
+
+module_init(gpio_driver_init);
+module_exit(gpio_driver_exit);
+
+#if 0
+
+void cntrlFrontPanelLed(fpLed_e eWhichLed, ledControl_e eOn)
+{
+	setGpio(2,(char)eWhichLed,(char)eOn);
+}
+
+
+
+EXPORT_SYMBOL(cntrlFrontPanelLed);
+#endif
+
+MODULE_AUTHOR("Aeronix");
+MODULE_LICENSE("GPL");
Index: build_tree/linux/drivers/gpio/gpio_driver.h
diff -u /dev/null build_tree/linux/drivers/gpio/gpio_driver.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/gpio/gpio_driver.h	Fri Nov  9 13:48:27 2007
@@ -0,0 +1,16 @@
+#ifndef __GPIO_DRIVER_H_
+#define __GPIO_DRIVER_H_
+
+
+#define GPIO_MAJOR 101
+
+/* FILE FOPS */
+static ssize_t gpio_read_method (struct file *file, char *buf, size_t count, loff_t *offset);
+static ssize_t gpio_write_method (struct file *file, const char *buf, size_t count, loff_t *offset);
+static int gpio_ioctl_method (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int gpio_open_method (struct inode *inode, struct file *file);
+static int gpio_release_method (struct inode *inode, struct file *file);
+
+ 
+#endif //__GPIO_DRIVER_H_
+
Index: build_tree/linux/drivers/mmc/mmc.c
diff -u build_tree/linux/drivers/mmc/mmc.c:1.1.1.1 build_tree/linux/drivers/mmc/mmc.c:1.1.1.2
--- build_tree/linux/drivers/mmc/mmc.c:1.1.1.1	Thu Nov  8 14:27:03 2007
+++ build_tree/linux/drivers/mmc/mmc.c	Fri Nov  9 13:48:08 2007
@@ -26,7 +26,7 @@
 #include <linux/mmc/protocol.h>
 
 #include "mmc.h"
-
+
 #define CMD_RETRIES	3
 
 /*
@@ -708,8 +708,10 @@
 	resp[3] = card->raw_scr[1];
 	resp[2] = card->raw_scr[0];
 
-	scr_struct = UNSTUFF_BITS(resp, 60, 4);
-	if (scr_struct != 0) {
+	scr_struct = UNSTUFF_BITS(resp, 60, 4);
+
+	printk("%s: SCR structure version %d\n",mmc_hostname(card->host), scr_struct);
+	if (scr_struct > 1) {
 		printk("%s: unrecognised SCR structure version %d\n",
 			mmc_hostname(card->host), scr_struct);
 		mmc_card_set_bad(card);
@@ -1025,7 +1027,7 @@
 		}
 
 		memcpy(card->raw_csd, cmd.resp, sizeof(card->raw_csd));
-
+
 		mmc_decode_csd(card);
 		mmc_decode_cid(card);
 	}
@@ -1232,7 +1234,7 @@
 		card->raw_scr[0] = ntohl(card->raw_scr[0]);
 		card->raw_scr[1] = ntohl(card->raw_scr[1]);
 
-		mmc_decode_scr(card);
+		mmc_decode_scr(card);
 	}
 
 	mmc_deselect_cards(host);
@@ -1518,7 +1520,9 @@
  *	from the socket(s).  We don't know which socket or cards.
  */
 void mmc_detect_change(struct mmc_host *host, unsigned long delay)
-{
+{
+	printk(KERN_INFO"mmc_detect_change delay = %d \n",delay);
+
 	mmc_schedule_delayed_work(&host->detect, delay);
 }
 
@@ -1533,7 +1537,10 @@
 	unsigned char power_mode;
 
 	mmc_claim_host(host);
-
+
+
+	printk(KERN_INFO"mmc_rescan...\n");
+
 	/*
 	 * Check for removed cards and newly inserted ones. We check for
 	 * removed cards first so we can intelligently re-select the VDD.
@@ -1573,8 +1580,14 @@
 		if (!mmc_card_present(card) && !mmc_card_dead(card)) {
 			if (mmc_register_card(card))
 				mmc_card_set_dead(card);
-			else
-				mmc_card_set_present(card);
+			else
+			{
+				mmc_card_set_present(card);
+
+//				printk(KERN_INFO"CARD FOUND send ADD event 0x%x\n",&host->parent->kobj);
+
+//				kobject_uevent(&host->parent->kobj, KOBJ_CHANGE);
+			}
 		}
 
 		/*
@@ -1583,6 +1596,9 @@
 		if (mmc_card_dead(card)) {
 			list_del(&card->node);
 			mmc_remove_card(card);
+			
+//			printk(KERN_INFO"CARD REMOVED send ADD event 0x%x\n",&host->parent->kobj);
+//			kobject_uevent(&host->parent->kobj, KOBJ_CHANGE);
 		}
 	}
 
Index: build_tree/linux/drivers/mmc/mmc_block.c
diff -u build_tree/linux/drivers/mmc/mmc_block.c:1.1.1.1 build_tree/linux/drivers/mmc/mmc_block.c:1.1.1.2
--- build_tree/linux/drivers/mmc/mmc_block.c:1.1.1.1	Thu Nov  8 14:27:03 2007
+++ build_tree/linux/drivers/mmc/mmc_block.c	Fri Nov  9 13:48:08 2007
@@ -44,7 +44,8 @@
  */
 #define MMC_SHIFT	3
 
-static int major;
+//static int major;
+static int major = 179;
 
 /*
  * There is one mmc_blk_data per slot.
Index: build_tree/linux/drivers/mmc/mmc_queue.c
diff -u build_tree/linux/drivers/mmc/mmc_queue.c:1.1.1.1 build_tree/linux/drivers/mmc/mmc_queue.c:1.1.1.2
--- build_tree/linux/drivers/mmc/mmc_queue.c:1.1.1.1	Thu Nov  8 14:27:03 2007
+++ build_tree/linux/drivers/mmc/mmc_queue.c	Fri Nov  9 13:48:08 2007
@@ -28,26 +28,29 @@
 	struct mmc_queue *mq = q->queuedata;
 	int ret = BLKPREP_KILL;
 
-	if (blk_special_request(req)) {
-		/*
-		 * Special commands already have the command
-		 * blocks already setup in req->special.
-		 */
-		BUG_ON(!req->special);
-
-		ret = BLKPREP_OK;
-	} else if (blk_fs_request(req) || blk_pc_request(req)) {
-		/*
-		 * Block I/O requests need translating according
-		 * to the protocol.
-		 */
-		ret = mq->prep_fn(mq, req);
-	} else {
-		/*
-		 * Everything else is invalid.
-		 */
-		blk_dump_rq_flags(req, "MMC bad request");
-	}
+	if(mq)
+	{
+		if (blk_special_request(req)) {
+			/*
+			 * Special commands already have the command
+			 * blocks already setup in req->special.
+			 */
+			BUG_ON(!req->special);
+
+			ret = BLKPREP_OK;
+		} else if (blk_fs_request(req) || blk_pc_request(req)) {
+			/*
+			 * Block I/O requests need translating according
+			 * to the protocol.
+			 */
+			ret = mq->prep_fn(mq, req);
+		} else {
+			/*
+			 * Everything else is invalid.
+			 */
+			blk_dump_rq_flags(req, "MMC bad request");
+		}
+	}//end check for mq
 
 	if (ret == BLKPREP_OK)
 		req->cmd_flags |= REQ_DONTPREP;
Index: build_tree/linux/drivers/mtd/chips/cfi_cmdset_0001.c
diff -u build_tree/linux/drivers/mtd/chips/cfi_cmdset_0001.c:1.1.1.1 build_tree/linux/drivers/mtd/chips/cfi_cmdset_0001.c:1.1.1.2
--- build_tree/linux/drivers/mtd/chips/cfi_cmdset_0001.c:1.1.1.1	Thu Nov  8 14:27:22 2007
+++ build_tree/linux/drivers/mtd/chips/cfi_cmdset_0001.c	Fri Nov  9 13:48:27 2007
@@ -220,6 +220,12 @@
 	}
 }
 
+static void fixup_intel_unlock(struct mtd_info *mtd, void *param)
+{
+	/* unlock partitions */
+	mtd->flags |= MTD_STUPID_LOCK;
+}
+
 static struct cfi_fixup cfi_fixup_table[] = {
 #ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_intel_strataflash, NULL },
@@ -232,6 +238,7 @@
 #endif
 	{ CFI_MFR_ST, 0x00ba, /* M28W320CT */ fixup_st_m28w320ct, NULL },
 	{ CFI_MFR_ST, 0x00bb, /* M28W320CB */ fixup_st_m28w320cb, NULL },
+	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_intel_unlock, NULL },
 	{ 0, 0, NULL, NULL }
 };
 
Index: build_tree/linux/drivers/mtd/maps/mainstone-flash.c
diff -u build_tree/linux/drivers/mtd/maps/mainstone-flash.c:1.1.1.1 build_tree/linux/drivers/mtd/maps/mainstone-flash.c:1.1.1.2
--- build_tree/linux/drivers/mtd/maps/mainstone-flash.c:1.1.1.1	Thu Nov  8 14:27:22 2007
+++ build_tree/linux/drivers/mtd/maps/mainstone-flash.c	Fri Nov  9 13:48:27 2007
@@ -36,7 +36,9 @@
 static void mainstone_map_inval_cache(struct map_info *map, unsigned long from,
 				      ssize_t len)
 {
-	consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
+
+//	printk(KERN_NOTICE "TEST: 0x%08lX, 0x%08lX, 0x%08lX, 0x%08lX\n", map, map->cached, from, len);
+//	consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
 }
 
 static struct map_info mainstone_maps[2] = { {
@@ -52,17 +54,17 @@
 static struct mtd_partition mainstone_partitions[] = {
 	{
 		.name =		"Bootloader",
-		.size =		0x00040000,
+		.size =		0x00010000,
 		.offset =	0,
-		.mask_flags =	MTD_WRITEABLE  /* force read-only */
+/* JWK in production, we may want this protected		.mask_flags =	MTD_WRITEABLE  /* force read-only */
 	},{
 		.name =		"Kernel",
-		.size =		0x00400000,
-		.offset =	0x00040000,
+		.size =		0x00230000,
+		.offset =	0x00010000,
 	},{
 		.name =		"Filesystem",
 		.size =		MTDPART_SIZ_FULL,
-		.offset =	0x00440000
+		.offset =	0x00240000
 	}
 };
 
@@ -87,9 +89,11 @@
 	printk(KERN_NOTICE "Mainstone configured to boot from %s\n",
 	       mainstone_maps[0].name);
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < 1; i++) {
 		mainstone_maps[i].virt = ioremap(mainstone_maps[i].phys,
 						 WINDOW_SIZE);
+	printk(KERN_NOTICE "Mainstone configured: 0x%08lX, 0x%08lX, 0x%08lX \n", mainstone_maps[i].phys, mainstone_maps[i].virt, WINDOW_SIZE);
+
 		if (!mainstone_maps[i].virt) {
 			printk(KERN_WARNING "Failed to ioremap %s\n",
 			       mainstone_maps[i].name);
@@ -97,11 +101,13 @@
 				ret = -ENOMEM;
 			continue;
 		}
+/*
 		mainstone_maps[i].cached =
 			ioremap_cached(mainstone_maps[i].phys, WINDOW_SIZE);
 		if (!mainstone_maps[i].cached)
 			printk(KERN_WARNING "Failed to ioremap cached %s\n",
 			       mainstone_maps[i].name);
+*/
 		simple_map_init(&mainstone_maps[i]);
 
 		printk(KERN_NOTICE
@@ -132,7 +138,7 @@
 	if (!mymtds[0] && !mymtds[1])
 		return ret;
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < 1; i++) {
 		if (!mymtds[i]) {
 			printk(KERN_WARNING "%s is absent. Skipping\n",
 			       mainstone_maps[i].name);
@@ -156,7 +162,7 @@
 static void __exit cleanup_mainstone(void)
 {
 	int i;
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < 1; i++) {
 		if (!mymtds[i])
 			continue;
 
Index: build_tree/linux/drivers/video/fbmem.c
diff -u build_tree/linux/drivers/video/fbmem.c:1.1.1.1 build_tree/linux/drivers/video/fbmem.c:1.1.1.2
--- build_tree/linux/drivers/video/fbmem.c:1.1.1.1	Thu Nov  8 14:27:22 2007
+++ build_tree/linux/drivers/video/fbmem.c	Fri Nov  9 13:48:28 2007
@@ -57,6 +57,17 @@
 /*
  * Helpers
  */
+extern const struct linux_logo logo_zipit_clut224;
+
+const struct linux_logo *fb_find_zipit_logo()
+{
+	const struct linux_logo *logo = NULL;
+
+	logo = &logo_zipit_clut224;
+
+	return logo;
+}
+
 
 int fb_get_color_depth(struct fb_var_screeninfo *var,
 		       struct fb_fix_screeninfo *fix)
@@ -404,7 +415,7 @@
 	} else if (rotate == FB_ROTATE_CCW) {
 		for (x = 0; x < num_online_cpus() &&
 			     x * (fb_logo.logo->width + 8) <=
-			     info->var.yres - fb_logo.logo->width; x++) {
+			     (info->var.yres + 10) - fb_logo.logo->width; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dy -= fb_logo.logo->width + 8;
 		}
@@ -450,7 +461,7 @@
 	}
 
 	/* Return if no suitable logo was found */
-	fb_logo.logo = fb_find_logo(depth);
+	fb_logo.logo = fb_find_zipit_logo();
 
 	if (!fb_logo.logo) {
 		return 0;
@@ -486,6 +497,7 @@
 	if (fb_logo.logo == NULL || info->state != FBINFO_STATE_RUNNING)
 		return 0;
 
+	printk(KERN_NOTICE "ZIPIT2 - SHOW LOGO \n");
 	image.depth = 8;
 	image.data = fb_logo.logo->data;
 
@@ -520,11 +532,12 @@
 		fb_set_logo(info, fb_logo.logo, logo_new, fb_logo.depth);
 	}
 
-	image.dx = 0;
-	image.dy = 0;
 	image.width = fb_logo.logo->width;
 	image.height = fb_logo.logo->height;
 
+	image.dx = 0;
+	image.dy = 0;
+
 	if (rotate) {
 		logo_rotate = kmalloc(fb_logo.logo->width *
 				      fb_logo.logo->height, GFP_KERNEL);
@@ -532,6 +545,10 @@
 			fb_rotate_logo(info, logo_rotate, &image, rotate);
 	}
 
+	//center image on screen
+	image.dx = (info->var.xres - image.width)>>1;
+	image.dy = (info->var.yres - image.height)>>1;
+
 	fb_do_show_logo(info, &image, rotate);
 
 	kfree(palette);
@@ -729,6 +746,7 @@
 #ifdef CONFIG_KMOD
 static void try_to_load(int fb)
 {
+        printk(KERN_NOTICE "ZIPIT2 - try_to_load \n");
 	request_module("fb%d", fb);
 }
 #endif /* CONFIG_KMOD */
@@ -898,6 +916,7 @@
 			return -EFAULT;
 		return 0;
 	case FBIOGET_FSCREENINFO:
+                printk(KERN_NOTICE "ZIPIT2 - fb_ioctl FBIOGET_FSCREENINFO \n");
 		return copy_to_user(argp, &info->fix,
 				    sizeof(fix)) ? -EFAULT : 0;
 	case FBIOPUTCMAP:
@@ -1099,6 +1118,7 @@
 		break;
 
 	case FBIOGET_FSCREENINFO:
+                printk(KERN_NOTICE "ZIPIT2 - fb_compat_ioctl FBIOGET_FSCREENINFO \n");
 		ret = fb_get_fscreeninfo(inode, file, cmd, arg);
 		break;
 
@@ -1128,6 +1148,7 @@
 	unsigned long start;
 	u32 len;
 #endif
+        printk(KERN_NOTICE "ZIPIT2 - fb_mmap....\n");
 
 	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
 		return -EINVAL;
@@ -1219,6 +1240,8 @@
 	int fbidx = iminor(inode);
 	struct fb_info *info;
 	int res = 0;
+        
+        printk(KERN_NOTICE "ZIPIT2 - fb_open \n");
 
 	if (fbidx >= FB_MAX)
 		return -ENODEV;
@@ -1227,9 +1250,15 @@
 		try_to_load(fbidx);
 #endif /* CONFIG_KMOD */
 	if (!(info = registered_fb[fbidx]))
+        {
+        	printk(KERN_NOTICE "ZIPIT2 - error getting registered fb(1) \n");
 		return -ENODEV;
+        }
 	if (!try_module_get(info->fbops->owner))
+        {
+        	printk(KERN_NOTICE "ZIPIT2 - error getting registered fb(2) \n");
 		return -ENODEV;
+        }
 	file->private_data = info;
 	if (info->fbops->fb_open) {
 		res = info->fbops->fb_open(info,1);
@@ -1287,6 +1316,7 @@
 	struct fb_event event;
 	struct fb_videomode mode;
 
+        printk(KERN_NOTICE "ZIPIT2 - register_framebuffer \n");
 	if (num_registered_fb == FB_MAX)
 		return -ENXIO;
 	num_registered_fb++;
@@ -1305,6 +1335,7 @@
 		fb_init_device(fb_info);
 
 	if (fb_info->pixmap.addr == NULL) {
+                printk(KERN_WARNING "ZIPIT2 - pixmap.addr == NULL \n");
 		fb_info->pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL);
 		if (fb_info->pixmap.addr) {
 			fb_info->pixmap.size = FBPIXMAPSIZE;
@@ -1325,6 +1356,12 @@
 
 	event.info = fb_info;
 	fb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &event);
+
+	fb_prepare_logo(fb_info,3);
+	fb_show_logo(fb_info,3);
+
+	pxa_backlight(1);
+
 	return 0;
 }
 
@@ -1397,6 +1434,8 @@
 static int __init
 fbmem_init(void)
 {
+        printk(KERN_NOTICE "ZIPIT2 - fbmem_init.. \n");
+
 	create_proc_read_entry("fb", 0, NULL, fbmem_read_proc, NULL);
 
 	if (register_chrdev(FB_MAJOR,"fb",&fb_fops))
Index: build_tree/linux/drivers/video/pxafb.c
diff -u build_tree/linux/drivers/video/pxafb.c:1.1.1.1 build_tree/linux/drivers/video/pxafb.c:1.1.1.2
--- build_tree/linux/drivers/video/pxafb.c:1.1.1.1	Thu Nov  8 14:27:22 2007
+++ build_tree/linux/drivers/video/pxafb.c	Fri Nov  9 13:48:27 2007
@@ -75,7 +75,9 @@
 
 	local_irq_save(flags);
 	/*
+q
 	 * We need to handle two requests being made at the same time.
+q
 	 * There are two important cases:
 	 *  1. When we are changing VT (C_REENABLE) while unblanking (C_ENABLE)
 	 *     We must perform the unblanking, which will do our REENABLE for us.
@@ -730,6 +732,16 @@
 	return 0;
 }
 
+void pxa_backlight(int on)
+{
+	if(on)
+		GPSR0 = (1 << 11);
+	else
+		GPSR0 = ~(1 << 11);
+
+}
+EXPORT_SYMBOL(pxa_backlight);
+
 /*
  * NOTE!  The following functions are purely helpers for set_ctrlr_state.
  * Do not call them directly; set_ctrlr_state does the correct serialisation
@@ -740,8 +752,8 @@
 {
 	pr_debug("pxafb: backlight o%s\n", on ? "n" : "ff");
 
- 	if (pxafb_backlight_power)
- 		pxafb_backlight_power(on);
+// 	if (pxafb_backlight_power)
+ //		pxafb_backlight_power(on);
 }
 
 static inline void __pxafb_lcd_power(struct pxafb_info *fbi, int on)
@@ -1341,6 +1353,8 @@
 #ifdef DEBUG_VAR
         /* Check for various illegal bit-combinations. Currently only
 	 * a warning is given. */
+        printk(KERN_NOTICE "ZIPIT2 lccr0 = 0x%x \n",inf->lccr0);
+        printk(KERN_NOTICE "ZIPIT2 lccr3 = 0x%x \n",inf->lccr3);
 
         if (inf->lccr0 & LCCR0_INVALID_CONFIG_MASK)
                 dev_warn(&dev->dev, "machine LCCR0 setting contains illegal bits: %08x\n",
@@ -1460,6 +1474,7 @@
 
 int __devinit pxafb_init(void)
 {
+        int ret;
 #ifndef MODULE
 	char *option = NULL;
 
@@ -1467,7 +1482,12 @@
 		return -ENODEV;
 	pxafb_setup(option);
 #endif
-	return platform_driver_register(&pxafb_driver);
+	ret =  platform_driver_register(&pxafb_driver);
+
+        if(ret < 0)
+           printk(KERN_NOTICE "ERROR registering PXAFB driver...\n");
+        else
+           printk(KERN_NOTICE "PXAFB driver registered...\n");
 }
 
 module_init(pxafb_init);
Index: build_tree/linux/drivers/video/logo/Kconfig
diff -u build_tree/linux/drivers/video/logo/Kconfig:1.1.1.1 build_tree/linux/drivers/video/logo/Kconfig:1.1.1.2
--- build_tree/linux/drivers/video/logo/Kconfig:1.1.1.1	Thu Nov  8 14:27:23 2007
+++ build_tree/linux/drivers/video/logo/Kconfig	Fri Nov  9 13:48:28 2007
@@ -25,6 +25,11 @@
 	depends on LOGO
 	default y
 
+config LOGO_ZIPIT
+       bool "Zipit2 Logo"
+       depends on LOGO
+       default y
+
 config LOGO_DEC_CLUT224
 	bool "224-color Digital Equipment Corporation Linux logo"
 	depends on LOGO && (MACH_DECSTATION || ALPHA)
Index: build_tree/linux/drivers/video/logo/Makefile
diff -u build_tree/linux/drivers/video/logo/Makefile:1.1.1.1 build_tree/linux/drivers/video/logo/Makefile:1.1.1.2
--- build_tree/linux/drivers/video/logo/Makefile:1.1.1.1	Thu Nov  8 14:27:23 2007
+++ build_tree/linux/drivers/video/logo/Makefile	Fri Nov  9 13:48:28 2007
@@ -13,7 +13,7 @@
 obj-$(CONFIG_LOGO_SUPERH_VGA16)		+= logo_superh_vga16.o
 obj-$(CONFIG_LOGO_SUPERH_CLUT224)	+= logo_superh_clut224.o
 obj-$(CONFIG_LOGO_M32R_CLUT224)		+= logo_m32r_clut224.o
-
+obj-$(CONFIG_LOGO_ZIPIT)                += logo_zipit_clut224.o
 # How to generate logo's
 
 # Use logo-cfiles to retrieve list of .c files to be built
Index: build_tree/linux/drivers/video/logo/logo_zipit_clut224.ppm
diff -u /dev/null build_tree/linux/drivers/video/logo/logo_zipit_clut224.ppm:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/drivers/video/logo/logo_zipit_clut224.ppm	Fri Nov  9 13:48:29 2007
@@ -0,0 +1,121 @@
+P3
+98 118
+255
+255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 32 32 64 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 128 128 128 128 128 128 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 160 160 164 32 64 64 32 64 64 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 128 128 128 160 160 164 160 160 164 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 32 64 128 32 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 160 160 164 192 192 192 192 192 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 192 220 192 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 192 192 192 220 192 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 96 128 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 96 128 128 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 128 128 96 96 128 96 96 128 96 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 96 128 96 96 128 96 96 128 128 128 192 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 96 96 128 96 96 128 96 96 128 96 96 128 96 96 128 96 96 128 96 96 128 96 96 128 96 96 128 96 96 128 64 96 128 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 160 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 160 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 128 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 128 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 160 192 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 128 128 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 160 160 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 128 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 192 192 192 192 192 192 192 192 192 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 192 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 192 192 192 192 192 192 192 192 192 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 160 192 192 96 128 128 64 96 128 64 64 128 64 64 128 96 96 128 160 160 192 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 160 160 192 96 96 128 64 96 128 64 64 128 64 64 128 96 96 128 160 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 160 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 128 128 192 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 160 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 128 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 128 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 128 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 160 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 128 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 192 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 160 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 160 160 164 96 96 128 64 96 128 64 96 128 128 128 192 192 192 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 96 128 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 192 220 192 128 128 192 96 96 128 64 96 128 64 96 128 128 128 192 192 192 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 160 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 128 160 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 128 160 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 128 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 160 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 160 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 128 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 128 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 160 160 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 128 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 160 160 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 160 160 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 128 128 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 160 164 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 192 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 96 128 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 128 128 192 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 128 128 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 128 160 192 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 64 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 128 128 192 192 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 160 160 192 160 160 192 160 160 192 160 160 192 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 251 240 160 160 192 160 160 192 160 160 192 160 192 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 192 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 220 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 160 160 192 255 255 255 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 255 251 240 192 192 192 64 96 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 128 128 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 160 160 192 128 160 192 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 96 96 128 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 96 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 64 96 128 96 128 192 192 220 192 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 128 128 128 160 160 164 192 192 192 192 220 192 255 251 240 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 32 32 64 32 64 64 32 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 32 32 64 32 32 64 32 32 64 32 64 64 32 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 64 64 128 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
+255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
Index: build_tree/linux/include/asm/.gitignore
diff -u /dev/null build_tree/linux/include/asm/.gitignore:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/include/asm/.gitignore	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,2 @@
+arch
+mach-types.h
Index: build_tree/linux/include/asm/Kbuild
diff -u /dev/null build_tree/linux/include/asm/Kbuild:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/include/asm/Kbuild	Fri Nov  9 13:48:55 2007
@@ -0,0 +1 @@
+include include/asm-generic/Kbuild.asm
Index: build_tree/linux/include/asm/a.out.h
diff -u /dev/null build_tree/linux/include/asm/a.out.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:41 2008
+++ build_tree/linux/include/asm/a.out.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,39 @@
+#ifndef __ARM_A_OUT_H__
+#define __ARM_A_OUT_H__
+
+#include <linux/personality.h>
+#include <asm/types.h>
+
+struct exec
+{
+  __u32 a_info;		/* Use macros N_MAGIC, etc for access */
+  __u32 a_text;		/* length of text, in bytes */
+  __u32 a_data;		/* length of data, in bytes */
+  __u32 a_bss;		/* length of uninitialized data area for file, in bytes */
+  __u32 a_syms;		/* length of symbol table data in file, in bytes */
+  __u32 a_entry;	/* start address */
+  __u32 a_trsize;	/* length of relocation info for text, in bytes */
+  __u32 a_drsize;	/* length of relocation info for data, in bytes */
+};
+
+/*
+ * This is always the same
+ */
+#define N_TXTADDR(a)	(0x00008000)
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#define M_ARM 103
+
+#ifdef __KERNEL__
+#define STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
+			 TASK_SIZE : TASK_SIZE_26)
+#endif
+
+#ifndef LIBRARY_START_TEXT
+#define LIBRARY_START_TEXT	(0x00c00000)
+#endif
+
+#endif /* __A_OUT_GNU_H__ */
Index: build_tree/linux/include/asm/asm-offsets.h
diff -u /dev/null build_tree/linux/include/asm/asm-offsets.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/asm-offsets.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,66 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define TSK_ACTIVE_MM 132 /* offsetof(struct task_struct, active_mm)	@ */
+
+#define TI_FLAGS 0 /* offsetof(struct thread_info, flags)	@ */
+#define TI_PREEMPT 4 /* offsetof(struct thread_info, preempt_count)	@ */
+#define TI_ADDR_LIMIT 8 /* offsetof(struct thread_info, addr_limit)	@ */
+#define TI_TASK 12 /* offsetof(struct thread_info, task)	@ */
+#define TI_EXEC_DOMAIN 16 /* offsetof(struct thread_info, exec_domain)	@ */
+#define TI_CPU 20 /* offsetof(struct thread_info, cpu)	@ */
+#define TI_CPU_DOMAIN 24 /* offsetof(struct thread_info, cpu_domain)	@ */
+#define TI_CPU_SAVE 28 /* offsetof(struct thread_info, cpu_context)	@ */
+#define TI_USED_CP 76 /* offsetof(struct thread_info, used_cp)	@ */
+#define TI_TP_VALUE 92 /* offsetof(struct thread_info, tp_value)	@ */
+#define TI_FPSTATE 280 /* offsetof(struct thread_info, fpstate)	@ */
+#define TI_VFPSTATE 432 /* offsetof(struct thread_info, vfpstate)	@ */
+#define TI_IWMMXT_STATE 280 /* offsetof(struct thread_info, fpstate.iwmmxt)	@ */
+
+#define S_R0 0 /* offsetof(struct pt_regs, ARM_r0)	@ */
+#define S_R1 4 /* offsetof(struct pt_regs, ARM_r1)	@ */
+#define S_R2 8 /* offsetof(struct pt_regs, ARM_r2)	@ */
+#define S_R3 12 /* offsetof(struct pt_regs, ARM_r3)	@ */
+#define S_R4 16 /* offsetof(struct pt_regs, ARM_r4)	@ */
+#define S_R5 20 /* offsetof(struct pt_regs, ARM_r5)	@ */
+#define S_R6 24 /* offsetof(struct pt_regs, ARM_r6)	@ */
+#define S_R7 28 /* offsetof(struct pt_regs, ARM_r7)	@ */
+#define S_R8 32 /* offsetof(struct pt_regs, ARM_r8)	@ */
+#define S_R9 36 /* offsetof(struct pt_regs, ARM_r9)	@ */
+#define S_R10 40 /* offsetof(struct pt_regs, ARM_r10)	@ */
+#define S_FP 44 /* offsetof(struct pt_regs, ARM_fp)	@ */
+#define S_IP 48 /* offsetof(struct pt_regs, ARM_ip)	@ */
+#define S_SP 52 /* offsetof(struct pt_regs, ARM_sp)	@ */
+#define S_LR 56 /* offsetof(struct pt_regs, ARM_lr)	@ */
+#define S_PC 60 /* offsetof(struct pt_regs, ARM_pc)	@ */
+#define S_PSR 64 /* offsetof(struct pt_regs, ARM_cpsr)	@ */
+#define S_OLD_R0 68 /* offsetof(struct pt_regs, ARM_ORIG_r0)	@ */
+#define S_FRAME_SIZE 72 /* sizeof(struct pt_regs)	@ */
+
+#define VMA_VM_MM 0 /* offsetof(struct vm_area_struct, vm_mm)	@ */
+#define VMA_VM_FLAGS 20 /* offsetof(struct vm_area_struct, vm_flags)	@ */
+
+#define VM_EXEC 4 /* VM_EXEC	@ */
+
+#define PAGE_SZ 4096 /* PAGE_SIZE	@ */
+
+#define SYS_ERROR0 10420224 /* 0x9f0000	@ */
+
+#define SIZEOF_MACHINE_DESC 52 /* sizeof(struct machine_desc)	@ */
+#define MACHINFO_TYPE 0 /* offsetof(struct machine_desc, nr)	@ */
+#define MACHINFO_NAME 12 /* offsetof(struct machine_desc, name)	@ */
+#define MACHINFO_PHYSIO 4 /* offsetof(struct machine_desc, phys_io)	@ */
+#define MACHINFO_PGOFFIO 8 /* offsetof(struct machine_desc, io_pg_offst)	@ */
+
+#define PROC_INFO_SZ 52 /* sizeof(struct proc_info_list)	@ */
+#define PROCINFO_INITFUNC 16 /* offsetof(struct proc_info_list, __cpu_flush)	@ */
+#define PROCINFO_MM_MMUFLAGS 8 /* offsetof(struct proc_info_list, __cpu_mm_mmu_flags)	@ */
+#define PROCINFO_IO_MMUFLAGS 12 /* offsetof(struct proc_info_list, __cpu_io_mmu_flags)	@ */
+
+#endif
Index: build_tree/linux/include/asm/assembler.h
diff -u /dev/null build_tree/linux/include/asm/assembler.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/assembler.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,101 @@
+/*
+ *  linux/include/asm-arm/assembler.h
+ *
+ *  Copyright (C) 1996-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file contains arm architecture specific defines
+ *  for the different processors.
+ *
+ *  Do not include any C declarations in this file - it is included by
+ *  assembler source.
+ */
+#ifndef __ASSEMBLY__
+#error "Only include this from assembly code"
+#endif
+
+#include <asm/ptrace.h>
+
+/*
+ * Endian independent macros for shifting bytes within registers.
+ */
+#ifndef __ARMEB__
+#define pull            lsr
+#define push            lsl
+#define get_byte_0      lsl #0
+#define get_byte_1	lsr #8
+#define get_byte_2	lsr #16
+#define get_byte_3	lsr #24
+#define put_byte_0      lsl #0
+#define put_byte_1	lsl #8
+#define put_byte_2	lsl #16
+#define put_byte_3	lsl #24
+#else
+#define pull            lsl
+#define push            lsr
+#define get_byte_0	lsr #24
+#define get_byte_1	lsr #16
+#define get_byte_2	lsr #8
+#define get_byte_3      lsl #0
+#define put_byte_0	lsl #24
+#define put_byte_1	lsl #16
+#define put_byte_2	lsl #8
+#define put_byte_3      lsl #0
+#endif
+
+/*
+ * Data preload for architectures that support it
+ */
+#if __LINUX_ARM_ARCH__ >= 5
+#define PLD(code...)	code
+#else
+#define PLD(code...)
+#endif
+
+/*
+ * Enable and disable interrupts
+ */
+#if __LINUX_ARM_ARCH__ >= 6
+	.macro	disable_irq
+	cpsid	i
+	.endm
+
+	.macro	enable_irq
+	cpsie	i
+	.endm
+#else
+	.macro	disable_irq
+	msr	cpsr_c, #PSR_I_BIT | SVC_MODE
+	.endm
+
+	.macro	enable_irq
+	msr	cpsr_c, #SVC_MODE
+	.endm
+#endif
+
+/*
+ * Save the current IRQ state and disable IRQs.  Note that this macro
+ * assumes FIQs are enabled, and that the processor is in SVC mode.
+ */
+	.macro	save_and_disable_irqs, oldcpsr
+	mrs	\oldcpsr, cpsr
+	disable_irq
+	.endm
+
+/*
+ * Restore interrupt state previously stored in a register.  We don't
+ * guarantee that this will preserve the flags.
+ */
+	.macro	restore_irqs, oldcpsr
+	msr	cpsr_c, \oldcpsr
+	.endm
+
+#define USER(x...)				\
+9999:	x;					\
+	.section __ex_table,"a";		\
+	.align	3;				\
+	.long	9999b,9001f;			\
+	.previous
Index: build_tree/linux/include/asm/atomic.h
diff -u /dev/null build_tree/linux/include/asm/atomic.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/atomic.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,211 @@
+/*
+ *  linux/include/asm-arm/atomic.h
+ *
+ *  Copyright (C) 1996 Russell King.
+ *  Copyright (C) 2002 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_ATOMIC_H
+#define __ASM_ARM_ATOMIC_H
+
+#include <linux/compiler.h>
+
+typedef struct { volatile int counter; } atomic_t;
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+#ifdef __KERNEL__
+
+#define atomic_read(v)	((v)->counter)
+
+#if __LINUX_ARM_ARCH__ >= 6
+
+/*
+ * ARMv6 UP and SMP safe atomic ops.  We use load exclusive and
+ * store exclusive to ensure that these are atomic.  We may loop
+ * to ensure that the update happens.  Writing to 'v->counter'
+ * without using the following operations WILL break the atomic
+ * nature of these ops.
+ */
+static inline void atomic_set(atomic_t *v, int i)
+{
+	unsigned long tmp;
+
+	__asm__ __volatile__("@ atomic_set\n"
+"1:	ldrex	%0, [%1]\n"
+"	strex	%0, %2, [%1]\n"
+"	teq	%0, #0\n"
+"	bne	1b"
+	: "=&r" (tmp)
+	: "r" (&v->counter), "r" (i)
+	: "cc");
+}
+
+static inline int atomic_add_return(int i, atomic_t *v)
+{
+	unsigned long tmp;
+	int result;
+
+	__asm__ __volatile__("@ atomic_add_return\n"
+"1:	ldrex	%0, [%2]\n"
+"	add	%0, %0, %3\n"
+"	strex	%1, %0, [%2]\n"
+"	teq	%1, #0\n"
+"	bne	1b"
+	: "=&r" (result), "=&r" (tmp)
+	: "r" (&v->counter), "Ir" (i)
+	: "cc");
+
+	return result;
+}
+
+static inline int atomic_sub_return(int i, atomic_t *v)
+{
+	unsigned long tmp;
+	int result;
+
+	__asm__ __volatile__("@ atomic_sub_return\n"
+"1:	ldrex	%0, [%2]\n"
+"	sub	%0, %0, %3\n"
+"	strex	%1, %0, [%2]\n"
+"	teq	%1, #0\n"
+"	bne	1b"
+	: "=&r" (result), "=&r" (tmp)
+	: "r" (&v->counter), "Ir" (i)
+	: "cc");
+
+	return result;
+}
+
+static inline int atomic_cmpxchg(atomic_t *ptr, int old, int new)
+{
+	unsigned long oldval, res;
+
+	do {
+		__asm__ __volatile__("@ atomic_cmpxchg\n"
+		"ldrex	%1, [%2]\n"
+		"mov	%0, #0\n"
+		"teq	%1, %3\n"
+		"strexeq %0, %4, [%2]\n"
+		    : "=&r" (res), "=&r" (oldval)
+		    : "r" (&ptr->counter), "Ir" (old), "r" (new)
+		    : "cc");
+	} while (res);
+
+	return oldval;
+}
+
+static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
+{
+	unsigned long tmp, tmp2;
+
+	__asm__ __volatile__("@ atomic_clear_mask\n"
+"1:	ldrex	%0, [%2]\n"
+"	bic	%0, %0, %3\n"
+"	strex	%1, %0, [%2]\n"
+"	teq	%1, #0\n"
+"	bne	1b"
+	: "=&r" (tmp), "=&r" (tmp2)
+	: "r" (addr), "Ir" (mask)
+	: "cc");
+}
+
+#else /* ARM_ARCH_6 */
+
+#include <asm/system.h>
+
+#ifdef CONFIG_SMP
+#error SMP not supported on pre-ARMv6 CPUs
+#endif
+
+#define atomic_set(v,i)	(((v)->counter) = (i))
+
+static inline int atomic_add_return(int i, atomic_t *v)
+{
+	unsigned long flags;
+	int val;
+
+	raw_local_irq_save(flags);
+	val = v->counter;
+	v->counter = val += i;
+	raw_local_irq_restore(flags);
+
+	return val;
+}
+
+static inline int atomic_sub_return(int i, atomic_t *v)
+{
+	unsigned long flags;
+	int val;
+
+	raw_local_irq_save(flags);
+	val = v->counter;
+	v->counter = val -= i;
+	raw_local_irq_restore(flags);
+
+	return val;
+}
+
+static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
+{
+	int ret;
+	unsigned long flags;
+
+	raw_local_irq_save(flags);
+	ret = v->counter;
+	if (likely(ret == old))
+		v->counter = new;
+	raw_local_irq_restore(flags);
+
+	return ret;
+}
+
+static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
+{
+	unsigned long flags;
+
+	raw_local_irq_save(flags);
+	*addr &= ~mask;
+	raw_local_irq_restore(flags);
+}
+
+#endif /* __LINUX_ARM_ARCH__ */
+
+#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
+
+static inline int atomic_add_unless(atomic_t *v, int a, int u)
+{
+	int c, old;
+
+	c = atomic_read(v);
+	while (c != u && (old = atomic_cmpxchg((v), c, c + a)) != c)
+		c = old;
+	return c != u;
+}
+#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+
+#define atomic_add(i, v)	(void) atomic_add_return(i, v)
+#define atomic_inc(v)		(void) atomic_add_return(1, v)
+#define atomic_sub(i, v)	(void) atomic_sub_return(i, v)
+#define atomic_dec(v)		(void) atomic_sub_return(1, v)
+
+#define atomic_inc_and_test(v)	(atomic_add_return(1, v) == 0)
+#define atomic_dec_and_test(v)	(atomic_sub_return(1, v) == 0)
+#define atomic_inc_return(v)    (atomic_add_return(1, v))
+#define atomic_dec_return(v)    (atomic_sub_return(1, v))
+#define atomic_sub_and_test(i, v) (atomic_sub_return(i, v) == 0)
+
+#define atomic_add_negative(i,v) (atomic_add_return(i, v) < 0)
+
+/* Atomic operations are already serializing on ARM */
+#define smp_mb__before_atomic_dec()	barrier()
+#define smp_mb__after_atomic_dec()	barrier()
+#define smp_mb__before_atomic_inc()	barrier()
+#define smp_mb__after_atomic_inc()	barrier()
+
+#include <asm-generic/atomic.h>
+#endif
+#endif
Index: build_tree/linux/include/asm/auxvec.h
diff -u /dev/null build_tree/linux/include/asm/auxvec.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/auxvec.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,4 @@
+#ifndef __ASMARM_AUXVEC_H
+#define __ASMARM_AUXVEC_H
+
+#endif
Index: build_tree/linux/include/asm/bitops.h
diff -u /dev/null build_tree/linux/include/asm/bitops.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/bitops.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,326 @@
+/*
+ * Copyright 1995, Russell King.
+ * Various bits and pieces copyrights include:
+ *  Linus Torvalds (test_bit).
+ * Big endian support: Copyright 2001, Nicolas Pitre
+ *  reworked by rmk.
+ *
+ * bit 0 is the LSB of an "unsigned long" quantity.
+ *
+ * Please note that the code in this file should never be included
+ * from user space.  Many of these are not implemented in assembler
+ * since they would be too costly.  Also, they require privileged
+ * instructions (which are not available from user mode) to ensure
+ * that they are atomic.
+ */
+
+#ifndef __ASM_ARM_BITOPS_H
+#define __ASM_ARM_BITOPS_H
+
+#ifdef __KERNEL__
+
+#include <linux/compiler.h>
+#include <asm/system.h>
+
+#define smp_mb__before_clear_bit()	mb()
+#define smp_mb__after_clear_bit()	mb()
+
+/*
+ * These functions are the basis of our bit ops.
+ *
+ * First, the atomic bitops. These use native endian.
+ */
+static inline void ____atomic_set_bit(unsigned int bit, volatile unsigned long *p)
+{
+	unsigned long flags;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	raw_local_irq_save(flags);
+	*p |= mask;
+	raw_local_irq_restore(flags);
+}
+
+static inline void ____atomic_clear_bit(unsigned int bit, volatile unsigned long *p)
+{
+	unsigned long flags;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	raw_local_irq_save(flags);
+	*p &= ~mask;
+	raw_local_irq_restore(flags);
+}
+
+static inline void ____atomic_change_bit(unsigned int bit, volatile unsigned long *p)
+{
+	unsigned long flags;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	raw_local_irq_save(flags);
+	*p ^= mask;
+	raw_local_irq_restore(flags);
+}
+
+static inline int
+____atomic_test_and_set_bit(unsigned int bit, volatile unsigned long *p)
+{
+	unsigned long flags;
+	unsigned int res;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	raw_local_irq_save(flags);
+	res = *p;
+	*p = res | mask;
+	raw_local_irq_restore(flags);
+
+	return res & mask;
+}
+
+static inline int
+____atomic_test_and_clear_bit(unsigned int bit, volatile unsigned long *p)
+{
+	unsigned long flags;
+	unsigned int res;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	raw_local_irq_save(flags);
+	res = *p;
+	*p = res & ~mask;
+	raw_local_irq_restore(flags);
+
+	return res & mask;
+}
+
+static inline int
+____atomic_test_and_change_bit(unsigned int bit, volatile unsigned long *p)
+{
+	unsigned long flags;
+	unsigned int res;
+	unsigned long mask = 1UL << (bit & 31);
+
+	p += bit >> 5;
+
+	raw_local_irq_save(flags);
+	res = *p;
+	*p = res ^ mask;
+	raw_local_irq_restore(flags);
+
+	return res & mask;
+}
+
+#include <asm-generic/bitops/non-atomic.h>
+
+/*
+ *  A note about Endian-ness.
+ *  -------------------------
+ *
+ * When the ARM is put into big endian mode via CR15, the processor
+ * merely swaps the order of bytes within words, thus:
+ *
+ *          ------------ physical data bus bits -----------
+ *          D31 ... D24  D23 ... D16  D15 ... D8  D7 ... D0
+ * little     byte 3       byte 2       byte 1      byte 0
+ * big        byte 0       byte 1       byte 2      byte 3
+ *
+ * This means that reading a 32-bit word at address 0 returns the same
+ * value irrespective of the endian mode bit.
+ *
+ * Peripheral devices should be connected with the data bus reversed in
+ * "Big Endian" mode.  ARM Application Note 61 is applicable, and is
+ * available from http://www.arm.com/.
+ *
+ * The following assumes that the data bus connectivity for big endian
+ * mode has been followed.
+ *
+ * Note that bit 0 is defined to be 32-bit word bit 0, not byte 0 bit 0.
+ */
+
+/*
+ * Little endian assembly bitops.  nr = 0 -> byte 0 bit 0.
+ */
+extern void _set_bit_le(int nr, volatile unsigned long * p);
+extern void _clear_bit_le(int nr, volatile unsigned long * p);
+extern void _change_bit_le(int nr, volatile unsigned long * p);
+extern int _test_and_set_bit_le(int nr, volatile unsigned long * p);
+extern int _test_and_clear_bit_le(int nr, volatile unsigned long * p);
+extern int _test_and_change_bit_le(int nr, volatile unsigned long * p);
+extern int _find_first_zero_bit_le(const void * p, unsigned size);
+extern int _find_next_zero_bit_le(const void * p, int size, int offset);
+extern int _find_first_bit_le(const unsigned long *p, unsigned size);
+extern int _find_next_bit_le(const unsigned long *p, int size, int offset);
+
+/*
+ * Big endian assembly bitops.  nr = 0 -> byte 3 bit 0.
+ */
+extern void _set_bit_be(int nr, volatile unsigned long * p);
+extern void _clear_bit_be(int nr, volatile unsigned long * p);
+extern void _change_bit_be(int nr, volatile unsigned long * p);
+extern int _test_and_set_bit_be(int nr, volatile unsigned long * p);
+extern int _test_and_clear_bit_be(int nr, volatile unsigned long * p);
+extern int _test_and_change_bit_be(int nr, volatile unsigned long * p);
+extern int _find_first_zero_bit_be(const void * p, unsigned size);
+extern int _find_next_zero_bit_be(const void * p, int size, int offset);
+extern int _find_first_bit_be(const unsigned long *p, unsigned size);
+extern int _find_next_bit_be(const unsigned long *p, int size, int offset);
+
+#ifndef CONFIG_SMP
+/*
+ * The __* form of bitops are non-atomic and may be reordered.
+ */
+#define	ATOMIC_BITOP_LE(name,nr,p)		\
+	(__builtin_constant_p(nr) ?		\
+	 ____atomic_##name(nr, p) :		\
+	 _##name##_le(nr,p))
+
+#define	ATOMIC_BITOP_BE(name,nr,p)		\
+	(__builtin_constant_p(nr) ?		\
+	 ____atomic_##name(nr, p) :		\
+	 _##name##_be(nr,p))
+#else
+#define ATOMIC_BITOP_LE(name,nr,p)	_##name##_le(nr,p)
+#define ATOMIC_BITOP_BE(name,nr,p)	_##name##_be(nr,p)
+#endif
+
+#define NONATOMIC_BITOP(name,nr,p)		\
+	(____nonatomic_##name(nr, p))
+
+#ifndef __ARMEB__
+/*
+ * These are the little endian, atomic definitions.
+ */
+#define set_bit(nr,p)			ATOMIC_BITOP_LE(set_bit,nr,p)
+#define clear_bit(nr,p)			ATOMIC_BITOP_LE(clear_bit,nr,p)
+#define change_bit(nr,p)		ATOMIC_BITOP_LE(change_bit,nr,p)
+#define test_and_set_bit(nr,p)		ATOMIC_BITOP_LE(test_and_set_bit,nr,p)
+#define test_and_clear_bit(nr,p)	ATOMIC_BITOP_LE(test_and_clear_bit,nr,p)
+#define test_and_change_bit(nr,p)	ATOMIC_BITOP_LE(test_and_change_bit,nr,p)
+#define find_first_zero_bit(p,sz)	_find_first_zero_bit_le(p,sz)
+#define find_next_zero_bit(p,sz,off)	_find_next_zero_bit_le(p,sz,off)
+#define find_first_bit(p,sz)		_find_first_bit_le(p,sz)
+#define find_next_bit(p,sz,off)		_find_next_bit_le(p,sz,off)
+
+#define WORD_BITOFF_TO_LE(x)		((x))
+
+#else
+
+/*
+ * These are the big endian, atomic definitions.
+ */
+#define set_bit(nr,p)			ATOMIC_BITOP_BE(set_bit,nr,p)
+#define clear_bit(nr,p)			ATOMIC_BITOP_BE(clear_bit,nr,p)
+#define change_bit(nr,p)		ATOMIC_BITOP_BE(change_bit,nr,p)
+#define test_and_set_bit(nr,p)		ATOMIC_BITOP_BE(test_and_set_bit,nr,p)
+#define test_and_clear_bit(nr,p)	ATOMIC_BITOP_BE(test_and_clear_bit,nr,p)
+#define test_and_change_bit(nr,p)	ATOMIC_BITOP_BE(test_and_change_bit,nr,p)
+#define find_first_zero_bit(p,sz)	_find_first_zero_bit_be(p,sz)
+#define find_next_zero_bit(p,sz,off)	_find_next_zero_bit_be(p,sz,off)
+#define find_first_bit(p,sz)		_find_first_bit_be(p,sz)
+#define find_next_bit(p,sz,off)		_find_next_bit_be(p,sz,off)
+
+#define WORD_BITOFF_TO_LE(x)		((x) ^ 0x18)
+
+#endif
+
+#if __LINUX_ARM_ARCH__ < 5
+
+#include <asm-generic/bitops/ffz.h>
+#include <asm-generic/bitops/__ffs.h>
+#include <asm-generic/bitops/fls.h>
+#include <asm-generic/bitops/ffs.h>
+
+#else
+
+static inline int constant_fls(int x)
+{
+	int r = 32;
+
+	if (!x)
+		return 0;
+	if (!(x & 0xffff0000u)) {
+		x <<= 16;
+		r -= 16;
+	}
+	if (!(x & 0xff000000u)) {
+		x <<= 8;
+		r -= 8;
+	}
+	if (!(x & 0xf0000000u)) {
+		x <<= 4;
+		r -= 4;
+	}
+	if (!(x & 0xc0000000u)) {
+		x <<= 2;
+		r -= 2;
+	}
+	if (!(x & 0x80000000u)) {
+		x <<= 1;
+		r -= 1;
+	}
+	return r;
+}
+
+/*
+ * On ARMv5 and above those functions can be implemented around
+ * the clz instruction for much better code efficiency.
+ */
+
+#define fls(x) \
+	( __builtin_constant_p(x) ? constant_fls(x) : \
+	  ({ int __r; asm("clz\t%0, %1" : "=r"(__r) : "r"(x) : "cc"); 32-__r; }) )
+#define ffs(x) ({ unsigned long __t = (x); fls(__t & -__t); })
+#define __ffs(x) (ffs(x) - 1)
+#define ffz(x) __ffs( ~(x) )
+
+#endif
+
+#include <asm-generic/bitops/fls64.h>
+
+#include <asm-generic/bitops/sched.h>
+#include <asm-generic/bitops/hweight.h>
+
+/*
+ * Ext2 is defined to use little-endian byte ordering.
+ * These do not need to be atomic.
+ */
+#define ext2_set_bit(nr,p)			\
+		__test_and_set_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define ext2_set_bit_atomic(lock,nr,p)          \
+                test_and_set_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define ext2_clear_bit(nr,p)			\
+		__test_and_clear_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define ext2_clear_bit_atomic(lock,nr,p)        \
+                test_and_clear_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define ext2_test_bit(nr,p)			\
+		test_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define ext2_find_first_zero_bit(p,sz)		\
+		_find_first_zero_bit_le(p,sz)
+#define ext2_find_next_zero_bit(p,sz,off)	\
+		_find_next_zero_bit_le(p,sz,off)
+
+/*
+ * Minix is defined to use little-endian byte ordering.
+ * These do not need to be atomic.
+ */
+#define minix_set_bit(nr,p)			\
+		__set_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define minix_test_bit(nr,p)			\
+		test_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define minix_test_and_set_bit(nr,p)		\
+		__test_and_set_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define minix_test_and_clear_bit(nr,p)		\
+		__test_and_clear_bit(WORD_BITOFF_TO_LE(nr), (unsigned long *)(p))
+#define minix_find_first_zero_bit(p,sz)		\
+		_find_first_zero_bit_le(p,sz)
+
+#endif /* __KERNEL__ */
+
+#endif /* _ARM_BITOPS_H */
Index: build_tree/linux/include/asm/bug.h
diff -u /dev/null build_tree/linux/include/asm/bug.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/bug.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,24 @@
+#ifndef _ASMARM_BUG_H
+#define _ASMARM_BUG_H
+
+
+#ifdef CONFIG_BUG
+#ifdef CONFIG_DEBUG_BUGVERBOSE
+extern void __bug(const char *file, int line) __attribute__((noreturn));
+
+/* give file/line information */
+#define BUG()		__bug(__FILE__, __LINE__)
+
+#else
+
+/* this just causes an oops */
+#define BUG()		(*(int *)0 = 0)
+
+#endif
+
+#define HAVE_ARCH_BUG
+#endif
+
+#include <asm-generic/bug.h>
+
+#endif
Index: build_tree/linux/include/asm/bugs.h
diff -u /dev/null build_tree/linux/include/asm/bugs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/bugs.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/bugs.h
+ *
+ *  Copyright (C) 1995-2003 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_BUGS_H
+#define __ASM_BUGS_H
+
+#ifdef CONFIG_MMU
+extern void check_writebuffer_bugs(void);
+
+#define check_bugs() check_writebuffer_bugs()
+#else
+#define check_bugs() do { } while (0)
+#endif
+
+#endif
Index: build_tree/linux/include/asm/byteorder.h
diff -u /dev/null build_tree/linux/include/asm/byteorder.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/byteorder.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,58 @@
+/*
+ *  linux/include/asm-arm/byteorder.h
+ *
+ * ARM Endian-ness.  In little endian mode, the data bus is connected such
+ * that byte accesses appear as:
+ *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
+ * and word accesses (data or instruction) appear as:
+ *  d0...d31
+ *
+ * When in big endian mode, byte accesses appear as:
+ *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
+ * and word accesses (data or instruction) appear as:
+ *  d0...d31
+ */
+#ifndef __ASM_ARM_BYTEORDER_H
+#define __ASM_ARM_BYTEORDER_H
+
+#include <linux/compiler.h>
+#include <asm/types.h>
+
+static inline __attribute_const__ __u32 ___arch__swab32(__u32 x)
+{
+	__u32 t;
+
+#ifndef __thumb__
+	if (!__builtin_constant_p(x)) {
+		/*
+		 * The compiler needs a bit of a hint here to always do the
+		 * right thing and not screw it up to different degrees
+		 * depending on the gcc version.
+		 */
+		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
+	} else
+#endif
+		t = x ^ ((x << 16) | (x >> 16)); /* eor r1,r0,r0,ror #16 */
+
+	x = (x << 24) | (x >> 8);		/* mov r0,r0,ror #8      */
+	t &= ~0x00FF0000;			/* bic r1,r1,#0x00FF0000 */
+	x ^= (t >> 8);				/* eor r0,r0,r1,lsr #8   */
+
+	return x;
+}
+
+#define __arch__swab32(x) ___arch__swab32(x)
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#ifdef __ARMEB__
+#include <linux/byteorder/big_endian.h>
+#else
+#include <linux/byteorder/little_endian.h>
+#endif
+
+#endif
+
Index: build_tree/linux/include/asm/cache.h
diff -u /dev/null build_tree/linux/include/asm/cache.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/cache.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,10 @@
+/*
+ *  linux/include/asm-arm/cache.h
+ */
+#ifndef __ASMARM_CACHE_H
+#define __ASMARM_CACHE_H
+
+#define L1_CACHE_SHIFT		5
+#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
+
+#endif
Index: build_tree/linux/include/asm/cacheflush.h
diff -u /dev/null build_tree/linux/include/asm/cacheflush.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/cacheflush.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,480 @@
+/*
+ *  linux/include/asm-arm/cacheflush.h
+ *
+ *  Copyright (C) 1999-2002 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_CACHEFLUSH_H
+#define _ASMARM_CACHEFLUSH_H
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+
+#include <asm/glue.h>
+#include <asm/shmparam.h>
+
+#define CACHE_COLOUR(vaddr)	((vaddr & (SHMLBA - 1)) >> PAGE_SHIFT)
+
+/*
+ *	Cache Model
+ *	===========
+ */
+#undef _CACHE
+#undef MULTI_CACHE
+
+#if defined(CONFIG_CPU_CACHE_V3)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE v3
+# endif
+#endif
+
+#if defined(CONFIG_CPU_CACHE_V4)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE v4
+# endif
+#endif
+
+#if defined(CONFIG_CPU_ARM920T) || defined(CONFIG_CPU_ARM922T) || \
+    defined(CONFIG_CPU_ARM925T) || defined(CONFIG_CPU_ARM1020)
+# define MULTI_CACHE 1
+#endif
+
+#if defined(CONFIG_CPU_ARM926T)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE arm926
+# endif
+#endif
+
+#if defined(CONFIG_CPU_ARM940T)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE arm940
+# endif
+#endif
+
+#if defined(CONFIG_CPU_ARM946E)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE arm946
+# endif
+#endif
+
+#if defined(CONFIG_CPU_CACHE_V4WB)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE v4wb
+# endif
+#endif
+
+#if defined(CONFIG_CPU_XSCALE)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE xscale
+# endif
+#endif
+
+#if defined(CONFIG_CPU_XSC3)
+# ifdef _CACHE
+#  define MULTI_CACHE 1
+# else
+#  define _CACHE xsc3
+# endif
+#endif
+
+#if defined(CONFIG_CPU_V6)
+//# ifdef _CACHE
+#  define MULTI_CACHE 1
+//# else
+//#  define _CACHE v6
+//# endif
+#endif
+
+#if !defined(_CACHE) && !defined(MULTI_CACHE)
+#error Unknown cache maintainence model
+#endif
+
+/*
+ * This flag is used to indicate that the page pointed to by a pte
+ * is dirty and requires cleaning before returning it to the user.
+ */
+#define PG_dcache_dirty PG_arch_1
+
+/*
+ *	MM Cache Management
+ *	===================
+ *
+ *	The arch/arm/mm/cache-*.S and arch/arm/mm/proc-*.S files
+ *	implement these methods.
+ *
+ *	Start addresses are inclusive and end addresses are exclusive;
+ *	start addresses should be rounded down, end addresses up.
+ *
+ *	See Documentation/cachetlb.txt for more information.
+ *	Please note that the implementation of these, and the required
+ *	effects are cache-type (VIVT/VIPT/PIPT) specific.
+ *
+ *	flush_cache_kern_all()
+ *
+ *		Unconditionally clean and invalidate the entire cache.
+ *
+ *	flush_cache_user_mm(mm)
+ *
+ *		Clean and invalidate all user space cache entries
+ *		before a change of page tables.
+ *
+ *	flush_cache_user_range(start, end, flags)
+ *
+ *		Clean and invalidate a range of cache entries in the
+ *		specified address space before a change of page tables.
+ *		- start - user start address (inclusive, page aligned)
+ *		- end   - user end address   (exclusive, page aligned)
+ *		- flags - vma->vm_flags field
+ *
+ *	coherent_kern_range(start, end)
+ *
+ *		Ensure coherency between the Icache and the Dcache in the
+ *		region described by start, end.  If you have non-snooping
+ *		Harvard caches, you need to implement this function.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
+ *	DMA Cache Coherency
+ *	===================
+ *
+ *	dma_inv_range(start, end)
+ *
+ *		Invalidate (discard) the specified virtual address range.
+ *		May not write back any entries.  If 'start' or 'end'
+ *		are not cache line aligned, those lines must be written
+ *		back.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
+ *	dma_clean_range(start, end)
+ *
+ *		Clean (write back) the specified virtual address range.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
+ *	dma_flush_range(start, end)
+ *
+ *		Clean and invalidate the specified virtual address range.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ */
+
+struct cpu_cache_fns {
+	void (*flush_kern_all)(void);
+	void (*flush_user_all)(void);
+	void (*flush_user_range)(unsigned long, unsigned long, unsigned int);
+
+	void (*coherent_kern_range)(unsigned long, unsigned long);
+	void (*coherent_user_range)(unsigned long, unsigned long);
+	void (*flush_kern_dcache_page)(void *);
+
+	void (*dma_inv_range)(const void *, const void *);
+	void (*dma_clean_range)(const void *, const void *);
+	void (*dma_flush_range)(const void *, const void *);
+};
+
+struct outer_cache_fns {
+	void (*inv_range)(unsigned long, unsigned long);
+	void (*clean_range)(unsigned long, unsigned long);
+	void (*flush_range)(unsigned long, unsigned long);
+};
+
+/*
+ * Select the calling method
+ */
+#ifdef MULTI_CACHE
+
+extern struct cpu_cache_fns cpu_cache;
+
+#define __cpuc_flush_kern_all		cpu_cache.flush_kern_all
+#define __cpuc_flush_user_all		cpu_cache.flush_user_all
+#define __cpuc_flush_user_range		cpu_cache.flush_user_range
+#define __cpuc_coherent_kern_range	cpu_cache.coherent_kern_range
+#define __cpuc_coherent_user_range	cpu_cache.coherent_user_range
+#define __cpuc_flush_dcache_page	cpu_cache.flush_kern_dcache_page
+
+/*
+ * These are private to the dma-mapping API.  Do not use directly.
+ * Their sole purpose is to ensure that data held in the cache
+ * is visible to DMA, or data written by DMA to system memory is
+ * visible to the CPU.
+ */
+#define dmac_inv_range			cpu_cache.dma_inv_range
+#define dmac_clean_range		cpu_cache.dma_clean_range
+#define dmac_flush_range		cpu_cache.dma_flush_range
+
+#else
+
+#define __cpuc_flush_kern_all		__glue(_CACHE,_flush_kern_cache_all)
+#define __cpuc_flush_user_all		__glue(_CACHE,_flush_user_cache_all)
+#define __cpuc_flush_user_range		__glue(_CACHE,_flush_user_cache_range)
+#define __cpuc_coherent_kern_range	__glue(_CACHE,_coherent_kern_range)
+#define __cpuc_coherent_user_range	__glue(_CACHE,_coherent_user_range)
+#define __cpuc_flush_dcache_page	__glue(_CACHE,_flush_kern_dcache_page)
+
+extern void __cpuc_flush_kern_all(void);
+extern void __cpuc_flush_user_all(void);
+extern void __cpuc_flush_user_range(unsigned long, unsigned long, unsigned int);
+extern void __cpuc_coherent_kern_range(unsigned long, unsigned long);
+extern void __cpuc_coherent_user_range(unsigned long, unsigned long);
+extern void __cpuc_flush_dcache_page(void *);
+
+/*
+ * These are private to the dma-mapping API.  Do not use directly.
+ * Their sole purpose is to ensure that data held in the cache
+ * is visible to DMA, or data written by DMA to system memory is
+ * visible to the CPU.
+ */
+#define dmac_inv_range			__glue(_CACHE,_dma_inv_range)
+#define dmac_clean_range		__glue(_CACHE,_dma_clean_range)
+#define dmac_flush_range		__glue(_CACHE,_dma_flush_range)
+
+extern void dmac_inv_range(const void *, const void *);
+extern void dmac_clean_range(const void *, const void *);
+extern void dmac_flush_range(const void *, const void *);
+
+#endif
+
+#ifdef CONFIG_OUTER_CACHE
+
+extern struct outer_cache_fns outer_cache;
+
+static inline void outer_inv_range(unsigned long start, unsigned long end)
+{
+	if (outer_cache.inv_range)
+		outer_cache.inv_range(start, end);
+}
+static inline void outer_clean_range(unsigned long start, unsigned long end)
+{
+	if (outer_cache.clean_range)
+		outer_cache.clean_range(start, end);
+}
+static inline void outer_flush_range(unsigned long start, unsigned long end)
+{
+	if (outer_cache.flush_range)
+		outer_cache.flush_range(start, end);
+}
+
+#else
+
+static inline void outer_inv_range(unsigned long start, unsigned long end)
+{ }
+static inline void outer_clean_range(unsigned long start, unsigned long end)
+{ }
+static inline void outer_flush_range(unsigned long start, unsigned long end)
+{ }
+
+#endif
+
+/*
+ * flush_cache_vmap() is used when creating mappings (eg, via vmap,
+ * vmalloc, ioremap etc) in kernel space for pages.  Since the
+ * direct-mappings of these pages may contain cached data, we need
+ * to do a full cache flush to ensure that writebacks don't corrupt
+ * data placed into these pages via the new mappings.
+ */
+#define flush_cache_vmap(start, end)		flush_cache_all()
+#define flush_cache_vunmap(start, end)		flush_cache_all()
+
+/*
+ * Copy user data from/to a page which is mapped into a different
+ * processes address space.  Really, we want to allow our "user
+ * space" model to handle this.
+ */
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+	do {							\
+		memcpy(dst, src, len);				\
+		flush_ptrace_access(vma, page, vaddr, dst, len, 1);\
+	} while (0)
+
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+	do {							\
+		memcpy(dst, src, len);				\
+	} while (0)
+
+/*
+ * Convert calls to our calling convention.
+ */
+#define flush_cache_all()		__cpuc_flush_kern_all()
+#ifndef CONFIG_CPU_CACHE_VIPT
+static inline void flush_cache_mm(struct mm_struct *mm)
+{
+	if (cpu_isset(smp_processor_id(), mm->cpu_vm_mask))
+		__cpuc_flush_user_all();
+}
+
+static inline void
+flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)
+{
+	if (cpu_isset(smp_processor_id(), vma->vm_mm->cpu_vm_mask))
+		__cpuc_flush_user_range(start & PAGE_MASK, PAGE_ALIGN(end),
+					vma->vm_flags);
+}
+
+static inline void
+flush_cache_page(struct vm_area_struct *vma, unsigned long user_addr, unsigned long pfn)
+{
+	if (cpu_isset(smp_processor_id(), vma->vm_mm->cpu_vm_mask)) {
+		unsigned long addr = user_addr & PAGE_MASK;
+		__cpuc_flush_user_range(addr, addr + PAGE_SIZE, vma->vm_flags);
+	}
+}
+
+static inline void
+flush_ptrace_access(struct vm_area_struct *vma, struct page *page,
+			 unsigned long uaddr, void *kaddr,
+			 unsigned long len, int write)
+{
+	if (cpu_isset(smp_processor_id(), vma->vm_mm->cpu_vm_mask)) {
+		unsigned long addr = (unsigned long)kaddr;
+		__cpuc_coherent_kern_range(addr, addr + len);
+	}
+}
+#else
+extern void flush_cache_mm(struct mm_struct *mm);
+extern void flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end);
+extern void flush_cache_page(struct vm_area_struct *vma, unsigned long user_addr, unsigned long pfn);
+extern void flush_ptrace_access(struct vm_area_struct *vma, struct page *page,
+				unsigned long uaddr, void *kaddr,
+				unsigned long len, int write);
+#endif
+
+#define flush_cache_dup_mm(mm) flush_cache_mm(mm)
+
+/*
+ * flush_cache_user_range is used when we want to ensure that the
+ * Harvard caches are synchronised for the user space address range.
+ * This is used for the ARM private sys_cacheflush system call.
+ */
+#define flush_cache_user_range(vma,start,end) \
+	__cpuc_coherent_user_range((start) & PAGE_MASK, PAGE_ALIGN(end))
+
+/*
+ * Perform necessary cache operations to ensure that data previously
+ * stored within this range of addresses can be executed by the CPU.
+ */
+#define flush_icache_range(s,e)		__cpuc_coherent_kern_range(s,e)
+
+/*
+ * Perform necessary cache operations to ensure that the TLB will
+ * see data written in the specified area.
+ */
+#define clean_dcache_area(start,size)	cpu_dcache_clean_area(start, size)
+
+/*
+ * flush_dcache_page is used when the kernel has written to the page
+ * cache page at virtual address page->virtual.
+ *
+ * If this page isn't mapped (ie, page_mapping == NULL), or it might
+ * have userspace mappings, then we _must_ always clean + invalidate
+ * the dcache entries associated with the kernel mapping.
+ *
+ * Otherwise we can defer the operation, and clean the cache when we are
+ * about to change to user space.  This is the same method as used on SPARC64.
+ * See update_mmu_cache for the user space part.
+ */
+extern void flush_dcache_page(struct page *);
+
+extern void __flush_dcache_page(struct address_space *mapping, struct page *page);
+
+#define ARCH_HAS_FLUSH_ANON_PAGE
+static inline void flush_anon_page(struct vm_area_struct *vma,
+			 struct page *page, unsigned long vmaddr)
+{
+	extern void __flush_anon_page(struct vm_area_struct *vma,
+				struct page *, unsigned long);
+	if (PageAnon(page))
+		__flush_anon_page(vma, page, vmaddr);
+}
+
+#define flush_dcache_mmap_lock(mapping) \
+	write_lock_irq(&(mapping)->tree_lock)
+#define flush_dcache_mmap_unlock(mapping) \
+	write_unlock_irq(&(mapping)->tree_lock)
+
+#define flush_icache_user_range(vma,page,addr,len) \
+	flush_dcache_page(page)
+
+/*
+ * We don't appear to need to do anything here.  In fact, if we did, we'd
+ * duplicate cache flushing elsewhere performed by flush_dcache_page().
+ */
+#define flush_icache_page(vma,page)	do { } while (0)
+
+#define __cacheid_present(val)		(val != read_cpuid(CPUID_ID))
+#define __cacheid_vivt(val)		((val & (15 << 25)) != (14 << 25))
+#define __cacheid_vipt(val)		((val & (15 << 25)) == (14 << 25))
+#define __cacheid_vipt_nonaliasing(val)	((val & (15 << 25 | 1 << 23)) == (14 << 25))
+#define __cacheid_vipt_aliasing(val)	((val & (15 << 25 | 1 << 23)) == (14 << 25 | 1 << 23))
+
+#if defined(CONFIG_CPU_CACHE_VIVT) && !defined(CONFIG_CPU_CACHE_VIPT)
+
+#define cache_is_vivt()			1
+#define cache_is_vipt()			0
+#define cache_is_vipt_nonaliasing()	0
+#define cache_is_vipt_aliasing()	0
+
+#elif defined(CONFIG_CPU_CACHE_VIPT)
+
+#define cache_is_vivt()			0
+#define cache_is_vipt()			1
+#define cache_is_vipt_nonaliasing()					\
+	({								\
+		unsigned int __val = read_cpuid(CPUID_CACHETYPE);	\
+		__cacheid_vipt_nonaliasing(__val);			\
+	})
+
+#define cache_is_vipt_aliasing()					\
+	({								\
+		unsigned int __val = read_cpuid(CPUID_CACHETYPE);	\
+		__cacheid_vipt_aliasing(__val);				\
+	})
+
+#else
+
+#define cache_is_vivt()							\
+	({								\
+		unsigned int __val = read_cpuid(CPUID_CACHETYPE);	\
+		(!__cacheid_present(__val)) || __cacheid_vivt(__val);	\
+	})
+		
+#define cache_is_vipt()							\
+	({								\
+		unsigned int __val = read_cpuid(CPUID_CACHETYPE);	\
+		__cacheid_present(__val) && __cacheid_vipt(__val);	\
+	})
+
+#define cache_is_vipt_nonaliasing()					\
+	({								\
+		unsigned int __val = read_cpuid(CPUID_CACHETYPE);	\
+		__cacheid_present(__val) &&				\
+		 __cacheid_vipt_nonaliasing(__val);			\
+	})
+
+#define cache_is_vipt_aliasing()					\
+	({								\
+		unsigned int __val = read_cpuid(CPUID_CACHETYPE);	\
+		__cacheid_present(__val) &&				\
+		 __cacheid_vipt_aliasing(__val);			\
+	})
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/checksum.h
diff -u /dev/null build_tree/linux/include/asm/checksum.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/checksum.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,139 @@
+/*
+ *  linux/include/asm-arm/checksum.h
+ *
+ * IP checksum routines
+ *
+ * Copyright (C) Original authors of ../asm-i386/checksum.h
+ * Copyright (C) 1996-1999 Russell King
+ */
+#ifndef __ASM_ARM_CHECKSUM_H
+#define __ASM_ARM_CHECKSUM_H
+
+#include <linux/in6.h>
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+__wsum csum_partial(const void *buff, int len, __wsum sum);
+
+/*
+ * the same as csum_partial, but copies from src while it
+ * checksums, and handles user-space pointer exceptions correctly, when needed.
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+__wsum
+csum_partial_copy_nocheck(const void *src, void *dst, int len, __wsum sum);
+
+__wsum
+csum_partial_copy_from_user(const void __user *src, void *dst, int len, __wsum sum, int *err_ptr);
+
+/*
+ * 	Fold a partial checksum without adding pseudo headers
+ */
+static inline __sum16 csum_fold(__wsum sum)
+{
+	__asm__(
+	"add	%0, %1, %1, ror #16	@ csum_fold"
+	: "=r" (sum)
+	: "r" (sum)
+	: "cc");
+	return (__force __sum16)(~(__force u32)sum >> 16);
+}
+
+/*
+ *	This is a version of ip_compute_csum() optimized for IP headers,
+ *	which always checksum on 4 octet boundaries.
+ */
+static inline __sum16
+ip_fast_csum(const void *iph, unsigned int ihl)
+{
+	unsigned int tmp1;
+	__wsum sum;
+
+	__asm__ __volatile__(
+	"ldr	%0, [%1], #4		@ ip_fast_csum		\n\
+	ldr	%3, [%1], #4					\n\
+	sub	%2, %2, #5					\n\
+	adds	%0, %0, %3					\n\
+	ldr	%3, [%1], #4					\n\
+	adcs	%0, %0, %3					\n\
+	ldr	%3, [%1], #4					\n\
+1:	adcs	%0, %0, %3					\n\
+	ldr	%3, [%1], #4					\n\
+	tst	%2, #15			@ do this carefully	\n\
+	subne	%2, %2, #1		@ without destroying	\n\
+	bne	1b			@ the carry flag	\n\
+	adcs	%0, %0, %3					\n\
+	adc	%0, %0, #0"
+	: "=r" (sum), "=r" (iph), "=r" (ihl), "=r" (tmp1)
+	: "1" (iph), "2" (ihl)
+	: "cc", "memory");
+	return csum_fold(sum);
+}
+
+static inline __wsum
+csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len,
+		   unsigned short proto, __wsum sum)
+{
+	__asm__(
+	"adds	%0, %1, %2		@ csum_tcpudp_nofold	\n\
+	adcs	%0, %0, %3					\n"
+#ifdef __ARMEB__
+	"adcs	%0, %0, %4					\n"
+#else
+	"adcs	%0, %0, %4, lsl #8				\n"
+#endif
+	"adcs	%0, %0, %5					\n\
+	adc	%0, %0, #0"
+	: "=&r"(sum)
+	: "r" (sum), "r" (daddr), "r" (saddr), "r" (len), "Ir" (htons(proto))
+	: "cc");
+	return sum;
+}	
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+static inline __sum16
+csum_tcpudp_magic(__be32 saddr, __be32 daddr, unsigned short len,
+		  unsigned short proto, __wsum sum)
+{
+	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
+}
+
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+static inline __sum16
+ip_compute_csum(const void *buff, int len)
+{
+	return csum_fold(csum_partial(buff, len, 0));
+}
+
+#define _HAVE_ARCH_IPV6_CSUM
+extern __wsum
+__csum_ipv6_magic(const struct in6_addr *saddr, const struct in6_addr *daddr, __be32 len,
+		__be32 proto, __wsum sum);
+
+static inline __sum16
+csum_ipv6_magic(const struct in6_addr *saddr, const struct in6_addr *daddr, __u32 len,
+		unsigned short proto, __wsum sum)
+{
+	return csum_fold(__csum_ipv6_magic(saddr, daddr, htonl(len),
+					   htonl(proto), sum));
+}
+#endif
Index: build_tree/linux/include/asm/cnt32_to_63.h
diff -u /dev/null build_tree/linux/include/asm/cnt32_to_63.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/cnt32_to_63.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,78 @@
+/*
+ *  include/asm/cnt32_to_63.h -- extend a 32-bit counter to 63 bits
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	December 3, 2006
+ *  Copyright:	MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ */
+
+#ifndef __INCLUDE_CNT32_TO_63_H__
+#define __INCLUDE_CNT32_TO_63_H__
+
+#include <linux/compiler.h>
+#include <asm/types.h>
+#include <asm/byteorder.h>
+
+/*
+ * Prototype: u64 cnt32_to_63(u32 cnt)
+ * Many hardware clock counters are only 32 bits wide and therefore have
+ * a relatively short period making wrap-arounds rather frequent.  This
+ * is a problem when implementing sched_clock() for example, where a 64-bit
+ * non-wrapping monotonic value is expected to be returned.
+ *
+ * To overcome that limitation, let's extend a 32-bit counter to 63 bits
+ * in a completely lock free fashion. Bits 0 to 31 of the clock are provided
+ * by the hardware while bits 32 to 62 are stored in memory.  The top bit in
+ * memory is used to synchronize with the hardware clock half-period.  When
+ * the top bit of both counters (hardware and in memory) differ then the
+ * memory is updated with a new value, incrementing it when the hardware
+ * counter wraps around.
+ *
+ * Because a word store in memory is atomic then the incremented value will
+ * always be in synch with the top bit indicating to any potential concurrent
+ * reader if the value in memory is up to date or not with regards to the
+ * needed increment.  And any race in updating the value in memory is harmless
+ * as the same value would simply be stored more than once.
+ *
+ * The only restriction for the algorithm to work properly is that this
+ * code must be executed at least once per each half period of the 32-bit
+ * counter to properly update the state bit in memory. This is usually not a
+ * problem in practice, but if it is then a kernel timer could be scheduled
+ * to manage for this code to be executed often enough.
+ *
+ * Note that the top bit (bit 63) in the returned value should be considered
+ * as garbage.  It is not cleared here because callers are likely to use a
+ * multiplier on the returned value which can get rid of the top bit
+ * implicitly by making the multiplier even, therefore saving on a runtime
+ * clear-bit instruction. Otherwise caller must remember to clear the top
+ * bit explicitly.
+ */
+
+/* this is used only to give gcc a clue about good code generation */
+typedef union {
+	struct {
+#if defined(__LITTLE_ENDIAN)
+		u32 lo, hi;
+#elif defined(__BIG_ENDIAN)
+		u32 hi, lo;
+#endif
+	};
+	u64 val;
+} cnt32_to_63_t;
+
+#define cnt32_to_63(cnt_lo) \
+({ \
+	static volatile u32 __m_cnt_hi = 0; \
+	cnt32_to_63_t __x; \
+	__x.hi = __m_cnt_hi; \
+	__x.lo = (cnt_lo); \
+ 	if (unlikely((s32)(__x.hi ^ __x.lo) < 0)) \
+		__m_cnt_hi = __x.hi = (__x.hi ^ 0x80000000) + (__x.hi >> 31); \
+	__x.val; \
+})
+
+#endif
Index: build_tree/linux/include/asm/cpu-multi32.h
diff -u /dev/null build_tree/linux/include/asm/cpu-multi32.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/cpu-multi32.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,65 @@
+/*
+ *  linux/include/asm-arm/cpu-multi32.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm/page.h>
+
+struct mm_struct;
+
+/*
+ * Don't change this structure - ASM code
+ * relies on it.
+ */
+extern struct processor {
+	/* MISC
+	 * get data abort address/flags
+	 */
+	void (*_data_abort)(unsigned long pc);
+	/*
+	 * Set up any processor specifics
+	 */
+	void (*_proc_init)(void);
+	/*
+	 * Disable any processor specifics
+	 */
+	void (*_proc_fin)(void);
+	/*
+	 * Special stuff for a reset
+	 */
+	void (*reset)(unsigned long addr) __attribute__((noreturn));
+	/*
+	 * Idle the processor
+	 */
+	int (*_do_idle)(void);
+	/*
+	 * Processor architecture specific
+	 */
+	/*
+	 * clean a virtual address range from the
+	 * D-cache without flushing the cache.
+	 */
+	void (*dcache_clean_area)(void *addr, int size);
+
+	/*
+	 * Set the page table
+	 */
+	void (*switch_mm)(unsigned long pgd_phys, struct mm_struct *mm);
+	/*
+	 * Set a possibly extended PTE.  Non-extended PTEs should
+	 * ignore 'ext'.
+	 */
+	void (*set_pte_ext)(pte_t *ptep, pte_t pte, unsigned int ext);
+} processor;
+
+#define cpu_proc_init()			processor._proc_init()
+#define cpu_proc_fin()			processor._proc_fin()
+#define cpu_reset(addr)			processor.reset(addr)
+#define cpu_do_idle()			processor._do_idle()
+#define cpu_dcache_clean_area(addr,sz)	processor.dcache_clean_area(addr,sz)
+#define cpu_set_pte_ext(ptep,pte,ext)	processor.set_pte_ext(ptep,pte,ext)
+#define cpu_do_switch_mm(pgd,mm)	processor.switch_mm(pgd,mm)
Index: build_tree/linux/include/asm/cpu-single.h
diff -u /dev/null build_tree/linux/include/asm/cpu-single.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/cpu-single.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/asm-arm/cpu-single.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/*
+ * Single CPU
+ */
+#ifdef __STDC__
+#define __catify_fn(name,x)	name##x
+#else
+#define __catify_fn(name,x)	name/**/x
+#endif
+#define __cpu_fn(name,x)	__catify_fn(name,x)
+
+/*
+ * If we are supporting multiple CPUs, then we must use a table of
+ * function pointers for this lot.  Otherwise, we can optimise the
+ * table away.
+ */
+#define cpu_proc_init			__cpu_fn(CPU_NAME,_proc_init)
+#define cpu_proc_fin			__cpu_fn(CPU_NAME,_proc_fin)
+#define cpu_reset			__cpu_fn(CPU_NAME,_reset)
+#define cpu_do_idle			__cpu_fn(CPU_NAME,_do_idle)
+#define cpu_dcache_clean_area		__cpu_fn(CPU_NAME,_dcache_clean_area)
+#define cpu_do_switch_mm		__cpu_fn(CPU_NAME,_switch_mm)
+#define cpu_set_pte_ext			__cpu_fn(CPU_NAME,_set_pte_ext)
+
+#include <asm/page.h>
+
+struct mm_struct;
+
+/* declare all the functions as extern */
+extern void cpu_proc_init(void);
+extern void cpu_proc_fin(void);
+extern int cpu_do_idle(void);
+extern void cpu_dcache_clean_area(void *, int);
+extern void cpu_do_switch_mm(unsigned long pgd_phys, struct mm_struct *mm);
+extern void cpu_set_pte_ext(pte_t *ptep, pte_t pte, unsigned int ext);
+extern void cpu_reset(unsigned long addr) __attribute__((noreturn));
Index: build_tree/linux/include/asm/cpu.h
diff -u /dev/null build_tree/linux/include/asm/cpu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/cpu.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,25 @@
+/*
+ *  linux/include/asm-arm/cpu.h
+ *
+ *  Copyright (C) 2004-2005 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_CPU_H
+#define __ASM_ARM_CPU_H
+
+#include <linux/percpu.h>
+
+struct cpuinfo_arm {
+	struct cpu	cpu;
+#ifdef CONFIG_SMP
+	struct task_struct *idle;
+	unsigned int	loops_per_jiffy;
+#endif
+};
+
+DECLARE_PER_CPU(struct cpuinfo_arm, cpu_data);
+
+#endif
Index: build_tree/linux/include/asm/cputime.h
diff -u /dev/null build_tree/linux/include/asm/cputime.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/cputime.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef __ARM_CPUTIME_H
+#define __ARM_CPUTIME_H
+
+#include <asm-generic/cputime.h>
+
+#endif /* __ARM_CPUTIME_H */
Index: build_tree/linux/include/asm/current.h
diff -u /dev/null build_tree/linux/include/asm/current.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/current.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,15 @@
+#ifndef _ASMARM_CURRENT_H
+#define _ASMARM_CURRENT_H
+
+#include <linux/thread_info.h>
+
+static inline struct task_struct *get_current(void) __attribute_const__;
+
+static inline struct task_struct *get_current(void)
+{
+	return current_thread_info()->task;
+}
+
+#define current (get_current())
+
+#endif /* _ASMARM_CURRENT_H */
Index: build_tree/linux/include/asm/delay.h
diff -u /dev/null build_tree/linux/include/asm/delay.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/delay.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1995-2004 Russell King
+ *
+ * Delay routines, using a pre-computed "loops_per_second" value.
+ */
+#ifndef __ASM_ARM_DELAY_H
+#define __ASM_ARM_DELAY_H
+
+#include <asm/param.h>	/* HZ */
+
+extern void __delay(int loops);
+
+/*
+ * This function intentionally does not exist; if you see references to
+ * it, it means that you're calling udelay() with an out of range value.
+ *
+ * With currently imposed limits, this means that we support a max delay
+ * of 2000us. Further limits: HZ<=1000 and bogomips<=3355
+ */
+extern void __bad_udelay(void);
+
+/*
+ * division by multiplication: you don't have to worry about
+ * loss of precision.
+ *
+ * Use only for very small delays ( < 1 msec).  Should probably use a
+ * lookup table, really, as the multiplications take much too long with
+ * short delays.  This is a "reasonable" implementation, though (and the
+ * first constant multiplications gets optimized away if the delay is
+ * a constant)
+ */
+extern void __udelay(unsigned long usecs);
+extern void __const_udelay(unsigned long);
+
+#define MAX_UDELAY_MS 2
+
+#define udelay(n)							\
+	(__builtin_constant_p(n) ?					\
+	  ((n) > (MAX_UDELAY_MS * 1000) ? __bad_udelay() :		\
+			__const_udelay((n) * ((2199023U*HZ)>>11))) :	\
+	  __udelay(n))
+
+#endif /* defined(_ARM_DELAY_H) */
+
Index: build_tree/linux/include/asm/device.h
diff -u /dev/null build_tree/linux/include/asm/device.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/device.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,15 @@
+/*
+ * Arch specific extensions to struct device
+ *
+ * This file is released under the GPLv2
+ */
+#ifndef ASMARM_DEVICE_H
+#define ASMARM_DEVICE_H
+
+struct dev_archdata {
+#ifdef CONFIG_DMABOUNCE
+	struct dmabounce_device_info *dmabounce;
+#endif
+};
+
+#endif
Index: build_tree/linux/include/asm/div64.h
diff -u /dev/null build_tree/linux/include/asm/div64.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/div64.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,226 @@
+#ifndef __ASM_ARM_DIV64
+#define __ASM_ARM_DIV64
+
+#include <asm/system.h>
+
+/*
+ * The semantics of do_div() are:
+ *
+ * uint32_t do_div(uint64_t *n, uint32_t base)
+ * {
+ * 	uint32_t remainder = *n % base;
+ * 	*n = *n / base;
+ * 	return remainder;
+ * }
+ *
+ * In other words, a 64-bit dividend with a 32-bit divisor producing
+ * a 64-bit result and a 32-bit remainder.  To accomplish this optimally
+ * we call a special __do_div64 helper with completely non standard
+ * calling convention for arguments and results (beware).
+ */
+
+#ifdef __ARMEB__
+#define __xh "r0"
+#define __xl "r1"
+#else
+#define __xl "r0"
+#define __xh "r1"
+#endif
+
+#define __do_div_asm(n, base)					\
+({								\
+	register unsigned int __base      asm("r4") = base;	\
+	register unsigned long long __n   asm("r0") = n;	\
+	register unsigned long long __res asm("r2");		\
+	register unsigned int __rem       asm(__xh);		\
+	asm(	__asmeq("%0", __xh)				\
+		__asmeq("%1", "r2")				\
+		__asmeq("%2", "r0")				\
+		__asmeq("%3", "r4")				\
+		"bl	__do_div64"				\
+		: "=r" (__rem), "=r" (__res)			\
+		: "r" (__n), "r" (__base)			\
+		: "ip", "lr", "cc");				\
+	n = __res;						\
+	__rem;							\
+})
+
+#if __GNUC__ < 4
+
+/*
+ * gcc versions earlier than 4.0 are simply too problematic for the
+ * optimized implementation below. First there is gcc PR 15089 that
+ * tend to trig on more complex constructs, spurious .global __udivsi3
+ * are inserted even if none of those symbols are referenced in the
+ * generated code, and those gcc versions are not able to do constant
+ * propagation on long long values anyway.
+ */
+#define do_div(n, base) __do_div_asm(n, base)
+
+#elif __GNUC__ >= 4
+
+#include <asm/bug.h>
+
+/*
+ * If the divisor happens to be constant, we determine the appropriate
+ * inverse at compile time to turn the division into a few inline
+ * multiplications instead which is much faster. And yet only if compiling
+ * for ARMv4 or higher (we need umull/umlal) and if the gcc version is
+ * sufficiently recent to perform proper long long constant propagation.
+ * (It is unfortunate that gcc doesn't perform all this internally.)
+ */
+#define do_div(n, base)							\
+({									\
+	unsigned int __r, __b = (base);					\
+	if (!__builtin_constant_p(__b) || __b == 0 ||			\
+	    (__LINUX_ARM_ARCH__ < 4 && (__b & (__b - 1)) != 0)) {	\
+		/* non-constant divisor (or zero): slow path */		\
+		__r = __do_div_asm(n, __b);				\
+	} else if ((__b & (__b - 1)) == 0) {				\
+		/* Trivial: __b is constant and a power of 2 */		\
+		/* gcc does the right thing with this code.  */		\
+		__r = n;						\
+		__r &= (__b - 1);					\
+		n /= __b;						\
+	} else {							\
+		/* Multiply by inverse of __b: n/b = n*(p/b)/p       */	\
+		/* We rely on the fact that most of this code gets   */	\
+		/* optimized away at compile time due to constant    */	\
+		/* propagation and only a couple inline assembly     */	\
+		/* instructions should remain. Better avoid any      */	\
+		/* code construct that might prevent that.           */	\
+		unsigned long long __res, __x, __t, __m, __n = n;	\
+		unsigned int __c, __p, __z = 0;				\
+		/* preserve low part of n for reminder computation */	\
+		__r = __n;						\
+		/* determine number of bits to represent __b */		\
+		__p = 1 << __div64_fls(__b);				\
+		/* compute __m = ((__p << 64) + __b - 1) / __b */	\
+		__m = (~0ULL / __b) * __p;				\
+		__m += (((~0ULL % __b + 1) * __p) + __b - 1) / __b;	\
+		/* compute __res = __m*(~0ULL/__b*__b-1)/(__p << 64) */	\
+		__x = ~0ULL / __b * __b - 1;				\
+		__res = (__m & 0xffffffff) * (__x & 0xffffffff);	\
+		__res >>= 32;						\
+		__res += (__m & 0xffffffff) * (__x >> 32);		\
+		__t = __res;						\
+		__res += (__x & 0xffffffff) * (__m >> 32);		\
+		__t = (__res < __t) ? (1ULL << 32) : 0;			\
+		__res = (__res >> 32) + __t;				\
+		__res += (__m >> 32) * (__x >> 32);			\
+		__res /= __p;						\
+		/* Now sanitize and optimize what we've got. */		\
+		if (~0ULL % (__b / (__b & -__b)) == 0) {		\
+			/* those cases can be simplified with: */	\
+			__n /= (__b & -__b);				\
+			__m = ~0ULL / (__b / (__b & -__b));		\
+			__p = 1;					\
+			__c = 1;					\
+		} else if (__res != __x / __b) {			\
+			/* We can't get away without a correction    */	\
+			/* to compensate for bit truncation errors.  */	\
+			/* To avoid it we'd need an additional bit   */	\
+			/* to represent __m which would overflow it. */	\
+			/* Instead we do m=p/b and n/b=(n*m+m)/p.    */	\
+			__c = 1;					\
+			/* Compute __m = (__p << 64) / __b */		\
+			__m = (~0ULL / __b) * __p;			\
+			__m += ((~0ULL % __b + 1) * __p) / __b;		\
+		} else {						\
+			/* Reduce __m/__p, and try to clear bit 31   */	\
+			/* of __m when possible otherwise that'll    */	\
+			/* need extra overflow handling later.       */	\
+			unsigned int __bits = -(__m & -__m);		\
+			__bits |= __m >> 32;				\
+			__bits = (~__bits) << 1;			\
+			/* If __bits == 0 then setting bit 31 is     */	\
+			/* unavoidable.  Simply apply the maximum    */	\
+			/* possible reduction in that case.          */	\
+			/* Otherwise the MSB of __bits indicates the */	\
+			/* best reduction we should apply.           */	\
+			if (!__bits) {					\
+				__p /= (__m & -__m);			\
+				__m /= (__m & -__m);			\
+			} else {					\
+				__p >>= __div64_fls(__bits);		\
+				__m >>= __div64_fls(__bits);		\
+			}						\
+			/* No correction needed. */			\
+			__c = 0;					\
+		}							\
+		/* Now we have a combination of 2 conditions:        */	\
+		/* 1) whether or not we need a correction (__c), and */	\
+		/* 2) whether or not there might be an overflow in   */	\
+		/*    the cross product (__m & ((1<<63) | (1<<31)))  */	\
+		/* Select the best insn combination to perform the   */	\
+		/* actual __m * __n / (__p << 64) operation.         */	\
+		if (!__c) {						\
+			asm (	"umull	%Q0, %R0, %1, %Q2\n\t"		\
+				"mov	%Q0, #0"			\
+				: "=&r" (__res)				\
+				: "r" (__m), "r" (__n)			\
+				: "cc" );				\
+		} else if (!(__m & ((1ULL << 63) | (1ULL << 31)))) {	\
+			__res = __m;					\
+			asm (	"umlal	%Q0, %R0, %Q1, %Q2\n\t"		\
+				"mov	%Q0, #0"			\
+				: "+r" (__res)				\
+				: "r" (__m), "r" (__n)			\
+				: "cc" );				\
+		} else {						\
+			asm (	"umull	%Q0, %R0, %Q1, %Q2\n\t"		\
+				"cmn	%Q0, %Q1\n\t"			\
+				"adcs	%R0, %R0, %R1\n\t"		\
+				"adc	%Q0, %3, #0"			\
+				: "=&r" (__res)				\
+				: "r" (__m), "r" (__n), "r" (__z)	\
+				: "cc" );				\
+		}							\
+		if (!(__m & ((1ULL << 63) | (1ULL << 31)))) {		\
+			asm (	"umlal	%R0, %Q0, %R1, %Q2\n\t"		\
+				"umlal	%R0, %Q0, %Q1, %R2\n\t"		\
+				"mov	%R0, #0\n\t"			\
+				"umlal	%Q0, %R0, %R1, %R2"		\
+				: "+r" (__res)				\
+				: "r" (__m), "r" (__n)			\
+				: "cc" );				\
+		} else {						\
+			asm (	"umlal	%R0, %Q0, %R2, %Q3\n\t"		\
+				"umlal	%R0, %1, %Q2, %R3\n\t"		\
+				"mov	%R0, #0\n\t"			\
+				"adds	%Q0, %1, %Q0\n\t"		\
+				"adc	%R0, %R0, #0\n\t"		\
+				"umlal	%Q0, %R0, %R2, %R3"		\
+				: "+r" (__res), "+r" (__z)		\
+				: "r" (__m), "r" (__n)			\
+				: "cc" );				\
+		}							\
+		__res /= __p;						\
+		/* The reminder can be computed with 32-bit regs     */	\
+		/* only, and gcc is good at that.                    */	\
+		{							\
+			unsigned int __res0 = __res;			\
+			unsigned int __b0 = __b;			\
+			__r -= __res0 * __b0;				\
+		}							\
+		/* BUG_ON(__r >= __b || __res * __b + __r != n); */	\
+		n = __res;						\
+	}								\
+	__r;								\
+})
+
+/* our own fls implementation to make sure constant propagation is fine */
+#define __div64_fls(bits)						\
+({									\
+	unsigned int __left = (bits), __nr = 0;				\
+	if (__left & 0xffff0000) __nr += 16, __left >>= 16;		\
+	if (__left & 0x0000ff00) __nr +=  8, __left >>=  8;		\
+	if (__left & 0x000000f0) __nr +=  4, __left >>=  4;		\
+	if (__left & 0x0000000c) __nr +=  2, __left >>=  2;		\
+	if (__left & 0x00000002) __nr +=  1;				\
+	__nr;								\
+})
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/dma-mapping.h
diff -u /dev/null build_tree/linux/include/asm/dma-mapping.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/dma-mapping.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,456 @@
+#ifndef ASMARM_DMA_MAPPING_H
+#define ASMARM_DMA_MAPPING_H
+
+#ifdef __KERNEL__
+
+#include <linux/mm.h> /* need struct page */
+
+#include <asm/scatterlist.h>
+
+/*
+ * DMA-consistent mapping functions.  These allocate/free a region of
+ * uncached, unwrite-buffered mapped memory space for use with DMA
+ * devices.  This is the "generic" version.  The PCI specific version
+ * is in pci.h
+ *
+ * Note: Drivers should NOT use this function directly, as it will break
+ * platforms with CONFIG_DMABOUNCE.
+ * Use the driver DMA support - see dma-mapping.h (dma_sync_*)
+ */
+extern void consistent_sync(const void *kaddr, size_t size, int rw);
+
+/*
+ * Return whether the given device DMA address mask can be supported
+ * properly.  For example, if your device can only drive the low 24-bits
+ * during bus mastering, then you would pass 0x00ffffff as the mask
+ * to this function.
+ *
+ * FIXME: This should really be a platform specific issue - we should
+ * return false if GFP_DMA allocations may not satisfy the supplied 'mask'.
+ */
+static inline int dma_supported(struct device *dev, u64 mask)
+{
+	return dev->dma_mask && *dev->dma_mask != 0;
+}
+
+static inline int dma_set_mask(struct device *dev, u64 dma_mask)
+{
+	if (!dev->dma_mask || !dma_supported(dev, dma_mask))
+		return -EIO;
+
+	*dev->dma_mask = dma_mask;
+
+	return 0;
+}
+
+static inline int dma_get_cache_alignment(void)
+{
+	return 32;
+}
+
+static inline int dma_is_consistent(struct device *dev, dma_addr_t handle)
+{
+	return !!arch_is_coherent();
+}
+
+/*
+ * DMA errors are defined by all-bits-set in the DMA address.
+ */
+static inline int dma_mapping_error(dma_addr_t dma_addr)
+{
+	return dma_addr == ~0;
+}
+
+/*
+ * Dummy noncoherent implementation.  We don't provide a dma_cache_sync
+ * function so drivers using this API are highlighted with build warnings.
+ */
+static inline void *
+dma_alloc_noncoherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
+{
+	return NULL;
+}
+
+static inline void
+dma_free_noncoherent(struct device *dev, size_t size, void *cpu_addr,
+		     dma_addr_t handle)
+{
+}
+
+/**
+ * dma_alloc_coherent - allocate consistent memory for DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @size: required memory size
+ * @handle: bus-specific DMA address
+ *
+ * Allocate some uncached, unbuffered memory for a device for
+ * performing DMA.  This function allocates pages, and will
+ * return the CPU-viewed address, and sets @handle to be the
+ * device-viewed address.
+ */
+extern void *
+dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp);
+
+/**
+ * dma_free_coherent - free memory allocated by dma_alloc_coherent
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @size: size of memory originally requested in dma_alloc_coherent
+ * @cpu_addr: CPU-view address returned from dma_alloc_coherent
+ * @handle: device-view address returned from dma_alloc_coherent
+ *
+ * Free (and unmap) a DMA buffer previously allocated by
+ * dma_alloc_coherent().
+ *
+ * References to memory and mappings associated with cpu_addr/handle
+ * during and after this call executing are illegal.
+ */
+extern void
+dma_free_coherent(struct device *dev, size_t size, void *cpu_addr,
+		  dma_addr_t handle);
+
+/**
+ * dma_mmap_coherent - map a coherent DMA allocation into user space
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @vma: vm_area_struct describing requested user mapping
+ * @cpu_addr: kernel CPU-view address returned from dma_alloc_coherent
+ * @handle: device-view address returned from dma_alloc_coherent
+ * @size: size of memory originally requested in dma_alloc_coherent
+ *
+ * Map a coherent DMA buffer previously allocated by dma_alloc_coherent
+ * into user space.  The coherent DMA buffer must not be freed by the
+ * driver until the user space mapping has been released.
+ */
+int dma_mmap_coherent(struct device *dev, struct vm_area_struct *vma,
+		      void *cpu_addr, dma_addr_t handle, size_t size);
+
+
+/**
+ * dma_alloc_writecombine - allocate writecombining memory for DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @size: required memory size
+ * @handle: bus-specific DMA address
+ *
+ * Allocate some uncached, buffered memory for a device for
+ * performing DMA.  This function allocates pages, and will
+ * return the CPU-viewed address, and sets @handle to be the
+ * device-viewed address.
+ */
+extern void *
+dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp);
+
+#define dma_free_writecombine(dev,size,cpu_addr,handle) \
+	dma_free_coherent(dev,size,cpu_addr,handle)
+
+int dma_mmap_writecombine(struct device *dev, struct vm_area_struct *vma,
+			  void *cpu_addr, dma_addr_t handle, size_t size);
+
+
+/**
+ * dma_map_single - map a single buffer for streaming DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @cpu_addr: CPU direct mapped address of buffer
+ * @size: size of buffer to map
+ * @dir: DMA transfer direction
+ *
+ * Ensure that any data held in the cache is appropriately discarded
+ * or written back.
+ *
+ * The device owns this memory once this call has completed.  The CPU
+ * can regain ownership by calling dma_unmap_single() or
+ * dma_sync_single_for_cpu().
+ */
+#ifndef CONFIG_DMABOUNCE
+static inline dma_addr_t
+dma_map_single(struct device *dev, void *cpu_addr, size_t size,
+	       enum dma_data_direction dir)
+{
+	if (!arch_is_coherent())
+		consistent_sync(cpu_addr, size, dir);
+
+	return virt_to_dma(dev, (unsigned long)cpu_addr);
+}
+#else
+extern dma_addr_t dma_map_single(struct device *,void *, size_t, enum dma_data_direction);
+#endif
+
+/**
+ * dma_map_page - map a portion of a page for streaming DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @page: page that buffer resides in
+ * @offset: offset into page for start of buffer
+ * @size: size of buffer to map
+ * @dir: DMA transfer direction
+ *
+ * Ensure that any data held in the cache is appropriately discarded
+ * or written back.
+ *
+ * The device owns this memory once this call has completed.  The CPU
+ * can regain ownership by calling dma_unmap_page() or
+ * dma_sync_single_for_cpu().
+ */
+static inline dma_addr_t
+dma_map_page(struct device *dev, struct page *page,
+	     unsigned long offset, size_t size,
+	     enum dma_data_direction dir)
+{
+	return dma_map_single(dev, page_address(page) + offset, size, (int)dir);
+}
+
+/**
+ * dma_unmap_single - unmap a single buffer previously mapped
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @handle: DMA address of buffer
+ * @size: size of buffer to map
+ * @dir: DMA transfer direction
+ *
+ * Unmap a single streaming mode DMA translation.  The handle and size
+ * must match what was provided in the previous dma_map_single() call.
+ * All other usages are undefined.
+ *
+ * After this call, reads by the CPU to the buffer are guaranteed to see
+ * whatever the device wrote there.
+ */
+#ifndef CONFIG_DMABOUNCE
+static inline void
+dma_unmap_single(struct device *dev, dma_addr_t handle, size_t size,
+		 enum dma_data_direction dir)
+{
+	/* nothing to do */
+}
+#else
+extern void dma_unmap_single(struct device *, dma_addr_t, size_t, enum dma_data_direction);
+#endif
+
+/**
+ * dma_unmap_page - unmap a buffer previously mapped through dma_map_page()
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @handle: DMA address of buffer
+ * @size: size of buffer to map
+ * @dir: DMA transfer direction
+ *
+ * Unmap a single streaming mode DMA translation.  The handle and size
+ * must match what was provided in the previous dma_map_single() call.
+ * All other usages are undefined.
+ *
+ * After this call, reads by the CPU to the buffer are guaranteed to see
+ * whatever the device wrote there.
+ */
+static inline void
+dma_unmap_page(struct device *dev, dma_addr_t handle, size_t size,
+	       enum dma_data_direction dir)
+{
+	dma_unmap_single(dev, handle, size, (int)dir);
+}
+
+/**
+ * dma_map_sg - map a set of SG buffers for streaming mode DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @sg: list of buffers
+ * @nents: number of buffers to map
+ * @dir: DMA transfer direction
+ *
+ * Map a set of buffers described by scatterlist in streaming
+ * mode for DMA.  This is the scatter-gather version of the
+ * above dma_map_single interface.  Here the scatter gather list
+ * elements are each tagged with the appropriate dma address
+ * and length.  They are obtained via sg_dma_{address,length}(SG).
+ *
+ * NOTE: An implementation may be able to use a smaller number of
+ *       DMA address/length pairs than there are SG table elements.
+ *       (for example via virtual mapping capabilities)
+ *       The routine returns the number of addr/length pairs actually
+ *       used, at most nents.
+ *
+ * Device ownership issues as mentioned above for dma_map_single are
+ * the same here.
+ */
+#ifndef CONFIG_DMABOUNCE
+static inline int
+dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+	   enum dma_data_direction dir)
+{
+	int i;
+
+	for (i = 0; i < nents; i++, sg++) {
+		char *virt;
+
+		sg->dma_address = page_to_dma(dev, sg->page) + sg->offset;
+		virt = page_address(sg->page) + sg->offset;
+
+		if (!arch_is_coherent())
+			consistent_sync(virt, sg->length, dir);
+	}
+
+	return nents;
+}
+#else
+extern int dma_map_sg(struct device *, struct scatterlist *, int, enum dma_data_direction);
+#endif
+
+/**
+ * dma_unmap_sg - unmap a set of SG buffers mapped by dma_map_sg
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @sg: list of buffers
+ * @nents: number of buffers to map
+ * @dir: DMA transfer direction
+ *
+ * Unmap a set of streaming mode DMA translations.
+ * Again, CPU read rules concerning calls here are the same as for
+ * dma_unmap_single() above.
+ */
+#ifndef CONFIG_DMABOUNCE
+static inline void
+dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nents,
+	     enum dma_data_direction dir)
+{
+
+	/* nothing to do */
+}
+#else
+extern void dma_unmap_sg(struct device *, struct scatterlist *, int, enum dma_data_direction);
+#endif
+
+
+/**
+ * dma_sync_single_for_cpu
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @handle: DMA address of buffer
+ * @size: size of buffer to map
+ * @dir: DMA transfer direction
+ *
+ * Make physical memory consistent for a single streaming mode DMA
+ * translation after a transfer.
+ *
+ * If you perform a dma_map_single() but wish to interrogate the
+ * buffer using the cpu, yet do not wish to teardown the PCI dma
+ * mapping, you must call this function before doing so.  At the
+ * next point you give the PCI dma address back to the card, you
+ * must first the perform a dma_sync_for_device, and then the
+ * device again owns the buffer.
+ */
+#ifndef CONFIG_DMABOUNCE
+static inline void
+dma_sync_single_for_cpu(struct device *dev, dma_addr_t handle, size_t size,
+			enum dma_data_direction dir)
+{
+	if (!arch_is_coherent())
+		consistent_sync((void *)dma_to_virt(dev, handle), size, dir);
+}
+
+static inline void
+dma_sync_single_for_device(struct device *dev, dma_addr_t handle, size_t size,
+			   enum dma_data_direction dir)
+{
+	if (!arch_is_coherent())
+		consistent_sync((void *)dma_to_virt(dev, handle), size, dir);
+}
+#else
+extern void dma_sync_single_for_cpu(struct device*, dma_addr_t, size_t, enum dma_data_direction);
+extern void dma_sync_single_for_device(struct device*, dma_addr_t, size_t, enum dma_data_direction);
+#endif
+
+
+/**
+ * dma_sync_sg_for_cpu
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @sg: list of buffers
+ * @nents: number of buffers to map
+ * @dir: DMA transfer direction
+ *
+ * Make physical memory consistent for a set of streaming
+ * mode DMA translations after a transfer.
+ *
+ * The same as dma_sync_single_for_* but for a scatter-gather list,
+ * same rules and usage.
+ */
+#ifndef CONFIG_DMABOUNCE
+static inline void
+dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nents,
+		    enum dma_data_direction dir)
+{
+	int i;
+
+	for (i = 0; i < nents; i++, sg++) {
+		char *virt = page_address(sg->page) + sg->offset;
+		if (!arch_is_coherent())
+			consistent_sync(virt, sg->length, dir);
+	}
+}
+
+static inline void
+dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int nents,
+		       enum dma_data_direction dir)
+{
+	int i;
+
+	for (i = 0; i < nents; i++, sg++) {
+		char *virt = page_address(sg->page) + sg->offset;
+		if (!arch_is_coherent())
+			consistent_sync(virt, sg->length, dir);
+	}
+}
+#else
+extern void dma_sync_sg_for_cpu(struct device*, struct scatterlist*, int, enum dma_data_direction);
+extern void dma_sync_sg_for_device(struct device*, struct scatterlist*, int, enum dma_data_direction);
+#endif
+
+#ifdef CONFIG_DMABOUNCE
+/*
+ * For SA-1111, IXP425, and ADI systems  the dma-mapping functions are "magic"
+ * and utilize bounce buffers as needed to work around limited DMA windows.
+ *
+ * On the SA-1111, a bug limits DMA to only certain regions of RAM.
+ * On the IXP425, the PCI inbound window is 64MB (256MB total RAM)
+ * On some ADI engineering sytems, PCI inbound window is 32MB (12MB total RAM)
+ *
+ * The following are helper functions used by the dmabounce subystem
+ *
+ */
+
+/**
+ * dmabounce_register_dev
+ *
+ * @dev: valid struct device pointer
+ * @small_buf_size: size of buffers to use with small buffer pool
+ * @large_buf_size: size of buffers to use with large buffer pool (can be 0)
+ *
+ * This function should be called by low-level platform code to register
+ * a device as requireing DMA buffer bouncing. The function will allocate
+ * appropriate DMA pools for the device.
+ *
+ */
+extern int dmabounce_register_dev(struct device *, unsigned long, unsigned long);
+
+/**
+ * dmabounce_unregister_dev
+ *
+ * @dev: valid struct device pointer
+ *
+ * This function should be called by low-level platform code when device
+ * that was previously registered with dmabounce_register_dev is removed
+ * from the system.
+ *
+ */
+extern void dmabounce_unregister_dev(struct device *);
+
+/**
+ * dma_needs_bounce
+ *
+ * @dev: valid struct device pointer
+ * @dma_handle: dma_handle of unbounced buffer
+ * @size: size of region being mapped
+ *
+ * Platforms that utilize the dmabounce mechanism must implement
+ * this function.
+ *
+ * The dmabounce routines call this function whenever a dma-mapping
+ * is requested to determine whether a given buffer needs to be bounced
+ * or not. The function must return 0 if the the buffer is OK for
+ * DMA access and 1 if the buffer needs to be bounced.
+ *
+ */
+extern int dma_needs_bounce(struct device*, dma_addr_t, size_t);
+#endif /* CONFIG_DMABOUNCE */
+
+#endif /* __KERNEL__ */
+#endif
Index: build_tree/linux/include/asm/dma.h
diff -u /dev/null build_tree/linux/include/asm/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/dma.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,143 @@
+#ifndef __ASM_ARM_DMA_H
+#define __ASM_ARM_DMA_H
+
+typedef unsigned int dmach_t;
+
+#include <linux/spinlock.h>
+#include <asm/system.h>
+#include <asm/scatterlist.h>
+#include <asm/arch/dma.h>
+
+/*
+ * This is the maximum virtual address which can be DMA'd from.
+ */
+#ifndef MAX_DMA_ADDRESS
+#define MAX_DMA_ADDRESS	0xffffffff
+#endif
+
+/*
+ * DMA modes
+ */
+typedef unsigned int dmamode_t;
+
+#define DMA_MODE_MASK	3
+
+#define DMA_MODE_READ	 0
+#define DMA_MODE_WRITE	 1
+#define DMA_MODE_CASCADE 2
+#define DMA_AUTOINIT	 4
+
+extern spinlock_t  dma_spin_lock;
+
+static inline unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static inline void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+/* Clear the 'DMA Pointer Flip Flop'.
+ * Write 0 for LSB/MSB, 1 for MSB/LSB access.
+ */
+#define clear_dma_ff(channel)
+
+/* Set only the page register bits of the transfer address.
+ *
+ * NOTE: This is an architecture specific function, and should
+ *       be hidden from the drivers
+ */
+extern void set_dma_page(dmach_t channel, char pagenr);
+
+/* Request a DMA channel
+ *
+ * Some architectures may need to do allocate an interrupt
+ */
+extern int  request_dma(dmach_t channel, const char * device_id);
+
+/* Free a DMA channel
+ *
+ * Some architectures may need to do free an interrupt
+ */
+extern void free_dma(dmach_t channel);
+
+/* Enable DMA for this channel
+ *
+ * On some architectures, this may have other side effects like
+ * enabling an interrupt and setting the DMA registers.
+ */
+extern void enable_dma(dmach_t channel);
+
+/* Disable DMA for this channel
+ *
+ * On some architectures, this may have other side effects like
+ * disabling an interrupt or whatever.
+ */
+extern void disable_dma(dmach_t channel);
+
+/* Test whether the specified channel has an active DMA transfer
+ */
+extern int dma_channel_active(dmach_t channel);
+
+/* Set the DMA scatter gather list for this channel
+ *
+ * This should not be called if a DMA channel is enabled,
+ * especially since some DMA architectures don't update the
+ * DMA address immediately, but defer it to the enable_dma().
+ */
+extern void set_dma_sg(dmach_t channel, struct scatterlist *sg, int nr_sg);
+
+/* Set the DMA address for this channel
+ *
+ * This should not be called if a DMA channel is enabled,
+ * especially since some DMA architectures don't update the
+ * DMA address immediately, but defer it to the enable_dma().
+ */
+extern void __set_dma_addr(dmach_t channel, void *addr);
+#define set_dma_addr(channel, addr)				\
+	__set_dma_addr(channel, bus_to_virt(addr))
+
+/* Set the DMA byte count for this channel
+ *
+ * This should not be called if a DMA channel is enabled,
+ * especially since some DMA architectures don't update the
+ * DMA count immediately, but defer it to the enable_dma().
+ */
+extern void set_dma_count(dmach_t channel, unsigned long count);
+
+/* Set the transfer direction for this channel
+ *
+ * This should not be called if a DMA channel is enabled,
+ * especially since some DMA architectures don't update the
+ * DMA transfer direction immediately, but defer it to the
+ * enable_dma().
+ */
+extern void set_dma_mode(dmach_t channel, dmamode_t mode);
+
+/* Set the transfer speed for this channel
+ */
+extern void set_dma_speed(dmach_t channel, int cycle_ns);
+
+/* Get DMA residue count. After a DMA transfer, this
+ * should return zero. Reading this while a DMA transfer is
+ * still in progress will return unpredictable results.
+ * If called before the channel has been used, it may return 1.
+ * Otherwise, it returns the number of _bytes_ left to transfer.
+ */
+extern int  get_dma_residue(dmach_t channel);
+
+#ifndef NO_DMA
+#define NO_DMA	255
+#endif
+
+#ifdef CONFIG_PCI
+extern int isa_dma_bridge_buggy;
+#else
+#define isa_dma_bridge_buggy    (0)
+#endif
+
+#endif /* _ARM_DMA_H */
Index: build_tree/linux/include/asm/domain.h
diff -u /dev/null build_tree/linux/include/asm/domain.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/domain.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,78 @@
+/*
+ *  linux/include/asm-arm/domain.h
+ *
+ *  Copyright (C) 1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_DOMAIN_H
+#define __ASM_PROC_DOMAIN_H
+
+/*
+ * Domain numbers
+ *
+ *  DOMAIN_IO     - domain 2 includes all IO only
+ *  DOMAIN_USER   - domain 1 includes all user memory only
+ *  DOMAIN_KERNEL - domain 0 includes all kernel memory only
+ *
+ * The domain numbering depends on whether we support 36 physical
+ * address for I/O or not.  Addresses above the 32 bit boundary can
+ * only be mapped using supersections and supersections can only
+ * be set for domain 0.  We could just default to DOMAIN_IO as zero,
+ * but there may be systems with supersection support and no 36-bit
+ * addressing.  In such cases, we want to map system memory with
+ * supersections to reduce TLB misses and footprint.
+ *
+ * 36-bit addressing and supersections are only available on
+ * CPUs based on ARMv6+ or the Intel XSC3 core.
+ */
+#ifndef CONFIG_IO_36
+#define DOMAIN_KERNEL	0
+#define DOMAIN_TABLE	0
+#define DOMAIN_USER	1
+#define DOMAIN_IO	2
+#else
+#define DOMAIN_KERNEL	2
+#define DOMAIN_TABLE	2
+#define DOMAIN_USER	1
+#define DOMAIN_IO	0
+#endif
+
+/*
+ * Domain types
+ */
+#define DOMAIN_NOACCESS	0
+#define DOMAIN_CLIENT	1
+#define DOMAIN_MANAGER	3
+
+#define domain_val(dom,type)	((type) << (2*(dom)))
+
+#ifndef __ASSEMBLY__
+
+#ifdef CONFIG_MMU
+#define set_domain(x)					\
+	do {						\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c3, c0	@ set domain"	\
+	  : : "r" (x));					\
+	isb();						\
+	} while (0)
+
+#define modify_domain(dom,type)					\
+	do {							\
+	struct thread_info *thread = current_thread_info();	\
+	unsigned int domain = thread->cpu_domain;		\
+	domain &= ~domain_val(dom, DOMAIN_MANAGER);		\
+	thread->cpu_domain = domain | domain_val(dom, type);	\
+	set_domain(thread->cpu_domain);				\
+	} while (0)
+
+#else
+#define set_domain(x)		do { } while (0)
+#define modify_domain(dom,type)	do { } while (0)
+#endif
+
+#endif
+#endif /* !__ASSEMBLY__ */
Index: build_tree/linux/include/asm/dyntick.h
diff -u /dev/null build_tree/linux/include/asm/dyntick.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/dyntick.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef _ASMARM_DYNTICK_H
+#define _ASMARM_DYNTICK_H
+
+#include <asm/mach/time.h>
+
+#endif /* _ASMARM_DYNTICK_H */
Index: build_tree/linux/include/asm/ecard.h
diff -u /dev/null build_tree/linux/include/asm/ecard.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ecard.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,298 @@
+/*
+ * linux/include/asm-arm/ecard.h
+ *
+ * definitions for expansion cards
+ *
+ * This is a new system as from Linux 1.2.3
+ *
+ * Changelog:
+ *  11-12-1996	RMK	Further minor improvements
+ *  12-09-1997	RMK	Added interrupt enable/disable for card level
+ *
+ * Reference: Acorns Risc OS 3 Programmers Reference Manuals.
+ */
+
+#ifndef __ASM_ECARD_H
+#define __ASM_ECARD_H
+
+/*
+ * Currently understood cards (but not necessarily
+ * supported):
+ *                        Manufacturer  Product ID
+ */
+#define MANU_ACORN		0x0000
+#define PROD_ACORN_SCSI			0x0002
+#define PROD_ACORN_ETHER1		0x0003
+#define PROD_ACORN_MFM			0x000b
+
+#define MANU_ANT2		0x0011
+#define PROD_ANT_ETHER3			0x00a4
+
+#define MANU_ATOMWIDE		0x0017
+#define PROD_ATOMWIDE_3PSERIAL		0x0090
+
+#define MANU_IRLAM_INSTRUMENTS	0x001f
+#define MANU_IRLAM_INSTRUMENTS_ETHERN	0x5678
+
+#define MANU_OAK		0x0021
+#define PROD_OAK_SCSI			0x0058
+
+#define MANU_MORLEY		0x002b
+#define PROD_MORLEY_SCSI_UNCACHED	0x0067
+
+#define MANU_CUMANA		0x003a
+#define PROD_CUMANA_SCSI_2		0x003a
+#define PROD_CUMANA_SCSI_1		0x00a0
+
+#define MANU_ICS		0x003c
+#define PROD_ICS_IDE			0x00ae
+
+#define MANU_ICS2		0x003d
+#define PROD_ICS2_IDE			0x00ae
+
+#define MANU_SERPORT		0x003f
+#define PROD_SERPORT_DSPORT		0x00b9
+
+#define MANU_ARXE		0x0041
+#define PROD_ARXE_SCSI			0x00be
+
+#define MANU_I3			0x0046
+#define PROD_I3_ETHERLAN500		0x00d4
+#define PROD_I3_ETHERLAN600		0x00ec
+#define PROD_I3_ETHERLAN600A		0x011e
+
+#define MANU_ANT		0x0053
+#define PROD_ANT_ETHERM			0x00d8
+#define PROD_ANT_ETHERB			0x00e4
+
+#define MANU_ALSYSTEMS		0x005b
+#define PROD_ALSYS_SCSIATAPI		0x0107
+
+#define MANU_MCS		0x0063
+#define PROD_MCS_CONNECT32		0x0125
+
+#define MANU_EESOX		0x0064
+#define PROD_EESOX_SCSI2		0x008c
+
+#define MANU_YELLOWSTONE	0x0096
+#define PROD_YELLOWSTONE_RAPIDE32	0x0120
+
+#ifdef ECARD_C
+#define CONST
+#else
+#define CONST const
+#endif
+
+#define MAX_ECARDS	9
+
+typedef enum {				/* Cards address space		*/
+	ECARD_IOC,
+	ECARD_MEMC,
+	ECARD_EASI
+} card_type_t;
+
+typedef enum {				/* Speed for ECARD_IOC space	*/
+	ECARD_SLOW	 = 0,
+	ECARD_MEDIUM	 = 1,
+	ECARD_FAST	 = 2,
+	ECARD_SYNC	 = 3
+} card_speed_t;
+
+struct ecard_id {			/* Card ID structure		*/
+	unsigned short	manufacturer;
+	unsigned short	product;
+	void		*data;
+};
+
+struct in_ecid {			/* Packed card ID information	*/
+	unsigned short	product;	/* Product code			*/
+	unsigned short	manufacturer;	/* Manufacturer code		*/
+	unsigned char	id:4;		/* Simple ID			*/
+	unsigned char	cd:1;		/* Chunk dir present		*/
+	unsigned char	is:1;		/* Interrupt status pointers	*/
+	unsigned char	w:2;		/* Width			*/
+	unsigned char	country;	/* Country			*/
+	unsigned char	irqmask;	/* IRQ mask			*/
+	unsigned char	fiqmask;	/* FIQ mask			*/
+	unsigned long	irqoff;		/* IRQ offset			*/
+	unsigned long	fiqoff;		/* FIQ offset			*/
+};
+
+typedef struct expansion_card ecard_t;
+typedef unsigned long *loader_t;
+
+typedef struct {			/* Card handler routines	*/
+	void (*irqenable)(ecard_t *ec, int irqnr);
+	void (*irqdisable)(ecard_t *ec, int irqnr);
+	int  (*irqpending)(ecard_t *ec);
+	void (*fiqenable)(ecard_t *ec, int fiqnr);
+	void (*fiqdisable)(ecard_t *ec, int fiqnr);
+	int  (*fiqpending)(ecard_t *ec);
+} expansioncard_ops_t;
+
+#define ECARD_NUM_RESOURCES	(6)
+
+#define ECARD_RES_IOCSLOW	(0)
+#define ECARD_RES_IOCMEDIUM	(1)
+#define ECARD_RES_IOCFAST	(2)
+#define ECARD_RES_IOCSYNC	(3)
+#define ECARD_RES_MEMC		(4)
+#define ECARD_RES_EASI		(5)
+
+#define ecard_resource_start(ec,nr)	((ec)->resource[nr].start)
+#define ecard_resource_end(ec,nr)	((ec)->resource[nr].end)
+#define ecard_resource_len(ec,nr)	((ec)->resource[nr].end - \
+					 (ec)->resource[nr].start + 1)
+#define ecard_resource_flags(ec,nr)	((ec)->resource[nr].flags)
+
+/*
+ * This contains all the info needed on an expansion card
+ */
+struct expansion_card {
+	struct expansion_card  *next;
+
+	struct device		dev;
+	struct resource		resource[ECARD_NUM_RESOURCES];
+
+	/* Public data */
+	void __iomem		*irqaddr;	/* address of IRQ register	*/
+	void __iomem		*fiqaddr;	/* address of FIQ register	*/
+	unsigned char		irqmask;	/* IRQ mask			*/
+	unsigned char		fiqmask;	/* FIQ mask			*/
+	unsigned char  		claimed;	/* Card claimed?		*/
+
+	void			*irq_data;	/* Data for use for IRQ by card	*/
+	void			*fiq_data;	/* Data for use for FIQ by card	*/
+	const expansioncard_ops_t *ops;		/* Enable/Disable Ops for card	*/
+
+	CONST unsigned int	slot_no;	/* Slot number			*/
+	CONST unsigned int	dma;		/* DMA number (for request_dma)	*/
+	CONST unsigned int	irq;		/* IRQ number (for request_irq)	*/
+	CONST unsigned int	fiq;		/* FIQ number (for request_irq)	*/
+	CONST card_type_t	type;		/* Type of card			*/
+	CONST struct in_ecid	cid;		/* Card Identification		*/
+
+	/* Private internal data */
+	const char		*card_desc;	/* Card description		*/
+	CONST unsigned int	podaddr;	/* Base Linux address for card	*/
+	CONST loader_t		loader;		/* loader program */
+	u64			dma_mask;
+};
+
+struct in_chunk_dir {
+	unsigned int start_offset;
+	union {
+		unsigned char string[256];
+		unsigned char data[1];
+	} d;
+};
+
+/*
+ * ecard_claim: claim an expansion card entry
+ */
+#define ecard_claim(ec) ((ec)->claimed = 1)
+
+/*
+ * ecard_release: release an expansion card entry
+ */
+#define ecard_release(ec) ((ec)->claimed = 0)
+
+/*
+ * Read a chunk from an expansion card
+ * cd : where to put read data
+ * ec : expansion card info struct
+ * id : id number to find
+ * num: (n+1)'th id to find.
+ */
+extern int ecard_readchunk (struct in_chunk_dir *cd, struct expansion_card *ec, int id, int num);
+
+/*
+ * Obtain the address of a card.  This returns the "old style" address
+ * and should no longer be used.
+ */
+static inline unsigned int __deprecated
+ecard_address(struct expansion_card *ec, card_type_t type, card_speed_t speed)
+{
+	extern unsigned int __ecard_address(struct expansion_card *,
+					    card_type_t, card_speed_t);
+	return __ecard_address(ec, type, speed);
+}
+
+/*
+ * Request and release ecard resources
+ */
+extern int ecard_request_resources(struct expansion_card *ec);
+extern void ecard_release_resources(struct expansion_card *ec);
+
+#ifdef ECARD_C
+/* Definitions internal to ecard.c - for it's use only!!
+ *
+ * External expansion card header as read from the card
+ */
+struct ex_ecid {
+	unsigned char	r_irq:1;
+	unsigned char	r_zero:1;
+	unsigned char	r_fiq:1;
+	unsigned char	r_id:4;
+	unsigned char	r_a:1;
+
+	unsigned char	r_cd:1;
+	unsigned char	r_is:1;
+	unsigned char	r_w:2;
+	unsigned char	r_r1:4;
+
+	unsigned char	r_r2:8;
+
+	unsigned char	r_prod[2];
+
+	unsigned char	r_manu[2];
+
+	unsigned char	r_country;
+
+	unsigned char	r_fiqmask;
+	unsigned char	r_fiqoff[3];
+
+	unsigned char	r_irqmask;
+	unsigned char	r_irqoff[3];
+};
+
+/*
+ * Chunk directory entry as read from the card
+ */
+struct ex_chunk_dir {
+	unsigned char r_id;
+	unsigned char r_len[3];
+	unsigned long r_start;
+	union {
+		char string[256];
+		char data[1];
+	} d;
+#define c_id(x)		((x)->r_id)
+#define c_len(x)	((x)->r_len[0]|((x)->r_len[1]<<8)|((x)->r_len[2]<<16))
+#define c_start(x)	((x)->r_start)
+};
+
+#endif
+
+extern struct bus_type ecard_bus_type;
+
+#define ECARD_DEV(_d)	container_of((_d), struct expansion_card, dev)
+
+struct ecard_driver {
+	int			(*probe)(struct expansion_card *, const struct ecard_id *id);
+	void			(*remove)(struct expansion_card *);
+	void			(*shutdown)(struct expansion_card *);
+	const struct ecard_id	*id_table;
+	unsigned int		id;
+	struct device_driver	drv;
+};
+
+#define ECARD_DRV(_d)	container_of((_d), struct ecard_driver, drv)
+
+#define ecard_set_drvdata(ec,data)	dev_set_drvdata(&(ec)->dev, (data))
+#define ecard_get_drvdata(ec)		dev_get_drvdata(&(ec)->dev)
+
+int ecard_register_driver(struct ecard_driver *);
+void ecard_remove_driver(struct ecard_driver *);
+
+#endif
Index: build_tree/linux/include/asm/elf.h
diff -u /dev/null build_tree/linux/include/asm/elf.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/elf.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,139 @@
+#ifndef __ASMARM_ELF_H
+#define __ASMARM_ELF_H
+
+#ifndef __ASSEMBLY__
+/*
+ * ELF register definitions..
+ */
+#include <asm/ptrace.h>
+#include <asm/user.h>
+
+typedef unsigned long elf_greg_t;
+typedef unsigned long elf_freg_t[3];
+
+#define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct user_fp elf_fpregset_t;
+#endif
+
+#define EM_ARM	40
+#define EF_ARM_APCS26 0x08
+#define EF_ARM_SOFT_FLOAT 0x200
+#define EF_ARM_EABI_MASK 0xFF000000
+
+#define R_ARM_NONE	0
+#define R_ARM_PC24	1
+#define R_ARM_ABS32	2
+#define R_ARM_CALL	28
+#define R_ARM_JUMP24	29
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#ifdef __ARMEB__
+#define ELF_DATA	ELFDATA2MSB
+#else
+#define ELF_DATA	ELFDATA2LSB
+#endif
+#define ELF_ARCH	EM_ARM
+
+/*
+ * HWCAP flags - for elf_hwcap (in kernel) and AT_HWCAP
+ */
+#define HWCAP_SWP	1
+#define HWCAP_HALF	2
+#define HWCAP_THUMB	4
+#define HWCAP_26BIT	8	/* Play it safe */
+#define HWCAP_FAST_MULT	16
+#define HWCAP_FPA	32
+#define HWCAP_VFP	64
+#define HWCAP_EDSP	128
+#define HWCAP_JAVA	256
+#define HWCAP_IWMMXT	512
+#define HWCAP_CRUNCH	1024
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+/*
+ * This yields a mask that user programs can use to figure out what
+ * instruction set this cpu supports.
+ */
+#define ELF_HWCAP	(elf_hwcap)
+extern unsigned int elf_hwcap;
+
+/*
+ * This yields a string that ld.so will use to load implementation
+ * specific libraries for optimization.  This is more specific in
+ * intent than poking at uname or /proc/cpuinfo.
+ *
+ * For now we just provide a fairly general string that describes the
+ * processor family.  This could be made more specific later if someone
+ * implemented optimisations that require it.  26-bit CPUs give you
+ * "v1l" for ARM2 (no SWP) and "v2l" for anything else (ARM1 isn't
+ * supported).  32-bit CPUs give you "v3[lb]" for anything based on an
+ * ARM6 or ARM7 core and "armv4[lb]" for anything based on a StrongARM-1
+ * core.
+ */
+#define ELF_PLATFORM_SIZE 8
+#define ELF_PLATFORM	(elf_platform)
+
+extern char elf_platform[];
+#endif
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) ((x)->e_machine == EM_ARM && ELF_PROC_OK(x))
+
+/*
+ * 32-bit code is always OK.  Some cpus can do 26-bit, some can't.
+ */
+#define ELF_PROC_OK(x)	(ELF_THUMB_OK(x) && ELF_26BIT_OK(x))
+
+#define ELF_THUMB_OK(x) \
+	((elf_hwcap & HWCAP_THUMB && ((x)->e_entry & 1) == 1) || \
+	 ((x)->e_entry & 3) == 0)
+
+#define ELF_26BIT_OK(x) \
+	((elf_hwcap & HWCAP_26BIT && (x)->e_flags & EF_ARM_APCS26) || \
+	  ((x)->e_flags & EF_ARM_APCS26) == 0)
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	4096
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)
+
+/* When the program starts, a1 contains a pointer to a function to be 
+   registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
+   have no such handler.  */
+#define ELF_PLAT_INIT(_r, load_addr)	(_r)->ARM_r0 = 0
+
+/*
+ * Since the FPA coprocessor uses CP1 and CP2, and iWMMXt uses CP0
+ * and CP1, we only enable access to the iWMMXt coprocessor if the
+ * binary is EABI or softfloat (and thus, guaranteed not to use
+ * FPA instructions.)
+ */
+#define SET_PERSONALITY(ex, ibcs2)					\
+	do {								\
+		if ((ex).e_flags & EF_ARM_APCS26) {			\
+			set_personality(PER_LINUX);			\
+		} else {						\
+			set_personality(PER_LINUX_32BIT);		\
+			if (elf_hwcap & HWCAP_IWMMXT && (ex).e_flags & (EF_ARM_EABI_MASK | EF_ARM_SOFT_FLOAT)) \
+				set_thread_flag(TIF_USING_IWMMXT);	\
+			else						\
+				clear_thread_flag(TIF_USING_IWMMXT);	\
+		}							\
+	} while (0)
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/emergency-restart.h
diff -u /dev/null build_tree/linux/include/asm/emergency-restart.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/emergency-restart.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef _ASM_EMERGENCY_RESTART_H
+#define _ASM_EMERGENCY_RESTART_H
+
+#include <asm-generic/emergency-restart.h>
+
+#endif /* _ASM_EMERGENCY_RESTART_H */
Index: build_tree/linux/include/asm/errno.h
diff -u /dev/null build_tree/linux/include/asm/errno.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/errno.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef _ARM_ERRNO_H
+#define _ARM_ERRNO_H
+
+#include <asm-generic/errno.h>
+
+#endif
Index: build_tree/linux/include/asm/fcntl.h
diff -u /dev/null build_tree/linux/include/asm/fcntl.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/fcntl.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,11 @@
+#ifndef _ARM_FCNTL_H
+#define _ARM_FCNTL_H
+
+#define O_DIRECTORY	 040000	/* must be a directory */
+#define O_NOFOLLOW	0100000	/* don't follow links */
+#define O_DIRECT	0200000	/* direct disk access hint - currently ignored */
+#define O_LARGEFILE	0400000
+
+#include <asm-generic/fcntl.h>
+
+#endif
Index: build_tree/linux/include/asm/fiq.h
diff -u /dev/null build_tree/linux/include/asm/fiq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/fiq.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/asm-arm/fiq.h
+ *
+ * Support for FIQ on ARM architectures.
+ * Written by Philip Blundell <philb@gnu.org>, 1998
+ * Re-written by Russell King
+ */
+
+#ifndef __ASM_FIQ_H
+#define __ASM_FIQ_H
+
+#include <asm/ptrace.h>
+
+struct fiq_handler {
+	struct fiq_handler *next;
+	/* Name
+	 */
+	const char *name;
+	/* Called to ask driver to relinquish/
+	 * reacquire FIQ
+	 * return zero to accept, or -<errno>
+	 */
+	int (*fiq_op)(void *, int relinquish);
+	/* data for the relinquish/reacquire functions
+	 */
+	void *dev_id;
+};
+
+extern int claim_fiq(struct fiq_handler *f);
+extern void release_fiq(struct fiq_handler *f);
+extern void set_fiq_handler(void *start, unsigned int length);
+extern void set_fiq_regs(struct pt_regs *regs);
+extern void get_fiq_regs(struct pt_regs *regs);
+extern void enable_fiq(int fiq);
+extern void disable_fiq(int fiq);
+
+#endif
Index: build_tree/linux/include/asm/flat.h
diff -u /dev/null build_tree/linux/include/asm/flat.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/flat.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,18 @@
+/*
+ * include/asm-arm/flat.h -- uClinux flat-format executables
+ */
+
+#ifndef __ARM_FLAT_H__
+#define __ARM_FLAT_H__
+
+/* An odd number of words will be pushed after this alignment, so
+   deliberately misalign the value.  */
+#define	flat_stack_align(sp)	sp = (void *)(((unsigned long)(sp) - 4) | 4)
+#define	flat_argvp_envp_on_stack()		1
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
+#define	flat_get_addr_from_rp(rp, relval, flags) get_unaligned(rp)
+#define	flat_put_addr_at_rp(rp, val, relval)	put_unaligned(val,rp)
+#define	flat_get_relocate_addr(rel)		(rel)
+
+#endif /* __ARM_FLAT_H__ */
Index: build_tree/linux/include/asm/floppy.h
diff -u /dev/null build_tree/linux/include/asm/floppy.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/floppy.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,144 @@
+/*
+ *  linux/include/asm-arm/floppy.h
+ *
+ *  Copyright (C) 1996-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Note that we don't touch FLOPPY_DMA nor FLOPPY_IRQ here
+ */
+#ifndef __ASM_ARM_FLOPPY_H
+#define __ASM_ARM_FLOPPY_H
+#if 0
+#include <asm/arch/floppy.h>
+#endif
+
+#define fd_outb(val,port)			\
+	do {					\
+		if ((port) == FD_DOR)		\
+			fd_setdor((val));	\
+		else				\
+			outb((val),(port));	\
+	} while(0)
+
+#define fd_inb(port)		inb((port))
+#define fd_request_irq()	request_irq(IRQ_FLOPPYDISK,floppy_interrupt,\
+					    IRQF_DISABLED,"floppy",NULL)
+#define fd_free_irq()		free_irq(IRQ_FLOPPYDISK,NULL)
+#define fd_disable_irq()	disable_irq(IRQ_FLOPPYDISK)
+#define fd_enable_irq()		enable_irq(IRQ_FLOPPYDISK)
+
+#define fd_request_dma()	request_dma(DMA_FLOPPY,"floppy")
+#define fd_free_dma()		free_dma(DMA_FLOPPY)
+#define fd_disable_dma()	disable_dma(DMA_FLOPPY)
+#define fd_enable_dma()		enable_dma(DMA_FLOPPY)
+#define fd_clear_dma_ff()	clear_dma_ff(DMA_FLOPPY)
+#define fd_set_dma_mode(mode)	set_dma_mode(DMA_FLOPPY, (mode))
+#define fd_set_dma_addr(addr)	set_dma_addr(DMA_FLOPPY, virt_to_bus((addr)))
+#define fd_set_dma_count(len)	set_dma_count(DMA_FLOPPY, (len))
+#define fd_cacheflush(addr,sz)
+
+/* need to clean up dma.h */
+#define DMA_FLOPPYDISK		DMA_FLOPPY
+
+/* Floppy_selects is the list of DOR's to select drive fd
+ *
+ * On initialisation, the floppy list is scanned, and the drives allocated
+ * in the order that they are found.  This is done by seeking the drive
+ * to a non-zero track, and then restoring it to track 0.  If an error occurs,
+ * then there is no floppy drive present.       [to be put back in again]
+ */
+static unsigned char floppy_selects[2][4] =
+{
+	{ 0x10, 0x21, 0x23, 0x33 },
+	{ 0x10, 0x21, 0x23, 0x33 }
+};
+
+#define fd_setdor(dor)								\
+do {										\
+	int new_dor = (dor);							\
+	if (new_dor & 0xf0)							\
+		new_dor = (new_dor & 0x0c) | floppy_selects[fdc][new_dor & 3];	\
+	else									\
+		new_dor &= 0x0c;						\
+	outb(new_dor, FD_DOR);							\
+} while (0)
+
+/*
+ * Someday, we'll automatically detect which drives are present...
+ */
+static inline void fd_scandrives (void)
+{
+#if 0
+	int floppy, drive_count;
+
+	fd_disable_irq();
+	raw_cmd = &default_raw_cmd;
+	raw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_SEEK;
+	raw_cmd->track = 0;
+	raw_cmd->rate = ?;
+	drive_count = 0;
+	for (floppy = 0; floppy < 4; floppy ++) {
+		current_drive = drive_count;
+		/*
+		 * Turn on floppy motor
+		 */
+		if (start_motor(redo_fd_request))
+			continue;
+		/*
+		 * Set up FDC
+		 */
+		fdc_specify();
+		/*
+		 * Tell FDC to recalibrate
+		 */
+		output_byte(FD_RECALIBRATE);
+		LAST_OUT(UNIT(floppy));
+		/* wait for command to complete */
+		if (!successful) {
+			int i;
+			for (i = drive_count; i < 3; i--)
+				floppy_selects[fdc][i] = floppy_selects[fdc][i + 1];
+			floppy_selects[fdc][3] = 0;
+			floppy -= 1;
+		} else
+			drive_count++;
+	}
+#else
+	floppy_selects[0][0] = 0x10;
+	floppy_selects[0][1] = 0x21;
+	floppy_selects[0][2] = 0x23;
+	floppy_selects[0][3] = 0x33;
+#endif
+}
+
+#define FDC1 (0x3f0)
+
+#define FLOPPY0_TYPE 4
+#define FLOPPY1_TYPE 4
+
+#define N_FDC 1
+#define N_DRIVE 4
+
+#define FLOPPY_MOTOR_MASK 0xf0
+
+#define CROSS_64KB(a,s) (0)
+
+/*
+ * This allows people to reverse the order of
+ * fd0 and fd1, in case their hardware is
+ * strangely connected (as some RiscPCs
+ * and A5000s seem to be).
+ */
+static void driveswap(int *ints, int dummy, int dummy2)
+{
+	floppy_selects[0][0] ^= floppy_selects[0][1];
+	floppy_selects[0][1] ^= floppy_selects[0][0];
+	floppy_selects[0][0] ^= floppy_selects[0][1];
+}
+
+#define EXTRA_FLOPPY_PARAMS ,{ "driveswap", &driveswap, NULL, 0, 0 }
+	
+#endif
Index: build_tree/linux/include/asm/fpstate.h
diff -u /dev/null build_tree/linux/include/asm/fpstate.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/fpstate.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,88 @@
+/*
+ *  linux/include/asm-arm/fpstate.h
+ *
+ *  Copyright (C) 1995 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_FPSTATE_H
+#define __ASM_ARM_FPSTATE_H
+
+
+#ifndef __ASSEMBLY__
+
+/*
+ * VFP storage area has:
+ *  - FPEXC, FPSCR, FPINST and FPINST2.
+ *  - 16 double precision data registers
+ *  - an implementation-dependant word of state for FLDMX/FSTMX
+ * 
+ *  FPEXC will always be non-zero once the VFP has been used in this process.
+ */
+
+struct vfp_hard_struct {
+	__u64 fpregs[16];
+#if __LINUX_ARM_ARCH__ < 6
+	__u32 fpmx_state;
+#endif
+	__u32 fpexc;
+	__u32 fpscr;
+	/*
+	 * VFP implementation specific state
+	 */
+	__u32 fpinst;
+	__u32 fpinst2;
+#ifdef CONFIG_SMP
+	__u32 cpu;
+#endif
+};
+
+union vfp_state {
+	struct vfp_hard_struct	hard;
+};
+
+extern void vfp_flush_thread(union vfp_state *);
+extern void vfp_release_thread(union vfp_state *);
+
+#define FP_HARD_SIZE 35
+
+struct fp_hard_struct {
+	unsigned int save[FP_HARD_SIZE];		/* as yet undefined */
+};
+
+#define FP_SOFT_SIZE 35
+
+struct fp_soft_struct {
+	unsigned int save[FP_SOFT_SIZE];		/* undefined information */
+};
+
+#define IWMMXT_SIZE	0x98
+
+struct iwmmxt_struct {
+	unsigned int save[IWMMXT_SIZE / sizeof(unsigned int)];
+};
+
+union fp_state {
+	struct fp_hard_struct	hard;
+	struct fp_soft_struct	soft;
+#ifdef CONFIG_IWMMXT
+	struct iwmmxt_struct	iwmmxt;
+#endif
+};
+
+#define FP_SIZE (sizeof(union fp_state) / sizeof(int))
+
+struct crunch_state {
+	unsigned int	mvdx[16][2];
+	unsigned int	mvax[4][3];
+	unsigned int	dspsc[2];
+};
+
+#define CRUNCH_SIZE	sizeof(struct crunch_state)
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/futex.h
diff -u /dev/null build_tree/linux/include/asm/futex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/futex.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef _ASM_FUTEX_H
+#define _ASM_FUTEX_H
+
+#include <asm-generic/futex.h>
+
+#endif
Index: build_tree/linux/include/asm/glue.h
diff -u /dev/null build_tree/linux/include/asm/glue.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/glue.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,113 @@
+/*
+ *  linux/include/asm-arm/glue.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *  Copyright (C) 2000-2002 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file provides the glue to stick the processor-specific bits
+ *  into the kernel in an efficient manner.  The idea is to use branches
+ *  when we're only targetting one class of TLB, or indirect calls
+ *  when we're targetting multiple classes of TLBs.
+ */
+#ifdef __KERNEL__
+
+
+#ifdef __STDC__
+#define ____glue(name,fn)	name##fn
+#else
+#define ____glue(name,fn)	name/**/fn
+#endif
+#define __glue(name,fn)		____glue(name,fn)
+
+
+
+/*
+ *	Data Abort Model
+ *	================
+ *
+ *	We have the following to choose from:
+ *	  arm6          - ARM6 style
+ *	  arm7		- ARM7 style
+ *	  v4_early	- ARMv4 without Thumb early abort handler
+ *	  v4t_late	- ARMv4 with Thumb late abort handler
+ *	  v4t_early	- ARMv4 with Thumb early abort handler
+ *	  v5tej_early	- ARMv5 with Thumb and Java early abort handler
+ *	  xscale	- ARMv5 with Thumb with Xscale extensions
+ *	  v6_early	- ARMv6 generic early abort handler
+ */
+#undef CPU_ABORT_HANDLER
+#undef MULTI_ABORT
+
+#if defined(CONFIG_CPU_ARM610)
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER cpu_arm6_data_abort
+# endif
+#endif
+
+#if defined(CONFIG_CPU_ARM710)
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER cpu_arm7_data_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_LV4T
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v4t_late_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV4
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v4_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV4T
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v4t_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV5TJ
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v5tj_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV5T
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v5t_early_abort
+# endif
+#endif
+
+#ifdef CONFIG_CPU_ABRT_EV6
+# ifdef CPU_ABORT_HANDLER
+#  define MULTI_ABORT 1
+# else
+#  define CPU_ABORT_HANDLER v6_early_abort
+# endif
+#endif
+
+#ifndef CPU_ABORT_HANDLER
+#error Unknown data abort handler type
+#endif
+
+#endif
Index: build_tree/linux/include/asm/gpio.h
diff -u /dev/null build_tree/linux/include/asm/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/gpio.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,7 @@
+#ifndef _ARCH_ARM_GPIO_H
+#define _ARCH_ARM_GPIO_H
+
+/* not all ARM platforms necessarily support this API ... */
+#include <asm/arch/gpio.h>
+
+#endif /* _ARCH_ARM_GPIO_H */
Index: build_tree/linux/include/asm/hardirq.h
diff -u /dev/null build_tree/linux/include/asm/hardirq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/hardirq.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,32 @@
+#ifndef __ASM_HARDIRQ_H
+#define __ASM_HARDIRQ_H
+
+#include <linux/cache.h>
+#include <linux/threads.h>
+#include <asm/irq.h>
+
+typedef struct {
+	unsigned int __softirq_pending;
+	unsigned int local_timer_irqs;
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+#if NR_IRQS > 256
+#define HARDIRQ_BITS	9
+#else
+#define HARDIRQ_BITS	8
+#endif
+
+/*
+ * The hardirq mask has to be large enough to have space
+ * for potentially all IRQ sources in the system nesting
+ * on a single CPU:
+ */
+#if (1 << HARDIRQ_BITS) < NR_IRQS
+# error HARDIRQ_BITS is too low!
+#endif
+
+#define __ARCH_IRQ_EXIT_IRQS_DISABLED	1
+
+#endif /* __ASM_HARDIRQ_H */
Index: build_tree/linux/include/asm/hardware.h
diff -u /dev/null build_tree/linux/include/asm/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/hardware.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/hardware.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common hardware definitions
+ */
+
+#ifndef __ASM_HARDWARE_H
+#define __ASM_HARDWARE_H
+
+#include <asm/arch/hardware.h>
+
+#endif
Index: build_tree/linux/include/asm/hw_irq.h
diff -u /dev/null build_tree/linux/include/asm/hw_irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/hw_irq.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,20 @@
+/*
+ * Nothing to see here yet
+ */
+#ifndef _ARCH_ARM_HW_IRQ_H
+#define _ARCH_ARM_HW_IRQ_H
+
+#include <asm/mach/irq.h>
+
+#if defined(CONFIG_NO_IDLE_HZ)
+# include <asm/dyntick.h>
+# define handle_dynamic_tick(action)					\
+	if (!(action->flags & IRQF_TIMER) && system_timer->dyn_tick) {	\
+		write_seqlock(&xtime_lock);				\
+		if (system_timer->dyn_tick->state & DYN_TICK_ENABLED)	\
+			system_timer->dyn_tick->handler(irq, NULL);	\
+		write_sequnlock(&xtime_lock);				\
+	}
+#endif
+
+#endif
Index: build_tree/linux/include/asm/ide.h
diff -u /dev/null build_tree/linux/include/asm/ide.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ide.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/ide.h
+ *
+ *  Copyright (C) 1994-1996  Linus Torvalds & authors
+ */
+
+/*
+ *  This file contains the ARM architecture specific IDE code.
+ */
+
+#ifndef __ASMARM_IDE_H
+#define __ASMARM_IDE_H
+
+#ifdef __KERNEL__
+
+#ifndef MAX_HWIFS
+#define MAX_HWIFS	4
+#endif
+
+#if !defined(CONFIG_ARCH_L7200)
+# define IDE_ARCH_OBSOLETE_INIT
+# ifdef CONFIG_ARCH_CLPS7500
+#  define ide_default_io_ctl(base)	((base) + 0x206) /* obsolete */
+# else
+#  define ide_default_io_ctl(base)	(0)
+# endif
+#endif /* !ARCH_L7200 */
+
+#define __ide_mm_insw(port,addr,len)	readsw(port,addr,len)
+#define __ide_mm_insl(port,addr,len)	readsl(port,addr,len)
+#define __ide_mm_outsw(port,addr,len)	writesw(port,addr,len)
+#define __ide_mm_outsl(port,addr,len)	writesl(port,addr,len)
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASMARM_IDE_H */
Index: build_tree/linux/include/asm/io.h
diff -u /dev/null build_tree/linux/include/asm/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/io.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,276 @@
+/*
+ *  linux/include/asm-arm/io.h
+ *
+ *  Copyright (C) 1996-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Modifications:
+ *  16-Sep-1996	RMK	Inlined the inx/outx functions & optimised for both
+ *			constant addresses and variable addresses.
+ *  04-Dec-1997	RMK	Moved a lot of this stuff to the new architecture
+ *			specific IO header files.
+ *  27-Mar-1999	PJB	Second parameter of memcpy_toio is const..
+ *  04-Apr-1999	PJB	Added check_signature.
+ *  12-Dec-1999	RMK	More cleanups
+ *  18-Jun-2000 RMK	Removed virt_to_* and friends definitions
+ *  05-Oct-2004 BJD     Moved memory string functions to use void __iomem
+ */
+#ifndef __ASM_ARM_IO_H
+#define __ASM_ARM_IO_H
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <asm/memory.h>
+
+/*
+ * ISA I/O bus memory addresses are 1:1 with the physical address.
+ */
+#define isa_virt_to_bus virt_to_phys
+#define isa_page_to_bus page_to_phys
+#define isa_bus_to_virt phys_to_virt
+
+/*
+ * Generic IO read/write.  These perform native-endian accesses.  Note
+ * that some architectures will want to re-define __raw_{read,write}w.
+ */
+extern void __raw_writesb(void __iomem *addr, const void *data, int bytelen);
+extern void __raw_writesw(void __iomem *addr, const void *data, int wordlen);
+extern void __raw_writesl(void __iomem *addr, const void *data, int longlen);
+
+extern void __raw_readsb(const void __iomem *addr, void *data, int bytelen);
+extern void __raw_readsw(const void __iomem *addr, void *data, int wordlen);
+extern void __raw_readsl(const void __iomem *addr, void *data, int longlen);
+
+#define __raw_writeb(v,a)	(__chk_io_ptr(a), *(volatile unsigned char __force  *)(a) = (v))
+#define __raw_writew(v,a)	(__chk_io_ptr(a), *(volatile unsigned short __force *)(a) = (v))
+#define __raw_writel(v,a)	(__chk_io_ptr(a), *(volatile unsigned int __force   *)(a) = (v))
+
+#define __raw_readb(a)		(__chk_io_ptr(a), *(volatile unsigned char __force  *)(a))
+#define __raw_readw(a)		(__chk_io_ptr(a), *(volatile unsigned short __force *)(a))
+#define __raw_readl(a)		(__chk_io_ptr(a), *(volatile unsigned int __force   *)(a))
+
+/*
+ * Architecture ioremap implementation.
+ *
+ * __ioremap takes CPU physical address.
+ *
+ * __ioremap_pfn takes a Page Frame Number and an offset into that page
+ */
+extern void __iomem * __ioremap_pfn(unsigned long, unsigned long, size_t, unsigned long);
+extern void __iomem * __ioremap(unsigned long, size_t, unsigned long);
+extern void __iounmap(volatile void __iomem *addr);
+
+/*
+ * Bad read/write accesses...
+ */
+extern void __readwrite_bug(const char *fn);
+
+/*
+ * Now, pick up the machine-defined IO definitions
+ */
+#include <asm/arch/io.h>
+
+/*
+ *  IO port access primitives
+ *  -------------------------
+ *
+ * The ARM doesn't have special IO access instructions; all IO is memory
+ * mapped.  Note that these are defined to perform little endian accesses
+ * only.  Their primary purpose is to access PCI and ISA peripherals.
+ *
+ * Note that for a big endian machine, this implies that the following
+ * big endian mode connectivity is in place, as described by numerous
+ * ARM documents:
+ *
+ *    PCI:  D0-D7   D8-D15 D16-D23 D24-D31
+ *    ARM: D24-D31 D16-D23  D8-D15  D0-D7
+ *
+ * The machine specific io.h include defines __io to translate an "IO"
+ * address to a memory address.
+ *
+ * Note that we prevent GCC re-ordering or caching values in expressions
+ * by introducing sequence points into the in*() definitions.  Note that
+ * __raw_* do not guarantee this behaviour.
+ *
+ * The {in,out}[bwl] macros are for emulating x86-style PCI/ISA IO space.
+ */
+#ifdef __io
+#define outb(v,p)		__raw_writeb(v,__io(p))
+#define outw(v,p)		__raw_writew((__force __u16) \
+					cpu_to_le16(v),__io(p))
+#define outl(v,p)		__raw_writel((__force __u32) \
+					cpu_to_le32(v),__io(p))
+
+#define inb(p)	({ __u8 __v = __raw_readb(__io(p)); __v; })
+#define inw(p)	({ __u16 __v = le16_to_cpu((__force __le16) \
+			__raw_readw(__io(p))); __v; })
+#define inl(p)	({ __u32 __v = le32_to_cpu((__force __le32) \
+			__raw_readl(__io(p))); __v; })
+
+#define outsb(p,d,l)		__raw_writesb(__io(p),d,l)
+#define outsw(p,d,l)		__raw_writesw(__io(p),d,l)
+#define outsl(p,d,l)		__raw_writesl(__io(p),d,l)
+
+#define insb(p,d,l)		__raw_readsb(__io(p),d,l)
+#define insw(p,d,l)		__raw_readsw(__io(p),d,l)
+#define insl(p,d,l)		__raw_readsl(__io(p),d,l)
+#endif
+
+#define outb_p(val,port)	outb((val),(port))
+#define outw_p(val,port)	outw((val),(port))
+#define outl_p(val,port)	outl((val),(port))
+#define inb_p(port)		inb((port))
+#define inw_p(port)		inw((port))
+#define inl_p(port)		inl((port))
+
+#define outsb_p(port,from,len)	outsb(port,from,len)
+#define outsw_p(port,from,len)	outsw(port,from,len)
+#define outsl_p(port,from,len)	outsl(port,from,len)
+#define insb_p(port,to,len)	insb(port,to,len)
+#define insw_p(port,to,len)	insw(port,to,len)
+#define insl_p(port,to,len)	insl(port,to,len)
+
+/*
+ * String version of IO memory access ops:
+ */
+extern void _memcpy_fromio(void *, const volatile void __iomem *, size_t);
+extern void _memcpy_toio(volatile void __iomem *, const void *, size_t);
+extern void _memset_io(volatile void __iomem *, int, size_t);
+
+#define mmiowb()
+
+/*
+ *  Memory access primitives
+ *  ------------------------
+ *
+ * These perform PCI memory accesses via an ioremap region.  They don't
+ * take an address as such, but a cookie.
+ *
+ * Again, this are defined to perform little endian accesses.  See the
+ * IO port primitives for more information.
+ */
+#ifdef __mem_pci
+#define readb(c) ({ __u8  __v = __raw_readb(__mem_pci(c)); __v; })
+#define readw(c) ({ __u16 __v = le16_to_cpu((__force __le16) \
+					__raw_readw(__mem_pci(c))); __v; })
+#define readl(c) ({ __u32 __v = le32_to_cpu((__force __le32) \
+					__raw_readl(__mem_pci(c))); __v; })
+#define readb_relaxed(addr) readb(addr)
+#define readw_relaxed(addr) readw(addr)
+#define readl_relaxed(addr) readl(addr)
+
+#define readsb(p,d,l)		__raw_readsb(__mem_pci(p),d,l)
+#define readsw(p,d,l)		__raw_readsw(__mem_pci(p),d,l)
+#define readsl(p,d,l)		__raw_readsl(__mem_pci(p),d,l)
+
+#define writeb(v,c)		__raw_writeb(v,__mem_pci(c))
+#define writew(v,c)		__raw_writew((__force __u16) \
+					cpu_to_le16(v),__mem_pci(c))
+#define writel(v,c)		__raw_writel((__force __u32) \
+					cpu_to_le32(v),__mem_pci(c))
+
+#define writesb(p,d,l)		__raw_writesb(__mem_pci(p),d,l)
+#define writesw(p,d,l)		__raw_writesw(__mem_pci(p),d,l)
+#define writesl(p,d,l)		__raw_writesl(__mem_pci(p),d,l)
+
+#define memset_io(c,v,l)	_memset_io(__mem_pci(c),(v),(l))
+#define memcpy_fromio(a,c,l)	_memcpy_fromio((a),__mem_pci(c),(l))
+#define memcpy_toio(c,a,l)	_memcpy_toio(__mem_pci(c),(a),(l))
+
+#elif !defined(readb)
+
+#define readb(c)			(__readwrite_bug("readb"),0)
+#define readw(c)			(__readwrite_bug("readw"),0)
+#define readl(c)			(__readwrite_bug("readl"),0)
+#define writeb(v,c)			__readwrite_bug("writeb")
+#define writew(v,c)			__readwrite_bug("writew")
+#define writel(v,c)			__readwrite_bug("writel")
+
+#define check_signature(io,sig,len)	(0)
+
+#endif	/* __mem_pci */
+
+/*
+ * ioremap and friends.
+ *
+ * ioremap takes a PCI memory address, as specified in
+ * Documentation/IO-mapping.txt.
+ *
+ */
+#ifndef __arch_ioremap
+#define ioremap(cookie,size)		__ioremap(cookie,size,0)
+#define ioremap_nocache(cookie,size)	__ioremap(cookie,size,0)
+#define ioremap_cached(cookie,size)	__ioremap(cookie,size,L_PTE_CACHEABLE)
+#define iounmap(cookie)			__iounmap(cookie)
+#else
+#define ioremap(cookie,size)		__arch_ioremap((cookie),(size),0)
+#define ioremap_nocache(cookie,size)	__arch_ioremap((cookie),(size),0)
+#define ioremap_cached(cookie,size)	__arch_ioremap((cookie),(size),L_PTE_CACHEABLE)
+#define iounmap(cookie)			__arch_iounmap(cookie)
+#endif
+
+/*
+ * io{read,write}{8,16,32} macros
+ */
+#ifndef ioread8
+#define ioread8(p)	({ unsigned int __v = __raw_readb(p); __v; })
+#define ioread16(p)	({ unsigned int __v = le16_to_cpu(__raw_readw(p)); __v; })
+#define ioread32(p)	({ unsigned int __v = le32_to_cpu(__raw_readl(p)); __v; })
+
+#define iowrite8(v,p)	__raw_writeb(v, p)
+#define iowrite16(v,p)	__raw_writew(cpu_to_le16(v), p)
+#define iowrite32(v,p)	__raw_writel(cpu_to_le32(v), p)
+
+#define ioread8_rep(p,d,c)	__raw_readsb(p,d,c)
+#define ioread16_rep(p,d,c)	__raw_readsw(p,d,c)
+#define ioread32_rep(p,d,c)	__raw_readsl(p,d,c)
+
+#define iowrite8_rep(p,s,c)	__raw_writesb(p,s,c)
+#define iowrite16_rep(p,s,c)	__raw_writesw(p,s,c)
+#define iowrite32_rep(p,s,c)	__raw_writesl(p,s,c)
+
+extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
+extern void ioport_unmap(void __iomem *addr);
+#endif
+
+struct pci_dev;
+
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *addr);
+
+/*
+ * can the hardware map this into one segment or not, given no other
+ * constraints.
+ */
+#define BIOVEC_MERGEABLE(vec1, vec2)	\
+	((bvec_to_phys((vec1)) + (vec1)->bv_len) == bvec_to_phys((vec2)))
+
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+extern int valid_phys_addr_range(unsigned long addr, size_t size);
+extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+/*
+ * Register ISA memory and port locations for glibc iopl/inb/outb
+ * emulation.
+ */
+extern void register_isa_ports(unsigned int mmio, unsigned int io,
+			       unsigned int io_shift);
+
+#endif	/* __KERNEL__ */
+#endif	/* __ASM_ARM_IO_H */
Index: build_tree/linux/include/asm/ioctl.h
diff -u /dev/null build_tree/linux/include/asm/ioctl.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ioctl.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1 @@
+#include <asm-generic/ioctl.h>
Index: build_tree/linux/include/asm/ioctls.h
diff -u /dev/null build_tree/linux/include/asm/ioctls.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ioctls.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,80 @@
+#ifndef __ASM_ARM_IOCTLS_H
+#define __ASM_ARM_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450  /* these numbers need to be adjusted. */
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define FIOQSIZE	0x545E
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT	0x01	/* Transmitter physically empty */
+
+#endif
Index: build_tree/linux/include/asm/ipc.h
diff -u /dev/null build_tree/linux/include/asm/ipc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ipc.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1 @@
+#include <asm-generic/ipc.h>
Index: build_tree/linux/include/asm/ipcbuf.h
diff -u /dev/null build_tree/linux/include/asm/ipcbuf.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ipcbuf.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,29 @@
+#ifndef __ASMARM_IPCBUF_H
+#define __ASMARM_IPCBUF_H
+
+/*
+ * The ipc64_perm structure for arm architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t and seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm
+{
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+	unsigned short		__pad1;
+	unsigned short		seq;
+	unsigned short		__pad2;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* __ASMARM_IPCBUF_H */
Index: build_tree/linux/include/asm/irq.h
diff -u /dev/null build_tree/linux/include/asm/irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/irq.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,45 @@
+#ifndef __ASM_ARM_IRQ_H
+#define __ASM_ARM_IRQ_H
+
+#include <asm/arch/irqs.h>
+
+#ifndef irq_canonicalize
+#define irq_canonicalize(i)	(i)
+#endif
+
+#ifndef NR_IRQS
+#define NR_IRQS	128
+#endif
+
+/*
+ * Use this value to indicate lack of interrupt
+ * capability
+ */
+#ifndef NO_IRQ
+#define NO_IRQ	((unsigned int)(-1))
+#endif
+
+
+/*
+ * Migration helpers
+ */
+#define __IRQT_FALEDGE	IRQ_TYPE_EDGE_FALLING
+#define __IRQT_RISEDGE	IRQ_TYPE_EDGE_RISING
+#define __IRQT_LOWLVL	IRQ_TYPE_LEVEL_LOW
+#define __IRQT_HIGHLVL	IRQ_TYPE_LEVEL_HIGH
+
+#define IRQT_NOEDGE	(0)
+#define IRQT_RISING	(__IRQT_RISEDGE)
+#define IRQT_FALLING	(__IRQT_FALEDGE)
+#define IRQT_BOTHEDGE	(__IRQT_RISEDGE|__IRQT_FALEDGE)
+#define IRQT_LOW	(__IRQT_LOWLVL)
+#define IRQT_HIGH	(__IRQT_HIGHLVL)
+#define IRQT_PROBE	IRQ_TYPE_PROBE
+
+#ifndef __ASSEMBLY__
+struct irqaction;
+extern void migrate_irqs(void);
+#endif
+
+#endif
+
Index: build_tree/linux/include/asm/irq_regs.h
diff -u /dev/null build_tree/linux/include/asm/irq_regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/irq_regs.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1 @@
+#include <asm-generic/irq_regs.h>
Index: build_tree/linux/include/asm/irqflags.h
diff -u /dev/null build_tree/linux/include/asm/irqflags.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/irqflags.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,132 @@
+#ifndef __ASM_ARM_IRQFLAGS_H
+#define __ASM_ARM_IRQFLAGS_H
+
+#ifdef __KERNEL__
+
+#include <asm/ptrace.h>
+
+/*
+ * CPU interrupt mask handling.
+ */
+#if __LINUX_ARM_ARCH__ >= 6
+
+#define raw_local_irq_save(x)					\
+	({							\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_save\n"	\
+	"cpsid	i"						\
+	: "=r" (x) : : "memory", "cc");				\
+	})
+
+#define raw_local_irq_enable()  __asm__("cpsie i	@ __sti" : : : "memory", "cc")
+#define raw_local_irq_disable() __asm__("cpsid i	@ __cli" : : : "memory", "cc")
+#define local_fiq_enable()  __asm__("cpsie f	@ __stf" : : : "memory", "cc")
+#define local_fiq_disable() __asm__("cpsid f	@ __clf" : : : "memory", "cc")
+
+#else
+
+/*
+ * Save the current interrupt enable state & disable IRQs
+ */
+#define raw_local_irq_save(x)					\
+	({							\
+		unsigned long temp;				\
+		(void) (&temp == &x);				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_save\n"	\
+"	orr	%1, %0, #128\n"					\
+"	msr	cpsr_c, %1"					\
+	: "=r" (x), "=r" (temp)					\
+	:							\
+	: "memory", "cc");					\
+	})
+	
+/*
+ * Enable IRQs
+ */
+#define raw_local_irq_enable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_enable\n"	\
+"	bic	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+/*
+ * Disable IRQs
+ */
+#define raw_local_irq_disable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_disable\n"	\
+"	orr	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+/*
+ * Enable FIQs
+ */
+#define local_fiq_enable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ stf\n"		\
+"	bic	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+/*
+ * Disable FIQs
+ */
+#define local_fiq_disable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ clf\n"		\
+"	orr	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory", "cc");					\
+	})
+
+#endif
+
+/*
+ * Save the current interrupt enable state.
+ */
+#define raw_local_save_flags(x)					\
+	({							\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_save_flags"	\
+	: "=r" (x) : : "memory", "cc");				\
+	})
+
+/*
+ * restore saved IRQ & FIQ state
+ */
+#define raw_local_irq_restore(x)				\
+	__asm__ __volatile__(					\
+	"msr	cpsr_c, %0		@ local_irq_restore\n"	\
+	:							\
+	: "r" (x)						\
+	: "memory", "cc")
+
+#define raw_irqs_disabled_flags(flags)	\
+({					\
+	(int)((flags) & PSR_I_BIT);	\
+})
+
+#endif
+#endif
Index: build_tree/linux/include/asm/kexec.h
diff -u /dev/null build_tree/linux/include/asm/kexec.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/kexec.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,30 @@
+#ifndef _ARM_KEXEC_H
+#define _ARM_KEXEC_H
+
+#ifdef CONFIG_KEXEC
+
+/* Maximum physical address we can use pages from */
+#define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)
+/* Maximum address we can reach in physical address mode */
+#define KEXEC_DESTINATION_MEMORY_LIMIT (-1UL)
+/* Maximum address we can use for the control code buffer */
+#define KEXEC_CONTROL_MEMORY_LIMIT TASK_SIZE
+
+#define KEXEC_CONTROL_CODE_SIZE	4096
+
+#define KEXEC_ARCH KEXEC_ARCH_ARM
+
+#ifndef __ASSEMBLY__
+
+#define MAX_NOTE_BYTES 1024
+
+struct kimage;
+/* Provide a dummy definition to avoid build failures. */
+static inline void crash_setup_regs(struct pt_regs *newregs,
+                                        struct pt_regs *oldregs) { }
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* CONFIG_KEXEC */
+
+#endif /* _ARM_KEXEC_H */
Index: build_tree/linux/include/asm/kmap_types.h
diff -u /dev/null build_tree/linux/include/asm/kmap_types.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/kmap_types.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,24 @@
+#ifndef __ARM_KMAP_TYPES_H
+#define __ARM_KMAP_TYPES_H
+
+/*
+ * This is the "bare minimum".  AIO seems to require this.
+ */
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BIO_SRC_IRQ,
+	KM_BIO_DST_IRQ,
+	KM_PTE0,
+	KM_PTE1,
+	KM_IRQ0,
+	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#endif
Index: build_tree/linux/include/asm/leds.h
diff -u /dev/null build_tree/linux/include/asm/leds.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/leds.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,50 @@
+/*
+ *  linux/include/asm-arm/leds.h
+ *
+ *  Copyright (C) 1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Event-driven interface for LEDs on machines
+ *  Added led_start and led_stop- Alex Holden, 28th Dec 1998.
+ */
+#ifndef ASM_ARM_LEDS_H
+#define ASM_ARM_LEDS_H
+
+
+typedef enum {
+	led_idle_start,
+	led_idle_end,
+	led_timer,
+	led_start,
+	led_stop,
+	led_claim,		/* override idle & timer leds */
+	led_release,		/* restore idle & timer leds */
+	led_start_timer_mode,
+	led_stop_timer_mode,
+	led_green_on,
+	led_green_off,
+	led_amber_on,
+	led_amber_off,
+	led_red_on,
+	led_red_off,
+	led_blue_on,
+	led_blue_off,
+	/*
+	 * I want this between led_timer and led_start, but
+	 * someone has decided to export this to user space
+	 */
+	led_halted
+} led_event_t;
+
+/* Use this routine to handle LEDs */
+
+#ifdef CONFIG_LEDS
+extern void (*leds_event)(led_event_t);
+#else
+#define leds_event(e)
+#endif
+
+#endif
Index: build_tree/linux/include/asm/limits.h
diff -u /dev/null build_tree/linux/include/asm/limits.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/limits.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,11 @@
+#ifndef __ASM_PIPE_H
+#define __ASM_PIPE_H
+
+#ifndef PAGE_SIZE
+#include <asm/page.h>
+#endif
+
+#define PIPE_BUF	PAGE_SIZE
+
+#endif
+
Index: build_tree/linux/include/asm/linkage.h
diff -u /dev/null build_tree/linux/include/asm/linkage.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/linkage.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,7 @@
+#ifndef __ASM_LINKAGE_H
+#define __ASM_LINKAGE_H
+
+#define __ALIGN .align 0
+#define __ALIGN_STR ".align 0"
+
+#endif
Index: build_tree/linux/include/asm/local.h
diff -u /dev/null build_tree/linux/include/asm/local.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/local.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1 @@
+#include <asm-generic/local.h>
Index: build_tree/linux/include/asm/locks.h
diff -u /dev/null build_tree/linux/include/asm/locks.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/locks.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,274 @@
+/*
+ *  linux/include/asm-arm/locks.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Interrupt safe locking assembler. 
+ */
+#ifndef __ASM_PROC_LOCKS_H
+#define __ASM_PROC_LOCKS_H
+
+#if __LINUX_ARM_ARCH__ >= 6
+
+#define __down_op(ptr,fail)			\
+	({					\
+	__asm__ __volatile__(			\
+	"@ down_op\n"				\
+"1:	ldrex	lr, [%0]\n"			\
+"	sub	lr, lr, %1\n"			\
+"	strex	ip, lr, [%0]\n"			\
+"	teq	ip, #0\n"			\
+"	bne	1b\n"				\
+"	teq	lr, #0\n"			\
+"	movmi	ip, %0\n"			\
+"	blmi	" #fail				\
+	:					\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	smp_mb();				\
+	})
+
+#define __down_op_ret(ptr,fail)			\
+	({					\
+		unsigned int ret;		\
+	__asm__ __volatile__(			\
+	"@ down_op_ret\n"			\
+"1:	ldrex	lr, [%1]\n"			\
+"	sub	lr, lr, %2\n"			\
+"	strex	ip, lr, [%1]\n"			\
+"	teq	ip, #0\n"			\
+"	bne	1b\n"				\
+"	teq	lr, #0\n"			\
+"	movmi	ip, %1\n"			\
+"	movpl	ip, #0\n"			\
+"	blmi	" #fail "\n"			\
+"	mov	%0, ip"				\
+	: "=&r" (ret)				\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	smp_mb();				\
+	ret;					\
+	})
+
+#define __up_op(ptr,wake)			\
+	({					\
+	smp_mb();				\
+	__asm__ __volatile__(			\
+	"@ up_op\n"				\
+"1:	ldrex	lr, [%0]\n"			\
+"	add	lr, lr, %1\n"			\
+"	strex	ip, lr, [%0]\n"			\
+"	teq	ip, #0\n"			\
+"	bne	1b\n"				\
+"	cmp	lr, #0\n"			\
+"	movle	ip, %0\n"			\
+"	blle	" #wake				\
+	:					\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	})
+
+/*
+ * The value 0x01000000 supports up to 128 processors and
+ * lots of processes.  BIAS must be chosen such that sub'ing
+ * BIAS once per CPU will result in the long remaining
+ * negative.
+ */
+#define RW_LOCK_BIAS      0x01000000
+#define RW_LOCK_BIAS_STR "0x01000000"
+
+#define __down_op_write(ptr,fail)		\
+	({					\
+	__asm__ __volatile__(			\
+	"@ down_op_write\n"			\
+"1:	ldrex	lr, [%0]\n"			\
+"	sub	lr, lr, %1\n"			\
+"	strex	ip, lr, [%0]\n"			\
+"	teq	ip, #0\n"			\
+"	bne	1b\n"				\
+"	teq	lr, #0\n"			\
+"	movne	ip, %0\n"			\
+"	blne	" #fail				\
+	:					\
+	: "r" (ptr), "I" (RW_LOCK_BIAS)		\
+	: "ip", "lr", "cc");			\
+	smp_mb();				\
+	})
+
+#define __up_op_write(ptr,wake)			\
+	({					\
+	smp_mb();				\
+	__asm__ __volatile__(			\
+	"@ up_op_write\n"			\
+"1:	ldrex	lr, [%0]\n"			\
+"	adds	lr, lr, %1\n"			\
+"	strex	ip, lr, [%0]\n"			\
+"	teq	ip, #0\n"			\
+"	bne	1b\n"				\
+"	movcs	ip, %0\n"			\
+"	blcs	" #wake				\
+	:					\
+	: "r" (ptr), "I" (RW_LOCK_BIAS)		\
+	: "ip", "lr", "cc");			\
+	})
+
+#define __down_op_read(ptr,fail)		\
+	__down_op(ptr, fail)
+
+#define __up_op_read(ptr,wake)			\
+	({					\
+	smp_mb();				\
+	__asm__ __volatile__(			\
+	"@ up_op_read\n"			\
+"1:	ldrex	lr, [%0]\n"			\
+"	add	lr, lr, %1\n"			\
+"	strex	ip, lr, [%0]\n"			\
+"	teq	ip, #0\n"			\
+"	bne	1b\n"				\
+"	teq	lr, #0\n"			\
+"	moveq	ip, %0\n"			\
+"	bleq	" #wake				\
+	:					\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	})
+
+#else
+
+#define __down_op(ptr,fail)			\
+	({					\
+	__asm__ __volatile__(			\
+	"@ down_op\n"				\
+"	mrs	ip, cpsr\n"			\
+"	orr	lr, ip, #128\n"			\
+"	msr	cpsr_c, lr\n"			\
+"	ldr	lr, [%0]\n"			\
+"	subs	lr, lr, %1\n"			\
+"	str	lr, [%0]\n"			\
+"	msr	cpsr_c, ip\n"			\
+"	movmi	ip, %0\n"			\
+"	blmi	" #fail				\
+	:					\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	smp_mb();				\
+	})
+
+#define __down_op_ret(ptr,fail)			\
+	({					\
+		unsigned int ret;		\
+	__asm__ __volatile__(			\
+	"@ down_op_ret\n"			\
+"	mrs	ip, cpsr\n"			\
+"	orr	lr, ip, #128\n"			\
+"	msr	cpsr_c, lr\n"			\
+"	ldr	lr, [%1]\n"			\
+"	subs	lr, lr, %2\n"			\
+"	str	lr, [%1]\n"			\
+"	msr	cpsr_c, ip\n"			\
+"	movmi	ip, %1\n"			\
+"	movpl	ip, #0\n"			\
+"	blmi	" #fail "\n"			\
+"	mov	%0, ip"				\
+	: "=&r" (ret)				\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	smp_mb();				\
+	ret;					\
+	})
+
+#define __up_op(ptr,wake)			\
+	({					\
+	smp_mb();				\
+	__asm__ __volatile__(			\
+	"@ up_op\n"				\
+"	mrs	ip, cpsr\n"			\
+"	orr	lr, ip, #128\n"			\
+"	msr	cpsr_c, lr\n"			\
+"	ldr	lr, [%0]\n"			\
+"	adds	lr, lr, %1\n"			\
+"	str	lr, [%0]\n"			\
+"	msr	cpsr_c, ip\n"			\
+"	movle	ip, %0\n"			\
+"	blle	" #wake				\
+	:					\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	})
+
+/*
+ * The value 0x01000000 supports up to 128 processors and
+ * lots of processes.  BIAS must be chosen such that sub'ing
+ * BIAS once per CPU will result in the long remaining
+ * negative.
+ */
+#define RW_LOCK_BIAS      0x01000000
+#define RW_LOCK_BIAS_STR "0x01000000"
+
+#define __down_op_write(ptr,fail)		\
+	({					\
+	__asm__ __volatile__(			\
+	"@ down_op_write\n"			\
+"	mrs	ip, cpsr\n"			\
+"	orr	lr, ip, #128\n"			\
+"	msr	cpsr_c, lr\n"			\
+"	ldr	lr, [%0]\n"			\
+"	subs	lr, lr, %1\n"			\
+"	str	lr, [%0]\n"			\
+"	msr	cpsr_c, ip\n"			\
+"	movne	ip, %0\n"			\
+"	blne	" #fail				\
+	:					\
+	: "r" (ptr), "I" (RW_LOCK_BIAS)		\
+	: "ip", "lr", "cc");			\
+	smp_mb();				\
+	})
+
+#define __up_op_write(ptr,wake)			\
+	({					\
+	__asm__ __volatile__(			\
+	"@ up_op_write\n"			\
+"	mrs	ip, cpsr\n"			\
+"	orr	lr, ip, #128\n"			\
+"	msr	cpsr_c, lr\n"			\
+"	ldr	lr, [%0]\n"			\
+"	adds	lr, lr, %1\n"			\
+"	str	lr, [%0]\n"			\
+"	msr	cpsr_c, ip\n"			\
+"	movcs	ip, %0\n"			\
+"	blcs	" #wake				\
+	:					\
+	: "r" (ptr), "I" (RW_LOCK_BIAS)		\
+	: "ip", "lr", "cc");			\
+	smp_mb();				\
+	})
+
+#define __down_op_read(ptr,fail)		\
+	__down_op(ptr, fail)
+
+#define __up_op_read(ptr,wake)			\
+	({					\
+	smp_mb();				\
+	__asm__ __volatile__(			\
+	"@ up_op_read\n"			\
+"	mrs	ip, cpsr\n"			\
+"	orr	lr, ip, #128\n"			\
+"	msr	cpsr_c, lr\n"			\
+"	ldr	lr, [%0]\n"			\
+"	adds	lr, lr, %1\n"			\
+"	str	lr, [%0]\n"			\
+"	msr	cpsr_c, ip\n"			\
+"	moveq	ip, %0\n"			\
+"	bleq	" #wake				\
+	:					\
+	: "r" (ptr), "I" (1)			\
+	: "ip", "lr", "cc");			\
+	})
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/mach-types.h
diff -u /dev/null build_tree/linux/include/asm/mach-types.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mach-types.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,17160 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_NEXUSPCI             3
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_TBOX                 7
+#define MACH_TYPE_CO285                8
+#define MACH_TYPE_CLPS7110             9
+#define MACH_TYPE_ARCHIMEDES           10
+#define MACH_TYPE_A5K                  11
+#define MACH_TYPE_ETOILE               12
+#define MACH_TYPE_LACIE_NAS            13
+#define MACH_TYPE_CLPS7500             14
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_ITSY                 18
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_IXP1200              23
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_VICTOR               26
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_RANGER               28
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_FPIC                 33
+#define MACH_TYPE_EXTENEX1             34
+#define MACH_TYPE_SHERMAN              35
+#define MACH_TYPE_ACCELENT_SA          36
+#define MACH_TYPE_ACCELENT_L7200       37
+#define MACH_TYPE_NETPORT              38
+#define MACH_TYPE_PANGOLIN             39
+#define MACH_TYPE_YOPY                 40
+#define MACH_TYPE_COOLIDGE             41
+#define MACH_TYPE_HUW_WEBPANEL         42
+#define MACH_TYPE_SPOTME               43
+#define MACH_TYPE_FREEBIRD             44
+#define MACH_TYPE_TI925                45
+#define MACH_TYPE_RISCSTATION          46
+#define MACH_TYPE_CAVY                 47
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_OMNIMETER            49
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_CITYGO               51
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_SPOT                 53
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_WEBPAL               55
+#define MACH_TYPE_LINPDA               56
+#define MACH_TYPE_ANAKIN               57
+#define MACH_TYPE_MVI                  58
+#define MACH_TYPE_JUPITER              59
+#define MACH_TYPE_PSIONW               60
+#define MACH_TYPE_ALN                  61
+#define MACH_TYPE_CAMELOT              62
+#define MACH_TYPE_GDS2200              63
+#define MACH_TYPE_PSION_SERIES7        64
+#define MACH_TYPE_XFILE                65
+#define MACH_TYPE_ACCELENT_EP9312      66
+#define MACH_TYPE_IC200                67
+#define MACH_TYPE_CREDITLART           68
+#define MACH_TYPE_HTM                  69
+#define MACH_TYPE_IQ80310              70
+#define MACH_TYPE_FREEBOT              71
+#define MACH_TYPE_ENTEL                72
+#define MACH_TYPE_ENP3510              73
+#define MACH_TYPE_TRIZEPS              74
+#define MACH_TYPE_NESA                 75
+#define MACH_TYPE_VENUS                76
+#define MACH_TYPE_TARDIS               77
+#define MACH_TYPE_MERCURY              78
+#define MACH_TYPE_EMPEG                79
+#define MACH_TYPE_I80200FCC            80
+#define MACH_TYPE_ITT_CPB              81
+#define MACH_TYPE_SVC                  82
+#define MACH_TYPE_ALPHA2               84
+#define MACH_TYPE_ALPHA1               85
+#define MACH_TYPE_NETARM               86
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_PDA1                 88
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_ANIKO                90
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_CS89712              92
+#define MACH_TYPE_WEARARM              93
+#define MACH_TYPE_POSSIO_PX            94
+#define MACH_TYPE_SIDEARM              95
+#define MACH_TYPE_STORK                96
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_ACE                  98
+#define MACH_TYPE_BALLYARM             99
+#define MACH_TYPE_SIMPUTER             100
+#define MACH_TYPE_NEXTERM              101
+#define MACH_TYPE_SA1100_ELF           102
+#define MACH_TYPE_GATOR                103
+#define MACH_TYPE_GRANITE              104
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PLCE                 111
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_MEDALB               113
+#define MACH_TYPE_EAGLE                114
+#define MACH_TYPE_DSC21                115
+#define MACH_TYPE_DSC24                116
+#define MACH_TYPE_TI5472               117
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_UENGINE              119
+#define MACH_TYPE_BLUESTEM             120
+#define MACH_TYPE_XINGU8               121
+#define MACH_TYPE_BUSHSTB              122
+#define MACH_TYPE_EPSILON1             123
+#define MACH_TYPE_BALLOON              124
+#define MACH_TYPE_PUPPY                125
+#define MACH_TYPE_ELROY                126
+#define MACH_TYPE_GMS720               127
+#define MACH_TYPE_S24X                 128
+#define MACH_TYPE_JTEL_CLEP7312        129
+#define MACH_TYPE_CX821XX              130
+#define MACH_TYPE_EDB7312              131
+#define MACH_TYPE_BSA1110              132
+#define MACH_TYPE_POWERPIN             133
+#define MACH_TYPE_OPENARM              134
+#define MACH_TYPE_WHITECHAPEL          135
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_H3800                137
+#define MACH_TYPE_BLUE_V1              138
+#define MACH_TYPE_PXA_CERF             139
+#define MACH_TYPE_ARM7TEVB             140
+#define MACH_TYPE_D7400                141
+#define MACH_TYPE_PIRANHA              142
+#define MACH_TYPE_SBCAMELOT            143
+#define MACH_TYPE_KINGS                144
+#define MACH_TYPE_SMDK2400             145
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_IDR                  147
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_WEBNET               149
+#define MACH_TYPE_D7300                150
+#define MACH_TYPE_CEP                  151
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_VC547X               153
+#define MACH_TYPE_FILEWALKER           154
+#define MACH_TYPE_NETGATEWAY           155
+#define MACH_TYPE_SYMBOL2800           156
+#define MACH_TYPE_SUNS                 157
+#define MACH_TYPE_FRODO                158
+#define MACH_TYPE_MACH_TYTE_MS301      159
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_AMICO                163
+#define MACH_TYPE_IAM                  164
+#define MACH_TYPE_TT530                165
+#define MACH_TYPE_SAM2400              166
+#define MACH_TYPE_JORNADA56X           167
+#define MACH_TYPE_ACTIVE               168
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_WID                  170
+#define MACH_TYPE_SABINAL              171
+#define MACH_TYPE_IXP425_MATACUMBE     172
+#define MACH_TYPE_MINIPRINT            173
+#define MACH_TYPE_ADM510X              174
+#define MACH_TYPE_SVS200               175
+#define MACH_TYPE_ATG_TCU              176
+#define MACH_TYPE_JORNADA820           177
+#define MACH_TYPE_S3C44B0              178
+#define MACH_TYPE_MARGIS2              179
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_BRH                  181
+#define MACH_TYPE_S3C2410              182
+#define MACH_TYPE_POSSIO_PX30          183
+#define MACH_TYPE_S3C2800              184
+#define MACH_TYPE_FLEETWOOD            185
+#define MACH_TYPE_OMAHA                186
+#define MACH_TYPE_TA7                  187
+#define MACH_TYPE_NOVA                 188
+#define MACH_TYPE_HMK                  189
+#define MACH_TYPE_KARO                 190
+#define MACH_TYPE_FESTER               191
+#define MACH_TYPE_GPI                  192
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_I519                 194
+#define MACH_TYPE_NEXIO                195
+#define MACH_TYPE_BITBOX               196
+#define MACH_TYPE_G200                 197
+#define MACH_TYPE_GILL                 198
+#define MACH_TYPE_PXA_MERCURY          199
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_FRET                 201
+#define MACH_TYPE_EMAILPHONE           202
+#define MACH_TYPE_H3900                203
+#define MACH_TYPE_PXA1                 204
+#define MACH_TYPE_KOAN369              205
+#define MACH_TYPE_COGENT               206
+#define MACH_TYPE_ESL_SIMPUTER         207
+#define MACH_TYPE_ESL_SIMPUTER_CLR     208
+#define MACH_TYPE_ESL_SIMPUTER_BW      209
+#define MACH_TYPE_HHP_CRADLE           210
+#define MACH_TYPE_HE500                211
+#define MACH_TYPE_INHANDELF2           212
+#define MACH_TYPE_INHANDFTIP           213
+#define MACH_TYPE_DNP1110              214
+#define MACH_TYPE_PNP1110              215
+#define MACH_TYPE_CSB226               216
+#define MACH_TYPE_ARNOLD               217
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_JZ8028               219
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_FORTE                221
+#define MACH_TYPE_ACAM                 222
+#define MACH_TYPE_ABOX                 223
+#define MACH_TYPE_ATMEL                224
+#define MACH_TYPE_SITSANG              225
+#define MACH_TYPE_CPU1110LCDNET        226
+#define MACH_TYPE_MPL_VCMA9            227
+#define MACH_TYPE_OPUS_A1              228
+#define MACH_TYPE_DAYTONA              229
+#define MACH_TYPE_KILLBEAR             230
+#define MACH_TYPE_YOHO                 231
+#define MACH_TYPE_JASPER               232
+#define MACH_TYPE_DSC25                233
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_RAMSES               235
+#define MACH_TYPE_S28X                 236
+#define MACH_TYPE_MPORT3               237
+#define MACH_TYPE_PXA_EAGLE250         238
+#define MACH_TYPE_PDB                  239
+#define MACH_TYPE_BLUE_2G              240
+#define MACH_TYPE_BLUEARCH             241
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_EXPLORER             244
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_CHIMP                246
+#define MACH_TYPE_STORK_NEST           247
+#define MACH_TYPE_STORK_EGG            248
+#define MACH_TYPE_WISMO                249
+#define MACH_TYPE_EZLINX               250
+#define MACH_TYPE_AT91RM9200           251
+#define MACH_TYPE_ORION                252
+#define MACH_TYPE_NEPTUNE              253
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_PXA_WINS30           255
+#define MACH_TYPE_LAVINNA              256
+#define MACH_TYPE_PXA_UENGINE          257
+#define MACH_TYPE_INNOKOM              258
+#define MACH_TYPE_BMS                  259
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_PRPMC1100            261
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_ARMSTICK             263
+#define MACH_TYPE_ARMONIE              264
+#define MACH_TYPE_MPORT1               265
+#define MACH_TYPE_S3C5410              266
+#define MACH_TYPE_ZCP320A              267
+#define MACH_TYPE_I_BOX                268
+#define MACH_TYPE_STLC1502             269
+#define MACH_TYPE_SIREN                270
+#define MACH_TYPE_GREENLAKE            271
+#define MACH_TYPE_ARGUS                272
+#define MACH_TYPE_COMBADGE             273
+#define MACH_TYPE_ROKEPXA              274
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_GUIDEA07             276
+#define MACH_TYPE_TAT257               277
+#define MACH_TYPE_IGP2425              278
+#define MACH_TYPE_BLUEGRAMMA           279
+#define MACH_TYPE_IPOD                 280
+#define MACH_TYPE_ADSBITSYX            281
+#define MACH_TYPE_TRIZEPS2             282
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADSBITSYPLUS         284
+#define MACH_TYPE_ADSAGC               285
+#define MACH_TYPE_STP7312              286
+#define MACH_TYPE_NX_PHNX              287
+#define MACH_TYPE_WEP_EP250            288
+#define MACH_TYPE_INHANDELF3           289
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IYONIX               291
+#define MACH_TYPE_DAMICAM_SA1110       292
+#define MACH_TYPE_MEG03                293
+#define MACH_TYPE_PXA_WHITECHAPEL      294
+#define MACH_TYPE_NWSC                 295
+#define MACH_TYPE_NWLARM               296
+#define MACH_TYPE_IXP425_MGUARD        297
+#define MACH_TYPE_PXA_NETDCU4          298
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_ZODIAC               301
+#define MACH_TYPE_ARMMODUL             302
+#define MACH_TYPE_KETOP                303
+#define MACH_TYPE_AV7200               304
+#define MACH_TYPE_ARCH_TI925           305
+#define MACH_TYPE_ACQ200               306
+#define MACH_TYPE_PT_DAFIT             307
+#define MACH_TYPE_IHBA                 308
+#define MACH_TYPE_QUINQUE              309
+#define MACH_TYPE_NIMBRAONE            310
+#define MACH_TYPE_NIMBRA29X            311
+#define MACH_TYPE_NIMBRA210            312
+#define MACH_TYPE_HHP_D95XX            313
+#define MACH_TYPE_LABARM               314
+#define MACH_TYPE_M825XX               315
+#define MACH_TYPE_M7100                316
+#define MACH_TYPE_NIPC2                317
+#define MACH_TYPE_FU7202               318
+#define MACH_TYPE_ADSAGX               319
+#define MACH_TYPE_PXA_POOH             320
+#define MACH_TYPE_BANDON               321
+#define MACH_TYPE_PCM7210              322
+#define MACH_TYPE_NMS9200              323
+#define MACH_TYPE_LOGODL               324
+#define MACH_TYPE_M7140                325
+#define MACH_TYPE_KOREBOT              326
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_KOAN393              328
+#define MACH_TYPE_INHANDFTIP3          329
+#define MACH_TYPE_GONZO                330
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_SCANPASS             332
+#define MACH_TYPE_EP7312_POOH          333
+#define MACH_TYPE_TA7S                 334
+#define MACH_TYPE_TA7V                 335
+#define MACH_TYPE_ICARUS               336
+#define MACH_TYPE_H1900                337
+#define MACH_TYPE_GEMINI               338
+#define MACH_TYPE_AXIM                 339
+#define MACH_TYPE_AUDIOTRON            340
+#define MACH_TYPE_H2200                341
+#define MACH_TYPE_LOOX600              342
+#define MACH_TYPE_NIOP                 343
+#define MACH_TYPE_DM310                344
+#define MACH_TYPE_SEEDPXA_C2           345
+#define MACH_TYPE_IXP4XX_MGUARD_PCI    346
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_SCORPIO              348
+#define MACH_TYPE_VIVA                 349
+#define MACH_TYPE_PXA_XCARD            350
+#define MACH_TYPE_CSB335               351
+#define MACH_TYPE_IXRD425              352
+#define MACH_TYPE_IQ80315              353
+#define MACH_TYPE_NMP7312              354
+#define MACH_TYPE_CX861XX              355
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_XDA                  357
+#define MACH_TYPE_CSIR_IMS             358
+#define MACH_TYPE_IXP421_DNAEETH       359
+#define MACH_TYPE_POCKETSERV9200       360
+#define MACH_TYPE_TOTO                 361
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_KS8695P              363
+#define MACH_TYPE_SE4000               364
+#define MACH_TYPE_QUADRICEPS           365
+#define MACH_TYPE_BRONCO               366
+#define MACH_TYPE_ESL_SOFCOMP          368
+#define MACH_TYPE_S5C7375              369
+#define MACH_TYPE_SPEARHEAD            370
+#define MACH_TYPE_PANTERA              371
+#define MACH_TYPE_PRAYOGLITE           372
+#define MACH_TYPE_GUMSTIK              373
+#define MACH_TYPE_RCUBE                374
+#define MACH_TYPE_REA_OLV              375
+#define MACH_TYPE_PXA_IPHONE           376
+#define MACH_TYPE_S3C3410              377
+#define MACH_TYPE_ESPD_4510B           378
+#define MACH_TYPE_MP1X                 379
+#define MACH_TYPE_AT91RM9200TB         380
+#define MACH_TYPE_ADSVGX               381
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_PELEE                383
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_FUJITSU_CAMELOT      391
+#define MACH_TYPE_JANUS2M              392
+#define MACH_TYPE_EMBTF                393
+#define MACH_TYPE_HPM                  394
+#define MACH_TYPE_SMDK2410TK           395
+#define MACH_TYPE_SMDK2410AJ           396
+#define MACH_TYPE_STREETRACER          397
+#define MACH_TYPE_EFRAME               398
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_PXA_LARK             400
+#define MACH_TYPE_PNP2110              401
+#define MACH_TYPE_TCC72X               402
+#define MACH_TYPE_ALTAIR               403
+#define MACH_TYPE_KC3                  404
+#define MACH_TYPE_SINTEFTD             405
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_ADAY4X               407
+#define MACH_TYPE_LITE300              408
+#define MACH_TYPE_S5C7376              409
+#define MACH_TYPE_MT02                 410
+#define MACH_TYPE_MPORT3S              411
+#define MACH_TYPE_RA_ALPHA             412
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_VULCAN         414
+#define MACH_TYPE_STARGATE             415
+#define MACH_TYPE_ARMADILLOJ           416
+#define MACH_TYPE_ELROY_JACK           417
+#define MACH_TYPE_BACKEND              418
+#define MACH_TYPE_S5LINBOX             419
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_IA_CPU_9200          421
+#define MACH_TYPE_AT91_BJA1            422
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_TEN                  425
+#define MACH_TYPE_ROVERP5P             426
+#define MACH_TYPE_SC2700               427
+#define MACH_TYPE_EX_EAGLE             428
+#define MACH_TYPE_NX_PXA12             429
+#define MACH_TYPE_NX_PXA5              430
+#define MACH_TYPE_BLACKBOARD2          431
+#define MACH_TYPE_I819                 432
+#define MACH_TYPE_IXMB995E             433
+#define MACH_TYPE_SKYRIDER             434
+#define MACH_TYPE_SKYHAWK              435
+#define MACH_TYPE_ENTERPRISE           436
+#define MACH_TYPE_DEP2410              437
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_HOBBIT               439
+#define MACH_TYPE_H7210                440
+#define MACH_TYPE_PXA_NETDCU5          441
+#define MACH_TYPE_ACC                  442
+#define MACH_TYPE_ESL_SARVA            443
+#define MACH_TYPE_XM250                444
+#define MACH_TYPE_T6TC1XB              445
+#define MACH_TYPE_ESS710               446
+#define MACH_TYPE_MX31ADS              447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_BOLFENK              449
+#define MACH_TYPE_AT91RM9200KR         450
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_AXIMX3               453
+#define MACH_TYPE_EB67XDIP             454
+#define MACH_TYPE_WEBTXS               455
+#define MACH_TYPE_HAWK                 456
+#define MACH_TYPE_CCAT91SBC001         457
+#define MACH_TYPE_EXPRESSO             458
+#define MACH_TYPE_H4000                459
+#define MACH_TYPE_DINO                 460
+#define MACH_TYPE_ML675K               461
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_RECIVA_TT            464
+#define MACH_TYPE_CSTCB01              465
+#define MACH_TYPE_CSTCB1               466
+#define MACH_TYPE_SHADWELL             467
+#define MACH_TYPE_GOEPEL263            468
+#define MACH_TYPE_ACQ100               469
+#define MACH_TYPE_MX1FS2               470
+#define MACH_TYPE_HIPTOP_G1            471
+#define MACH_TYPE_SPARKY               472
+#define MACH_TYPE_NS9750               473
+#define MACH_TYPE_PHOENIX              474
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_DEISTERPXA           476
+#define MACH_TYPE_BCM1160              477
+#define MACH_TYPE_PCM022               478
+#define MACH_TYPE_ADSGCX               479
+#define MACH_TYPE_DREADNAUGHT          480
+#define MACH_TYPE_DM320                481
+#define MACH_TYPE_MARKOV               482
+#define MACH_TYPE_COS7A400             483
+#define MACH_TYPE_MILANO               484
+#define MACH_TYPE_UE9328               485
+#define MACH_TYPE_UEX255               486
+#define MACH_TYPE_UE2410               487
+#define MACH_TYPE_A620                 488
+#define MACH_TYPE_OCELOT               489
+#define MACH_TYPE_CHEETAH              490
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_ZVUE                 492
+#define MACH_TYPE_ROVERP1              493
+#define MACH_TYPE_ASIDIAL2             494
+#define MACH_TYPE_S3C24A0              495
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_S3C5500              498
+#define MACH_TYPE_SMDK5500             499
+#define MACH_TYPE_SIGNALSYNC           500
+#define MACH_TYPE_NBC                  501
+#define MACH_TYPE_KODIAK               502
+#define MACH_TYPE_NETBOOKPRO           503
+#define MACH_TYPE_HW90200              504
+#define MACH_TYPE_CONDOR               505
+#define MACH_TYPE_CUP                  506
+#define MACH_TYPE_KITE                 507
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_N10                  511
+#define MACH_TYPE_MONTAJADE            512
+#define MACH_TYPE_SG560                513
+#define MACH_TYPE_DP1000               514
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_RG100V3              516
+#define MACH_TYPE_MX2ADS               517
+#define MACH_TYPE_PXA_KILO             518
+#define MACH_TYPE_IXP4XX_EAGLE         519
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_MB2520F              521
+#define MACH_TYPE_EMC1000              522
+#define MACH_TYPE_TIDSC25              523
+#define MACH_TYPE_AKCPMXL              524
+#define MACH_TYPE_AV3XX                525
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_PXA_MPM10            527
+#define MACH_TYPE_PXA_KYANITE          528
+#define MACH_TYPE_SGOLD                529
+#define MACH_TYPE_OSCAR                530
+#define MACH_TYPE_EPXA4USB2            531
+#define MACH_TYPE_XSENGINE             532
+#define MACH_TYPE_IP600                533
+#define MACH_TYPE_MCAN2                534
+#define MACH_TYPE_DDI_BLUERIDGE        535
+#define MACH_TYPE_SKYMINDER            536
+#define MACH_TYPE_LPD79520             537
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HW90340              539
+#define MACH_TYPE_CIP_BOX              540
+#define MACH_TYPE_IVPN                 541
+#define MACH_TYPE_RSOC2                542
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_BOXER                544
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_AML42800AA           546
+#define MACH_TYPE_MACH_TYPE_ML674001   547
+#define MACH_TYPE_LPC2294              548
+#define MACH_TYPE_SWITCHGRASS          549
+#define MACH_TYPE_ENS_CMU              550
+#define MACH_TYPE_MM6_SDB              551
+#define MACH_TYPE_SATURN               552
+#define MACH_TYPE_I30030EVB            553
+#define MACH_TYPE_MXC27530EVB          554
+#define MACH_TYPE_SMDK2800             555
+#define MACH_TYPE_MTWILSON             556
+#define MACH_TYPE_ZITI                 557
+#define MACH_TYPE_GRANDFATHER          558
+#define MACH_TYPE_TENGINE              559
+#define MACH_TYPE_S3C2460              560
+#define MACH_TYPE_PDM                  561
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_H6300                563
+#define MACH_TYPE_RZ1700               564
+#define MACH_TYPE_A716                 565
+#define MACH_TYPE_ESTK2440A            566
+#define MACH_TYPE_ATWIXP425            567
+#define MACH_TYPE_CSB336               568
+#define MACH_TYPE_RIRM2                569
+#define MACH_TYPE_CX23518              570
+#define MACH_TYPE_CX2351X              571
+#define MACH_TYPE_COMPUTIME            572
+#define MACH_TYPE_IZARUS               573
+#define MACH_TYPE_RTS                  574
+#define MACH_TYPE_SE5100               575
+#define MACH_TYPE_S3C2510              576
+#define MACH_TYPE_CSB437TL             577
+#define MACH_TYPE_SLAUSON              578
+#define MACH_TYPE_PEARLRIVER           579
+#define MACH_TYPE_TDC_P210             580
+#define MACH_TYPE_SG580                581
+#define MACH_TYPE_WRSBCARM7            582
+#define MACH_TYPE_IPD                  583
+#define MACH_TYPE_PXA_DNP2110          584
+#define MACH_TYPE_XAENIAX              585
+#define MACH_TYPE_SOMN4250             586
+#define MACH_TYPE_PLEB2                587
+#define MACH_TYPE_CORNWALLIS           588
+#define MACH_TYPE_GURNEY_DRV           589
+#define MACH_TYPE_CHAFFEE              590
+#define MACH_TYPE_RMS101               591
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_SWIFT                593
+#define MACH_TYPE_ROVERP7              594
+#define MACH_TYPE_PR818S               595
+#define MACH_TYPE_TRXPRO               596
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_TRAB                 599
+#define MACH_TYPE_CMC_PU2              600
+#define MACH_TYPE_FULCRUM              601
+#define MACH_TYPE_NETGATE42X           602
+#define MACH_TYPE_STR710               603
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_TOMTOMGO             605
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_SG565                608
+#define MACH_TYPE_LPD79524             609
+#define MACH_TYPE_LPD79525             610
+#define MACH_TYPE_RMS100               611
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_HMS39C7092           614
+#define MACH_TYPE_ARMADILLO            615
+#define MACH_TYPE_IPCU                 616
+#define MACH_TYPE_LOOX720              617
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_ADSVIX               620
+#define MACH_TYPE_DM270                621
+#define MACH_TYPE_SOCLTPLUS            622
+#define MACH_TYPE_ECIA                 623
+#define MACH_TYPE_CM4008               624
+#define MACH_TYPE_P2001                625
+#define MACH_TYPE_TWISTER              626
+#define MACH_TYPE_MUDSHARK             627
+#define MACH_TYPE_HB2                  628
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_SENDT                630
+#define MACH_TYPE_MX2JAZZ              631
+#define MACH_TYPE_MULTIIO              632
+#define MACH_TYPE_HRDISPLAY            633
+#define MACH_TYPE_MXC27530ADS          634
+#define MACH_TYPE_TRIZEPS3             635
+#define MACH_TYPE_ZEFEERDZA            636
+#define MACH_TYPE_ZEFEERDZB            637
+#define MACH_TYPE_ZEFEERDZG            638
+#define MACH_TYPE_ZEFEERDZN            639
+#define MACH_TYPE_ZEFEERDZQ            640
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_ASTRO_JACK           643
+#define MACH_TYPE_TIP03                644
+#define MACH_TYPE_A9200EC              645
+#define MACH_TYPE_PNX0105              646
+#define MACH_TYPE_ADCPOECPU            647
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_ML69Q6203            649
+#define MACH_TYPE_MB9200               650
+#define MACH_TYPE_KULUN                651
+#define MACH_TYPE_SNAPPER              652
+#define MACH_TYPE_OPTIMA               653
+#define MACH_TYPE_DLHSBC               654
+#define MACH_TYPE_X30                  655
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_MANGA_KS8695         657
+#define MACH_TYPE_AJAX                 658
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_VVTK1000             661
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_VVTK3000             663
+#define MACH_TYPE_PIMX1                664
+#define MACH_TYPE_OLLIE                665
+#define MACH_TYPE_SKYMAX               666
+#define MACH_TYPE_JAZZ                 667
+#define MACH_TYPE_TEL_T3               668
+#define MACH_TYPE_AISINO_FCR255        669
+#define MACH_TYPE_BTWEB                670
+#define MACH_TYPE_DBG_LH79520          671
+#define MACH_TYPE_CM41XX               672
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_NGGPXA               674
+#define MACH_TYPE_CSB535               675
+#define MACH_TYPE_CSB536               676
+#define MACH_TYPE_PXA_TRAKPOD          677
+#define MACH_TYPE_PRAXIS               678
+#define MACH_TYPE_LH75411              679
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_LOOX410              682
+#define MACH_TYPE_WESTLAKE             683
+#define MACH_TYPE_NSB                  684
+#define MACH_TYPE_ESL_SARVA_STN        685
+#define MACH_TYPE_ESL_SARVA_TFT        686
+#define MACH_TYPE_ESL_SARVA_IAD        687
+#define MACH_TYPE_ESL_SARVA_ACC        688
+#define MACH_TYPE_TYPHOON              689
+#define MACH_TYPE_CNAV                 690
+#define MACH_TYPE_A730                 691
+#define MACH_TYPE_NETSTAR              692
+#define MACH_TYPE_PHASEFALE_SUPERCON   693
+#define MACH_TYPE_SHIVA1100            694
+#define MACH_TYPE_ETEXSC               695
+#define MACH_TYPE_IXDPG465             696
+#define MACH_TYPE_A9M2410              697
+#define MACH_TYPE_A9M2440              698
+#define MACH_TYPE_A9M9750              699
+#define MACH_TYPE_A9M9360              700
+#define MACH_TYPE_UNC90                701
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_SATVIEW              703
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_GP32                 706
+#define MACH_TYPE_GEM                  707
+#define MACH_TYPE_I858                 708
+#define MACH_TYPE_HX2750               709
+#define MACH_TYPE_MXC91131EVB          710
+#define MACH_TYPE_P700                 711
+#define MACH_TYPE_CPE                  712
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_NIMBRA340            714
+#define MACH_TYPE_LPC22XX              715
+#define MACH_TYPE_COMET3               716
+#define MACH_TYPE_COMET4               717
+#define MACH_TYPE_CSB625               718
+#define MACH_TYPE_FORTUNET2            719
+#define MACH_TYPE_S5H2200              720
+#define MACH_TYPE_OPTORM920            721
+#define MACH_TYPE_ADSBITSYXB           722
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_ADSPORTAL            724
+#define MACH_TYPE_LN2410SBC            725
+#define MACH_TYPE_CB3RUFC              726
+#define MACH_TYPE_MP2USB               727
+#define MACH_TYPE_NTNP425C             728
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_PCM7220              730
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_CMPXA                733
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_ITE8152              735
+#define MACH_TYPE_LPC3XXX              736
+#define MACH_TYPE_PUPPETEER            737
+#define MACH_TYPE_MACH_VADATECH        738
+#define MACH_TYPE_E570                 739
+#define MACH_TYPE_X50                  740
+#define MACH_TYPE_RECON                741
+#define MACH_TYPE_XBOARDGP8            742
+#define MACH_TYPE_FPIC2                743
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_A81                  745
+#define MACH_TYPE_SVM_SC25X            746
+#define MACH_TYPE_VADATECH020          747
+#define MACH_TYPE_TLI                  748
+#define MACH_TYPE_EDB9315LC            749
+#define MACH_TYPE_PASSEC               750
+#define MACH_TYPE_DS_TIGER             751
+#define MACH_TYPE_E310                 752
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_RT3000               754
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_PNX0106              756
+#define MACH_TYPE_HX21XX               757
+#define MACH_TYPE_FARADAY              758
+#define MACH_TYPE_SBC9312              759
+#define MACH_TYPE_BATMAN               760
+#define MACH_TYPE_JPD201               761
+#define MACH_TYPE_MIPSA                762
+#define MACH_TYPE_KACOM                763
+#define MACH_TYPE_SWARCOCPU            764
+#define MACH_TYPE_SWARCODSL            765
+#define MACH_TYPE_BLUEANGEL            766
+#define MACH_TYPE_HAIRYGRAMA           767
+#define MACH_TYPE_BANFF                768
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_SAM255               770
+#define MACH_TYPE_PPM10                771
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_SUNSET               773
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_MAINSTONE2           777
+#define MACH_TYPE_EZ_IXP42X            778
+#define MACH_TYPE_TAPWAVE_ZODIAC       779
+#define MACH_TYPE_UNIVERSALMETER       780
+#define MACH_TYPE_HICOARM9             781
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_KWS6000              783
+#define MACH_TYPE_PORTUX920T           784
+#define MACH_TYPE_EZ_X5                785
+#define MACH_TYPE_OMAP_RUDOLPH         786
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_REA9200              788
+#define MACH_TYPE_ACTS_PUNE_SA1110     789
+#define MACH_TYPE_IXP425               790
+#define MACH_TYPE_I30030ADS            791
+#define MACH_TYPE_PERCH                792
+#define MACH_TYPE_EIS05R1              793
+#define MACH_TYPE_PEPPERPAD            794
+#define MACH_TYPE_SB3010               795
+#define MACH_TYPE_RM9200               796
+#define MACH_TYPE_DMA03                797
+#define MACH_TYPE_ROAD_S101            798
+#define MACH_TYPE_IQ81340SC            799
+#define MACH_TYPE_IQ_NEXTGEN_B         800
+#define MACH_TYPE_IQ81340MC            801
+#define MACH_TYPE_IQ_NEXTGEN_D         802
+#define MACH_TYPE_IQ_NEXTGEN_E         803
+#define MACH_TYPE_MALLOW_AT91          804
+#define MACH_TYPE_CYBERTRACKER_I       805
+#define MACH_TYPE_GESBC931X            806
+#define MACH_TYPE_CENTIPAD             807
+#define MACH_TYPE_ARMSOC               808
+#define MACH_TYPE_SE4200               809
+#define MACH_TYPE_EMS197A              810
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_UC5471DSP            813
+#define MACH_TYPE_SJ5471ENG            814
+#define MACH_TYPE_CMPXA26X             815
+#define MACH_TYPE_NC                   816
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_AJAX52X              818
+#define MACH_TYPE_SIRIUSTAR            819
+#define MACH_TYPE_IODATA_HDLG          820
+#define MACH_TYPE_AT91RM9200UTL        821
+#define MACH_TYPE_BIOSAFE              822
+#define MACH_TYPE_MP1000               823
+#define MACH_TYPE_PARSY                824
+#define MACH_TYPE_CCXP                 825
+#define MACH_TYPE_OMAP_GSAMPLE         826
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_SAMOA                828
+#define MACH_TYPE_T3XSCALE             829
+#define MACH_TYPE_I878                 830
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_GECKO                832
+#define MACH_TYPE_DS101                833
+#define MACH_TYPE_OMAP_PALMTT2         834
+#define MACH_TYPE_XSCALE_PALMLD        835
+#define MACH_TYPE_CC9C                 836
+#define MACH_TYPE_SBC1670              837
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ML696K               840
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_MAESTRO              843
+#define MACH_TYPE_TUNGE2               844
+#define MACH_TYPE_IXBBM                845
+#define MACH_TYPE_MX27ADS              846
+#define MACH_TYPE_AX8004               847
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MAGPIE               850
+#define MACH_TYPE_MX21ADS              851
+#define MACH_TYPE_MB87M3400            852
+#define MACH_TYPE_MGUARD_DELTA         853
+#define MACH_TYPE_DAVINCI_DVDP         854
+#define MACH_TYPE_HTCUNIVERSAL         855
+#define MACH_TYPE_TPAD                 856
+#define MACH_TYPE_ROVERP3              857
+#define MACH_TYPE_JORNADA928           858
+#define MACH_TYPE_MV88FXX81            859
+#define MACH_TYPE_STMP36XX             860
+#define MACH_TYPE_SXNI79524            861
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_URANIUM              863
+#define MACH_TYPE_UCON                 864
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_L083_1000            866
+#define MACH_TYPE_EZX                  867
+#define MACH_TYPE_PNX5220              868
+#define MACH_TYPE_BUTTE                869
+#define MACH_TYPE_SRM2                 870
+#define MACH_TYPE_DSBR                 871
+#define MACH_TYPE_CRYSTALBALL          872
+#define MACH_TYPE_TINYPXA27X           873
+#define MACH_TYPE_HERBIE               874
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_CM4002               876
+#define MACH_TYPE_B4                   877
+#define MACH_TYPE_MAUI                 878
+#define MACH_TYPE_CYBERTRACKER_G       879
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_MIO8390              881
+#define MACH_TYPE_OMI_BOARD            882
+#define MACH_TYPE_MX21CIV              883
+#define MACH_TYPE_MAHI_CDAC            884
+#define MACH_TYPE_XSCALE_PALMTX        885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_SAMSYS_EP0           888
+#define MACH_TYPE_WG302V1              889
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_EB42X                891
+#define MACH_TYPE_IQ331ES              892
+#define MACH_TYPE_COSYDSP              893
+#define MACH_TYPE_UPLAT7D              894
+#define MACH_TYPE_PTDAVINCI            895
+#define MACH_TYPE_MBUS                 896
+#define MACH_TYPE_NADIA2VB             897
+#define MACH_TYPE_R1000                898
+#define MACH_TYPE_HW90250              899
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_OMAP_TORNADO         902
+#define MACH_TYPE_OLOCREEK             903
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_APF9328              906
+#define MACH_TYPE_OMAP_WIPOQ           907
+#define MACH_TYPE_OMAP_TWIP            908
+#define MACH_TYPE_XSCALE_PALMTREO650   909
+#define MACH_TYPE_ACUMEN               910
+#define MACH_TYPE_XP100                911
+#define MACH_TYPE_FS2410               912
+#define MACH_TYPE_PXA270_CERF          913
+#define MACH_TYPE_SQ2FTLPALM           914
+#define MACH_TYPE_BSEMSERVER           915
+#define MACH_TYPE_NETCLIENT            916
+#define MACH_TYPE_XSCALE_PALMTT5       917
+#define MACH_TYPE_OMAP_PALMTC          918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_MXC30030EVB          920
+#define MACH_TYPE_REA_2D               921
+#define MACH_TYPE_TI3E524              922
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_AUCKLAND             924
+#define MACH_TYPE_AK3320M              925
+#define MACH_TYPE_DURAMAX              926
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_PRONGHORN            928
+#define MACH_TYPE_FUNDY                929
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_CPU777               931
+#define MACH_TYPE_SIMICON9201          932
+#define MACH_TYPE_LEAP2_HPM            933
+#define MACH_TYPE_CM922TXA10           934
+#define MACH_TYPE_PXA                  935
+#define MACH_TYPE_SANDGATE2            936
+#define MACH_TYPE_SANDGATE2G           937
+#define MACH_TYPE_SANDGATE2P           938
+#define MACH_TYPE_FRED_JACK            939
+#define MACH_TYPE_TTG_COLOR1           940
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_NETDCU8              942
+#define MACH_TYPE_ML675050_CPU_BOA     943
+#define MACH_TYPE_NG_FVX538            944
+#define MACH_TYPE_NG_FVS338            945
+#define MACH_TYPE_PNX4103              946
+#define MACH_TYPE_HESDB                947
+#define MACH_TYPE_XSILO                948
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_EMLC                 950
+#define MACH_TYPE_SISTERON             951
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_TSC_VENUS            953
+#define MACH_TYPE_DS101J               954
+#define MACH_TYPE_MXC30030ADS          955
+#define MACH_TYPE_FUJITSU_WIMAXSOC     956
+#define MACH_TYPE_DUALPCMODEM          957
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_HTCAPACHE            959
+#define MACH_TYPE_IXDP435              960
+#define MACH_TYPE_CATPROVT100          961
+#define MACH_TYPE_PICOTUX1XX           962
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_EMPC2                965
+#define MACH_TYPE_VENTURA              966
+#define MACH_TYPE_PHIDGET_SBC          967
+#define MACH_TYPE_IJ3K                 968
+#define MACH_TYPE_PISGAH               969
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SG720                971
+#define MACH_TYPE_REDFOX               972
+#define MACH_TYPE_MYSH_EP9315_1        973
+#define MACH_TYPE_TPF106               974
+#define MACH_TYPE_AT91RM9200KG         975
+#define MACH_TYPE_SLEDB                976
+#define MACH_TYPE_ONTRACK              977
+#define MACH_TYPE_PM1200               978
+#define MACH_TYPE_ESS24XXX             979
+#define MACH_TYPE_COREMP7              980
+#define MACH_TYPE_NEXCODER_6446        981
+#define MACH_TYPE_STVC8380             982
+#define MACH_TYPE_TEKLYNX              983
+#define MACH_TYPE_CARBONADO            984
+#define MACH_TYPE_SYSMOS_MP730         985
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_PGIGIM               987
+#define MACH_TYPE_PTX9160P2            988
+#define MACH_TYPE_DCORE1               989
+#define MACH_TYPE_VICTORPXA            990
+#define MACH_TYPE_MX2DTB               991
+#define MACH_TYPE_PXA_IREX_ER0100      992
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_BARTEC_DEG           994
+#define MACH_TYPE_HW50251              995
+#define MACH_TYPE_IBOX                 996
+#define MACH_TYPE_ATLASLH7A404         997
+#define MACH_TYPE_PT2026               998
+#define MACH_TYPE_HTCALPINE            999
+#define MACH_TYPE_BARTEC_VTU           1000
+#define MACH_TYPE_VCOREII              1001
+#define MACH_TYPE_PDNB3                1002
+#define MACH_TYPE_HTCBEETLES           1003
+#define MACH_TYPE_S3C6400              1004
+#define MACH_TYPE_S3C2443              1005
+#define MACH_TYPE_OMAP_LDK             1006
+#define MACH_TYPE_SMDK2460             1007
+#define MACH_TYPE_SMDK2440             1008
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_WEBBOX               1010
+#define MACH_TYPE_CWWNDP               1011
+#define MACH_TYPE_DRAGON               1012
+#define MACH_TYPE_OPENDO_CPU_BOARD     1013
+#define MACH_TYPE_CCM2200              1014
+#define MACH_TYPE_ETWARM               1015
+#define MACH_TYPE_M93030               1016
+#define MACH_TYPE_CC7U                 1017
+#define MACH_TYPE_MTT_RANGER           1018
+#define MACH_TYPE_NEXUS                1019
+#define MACH_TYPE_DESMAN               1020
+#define MACH_TYPE_BKDE303              1021
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M7200            1023
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_SG640                1025
+#define MACH_TYPE_EDG79524             1026
+#define MACH_TYPE_AI2410               1027
+#define MACH_TYPE_IXP465               1028
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_HEINS                1030
+#define MACH_TYPE_MPLUSEVA             1031
+#define MACH_TYPE_RT042                1032
+#define MACH_TYPE_CWIEM                1033
+#define MACH_TYPE_CM_X270              1034
+#define MACH_TYPE_CM_X255              1035
+#define MACH_TYPE_ESH_AT91             1036
+#define MACH_TYPE_SANDGATE3            1037
+#define MACH_TYPE_PRIMO                1038
+#define MACH_TYPE_GEMSTONE             1039
+#define MACH_TYPE_PRONGHORNMETRO       1040
+#define MACH_TYPE_SIDEWINDER           1041
+#define MACH_TYPE_PICOMOD1             1042
+#define MACH_TYPE_SG590                1043
+#define MACH_TYPE_AKAI9307             1044
+#define MACH_TYPE_FONTAINE             1045
+#define MACH_TYPE_WOMBAT               1046
+#define MACH_TYPE_ACQ300               1047
+#define MACH_TYPE_MOD_270              1048
+#define MACH_TYPE_VC0820               1049
+#define MACH_TYPE_ANI_AIM              1050
+#define MACH_TYPE_JELLYFISH            1051
+#define MACH_TYPE_AMANITA              1052
+#define MACH_TYPE_VLINK                1053
+#define MACH_TYPE_DEXFLEX              1054
+#define MACH_TYPE_EIGEN_TTQ            1055
+#define MACH_TYPE_ARCOM_TITAN          1056
+#define MACH_TYPE_TABLA                1057
+#define MACH_TYPE_MDIRAC3              1058
+#define MACH_TYPE_MRHFBP2              1059
+#define MACH_TYPE_AT91RM9200RB         1060
+#define MACH_TYPE_ANI_APM              1061
+#define MACH_TYPE_ELLA1                1062
+#define MACH_TYPE_INHAND_PXA27X        1063
+#define MACH_TYPE_INHAND_PXA25X        1064
+#define MACH_TYPE_EMPOS_XM             1065
+#define MACH_TYPE_EMPOS                1066
+#define MACH_TYPE_EMPOS_TINY           1067
+#define MACH_TYPE_EMPOS_SM             1068
+#define MACH_TYPE_EGRET                1069
+#define MACH_TYPE_OSTRICH              1070
+#define MACH_TYPE_N50                  1071
+#define MACH_TYPE_ECBAT91              1072
+#define MACH_TYPE_STAREAST             1073
+#define MACH_TYPE_DSPG_DW              1074
+#define MACH_TYPE_ONEARM               1075
+#define MACH_TYPE_MRG110_6             1076
+#define MACH_TYPE_WRT300NV2            1077
+#define MACH_TYPE_XM_BULVERDE          1078
+#define MACH_TYPE_MSM6100              1079
+#define MACH_TYPE_ETI_B1               1080
+#define MACH_TYPE_ZILOG_ZA9L           1081
+#define MACH_TYPE_BIT2440              1082
+#define MACH_TYPE_NBI                  1083
+#define MACH_TYPE_SMDK2443             1084
+#define MACH_TYPE_VDAVINCI             1085
+#define MACH_TYPE_ATC6                 1086
+#define MACH_TYPE_MULTMDW              1087
+#define MACH_TYPE_MBA2440              1088
+#define MACH_TYPE_ECSD                 1089
+#define MACH_TYPE_ZIRE31               1090
+#define MACH_TYPE_FSG                  1091
+#define MACH_TYPE_RAZOR101             1092
+#define MACH_TYPE_OPERA_TDM            1093
+#define MACH_TYPE_COMCERTO             1094
+#define MACH_TYPE_TB0319               1095
+#define MACH_TYPE_KWS8000              1096
+#define MACH_TYPE_B2                   1097
+#define MACH_TYPE_LCL54                1098
+#define MACH_TYPE_AT91SAM9260EK        1099
+#define MACH_TYPE_GLANTANK             1100
+#define MACH_TYPE_N2100                1101
+#define MACH_TYPE_N4100                1102
+#define MACH_TYPE_VERTICAL_RSC4        1103
+#define MACH_TYPE_SG8100               1104
+#define MACH_TYPE_IM42XX               1105
+#define MACH_TYPE_FTXX                 1106
+#define MACH_TYPE_LWFUSION             1107
+#define MACH_TYPE_QT2410               1108
+#define MACH_TYPE_KIXRP435             1109
+#define MACH_TYPE_CCW9C                1110
+#define MACH_TYPE_DABHS                1111
+#define MACH_TYPE_GZMX                 1112
+#define MACH_TYPE_IPNW100AP            1113
+#define MACH_TYPE_CC9P9360DEV          1114
+#define MACH_TYPE_CC9P9750DEV          1115
+#define MACH_TYPE_CC9P9360VAL          1116
+#define MACH_TYPE_CC9P9750VAL          1117
+#define MACH_TYPE_NX70V                1118
+#define MACH_TYPE_AT91RM9200DF         1119
+#define MACH_TYPE_SE_PILOT2            1120
+#define MACH_TYPE_MTCN_T800            1121
+#define MACH_TYPE_VCMX212              1122
+#define MACH_TYPE_LYNX                 1123
+#define MACH_TYPE_AT91SAM9260ID        1124
+#define MACH_TYPE_HW86052              1125
+#define MACH_TYPE_PILZ_PMI3            1126
+#define MACH_TYPE_EDB9302A             1127
+#define MACH_TYPE_EDB9307A             1128
+#define MACH_TYPE_CT_DFS               1129
+#define MACH_TYPE_PILZ_PMI4            1130
+#define MACH_TYPE_XCEEDNP_IXP          1131
+#define MACH_TYPE_SMDK2442B            1132
+#define MACH_TYPE_XNODE                1133
+#define MACH_TYPE_AIDX270              1134
+#define MACH_TYPE_REMA                 1135
+#define MACH_TYPE_BPS1000              1136
+#define MACH_TYPE_HW90350              1137
+#define MACH_TYPE_OMAP_SDP3430         1138
+#define MACH_TYPE_BLUETOUCH            1139
+#define MACH_TYPE_VSTMS                1140
+#define MACH_TYPE_XSBASE270            1141
+#define MACH_TYPE_AT91SAM9260EK_CN     1142
+#define MACH_TYPE_ADSTURBOXB           1143
+#define MACH_TYPE_OTI4110              1144
+#define MACH_TYPE_HME_PXA              1145
+#define MACH_TYPE_DEISTERDCA           1146
+#define MACH_TYPE_CES_SSEM2            1147
+#define MACH_TYPE_CES_MTR              1148
+#define MACH_TYPE_TDS_AVNG_SBC         1149
+#define MACH_TYPE_EVEREST              1150
+#define MACH_TYPE_PNX4010              1151
+#define MACH_TYPE_OXNAS                1152
+#define MACH_TYPE_FIORI                1153
+#define MACH_TYPE_ML1200               1154
+#define MACH_TYPE_PECOS                1155
+#define MACH_TYPE_NB2XXX               1156
+#define MACH_TYPE_HW6900               1157
+#define MACH_TYPE_CDCS_QUOLL           1158
+#define MACH_TYPE_QUICKSILVER          1159
+#define MACH_TYPE_UPLAT926             1160
+#define MACH_TYPE_DEP2410_THOMAS       1161
+#define MACH_TYPE_DTK2410              1162
+#define MACH_TYPE_CHILI                1163
+#define MACH_TYPE_DEMETER              1164
+#define MACH_TYPE_DIONYSUS             1165
+#define MACH_TYPE_AS352X               1166
+#define MACH_TYPE_SERVICE              1167
+#define MACH_TYPE_CS_E9301             1168
+#define MACH_TYPE_MICRO9M              1169
+#define MACH_TYPE_IA_MOSPCK            1170
+#define MACH_TYPE_QL201B               1171
+#define MACH_TYPE_BBM                  1174
+#define MACH_TYPE_EXXX                 1175
+#define MACH_TYPE_WMA11B               1176
+#define MACH_TYPE_PELCO_ATLAS          1177
+#define MACH_TYPE_G500                 1178
+#define MACH_TYPE_BUG                  1179
+#define MACH_TYPE_MX33ADS              1180
+#define MACH_TYPE_CHUB                 1181
+#define MACH_TYPE_NEO1973_GTA01        1182
+#define MACH_TYPE_W90N740              1183
+#define MACH_TYPE_MEDALLION_SA2410     1184
+#define MACH_TYPE_IA_CPU_9200_2        1185
+#define MACH_TYPE_DIMMRM9200           1186
+#define MACH_TYPE_PM9261               1187
+#define MACH_TYPE_ML7304               1189
+#define MACH_TYPE_UCP250               1190
+#define MACH_TYPE_INTBOARD             1191
+#define MACH_TYPE_GULFSTREAM           1192
+#define MACH_TYPE_LABQUEST             1193
+#define MACH_TYPE_VCMX313              1194
+#define MACH_TYPE_URG200               1195
+#define MACH_TYPE_CPUX255LCDNET        1196
+#define MACH_TYPE_NETDCU9              1197
+#define MACH_TYPE_NETDCU10             1198
+#define MACH_TYPE_DSPG_DGA             1199
+#define MACH_TYPE_DSPG_DVW             1200
+#define MACH_TYPE_SOLOS                1201
+#define MACH_TYPE_AT91SAM9263EK        1202
+#define MACH_TYPE_OSSTBOX              1203
+#define MACH_TYPE_KBAT9261             1204
+#define MACH_TYPE_CT1100               1205
+#define MACH_TYPE_AKCPPXA              1206
+#define MACH_TYPE_ZEVIO_1020           1207
+#define MACH_TYPE_HITRACK              1208
+#define MACH_TYPE_SYME1                1209
+#define MACH_TYPE_SYHL1                1210
+#define MACH_TYPE_EMPCA400             1211
+#define MACH_TYPE_EM7210               1212
+#define MACH_TYPE_HTCHERMES            1213
+#define MACH_TYPE_ETI_C1               1214
+#define MACH_TYPE_MACH_DEP2410         1215
+#define MACH_TYPE_AC100                1216
+#define MACH_TYPE_SNEETCH              1217
+#define MACH_TYPE_STUDENTMATE          1218
+#define MACH_TYPE_ZIR2410              1219
+#define MACH_TYPE_ZIR2413              1220
+#define MACH_TYPE_DLONIP3              1221
+#define MACH_TYPE_INSTREAM             1222
+#define MACH_TYPE_AMBARELLA            1223
+#define MACH_TYPE_NEVIS                1224
+#define MACH_TYPE_HTC_TRINITY          1225
+#define MACH_TYPE_QL202B               1226
+#define MACH_TYPE_VPAC270              1227
+#define MACH_TYPE_RD129                1228
+#define MACH_TYPE_HTCWIZARD            1229
+#define MACH_TYPE_XSCALE_TREO680       1230
+#define MACH_TYPE_TECON_TMEZON         1231
+#define MACH_TYPE_ZYLONITE             1233
+#define MACH_TYPE_GENE1270             1234
+#define MACH_TYPE_ZIR2412              1235
+#define MACH_TYPE_MX31LITE             1236
+#define MACH_TYPE_T700WX               1237
+#define MACH_TYPE_VF100                1238
+#define MACH_TYPE_NSB2                 1239
+#define MACH_TYPE_NXHMI_BB             1240
+#define MACH_TYPE_NXHMI_RE             1241
+#define MACH_TYPE_N4100PRO             1242
+#define MACH_TYPE_SAM9260              1243
+#define MACH_TYPE_OMAP_TREO600         1244
+#define MACH_TYPE_INDY2410             1245
+#define MACH_TYPE_NELT_A               1246
+#define MACH_TYPE_N311                 1248
+#define MACH_TYPE_AT91SAM9260VGK       1249
+#define MACH_TYPE_AT91LEPPE            1250
+#define MACH_TYPE_AT91LEPCCN           1251
+#define MACH_TYPE_APC7100              1252
+#define MACH_TYPE_STARGAZER            1253
+#define MACH_TYPE_SONATA               1254
+#define MACH_TYPE_SCHMOOGIE            1255
+#define MACH_TYPE_AZTOOL               1256
+#define MACH_TYPE_MIOA701              1257
+#define MACH_TYPE_SXNI9260             1258
+#define MACH_TYPE_MXC27520EVB          1259
+#define MACH_TYPE_ARMADILLO5X0         1260
+#define MACH_TYPE_MB9260               1261
+#define MACH_TYPE_MB9263               1262
+#define MACH_TYPE_IPAC9302             1263
+#define MACH_TYPE_CC9P9360JS           1264
+#define MACH_TYPE_GALLIUM              1265
+#define MACH_TYPE_MSC2410              1266
+#define MACH_TYPE_GHI270               1267
+#define MACH_TYPE_DAVINCI_LEONARDO     1268
+#define MACH_TYPE_OIAB                 1269
+#define MACH_TYPE_SMDK6400             1270
+#define MACH_TYPE_NOKIA_N800           1271
+#define MACH_TYPE_GREENPHONE           1272
+#define MACH_TYPE_COMPEXWP18           1273
+#define MACH_TYPE_XMATE                1274
+#define MACH_TYPE_ENERGIZER            1275
+#define MACH_TYPE_IME1                 1276
+#define MACH_TYPE_SWEDATMS             1277
+#define MACH_TYPE_NTNP435C             1278
+#define MACH_TYPE_SPECTRO2             1279
+#define MACH_TYPE_H6039                1280
+#define MACH_TYPE_EP80219              1281
+#define MACH_TYPE_SAMOA_II             1282
+#define MACH_TYPE_CWMXL                1283
+#define MACH_TYPE_AS9200               1284
+#define MACH_TYPE_SFX1149              1285
+#define MACH_TYPE_NAVI010              1286
+#define MACH_TYPE_MULTMDP              1287
+#define MACH_TYPE_SCB9520              1288
+#define MACH_TYPE_HTCATHENA            1289
+#define MACH_TYPE_XP179                1290
+#define MACH_TYPE_H4300                1291
+#define MACH_TYPE_GORAMO_MLR           1292
+#define MACH_TYPE_MXC30020EVB          1293
+#define MACH_TYPE_ADSBITSIMX           1294
+#define MACH_TYPE_ADSPORTALPLUS        1295
+#define MACH_TYPE_MMSP2PLUS            1296
+#define MACH_TYPE_EM_X270              1297
+#define MACH_TYPE_TPP302               1298
+#define MACH_TYPE_TPM104               1299
+#define MACH_TYPE_TPM102               1300
+#define MACH_TYPE_TPM109               1301
+#define MACH_TYPE_FBXO1                1302
+#define MACH_TYPE_HXD8                 1303
+#define MACH_TYPE_NEO1973_GTA02        1304
+#define MACH_TYPE_EMTEST               1305
+#define MACH_TYPE_AD6900               1306
+#define MACH_TYPE_EUROPA               1307
+#define MACH_TYPE_METROCONNECT         1308
+#define MACH_TYPE_EZ_S2410             1309
+#define MACH_TYPE_EZ_S2440             1310
+#define MACH_TYPE_EZ_EP9312            1311
+#define MACH_TYPE_EZ_EP9315            1312
+#define MACH_TYPE_EZ_X7                1313
+#define MACH_TYPE_GODOTDB              1314
+#define MACH_TYPE_MISTRAL              1315
+#define MACH_TYPE_MSM                  1316
+#define MACH_TYPE_CT5910               1317
+#define MACH_TYPE_CT5912               1318
+#define MACH_TYPE_HYNET_INE            1319
+#define MACH_TYPE_HYNET_APP            1320
+#define MACH_TYPE_MSM7200              1321
+#define MACH_TYPE_MSM7600              1322
+#define MACH_TYPE_CEB255               1323
+#define MACH_TYPE_CIEL                 1324
+#define MACH_TYPE_SLM5650              1325
+#define MACH_TYPE_AT91SAM9RLEK         1326
+#define MACH_TYPE_COMTECH_ROUTER       1327
+#define MACH_TYPE_SBC2410X             1328
+#define MACH_TYPE_AT4X0BD              1329
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEXUSPCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUSPCI
+# endif
+# define machine_is_nexuspci()	(machine_arch_type == MACH_TYPE_NEXUSPCI)
+#else
+# define machine_is_nexuspci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBOX
+# endif
+# define machine_is_tbox()	(machine_arch_type == MACH_TYPE_TBOX)
+#else
+# define machine_is_tbox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CO285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CO285
+# endif
+# define machine_is_co285()	(machine_arch_type == MACH_TYPE_CO285)
+#else
+# define machine_is_co285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7110
+# endif
+# define machine_is_clps7110()	(machine_arch_type == MACH_TYPE_CLPS7110)
+#else
+# define machine_is_clps7110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCHIMEDES
+# endif
+# define machine_is_archimedes()	(machine_arch_type == MACH_TYPE_ARCHIMEDES)
+#else
+# define machine_is_archimedes()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_A5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A5K
+# endif
+# define machine_is_a5k()	(machine_arch_type == MACH_TYPE_A5K)
+#else
+# define machine_is_a5k()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ETOILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETOILE
+# endif
+# define machine_is_etoile()	(machine_arch_type == MACH_TYPE_ETOILE)
+#else
+# define machine_is_etoile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LACIE_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LACIE_NAS
+# endif
+# define machine_is_lacie_nas()	(machine_arch_type == MACH_TYPE_LACIE_NAS)
+#else
+# define machine_is_lacie_nas()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7500
+# endif
+# define machine_is_clps7500()	(machine_arch_type == MACH_TYPE_CLPS7500)
+#else
+# define machine_is_clps7500()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITSY
+# endif
+# define machine_is_itsy()	(machine_arch_type == MACH_TYPE_ITSY)
+#else
+# define machine_is_itsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP1200
+# endif
+# define machine_is_ixp1200()	(machine_arch_type == MACH_TYPE_IXP1200)
+#else
+# define machine_is_ixp1200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_VICTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTOR
+# endif
+# define machine_is_victor()	(machine_arch_type == MACH_TYPE_VICTOR)
+#else
+# define machine_is_victor()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RANGER
+# endif
+# define machine_is_ranger()	(machine_arch_type == MACH_TYPE_RANGER)
+#else
+# define machine_is_ranger()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FPIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC
+# endif
+# define machine_is_fpic()	(machine_arch_type == MACH_TYPE_FPIC)
+#else
+# define machine_is_fpic()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXTENEX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXTENEX1
+# endif
+# define machine_is_extenex1()	(machine_arch_type == MACH_TYPE_EXTENEX1)
+#else
+# define machine_is_extenex1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHERMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHERMAN
+# endif
+# define machine_is_sherman()	(machine_arch_type == MACH_TYPE_SHERMAN)
+#else
+# define machine_is_sherman()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_SA
+# endif
+# define machine_is_accelent_sa()	(machine_arch_type == MACH_TYPE_ACCELENT_SA)
+#else
+# define machine_is_accelent_sa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_L7200
+# endif
+# define machine_is_accelent_l7200()	(machine_arch_type == MACH_TYPE_ACCELENT_L7200)
+#else
+# define machine_is_accelent_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETPORT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETPORT
+# endif
+# define machine_is_netport()	(machine_arch_type == MACH_TYPE_NETPORT)
+#else
+# define machine_is_netport()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PANGOLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANGOLIN
+# endif
+# define machine_is_pangolin()	(machine_arch_type == MACH_TYPE_PANGOLIN)
+#else
+# define machine_is_pangolin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_YOPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOPY
+# endif
+# define machine_is_yopy()	(machine_arch_type == MACH_TYPE_YOPY)
+#else
+# define machine_is_yopy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COOLIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COOLIDGE
+# endif
+# define machine_is_coolidge()	(machine_arch_type == MACH_TYPE_COOLIDGE)
+#else
+# define machine_is_coolidge()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUW_WEBPANEL
+# endif
+# define machine_is_huw_webpanel()	(machine_arch_type == MACH_TYPE_HUW_WEBPANEL)
+#else
+# define machine_is_huw_webpanel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPOTME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOTME
+# endif
+# define machine_is_spotme()	(machine_arch_type == MACH_TYPE_SPOTME)
+#else
+# define machine_is_spotme()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FREEBIRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBIRD
+# endif
+# define machine_is_freebird()	(machine_arch_type == MACH_TYPE_FREEBIRD)
+#else
+# define machine_is_freebird()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI925
+# endif
+# define machine_is_ti925()	(machine_arch_type == MACH_TYPE_TI925)
+#else
+# define machine_is_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RISCSTATION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCSTATION
+# endif
+# define machine_is_riscstation()	(machine_arch_type == MACH_TYPE_RISCSTATION)
+#else
+# define machine_is_riscstation()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CAVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAVY
+# endif
+# define machine_is_cavy()	(machine_arch_type == MACH_TYPE_CAVY)
+#else
+# define machine_is_cavy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_OMNIMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMNIMETER
+# endif
+# define machine_is_omnimeter()	(machine_arch_type == MACH_TYPE_OMNIMETER)
+#else
+# define machine_is_omnimeter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CITYGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CITYGO
+# endif
+# define machine_is_citygo()	(machine_arch_type == MACH_TYPE_CITYGO)
+#else
+# define machine_is_citygo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SPOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOT
+# endif
+# define machine_is_spot()	(machine_arch_type == MACH_TYPE_SPOT)
+#else
+# define machine_is_spot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBPAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBPAL
+# endif
+# define machine_is_webpal()	(machine_arch_type == MACH_TYPE_WEBPAL)
+#else
+# define machine_is_webpal()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LINPDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINPDA
+# endif
+# define machine_is_linpda()	(machine_arch_type == MACH_TYPE_LINPDA)
+#else
+# define machine_is_linpda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANAKIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANAKIN
+# endif
+# define machine_is_anakin()	(machine_arch_type == MACH_TYPE_ANAKIN)
+#else
+# define machine_is_anakin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MVI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVI
+# endif
+# define machine_is_mvi()	(machine_arch_type == MACH_TYPE_MVI)
+#else
+# define machine_is_mvi()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JUPITER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JUPITER
+# endif
+# define machine_is_jupiter()	(machine_arch_type == MACH_TYPE_JUPITER)
+#else
+# define machine_is_jupiter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PSIONW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSIONW
+# endif
+# define machine_is_psionw()	(machine_arch_type == MACH_TYPE_PSIONW)
+#else
+# define machine_is_psionw()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALN
+# endif
+# define machine_is_aln()	(machine_arch_type == MACH_TYPE_ALN)
+#else
+# define machine_is_aln()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMELOT
+# endif
+# define machine_is_epxa()	(machine_arch_type == MACH_TYPE_CAMELOT)
+#else
+# define machine_is_epxa()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GDS2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GDS2200
+# endif
+# define machine_is_gds2200()	(machine_arch_type == MACH_TYPE_GDS2200)
+#else
+# define machine_is_gds2200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PSION_SERIES7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSION_SERIES7
+# endif
+# define machine_is_netbook()	(machine_arch_type == MACH_TYPE_PSION_SERIES7)
+#else
+# define machine_is_netbook()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XFILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XFILE
+# endif
+# define machine_is_xfile()	(machine_arch_type == MACH_TYPE_XFILE)
+#else
+# define machine_is_xfile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACCELENT_EP9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_EP9312
+# endif
+# define machine_is_accelent_ep9312()	(machine_arch_type == MACH_TYPE_ACCELENT_EP9312)
+#else
+# define machine_is_accelent_ep9312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IC200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IC200
+# endif
+# define machine_is_ic200()	(machine_arch_type == MACH_TYPE_IC200)
+#else
+# define machine_is_ic200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CREDITLART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CREDITLART
+# endif
+# define machine_is_creditlart()	(machine_arch_type == MACH_TYPE_CREDITLART)
+#else
+# define machine_is_creditlart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HTM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTM
+# endif
+# define machine_is_htm()	(machine_arch_type == MACH_TYPE_HTM)
+#else
+# define machine_is_htm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80310
+# endif
+# define machine_is_iq80310()	(machine_arch_type == MACH_TYPE_IQ80310)
+#else
+# define machine_is_iq80310()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FREEBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBOT
+# endif
+# define machine_is_freebot()	(machine_arch_type == MACH_TYPE_FREEBOT)
+#else
+# define machine_is_freebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENTEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTEL
+# endif
+# define machine_is_entel()	(machine_arch_type == MACH_TYPE_ENTEL)
+#else
+# define machine_is_entel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP3510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP3510
+# endif
+# define machine_is_enp3510()	(machine_arch_type == MACH_TYPE_ENP3510)
+#else
+# define machine_is_enp3510()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TRIZEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS
+# endif
+# define machine_is_trizeps()	(machine_arch_type == MACH_TYPE_TRIZEPS)
+#else
+# define machine_is_trizeps()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NESA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NESA
+# endif
+# define machine_is_nesa()	(machine_arch_type == MACH_TYPE_NESA)
+#else
+# define machine_is_nesa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENUS
+# endif
+# define machine_is_venus()	(machine_arch_type == MACH_TYPE_VENUS)
+#else
+# define machine_is_venus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TARDIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TARDIS
+# endif
+# define machine_is_tardis()	(machine_arch_type == MACH_TYPE_TARDIS)
+#else
+# define machine_is_tardis()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERCURY
+# endif
+# define machine_is_mercury()	(machine_arch_type == MACH_TYPE_MERCURY)
+#else
+# define machine_is_mercury()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMPEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPEG
+# endif
+# define machine_is_empeg()	(machine_arch_type == MACH_TYPE_EMPEG)
+#else
+# define machine_is_empeg()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I80200FCC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I80200FCC
+# endif
+# define machine_is_adi_evb()	(machine_arch_type == MACH_TYPE_I80200FCC)
+#else
+# define machine_is_adi_evb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITT_CPB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITT_CPB
+# endif
+# define machine_is_itt_cpb()	(machine_arch_type == MACH_TYPE_ITT_CPB)
+#else
+# define machine_is_itt_cpb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVC
+# endif
+# define machine_is_svc()	(machine_arch_type == MACH_TYPE_SVC)
+#else
+# define machine_is_svc()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA2
+# endif
+# define machine_is_alpha2()	(machine_arch_type == MACH_TYPE_ALPHA2)
+#else
+# define machine_is_alpha2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA1
+# endif
+# define machine_is_alpha1()	(machine_arch_type == MACH_TYPE_ALPHA1)
+#else
+# define machine_is_alpha1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETARM
+# endif
+# define machine_is_netarm()	(machine_arch_type == MACH_TYPE_NETARM)
+#else
+# define machine_is_netarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDA1
+# endif
+# define machine_is_pda1()	(machine_arch_type == MACH_TYPE_PDA1)
+#else
+# define machine_is_pda1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANIKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANIKO
+# endif
+# define machine_is_aniko()	(machine_arch_type == MACH_TYPE_ANIKO)
+#else
+# define machine_is_aniko()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CS89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS89712
+# endif
+# define machine_is_cs89712()	(machine_arch_type == MACH_TYPE_CS89712)
+#else
+# define machine_is_cs89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WEARARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEARARM
+# endif
+# define machine_is_weararm()	(machine_arch_type == MACH_TYPE_WEARARM)
+#else
+# define machine_is_weararm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_POSSIO_PX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX
+# endif
+# define machine_is_possio_px()	(machine_arch_type == MACH_TYPE_POSSIO_PX)
+#else
+# define machine_is_possio_px()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIDEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEARM
+# endif
+# define machine_is_sidearm()	(machine_arch_type == MACH_TYPE_SIDEARM)
+#else
+# define machine_is_sidearm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_STORK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK
+# endif
+# define machine_is_stork()	(machine_arch_type == MACH_TYPE_STORK)
+#else
+# define machine_is_stork()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACE
+# endif
+# define machine_is_ace()	(machine_arch_type == MACH_TYPE_ACE)
+#else
+# define machine_is_ace()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLYARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLYARM
+# endif
+# define machine_is_ballyarm()	(machine_arch_type == MACH_TYPE_BALLYARM)
+#else
+# define machine_is_ballyarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPUTER
+# endif
+# define machine_is_simputer()	(machine_arch_type == MACH_TYPE_SIMPUTER)
+#else
+# define machine_is_simputer()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXTERM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXTERM
+# endif
+# define machine_is_nexterm()	(machine_arch_type == MACH_TYPE_NEXTERM)
+#else
+# define machine_is_nexterm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SA1100_ELF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SA1100_ELF
+# endif
+# define machine_is_sa1100_elf()	(machine_arch_type == MACH_TYPE_SA1100_ELF)
+#else
+# define machine_is_sa1100_elf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATOR
+# endif
+# define machine_is_gator()	(machine_arch_type == MACH_TYPE_GATOR)
+#else
+# define machine_is_gator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GRANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANITE
+# endif
+# define machine_is_granite()	(machine_arch_type == MACH_TYPE_GRANITE)
+#else
+# define machine_is_granite()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PLCE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLCE
+# endif
+# define machine_is_plce()	(machine_arch_type == MACH_TYPE_PLCE)
+#else
+# define machine_is_plce()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEDALB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEDALB
+# endif
+# define machine_is_murphy()	(machine_arch_type == MACH_TYPE_MEDALB)
+#else
+# define machine_is_murphy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAGLE
+# endif
+# define machine_is_eagle()	(machine_arch_type == MACH_TYPE_EAGLE)
+#else
+# define machine_is_eagle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC21
+# endif
+# define machine_is_dsc21()	(machine_arch_type == MACH_TYPE_DSC21)
+#else
+# define machine_is_dsc21()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC24
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC24
+# endif
+# define machine_is_dsc24()	(machine_arch_type == MACH_TYPE_DSC24)
+#else
+# define machine_is_dsc24()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI5472
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI5472
+# endif
+# define machine_is_ti5472()	(machine_arch_type == MACH_TYPE_TI5472)
+#else
+# define machine_is_ti5472()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UENGINE
+# endif
+# define machine_is_uengine()	(machine_arch_type == MACH_TYPE_UENGINE)
+#else
+# define machine_is_uengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUESTEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUESTEM
+# endif
+# define machine_is_bluestem()	(machine_arch_type == MACH_TYPE_BLUESTEM)
+#else
+# define machine_is_bluestem()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_XINGU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XINGU8
+# endif
+# define machine_is_xingu8()	(machine_arch_type == MACH_TYPE_XINGU8)
+#else
+# define machine_is_xingu8()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BUSHSTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUSHSTB
+# endif
+# define machine_is_bushstb()	(machine_arch_type == MACH_TYPE_BUSHSTB)
+#else
+# define machine_is_bushstb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EPSILON1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPSILON1
+# endif
+# define machine_is_epsilon1()	(machine_arch_type == MACH_TYPE_EPSILON1)
+#else
+# define machine_is_epsilon1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON
+# endif
+# define machine_is_balloon()	(machine_arch_type == MACH_TYPE_BALLOON)
+#else
+# define machine_is_balloon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPY
+# endif
+# define machine_is_puppy()	(machine_arch_type == MACH_TYPE_PUPPY)
+#else
+# define machine_is_puppy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ELROY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY
+# endif
+# define machine_is_elroy()	(machine_arch_type == MACH_TYPE_ELROY)
+#else
+# define machine_is_elroy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GMS720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GMS720
+# endif
+# define machine_is_gms720()	(machine_arch_type == MACH_TYPE_GMS720)
+#else
+# define machine_is_gms720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S24X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S24X
+# endif
+# define machine_is_s24x()	(machine_arch_type == MACH_TYPE_S24X)
+#else
+# define machine_is_s24x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JTEL_CLEP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JTEL_CLEP7312
+# endif
+# define machine_is_jtel_clep7312()	(machine_arch_type == MACH_TYPE_JTEL_CLEP7312)
+#else
+# define machine_is_jtel_clep7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX821XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX821XX
+# endif
+# define machine_is_cx821xx()	(machine_arch_type == MACH_TYPE_CX821XX)
+#else
+# define machine_is_cx821xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7312
+# endif
+# define machine_is_edb7312()	(machine_arch_type == MACH_TYPE_EDB7312)
+#else
+# define machine_is_edb7312()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BSA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSA1110
+# endif
+# define machine_is_bsa1110()	(machine_arch_type == MACH_TYPE_BSA1110)
+#else
+# define machine_is_bsa1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POWERPIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POWERPIN
+# endif
+# define machine_is_powerpin()	(machine_arch_type == MACH_TYPE_POWERPIN)
+#else
+# define machine_is_powerpin()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPENARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENARM
+# endif
+# define machine_is_openarm()	(machine_arch_type == MACH_TYPE_OPENARM)
+#else
+# define machine_is_openarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITECHAPEL
+# endif
+# define machine_is_whitechapel()	(machine_arch_type == MACH_TYPE_WHITECHAPEL)
+#else
+# define machine_is_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3800
+# endif
+# define machine_is_h3800()	(machine_arch_type == MACH_TYPE_H3800)
+#else
+# define machine_is_h3800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUE_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_V1
+# endif
+# define machine_is_blue_v1()	(machine_arch_type == MACH_TYPE_BLUE_V1)
+#else
+# define machine_is_blue_v1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_CERF
+# endif
+# define machine_is_pxa_cerf()	(machine_arch_type == MACH_TYPE_PXA_CERF)
+#else
+# define machine_is_pxa_cerf()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARM7TEVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM7TEVB
+# endif
+# define machine_is_arm7tevb()	(machine_arch_type == MACH_TYPE_ARM7TEVB)
+#else
+# define machine_is_arm7tevb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7400
+# endif
+# define machine_is_d7400()	(machine_arch_type == MACH_TYPE_D7400)
+#else
+# define machine_is_d7400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PIRANHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIRANHA
+# endif
+# define machine_is_piranha()	(machine_arch_type == MACH_TYPE_PIRANHA)
+#else
+# define machine_is_piranha()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SBCAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBCAMELOT
+# endif
+# define machine_is_sbcamelot()	(machine_arch_type == MACH_TYPE_SBCAMELOT)
+#else
+# define machine_is_sbcamelot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KINGS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGS
+# endif
+# define machine_is_kings()	(machine_arch_type == MACH_TYPE_KINGS)
+#else
+# define machine_is_kings()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2400
+# endif
+# define machine_is_smdk2400()	(machine_arch_type == MACH_TYPE_SMDK2400)
+#else
+# define machine_is_smdk2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDR
+# endif
+# define machine_is_idr()	(machine_arch_type == MACH_TYPE_IDR)
+#else
+# define machine_is_idr()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBNET
+# endif
+# define machine_is_webnet()	(machine_arch_type == MACH_TYPE_WEBNET)
+#else
+# define machine_is_webnet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7300
+# endif
+# define machine_is_d7300()	(machine_arch_type == MACH_TYPE_D7300)
+#else
+# define machine_is_d7300()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEP
+# endif
+# define machine_is_cep()	(machine_arch_type == MACH_TYPE_CEP)
+#else
+# define machine_is_cep()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VC547X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC547X
+# endif
+# define machine_is_vc547x()	(machine_arch_type == MACH_TYPE_VC547X)
+#else
+# define machine_is_vc547x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FILEWALKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FILEWALKER
+# endif
+# define machine_is_filewalker()	(machine_arch_type == MACH_TYPE_FILEWALKER)
+#else
+# define machine_is_filewalker()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETGATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATEWAY
+# endif
+# define machine_is_netgateway()	(machine_arch_type == MACH_TYPE_NETGATEWAY)
+#else
+# define machine_is_netgateway()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SYMBOL2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYMBOL2800
+# endif
+# define machine_is_symbol2800()	(machine_arch_type == MACH_TYPE_SYMBOL2800)
+#else
+# define machine_is_symbol2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SUNS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNS
+# endif
+# define machine_is_suns()	(machine_arch_type == MACH_TYPE_SUNS)
+#else
+# define machine_is_suns()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRODO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRODO
+# endif
+# define machine_is_frodo()	(machine_arch_type == MACH_TYPE_FRODO)
+#else
+# define machine_is_frodo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MACH_TYTE_MS301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_TYTE_MS301
+# endif
+# define machine_is_ms301()	(machine_arch_type == MACH_TYPE_MACH_TYTE_MS301)
+#else
+# define machine_is_ms301()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AMICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMICO
+# endif
+# define machine_is_amico()	(machine_arch_type == MACH_TYPE_AMICO)
+#else
+# define machine_is_amico()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_IAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM
+# endif
+# define machine_is_iam()	(machine_arch_type == MACH_TYPE_IAM)
+#else
+# define machine_is_iam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TT530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT530
+# endif
+# define machine_is_tt530()	(machine_arch_type == MACH_TYPE_TT530)
+#else
+# define machine_is_tt530()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SAM2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM2400
+# endif
+# define machine_is_sam2400()	(machine_arch_type == MACH_TYPE_SAM2400)
+#else
+# define machine_is_sam2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA56X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA56X
+# endif
+# define machine_is_jornada56x()	(machine_arch_type == MACH_TYPE_JORNADA56X)
+#else
+# define machine_is_jornada56x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACTIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTIVE
+# endif
+# define machine_is_active()	(machine_arch_type == MACH_TYPE_ACTIVE)
+#else
+# define machine_is_active()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WID
+# endif
+# define machine_is_wid()	(machine_arch_type == MACH_TYPE_WID)
+#else
+# define machine_is_wid()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SABINAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SABINAL
+# endif
+# define machine_is_sabinal()	(machine_arch_type == MACH_TYPE_SABINAL)
+#else
+# define machine_is_sabinal()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MATACUMBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MATACUMBE
+# endif
+# define machine_is_ixp425_matacumbe()	(machine_arch_type == MACH_TYPE_IXP425_MATACUMBE)
+#else
+# define machine_is_ixp425_matacumbe()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MINIPRINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIPRINT
+# endif
+# define machine_is_miniprint()	(machine_arch_type == MACH_TYPE_MINIPRINT)
+#else
+# define machine_is_miniprint()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADM510X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADM510X
+# endif
+# define machine_is_adm510x()	(machine_arch_type == MACH_TYPE_ADM510X)
+#else
+# define machine_is_adm510x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVS200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVS200
+# endif
+# define machine_is_svs200()	(machine_arch_type == MACH_TYPE_SVS200)
+#else
+# define machine_is_svs200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATG_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATG_TCU
+# endif
+# define machine_is_atg_tcu()	(machine_arch_type == MACH_TYPE_ATG_TCU)
+#else
+# define machine_is_atg_tcu()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA820
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA820
+# endif
+# define machine_is_jornada820()	(machine_arch_type == MACH_TYPE_JORNADA820)
+#else
+# define machine_is_jornada820()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C44B0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C44B0
+# endif
+# define machine_is_s3c44b0()	(machine_arch_type == MACH_TYPE_S3C44B0)
+#else
+# define machine_is_s3c44b0()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MARGIS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARGIS2
+# endif
+# define machine_is_margis2()	(machine_arch_type == MACH_TYPE_MARGIS2)
+#else
+# define machine_is_margis2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRH
+# endif
+# define machine_is_brh()	(machine_arch_type == MACH_TYPE_BRH)
+#else
+# define machine_is_brh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2410
+# endif
+# define machine_is_s3c2410()	(machine_arch_type == MACH_TYPE_S3C2410)
+#else
+# define machine_is_s3c2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POSSIO_PX30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX30
+# endif
+# define machine_is_possio_px30()	(machine_arch_type == MACH_TYPE_POSSIO_PX30)
+#else
+# define machine_is_possio_px30()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2800
+# endif
+# define machine_is_s3c2800()	(machine_arch_type == MACH_TYPE_S3C2800)
+#else
+# define machine_is_s3c2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEETWOOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEETWOOD
+# endif
+# define machine_is_fleetwood()	(machine_arch_type == MACH_TYPE_FLEETWOOD)
+#else
+# define machine_is_fleetwood()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OMAHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAHA
+# endif
+# define machine_is_omaha()	(machine_arch_type == MACH_TYPE_OMAHA)
+#else
+# define machine_is_omaha()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7
+# endif
+# define machine_is_ta7()	(machine_arch_type == MACH_TYPE_TA7)
+#else
+# define machine_is_ta7()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOVA
+# endif
+# define machine_is_nova()	(machine_arch_type == MACH_TYPE_NOVA)
+#else
+# define machine_is_nova()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HMK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMK
+# endif
+# define machine_is_hmk()	(machine_arch_type == MACH_TYPE_HMK)
+#else
+# define machine_is_hmk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KARO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KARO
+# endif
+# define machine_is_karo()	(machine_arch_type == MACH_TYPE_KARO)
+#else
+# define machine_is_karo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FESTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FESTER
+# endif
+# define machine_is_fester()	(machine_arch_type == MACH_TYPE_FESTER)
+#else
+# define machine_is_fester()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GPI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPI
+# endif
+# define machine_is_gpi()	(machine_arch_type == MACH_TYPE_GPI)
+#else
+# define machine_is_gpi()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I519
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I519
+# endif
+# define machine_is_i519()	(machine_arch_type == MACH_TYPE_I519)
+#else
+# define machine_is_i519()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXIO
+# endif
+# define machine_is_nexio()	(machine_arch_type == MACH_TYPE_NEXIO)
+#else
+# define machine_is_nexio()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BITBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BITBOX
+# endif
+# define machine_is_bitbox()	(machine_arch_type == MACH_TYPE_BITBOX)
+#else
+# define machine_is_bitbox()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_G200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G200
+# endif
+# define machine_is_g200()	(machine_arch_type == MACH_TYPE_G200)
+#else
+# define machine_is_g200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GILL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GILL
+# endif
+# define machine_is_gill()	(machine_arch_type == MACH_TYPE_GILL)
+#else
+# define machine_is_gill()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MERCURY
+# endif
+# define machine_is_pxa_mercury()	(machine_arch_type == MACH_TYPE_PXA_MERCURY)
+#else
+# define machine_is_pxa_mercury()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRET
+# endif
+# define machine_is_fret()	(machine_arch_type == MACH_TYPE_FRET)
+#else
+# define machine_is_fret()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMAILPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMAILPHONE
+# endif
+# define machine_is_emailphone()	(machine_arch_type == MACH_TYPE_EMAILPHONE)
+#else
+# define machine_is_emailphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H3900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3900
+# endif
+# define machine_is_h3900()	(machine_arch_type == MACH_TYPE_H3900)
+#else
+# define machine_is_h3900()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA1
+# endif
+# define machine_is_pxa1()	(machine_arch_type == MACH_TYPE_PXA1)
+#else
+# define machine_is_pxa1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN369
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN369
+# endif
+# define machine_is_koan369()	(machine_arch_type == MACH_TYPE_KOAN369)
+#else
+# define machine_is_koan369()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_COGENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COGENT
+# endif
+# define machine_is_cogent()	(machine_arch_type == MACH_TYPE_COGENT)
+#else
+# define machine_is_cogent()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER
+# endif
+# define machine_is_esl_simputer()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER)
+#else
+# define machine_is_esl_simputer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_CLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_CLR
+# endif
+# define machine_is_esl_simputer_clr()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_CLR)
+#else
+# define machine_is_esl_simputer_clr()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_BW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_BW
+# endif
+# define machine_is_esl_simputer_bw()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_BW)
+#else
+# define machine_is_esl_simputer_bw()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_CRADLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_CRADLE
+# endif
+# define machine_is_hhp_cradle()	(machine_arch_type == MACH_TYPE_HHP_CRADLE)
+#else
+# define machine_is_hhp_cradle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HE500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HE500
+# endif
+# define machine_is_he500()	(machine_arch_type == MACH_TYPE_HE500)
+#else
+# define machine_is_he500()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDELF2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF2
+# endif
+# define machine_is_inhandelf2()	(machine_arch_type == MACH_TYPE_INHANDELF2)
+#else
+# define machine_is_inhandelf2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDFTIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP
+# endif
+# define machine_is_inhandftip()	(machine_arch_type == MACH_TYPE_INHANDFTIP)
+#else
+# define machine_is_inhandftip()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_DNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNP1110
+# endif
+# define machine_is_dnp1110()	(machine_arch_type == MACH_TYPE_DNP1110)
+#else
+# define machine_is_dnp1110()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP1110
+# endif
+# define machine_is_pnp1110()	(machine_arch_type == MACH_TYPE_PNP1110)
+#else
+# define machine_is_pnp1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB226
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB226
+# endif
+# define machine_is_csb226()	(machine_arch_type == MACH_TYPE_CSB226)
+#else
+# define machine_is_csb226()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ARNOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARNOLD
+# endif
+# define machine_is_arnold()	(machine_arch_type == MACH_TYPE_ARNOLD)
+#else
+# define machine_is_arnold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JZ8028
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JZ8028
+# endif
+# define machine_is_jz8028()	(machine_arch_type == MACH_TYPE_JZ8028)
+#else
+# define machine_is_jz8028()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FORTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTE
+# endif
+# define machine_is_forte()	(machine_arch_type == MACH_TYPE_FORTE)
+#else
+# define machine_is_forte()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACAM
+# endif
+# define machine_is_acam()	(machine_arch_type == MACH_TYPE_ACAM)
+#else
+# define machine_is_acam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ABOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABOX
+# endif
+# define machine_is_abox()	(machine_arch_type == MACH_TYPE_ABOX)
+#else
+# define machine_is_abox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATMEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATMEL
+# endif
+# define machine_is_atmel()	(machine_arch_type == MACH_TYPE_ATMEL)
+#else
+# define machine_is_atmel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SITSANG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SITSANG
+# endif
+# define machine_is_sitsang()	(machine_arch_type == MACH_TYPE_SITSANG)
+#else
+# define machine_is_sitsang()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CPU1110LCDNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU1110LCDNET
+# endif
+# define machine_is_cpu1110lcdnet()	(machine_arch_type == MACH_TYPE_CPU1110LCDNET)
+#else
+# define machine_is_cpu1110lcdnet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPL_VCMA9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPL_VCMA9
+# endif
+# define machine_is_mpl_vcma9()	(machine_arch_type == MACH_TYPE_MPL_VCMA9)
+#else
+# define machine_is_mpl_vcma9()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPUS_A1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPUS_A1
+# endif
+# define machine_is_opus_a1()	(machine_arch_type == MACH_TYPE_OPUS_A1)
+#else
+# define machine_is_opus_a1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAYTONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAYTONA
+# endif
+# define machine_is_daytona()	(machine_arch_type == MACH_TYPE_DAYTONA)
+#else
+# define machine_is_daytona()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KILLBEAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KILLBEAR
+# endif
+# define machine_is_killbear()	(machine_arch_type == MACH_TYPE_KILLBEAR)
+#else
+# define machine_is_killbear()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_YOHO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOHO
+# endif
+# define machine_is_yoho()	(machine_arch_type == MACH_TYPE_YOHO)
+#else
+# define machine_is_yoho()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASPER
+# endif
+# define machine_is_jasper()	(machine_arch_type == MACH_TYPE_JASPER)
+#else
+# define machine_is_jasper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC25
+# endif
+# define machine_is_dsc25()	(machine_arch_type == MACH_TYPE_DSC25)
+#else
+# define machine_is_dsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RAMSES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAMSES
+# endif
+# define machine_is_mnci()	(machine_arch_type == MACH_TYPE_RAMSES)
+#else
+# define machine_is_mnci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S28X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S28X
+# endif
+# define machine_is_s28x()	(machine_arch_type == MACH_TYPE_S28X)
+#else
+# define machine_is_s28x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3
+# endif
+# define machine_is_mport3()	(machine_arch_type == MACH_TYPE_MPORT3)
+#else
+# define machine_is_mport3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_EAGLE250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_EAGLE250
+# endif
+# define machine_is_pxa_eagle250()	(machine_arch_type == MACH_TYPE_PXA_EAGLE250)
+#else
+# define machine_is_pxa_eagle250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDB
+# endif
+# define machine_is_pdb()	(machine_arch_type == MACH_TYPE_PDB)
+#else
+# define machine_is_pdb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUE_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_2G
+# endif
+# define machine_is_blue_2g()	(machine_arch_type == MACH_TYPE_BLUE_2G)
+#else
+# define machine_is_blue_2g()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUEARCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEARCH
+# endif
+# define machine_is_bluearch()	(machine_arch_type == MACH_TYPE_BLUEARCH)
+#else
+# define machine_is_bluearch()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXPLORER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPLORER
+# endif
+# define machine_is_explorer()	(machine_arch_type == MACH_TYPE_EXPLORER)
+#else
+# define machine_is_explorer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CHIMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHIMP
+# endif
+# define machine_is_chimp()	(machine_arch_type == MACH_TYPE_CHIMP)
+#else
+# define machine_is_chimp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_NEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_NEST
+# endif
+# define machine_is_stork_nest()	(machine_arch_type == MACH_TYPE_STORK_NEST)
+#else
+# define machine_is_stork_nest()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_EGG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_EGG
+# endif
+# define machine_is_stork_egg()	(machine_arch_type == MACH_TYPE_STORK_EGG)
+#else
+# define machine_is_stork_egg()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WISMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WISMO
+# endif
+# define machine_is_wismo()	(machine_arch_type == MACH_TYPE_WISMO)
+#else
+# define machine_is_wismo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EZLINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZLINX
+# endif
+# define machine_is_ezlinx()	(machine_arch_type == MACH_TYPE_EZLINX)
+#else
+# define machine_is_ezlinx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200
+# endif
+# define machine_is_at91rm9200()	(machine_arch_type == MACH_TYPE_AT91RM9200)
+#else
+# define machine_is_at91rm9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ORION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORION
+# endif
+# define machine_is_orion()	(machine_arch_type == MACH_TYPE_ORION)
+#else
+# define machine_is_orion()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEPTUNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEPTUNE
+# endif
+# define machine_is_neptune()	(machine_arch_type == MACH_TYPE_NEPTUNE)
+#else
+# define machine_is_neptune()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WINS30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WINS30
+# endif
+# define machine_is_pxa_wins30()	(machine_arch_type == MACH_TYPE_PXA_WINS30)
+#else
+# define machine_is_pxa_wins30()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LAVINNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAVINNA
+# endif
+# define machine_is_lavinna()	(machine_arch_type == MACH_TYPE_LAVINNA)
+#else
+# define machine_is_lavinna()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_UENGINE
+# endif
+# define machine_is_pxa_uengine()	(machine_arch_type == MACH_TYPE_PXA_UENGINE)
+#else
+# define machine_is_pxa_uengine()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INNOKOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INNOKOM
+# endif
+# define machine_is_innokom()	(machine_arch_type == MACH_TYPE_INNOKOM)
+#else
+# define machine_is_innokom()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BMS
+# endif
+# define machine_is_bms()	(machine_arch_type == MACH_TYPE_BMS)
+#else
+# define machine_is_bms()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRPMC1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRPMC1100
+# endif
+# define machine_is_prpmc1100()	(machine_arch_type == MACH_TYPE_PRPMC1100)
+#else
+# define machine_is_prpmc1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMSTICK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSTICK
+# endif
+# define machine_is_armstick()	(machine_arch_type == MACH_TYPE_ARMSTICK)
+#else
+# define machine_is_armstick()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMONIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMONIE
+# endif
+# define machine_is_armonie()	(machine_arch_type == MACH_TYPE_ARMONIE)
+#else
+# define machine_is_armonie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT1
+# endif
+# define machine_is_mport1()	(machine_arch_type == MACH_TYPE_MPORT1)
+#else
+# define machine_is_mport1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C5410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5410
+# endif
+# define machine_is_s3c5410()	(machine_arch_type == MACH_TYPE_S3C5410)
+#else
+# define machine_is_s3c5410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZCP320A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZCP320A
+# endif
+# define machine_is_zcp320a()	(machine_arch_type == MACH_TYPE_ZCP320A)
+#else
+# define machine_is_zcp320a()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I_BOX
+# endif
+# define machine_is_i_box()	(machine_arch_type == MACH_TYPE_I_BOX)
+#else
+# define machine_is_i_box()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STLC1502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STLC1502
+# endif
+# define machine_is_stlc1502()	(machine_arch_type == MACH_TYPE_STLC1502)
+#else
+# define machine_is_stlc1502()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SIREN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIREN
+# endif
+# define machine_is_siren()	(machine_arch_type == MACH_TYPE_SIREN)
+#else
+# define machine_is_siren()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GREENLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREENLAKE
+# endif
+# define machine_is_greenlake()	(machine_arch_type == MACH_TYPE_GREENLAKE)
+#else
+# define machine_is_greenlake()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARGUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARGUS
+# endif
+# define machine_is_argus()	(machine_arch_type == MACH_TYPE_ARGUS)
+#else
+# define machine_is_argus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COMBADGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMBADGE
+# endif
+# define machine_is_combadge()	(machine_arch_type == MACH_TYPE_COMBADGE)
+#else
+# define machine_is_combadge()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ROKEPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROKEPXA
+# endif
+# define machine_is_rokepxa()	(machine_arch_type == MACH_TYPE_ROKEPXA)
+#else
+# define machine_is_rokepxa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUIDEA07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUIDEA07
+# endif
+# define machine_is_guidea07()	(machine_arch_type == MACH_TYPE_GUIDEA07)
+#else
+# define machine_is_guidea07()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TAT257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAT257
+# endif
+# define machine_is_tat257()	(machine_arch_type == MACH_TYPE_TAT257)
+#else
+# define machine_is_tat257()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IGP2425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGP2425
+# endif
+# define machine_is_igp2425()	(machine_arch_type == MACH_TYPE_IGP2425)
+#else
+# define machine_is_igp2425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUEGRAMMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEGRAMMA
+# endif
+# define machine_is_bluegrama()	(machine_arch_type == MACH_TYPE_BLUEGRAMMA)
+#else
+# define machine_is_bluegrama()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD
+# endif
+# define machine_is_ipod()	(machine_arch_type == MACH_TYPE_IPOD)
+#else
+# define machine_is_ipod()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSBITSYX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYX
+# endif
+# define machine_is_adsbitsyx()	(machine_arch_type == MACH_TYPE_ADSBITSYX)
+#else
+# define machine_is_adsbitsyx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TRIZEPS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS2
+# endif
+# define machine_is_trizeps2()	(machine_arch_type == MACH_TYPE_TRIZEPS2)
+#else
+# define machine_is_trizeps2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSYPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYPLUS
+# endif
+# define machine_is_adsbitsyplus()	(machine_arch_type == MACH_TYPE_ADSBITSYPLUS)
+#else
+# define machine_is_adsbitsyplus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSAGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGC
+# endif
+# define machine_is_adsagc()	(machine_arch_type == MACH_TYPE_ADSAGC)
+#else
+# define machine_is_adsagc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STP7312
+# endif
+# define machine_is_stp7312()	(machine_arch_type == MACH_TYPE_STP7312)
+#else
+# define machine_is_stp7312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PHNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PHNX
+# endif
+# define machine_is_nx_phnx()	(machine_arch_type == MACH_TYPE_NX_PHNX)
+#else
+# define machine_is_nx_phnx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEP_EP250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEP_EP250
+# endif
+# define machine_is_wep_ep250()	(machine_arch_type == MACH_TYPE_WEP_EP250)
+#else
+# define machine_is_wep_ep250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDELF3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF3
+# endif
+# define machine_is_inhandelf3()	(machine_arch_type == MACH_TYPE_INHANDELF3)
+#else
+# define machine_is_inhandelf3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IYONIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IYONIX
+# endif
+# define machine_is_iyonix()	(machine_arch_type == MACH_TYPE_IYONIX)
+#else
+# define machine_is_iyonix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAMICAM_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAMICAM_SA1110
+# endif
+# define machine_is_damicam1()	(machine_arch_type == MACH_TYPE_DAMICAM_SA1110)
+#else
+# define machine_is_damicam1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEG03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEG03
+# endif
+# define machine_is_meg03()	(machine_arch_type == MACH_TYPE_MEG03)
+#else
+# define machine_is_meg03()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WHITECHAPEL
+# endif
+# define machine_is_pxa_whitechapel()	(machine_arch_type == MACH_TYPE_PXA_WHITECHAPEL)
+#else
+# define machine_is_pxa_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWSC
+# endif
+# define machine_is_nwsc()	(machine_arch_type == MACH_TYPE_NWSC)
+#else
+# define machine_is_nwsc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWLARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWLARM
+# endif
+# define machine_is_nwlarm()	(machine_arch_type == MACH_TYPE_NWLARM)
+#else
+# define machine_is_nwlarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MGUARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MGUARD
+# endif
+# define machine_is_ixp425_mguard()	(machine_arch_type == MACH_TYPE_IXP425_MGUARD)
+#else
+# define machine_is_ixp425_mguard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_NETDCU4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU4
+# endif
+# define machine_is_pxa_netdcu4()	(machine_arch_type == MACH_TYPE_PXA_NETDCU4)
+#else
+# define machine_is_pxa_netdcu4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZODIAC
+# endif
+# define machine_is_zodiac()	(machine_arch_type == MACH_TYPE_ZODIAC)
+#else
+# define machine_is_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMMODUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMMODUL
+# endif
+# define machine_is_armmodul()	(machine_arch_type == MACH_TYPE_ARMMODUL)
+#else
+# define machine_is_armmodul()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KETOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KETOP
+# endif
+# define machine_is_ketop()	(machine_arch_type == MACH_TYPE_KETOP)
+#else
+# define machine_is_ketop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AV7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV7200
+# endif
+# define machine_is_av7200()	(machine_arch_type == MACH_TYPE_AV7200)
+#else
+# define machine_is_av7200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCH_TI925
+# endif
+# define machine_is_arch_ti925()	(machine_arch_type == MACH_TYPE_ARCH_TI925)
+#else
+# define machine_is_arch_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACQ200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ200
+# endif
+# define machine_is_acq200()	(machine_arch_type == MACH_TYPE_ACQ200)
+#else
+# define machine_is_acq200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_DAFIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_DAFIT
+# endif
+# define machine_is_pt_dafit()	(machine_arch_type == MACH_TYPE_PT_DAFIT)
+#else
+# define machine_is_pt_dafit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IHBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IHBA
+# endif
+# define machine_is_ihba()	(machine_arch_type == MACH_TYPE_IHBA)
+#else
+# define machine_is_ihba()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUINQUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUINQUE
+# endif
+# define machine_is_quinque()	(machine_arch_type == MACH_TYPE_QUINQUE)
+#else
+# define machine_is_quinque()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRAONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRAONE
+# endif
+# define machine_is_nimbraone()	(machine_arch_type == MACH_TYPE_NIMBRAONE)
+#else
+# define machine_is_nimbraone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA29X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA29X
+# endif
+# define machine_is_nimbra29x()	(machine_arch_type == MACH_TYPE_NIMBRA29X)
+#else
+# define machine_is_nimbra29x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA210
+# endif
+# define machine_is_nimbra210()	(machine_arch_type == MACH_TYPE_NIMBRA210)
+#else
+# define machine_is_nimbra210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_D95XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_D95XX
+# endif
+# define machine_is_hhp_d95xx()	(machine_arch_type == MACH_TYPE_HHP_D95XX)
+#else
+# define machine_is_hhp_d95xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LABARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LABARM
+# endif
+# define machine_is_labarm()	(machine_arch_type == MACH_TYPE_LABARM)
+#else
+# define machine_is_labarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_M825XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M825XX
+# endif
+# define machine_is_m825xx()	(machine_arch_type == MACH_TYPE_M825XX)
+#else
+# define machine_is_m825xx()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7100
+# endif
+# define machine_is_m7100()	(machine_arch_type == MACH_TYPE_M7100)
+#else
+# define machine_is_m7100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIPC2
+# endif
+# define machine_is_nipc2()	(machine_arch_type == MACH_TYPE_NIPC2)
+#else
+# define machine_is_nipc2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FU7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FU7202
+# endif
+# define machine_is_fu7202()	(machine_arch_type == MACH_TYPE_FU7202)
+#else
+# define machine_is_fu7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSAGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGX
+# endif
+# define machine_is_adsagx()	(machine_arch_type == MACH_TYPE_ADSAGX)
+#else
+# define machine_is_adsagx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_POOH
+# endif
+# define machine_is_pxa_pooh()	(machine_arch_type == MACH_TYPE_PXA_POOH)
+#else
+# define machine_is_pxa_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BANDON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANDON
+# endif
+# define machine_is_bandon()	(machine_arch_type == MACH_TYPE_BANDON)
+#else
+# define machine_is_bandon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PCM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7210
+# endif
+# define machine_is_pcm7210()	(machine_arch_type == MACH_TYPE_PCM7210)
+#else
+# define machine_is_pcm7210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMS9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMS9200
+# endif
+# define machine_is_nms9200()	(machine_arch_type == MACH_TYPE_NMS9200)
+#else
+# define machine_is_nms9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOGODL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGODL
+# endif
+# define machine_is_logodl()	(machine_arch_type == MACH_TYPE_LOGODL)
+#else
+# define machine_is_logodl()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7140
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7140
+# endif
+# define machine_is_m7140()	(machine_arch_type == MACH_TYPE_M7140)
+#else
+# define machine_is_m7140()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KOREBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOREBOT
+# endif
+# define machine_is_korebot()	(machine_arch_type == MACH_TYPE_KOREBOT)
+#else
+# define machine_is_korebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN393
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN393
+# endif
+# define machine_is_koan393()	(machine_arch_type == MACH_TYPE_KOAN393)
+#else
+# define machine_is_koan393()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDFTIP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP3
+# endif
+# define machine_is_inhandftip3()	(machine_arch_type == MACH_TYPE_INHANDFTIP3)
+#else
+# define machine_is_inhandftip3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GONZO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONZO
+# endif
+# define machine_is_gonzo()	(machine_arch_type == MACH_TYPE_GONZO)
+#else
+# define machine_is_gonzo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCANPASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCANPASS
+# endif
+# define machine_is_scanpass()	(machine_arch_type == MACH_TYPE_SCANPASS)
+#else
+# define machine_is_scanpass()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EP7312_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP7312_POOH
+# endif
+# define machine_is_ep7312_pooh()	(machine_arch_type == MACH_TYPE_EP7312_POOH)
+#else
+# define machine_is_ep7312_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7S
+# endif
+# define machine_is_ta7s()	(machine_arch_type == MACH_TYPE_TA7S)
+#else
+# define machine_is_ta7s()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7V
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7V
+# endif
+# define machine_is_ta7v()	(machine_arch_type == MACH_TYPE_TA7V)
+#else
+# define machine_is_ta7v()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ICARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICARUS
+# endif
+# define machine_is_icarus()	(machine_arch_type == MACH_TYPE_ICARUS)
+#else
+# define machine_is_icarus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1900
+# endif
+# define machine_is_h1900()	(machine_arch_type == MACH_TYPE_H1900)
+#else
+# define machine_is_h1900()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GEMINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMINI
+# endif
+# define machine_is_gemini()	(machine_arch_type == MACH_TYPE_GEMINI)
+#else
+# define machine_is_gemini()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AXIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIM
+# endif
+# define machine_is_axim()	(machine_arch_type == MACH_TYPE_AXIM)
+#else
+# define machine_is_axim()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUDIOTRON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUDIOTRON
+# endif
+# define machine_is_audiotron()	(machine_arch_type == MACH_TYPE_AUDIOTRON)
+#else
+# define machine_is_audiotron()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H2200
+# endif
+# define machine_is_h2200()	(machine_arch_type == MACH_TYPE_H2200)
+#else
+# define machine_is_h2200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOOX600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX600
+# endif
+# define machine_is_loox600()	(machine_arch_type == MACH_TYPE_LOOX600)
+#else
+# define machine_is_loox600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIOP
+# endif
+# define machine_is_niop()	(machine_arch_type == MACH_TYPE_NIOP)
+#else
+# define machine_is_niop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DM310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM310
+# endif
+# define machine_is_dm310()	(machine_arch_type == MACH_TYPE_DM310)
+#else
+# define machine_is_dm310()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SEEDPXA_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEEDPXA_C2
+# endif
+# define machine_is_seedpxa_c2()	(machine_arch_type == MACH_TYPE_SEEDPXA_C2)
+#else
+# define machine_is_seedpxa_c2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP4XX_MGUARD_PCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_MGUARD_PCI
+# endif
+# define machine_is_ixp4xx_mguardpci()	(machine_arch_type == MACH_TYPE_IXP4XX_MGUARD_PCI)
+#else
+# define machine_is_ixp4xx_mguardpci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCORPIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCORPIO
+# endif
+# define machine_is_scorpio()	(machine_arch_type == MACH_TYPE_SCORPIO)
+#else
+# define machine_is_scorpio()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVA
+# endif
+# define machine_is_viva()	(machine_arch_type == MACH_TYPE_VIVA)
+#else
+# define machine_is_viva()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_XCARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_XCARD
+# endif
+# define machine_is_pxa_xcard()	(machine_arch_type == MACH_TYPE_PXA_XCARD)
+#else
+# define machine_is_pxa_xcard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB335
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB335
+# endif
+# define machine_is_csb335()	(machine_arch_type == MACH_TYPE_CSB335)
+#else
+# define machine_is_csb335()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXRD425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXRD425
+# endif
+# define machine_is_ixrd425()	(machine_arch_type == MACH_TYPE_IXRD425)
+#else
+# define machine_is_ixrd425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80315
+# endif
+# define machine_is_iq80315()	(machine_arch_type == MACH_TYPE_IQ80315)
+#else
+# define machine_is_iq80315()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMP7312
+# endif
+# define machine_is_nmp7312()	(machine_arch_type == MACH_TYPE_NMP7312)
+#else
+# define machine_is_nmp7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX861XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX861XX
+# endif
+# define machine_is_cx861xx()	(machine_arch_type == MACH_TYPE_CX861XX)
+#else
+# define machine_is_cx861xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDA
+# endif
+# define machine_is_xda()	(machine_arch_type == MACH_TYPE_XDA)
+#else
+# define machine_is_xda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSIR_IMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSIR_IMS
+# endif
+# define machine_is_csir_ims()	(machine_arch_type == MACH_TYPE_CSIR_IMS)
+#else
+# define machine_is_csir_ims()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP421_DNAEETH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP421_DNAEETH
+# endif
+# define machine_is_ixp421_dnaeeth()	(machine_arch_type == MACH_TYPE_IXP421_DNAEETH)
+#else
+# define machine_is_ixp421_dnaeeth()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POCKETSERV9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POCKETSERV9200
+# endif
+# define machine_is_pocketserv9200()	(machine_arch_type == MACH_TYPE_POCKETSERV9200)
+#else
+# define machine_is_pocketserv9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TOTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOTO
+# endif
+# define machine_is_toto()	(machine_arch_type == MACH_TYPE_TOTO)
+#else
+# define machine_is_toto()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695P
+# endif
+# define machine_is_ks8695p()	(machine_arch_type == MACH_TYPE_KS8695P)
+#else
+# define machine_is_ks8695p()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SE4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4000
+# endif
+# define machine_is_se4000()	(machine_arch_type == MACH_TYPE_SE4000)
+#else
+# define machine_is_se4000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUADRICEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUADRICEPS
+# endif
+# define machine_is_quadriceps()	(machine_arch_type == MACH_TYPE_QUADRICEPS)
+#else
+# define machine_is_quadriceps()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRONCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRONCO
+# endif
+# define machine_is_bronco()	(machine_arch_type == MACH_TYPE_BRONCO)
+#else
+# define machine_is_bronco()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SOFCOMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SOFCOMP
+# endif
+# define machine_is_esl_sofcomp()	(machine_arch_type == MACH_TYPE_ESL_SOFCOMP)
+#else
+# define machine_is_esl_sofcomp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S5C7375
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7375
+# endif
+# define machine_is_s5c7375()	(machine_arch_type == MACH_TYPE_S5C7375)
+#else
+# define machine_is_s5c7375()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPEARHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEARHEAD
+# endif
+# define machine_is_spearhead()	(machine_arch_type == MACH_TYPE_SPEARHEAD)
+#else
+# define machine_is_spearhead()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PANTERA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANTERA
+# endif
+# define machine_is_pantera()	(machine_arch_type == MACH_TYPE_PANTERA)
+#else
+# define machine_is_pantera()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRAYOGLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAYOGLITE
+# endif
+# define machine_is_prayoglite()	(machine_arch_type == MACH_TYPE_PRAYOGLITE)
+#else
+# define machine_is_prayoglite()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIK
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIK)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RCUBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RCUBE
+# endif
+# define machine_is_rcube()	(machine_arch_type == MACH_TYPE_RCUBE)
+#else
+# define machine_is_rcube()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_REA_OLV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_OLV
+# endif
+# define machine_is_rea_olv()	(machine_arch_type == MACH_TYPE_REA_OLV)
+#else
+# define machine_is_rea_olv()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IPHONE
+# endif
+# define machine_is_pxa_iphone()	(machine_arch_type == MACH_TYPE_PXA_IPHONE)
+#else
+# define machine_is_pxa_iphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C3410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C3410
+# endif
+# define machine_is_s3c3410()	(machine_arch_type == MACH_TYPE_S3C3410)
+#else
+# define machine_is_s3c3410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESPD_4510B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPD_4510B
+# endif
+# define machine_is_espd_4510b()	(machine_arch_type == MACH_TYPE_ESPD_4510B)
+#else
+# define machine_is_espd_4510b()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MP1X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1X
+# endif
+# define machine_is_mp1x()	(machine_arch_type == MACH_TYPE_MP1X)
+#else
+# define machine_is_mp1x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200TB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200TB
+# endif
+# define machine_is_at91rm9200tb()	(machine_arch_type == MACH_TYPE_AT91RM9200TB)
+#else
+# define machine_is_at91rm9200tb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSVGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVGX
+# endif
+# define machine_is_adsvgx()	(machine_arch_type == MACH_TYPE_ADSVGX)
+#else
+# define machine_is_adsvgx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PELEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELEE
+# endif
+# define machine_is_pelee()	(machine_arch_type == MACH_TYPE_PELEE)
+#else
+# define machine_is_pelee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FUJITSU_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_CAMELOT
+# endif
+# define machine_is_fujitsu_camelot()	(machine_arch_type == MACH_TYPE_FUJITSU_CAMELOT)
+#else
+# define machine_is_fujitsu_camelot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JANUS2M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS2M
+# endif
+# define machine_is_janus2m()	(machine_arch_type == MACH_TYPE_JANUS2M)
+#else
+# define machine_is_janus2m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMBTF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMBTF
+# endif
+# define machine_is_embtf()	(machine_arch_type == MACH_TYPE_EMBTF)
+#else
+# define machine_is_embtf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPM
+# endif
+# define machine_is_hpm()	(machine_arch_type == MACH_TYPE_HPM)
+#else
+# define machine_is_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410TK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410TK
+# endif
+# define machine_is_smdk2410tk()	(machine_arch_type == MACH_TYPE_SMDK2410TK)
+#else
+# define machine_is_smdk2410tk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410AJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410AJ
+# endif
+# define machine_is_smdk2410aj()	(machine_arch_type == MACH_TYPE_SMDK2410AJ)
+#else
+# define machine_is_smdk2410aj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STREETRACER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STREETRACER
+# endif
+# define machine_is_streetracer()	(machine_arch_type == MACH_TYPE_STREETRACER)
+#else
+# define machine_is_streetracer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EFRAME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EFRAME
+# endif
+# define machine_is_eframe()	(machine_arch_type == MACH_TYPE_EFRAME)
+#else
+# define machine_is_eframe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_LARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_LARK
+# endif
+# define machine_is_pxa_lark()	(machine_arch_type == MACH_TYPE_PXA_LARK)
+#else
+# define machine_is_pxa_lark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP2110
+# endif
+# define machine_is_pxa_pnp2110()	(machine_arch_type == MACH_TYPE_PNP2110)
+#else
+# define machine_is_pxa_pnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC72X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC72X
+# endif
+# define machine_is_tcc72x()	(machine_arch_type == MACH_TYPE_TCC72X)
+#else
+# define machine_is_tcc72x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALTAIR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALTAIR
+# endif
+# define machine_is_altair()	(machine_arch_type == MACH_TYPE_ALTAIR)
+#else
+# define machine_is_altair()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KC3
+# endif
+# define machine_is_kc3()	(machine_arch_type == MACH_TYPE_KC3)
+#else
+# define machine_is_kc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SINTEFTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SINTEFTD
+# endif
+# define machine_is_sinteftd()	(machine_arch_type == MACH_TYPE_SINTEFTD)
+#else
+# define machine_is_sinteftd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADAY4X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADAY4X
+# endif
+# define machine_is_aday4x()	(machine_arch_type == MACH_TYPE_ADAY4X)
+#else
+# define machine_is_aday4x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITE300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITE300
+# endif
+# define machine_is_lite300()	(machine_arch_type == MACH_TYPE_LITE300)
+#else
+# define machine_is_lite300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5C7376
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7376
+# endif
+# define machine_is_s5c7376()	(machine_arch_type == MACH_TYPE_S5C7376)
+#else
+# define machine_is_s5c7376()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT02
+# endif
+# define machine_is_mt02()	(machine_arch_type == MACH_TYPE_MT02)
+#else
+# define machine_is_mt02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPORT3S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3S
+# endif
+# define machine_is_mport3s()	(machine_arch_type == MACH_TYPE_MPORT3S)
+#else
+# define machine_is_mport3s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RA_ALPHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RA_ALPHA
+# endif
+# define machine_is_ra_alpha()	(machine_arch_type == MACH_TYPE_RA_ALPHA)
+#else
+# define machine_is_ra_alpha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_VULCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
+# endif
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
+#else
+# define machine_is_arcom_vulcan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE
+# endif
+# define machine_is_stargate()	(machine_arch_type == MACH_TYPE_STARGATE)
+#else
+# define machine_is_stargate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLOJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLOJ
+# endif
+# define machine_is_armadilloj()	(machine_arch_type == MACH_TYPE_ARMADILLOJ)
+#else
+# define machine_is_armadilloj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELROY_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY_JACK
+# endif
+# define machine_is_elroy_jack()	(machine_arch_type == MACH_TYPE_ELROY_JACK)
+#else
+# define machine_is_elroy_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BACKEND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BACKEND
+# endif
+# define machine_is_backend()	(machine_arch_type == MACH_TYPE_BACKEND)
+#else
+# define machine_is_backend()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5LINBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5LINBOX
+# endif
+# define machine_is_s5linbox()	(machine_arch_type == MACH_TYPE_S5LINBOX)
+#else
+# define machine_is_s5linbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_CPU_9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_CPU_9200
+# endif
+# define machine_is_ia_cpu_9200()	(machine_arch_type == MACH_TYPE_IA_CPU_9200)
+#else
+# define machine_is_ia_cpu_9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91_BJA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91_BJA1
+# endif
+# define machine_is_at91_bja1()	(machine_arch_type == MACH_TYPE_AT91_BJA1)
+#else
+# define machine_is_at91_bja1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEN
+# endif
+# define machine_is_ten()	(machine_arch_type == MACH_TYPE_TEN)
+#else
+# define machine_is_ten()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP5P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP5P
+# endif
+# define machine_is_roverp5p()	(machine_arch_type == MACH_TYPE_ROVERP5P)
+#else
+# define machine_is_roverp5p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC2700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC2700
+# endif
+# define machine_is_sc2700()	(machine_arch_type == MACH_TYPE_SC2700)
+#else
+# define machine_is_sc2700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EX_EAGLE
+# endif
+# define machine_is_ex_eagle()	(machine_arch_type == MACH_TYPE_EX_EAGLE)
+#else
+# define machine_is_ex_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA12
+# endif
+# define machine_is_nx_pxa12()	(machine_arch_type == MACH_TYPE_NX_PXA12)
+#else
+# define machine_is_nx_pxa12()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA5
+# endif
+# define machine_is_nx_pxa5()	(machine_arch_type == MACH_TYPE_NX_PXA5)
+#else
+# define machine_is_nx_pxa5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKBOARD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKBOARD2
+# endif
+# define machine_is_blackboard2()	(machine_arch_type == MACH_TYPE_BLACKBOARD2)
+#else
+# define machine_is_blackboard2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I819
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I819
+# endif
+# define machine_is_i819()	(machine_arch_type == MACH_TYPE_I819)
+#else
+# define machine_is_i819()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXMB995E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXMB995E
+# endif
+# define machine_is_ixmb995e()	(machine_arch_type == MACH_TYPE_IXMB995E)
+#else
+# define machine_is_ixmb995e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYRIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYRIDER
+# endif
+# define machine_is_skyrider()	(machine_arch_type == MACH_TYPE_SKYRIDER)
+#else
+# define machine_is_skyrider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYHAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYHAWK
+# endif
+# define machine_is_skyhawk()	(machine_arch_type == MACH_TYPE_SKYHAWK)
+#else
+# define machine_is_skyhawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENTERPRISE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTERPRISE
+# endif
+# define machine_is_enterprise()	(machine_arch_type == MACH_TYPE_ENTERPRISE)
+#else
+# define machine_is_enterprise()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410
+# endif
+# define machine_is_dep2410()	(machine_arch_type == MACH_TYPE_DEP2410)
+#else
+# define machine_is_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOBBIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOBBIT
+# endif
+# define machine_is_hobbit()	(machine_arch_type == MACH_TYPE_HOBBIT)
+#else
+# define machine_is_hobbit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7210
+# endif
+# define machine_is_h7210()	(machine_arch_type == MACH_TYPE_H7210)
+#else
+# define machine_is_h7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_NETDCU5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU5
+# endif
+# define machine_is_pxa_netdcu5()	(machine_arch_type == MACH_TYPE_PXA_NETDCU5)
+#else
+# define machine_is_pxa_netdcu5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACC
+# endif
+# define machine_is_acc()	(machine_arch_type == MACH_TYPE_ACC)
+#else
+# define machine_is_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA
+# endif
+# define machine_is_esl_sarva()	(machine_arch_type == MACH_TYPE_ESL_SARVA)
+#else
+# define machine_is_esl_sarva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XM250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XM250
+# endif
+# define machine_is_xm250()	(machine_arch_type == MACH_TYPE_XM250)
+#else
+# define machine_is_xm250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T6TC1XB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T6TC1XB
+# endif
+# define machine_is_t6tc1xb()	(machine_arch_type == MACH_TYPE_T6TC1XB)
+#else
+# define machine_is_t6tc1xb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS710
+# endif
+# define machine_is_ess710()	(machine_arch_type == MACH_TYPE_ESS710)
+#else
+# define machine_is_ess710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31ADS
+# endif
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
+#else
+# define machine_is_mx31ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOLFENK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOLFENK
+# endif
+# define machine_is_bolfenk()	(machine_arch_type == MACH_TYPE_BOLFENK)
+#else
+# define machine_is_bolfenk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KR
+# endif
+# define machine_is_at91rm9200kr()	(machine_arch_type == MACH_TYPE_AT91RM9200KR)
+#else
+# define machine_is_at91rm9200kr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXIMX3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIMX3
+# endif
+# define machine_is_aximx3()	(machine_arch_type == MACH_TYPE_AXIMX3)
+#else
+# define machine_is_aximx3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB67XDIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB67XDIP
+# endif
+# define machine_is_eb67xdip()	(machine_arch_type == MACH_TYPE_EB67XDIP)
+#else
+# define machine_is_eb67xdip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBTXS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBTXS
+# endif
+# define machine_is_webtxs()	(machine_arch_type == MACH_TYPE_WEBTXS)
+#else
+# define machine_is_webtxs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAWK
+# endif
+# define machine_is_hawk()	(machine_arch_type == MACH_TYPE_HAWK)
+#else
+# define machine_is_hawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCAT91SBC001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCAT91SBC001
+# endif
+# define machine_is_ccat91sbc001()	(machine_arch_type == MACH_TYPE_CCAT91SBC001)
+#else
+# define machine_is_ccat91sbc001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSO
+# endif
+# define machine_is_expresso()	(machine_arch_type == MACH_TYPE_EXPRESSO)
+#else
+# define machine_is_expresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4000
+# endif
+# define machine_is_h4000()	(machine_arch_type == MACH_TYPE_H4000)
+#else
+# define machine_is_h4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINO
+# endif
+# define machine_is_dino()	(machine_arch_type == MACH_TYPE_DINO)
+#else
+# define machine_is_dino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML675K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML675K
+# endif
+# define machine_is_ml675k()	(machine_arch_type == MACH_TYPE_ML675K)
+#else
+# define machine_is_ml675k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECIVA_TT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECIVA_TT
+# endif
+# define machine_is_reciva_tt()	(machine_arch_type == MACH_TYPE_RECIVA_TT)
+#else
+# define machine_is_reciva_tt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB01
+# endif
+# define machine_is_cstcb01()	(machine_arch_type == MACH_TYPE_CSTCB01)
+#else
+# define machine_is_cstcb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB1
+# endif
+# define machine_is_cstcb1()	(machine_arch_type == MACH_TYPE_CSTCB1)
+#else
+# define machine_is_cstcb1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHADWELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHADWELL
+# endif
+# define machine_is_shadwell()	(machine_arch_type == MACH_TYPE_SHADWELL)
+#else
+# define machine_is_shadwell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOEPEL263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOEPEL263
+# endif
+# define machine_is_goepel263()	(machine_arch_type == MACH_TYPE_GOEPEL263)
+#else
+# define machine_is_goepel263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ100
+# endif
+# define machine_is_acq100()	(machine_arch_type == MACH_TYPE_ACQ100)
+#else
+# define machine_is_acq100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX1FS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1FS2
+# endif
+# define machine_is_mx1fs2()	(machine_arch_type == MACH_TYPE_MX1FS2)
+#else
+# define machine_is_mx1fs2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPTOP_G1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPTOP_G1
+# endif
+# define machine_is_hiptop_g1()	(machine_arch_type == MACH_TYPE_HIPTOP_G1)
+#else
+# define machine_is_hiptop_g1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARKY
+# endif
+# define machine_is_sparky()	(machine_arch_type == MACH_TYPE_SPARKY)
+#else
+# define machine_is_sparky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS9750
+# endif
+# define machine_is_ns9750()	(machine_arch_type == MACH_TYPE_NS9750)
+#else
+# define machine_is_ns9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHOENIX
+# endif
+# define machine_is_phoenix()	(machine_arch_type == MACH_TYPE_PHOENIX)
+#else
+# define machine_is_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTERPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTERPXA
+# endif
+# define machine_is_deisterpxa()	(machine_arch_type == MACH_TYPE_DEISTERPXA)
+#else
+# define machine_is_deisterpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM1160
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM1160
+# endif
+# define machine_is_bcm1160()	(machine_arch_type == MACH_TYPE_BCM1160)
+#else
+# define machine_is_bcm1160()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM022
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM022
+# endif
+# define machine_is_pcm022()	(machine_arch_type == MACH_TYPE_PCM022)
+#else
+# define machine_is_pcm022()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSGCX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSGCX
+# endif
+# define machine_is_adsgcx()	(machine_arch_type == MACH_TYPE_ADSGCX)
+#else
+# define machine_is_adsgcx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DREADNAUGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DREADNAUGHT
+# endif
+# define machine_is_dreadnaught()	(machine_arch_type == MACH_TYPE_DREADNAUGHT)
+#else
+# define machine_is_dreadnaught()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM320
+# endif
+# define machine_is_dm320()	(machine_arch_type == MACH_TYPE_DM320)
+#else
+# define machine_is_dm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARKOV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARKOV
+# endif
+# define machine_is_markov()	(machine_arch_type == MACH_TYPE_MARKOV)
+#else
+# define machine_is_markov()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COS7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COS7A400
+# endif
+# define machine_is_cos7a400()	(machine_arch_type == MACH_TYPE_COS7A400)
+#else
+# define machine_is_cos7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILANO
+# endif
+# define machine_is_milano()	(machine_arch_type == MACH_TYPE_MILANO)
+#else
+# define machine_is_milano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE9328
+# endif
+# define machine_is_ue9328()	(machine_arch_type == MACH_TYPE_UE9328)
+#else
+# define machine_is_ue9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEX255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEX255
+# endif
+# define machine_is_uex255()	(machine_arch_type == MACH_TYPE_UEX255)
+#else
+# define machine_is_uex255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE2410
+# endif
+# define machine_is_ue2410()	(machine_arch_type == MACH_TYPE_UE2410)
+#else
+# define machine_is_ue2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A620
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A620
+# endif
+# define machine_is_a620()	(machine_arch_type == MACH_TYPE_A620)
+#else
+# define machine_is_a620()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCELOT
+# endif
+# define machine_is_ocelot()	(machine_arch_type == MACH_TYPE_OCELOT)
+#else
+# define machine_is_ocelot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHEETAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHEETAH
+# endif
+# define machine_is_cheetah()	(machine_arch_type == MACH_TYPE_CHEETAH)
+#else
+# define machine_is_cheetah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZVUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZVUE
+# endif
+# define machine_is_zvue()	(machine_arch_type == MACH_TYPE_ZVUE)
+#else
+# define machine_is_zvue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP1
+# endif
+# define machine_is_roverp1()	(machine_arch_type == MACH_TYPE_ROVERP1)
+#else
+# define machine_is_roverp1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASIDIAL2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASIDIAL2
+# endif
+# define machine_is_asidial2()	(machine_arch_type == MACH_TYPE_ASIDIAL2)
+#else
+# define machine_is_asidial2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C24A0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C24A0
+# endif
+# define machine_is_s3c24a0()	(machine_arch_type == MACH_TYPE_S3C24A0)
+#else
+# define machine_is_s3c24a0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5500
+# endif
+# define machine_is_s3c5500()	(machine_arch_type == MACH_TYPE_S3C5500)
+#else
+# define machine_is_s3c5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5500
+# endif
+# define machine_is_smdk5500()	(machine_arch_type == MACH_TYPE_SMDK5500)
+#else
+# define machine_is_smdk5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIGNALSYNC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIGNALSYNC
+# endif
+# define machine_is_signalsync()	(machine_arch_type == MACH_TYPE_SIGNALSYNC)
+#else
+# define machine_is_signalsync()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NBC
+# endif
+# define machine_is_nbc()	(machine_arch_type == MACH_TYPE_NBC)
+#else
+# define machine_is_nbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KODIAK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KODIAK
+# endif
+# define machine_is_kodiak()	(machine_arch_type == MACH_TYPE_KODIAK)
+#else
+# define machine_is_kodiak()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETBOOKPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETBOOKPRO
+# endif
+# define machine_is_netbookpro()	(machine_arch_type == MACH_TYPE_NETBOOKPRO)
+#else
+# define machine_is_netbookpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90200
+# endif
+# define machine_is_hw90200()	(machine_arch_type == MACH_TYPE_HW90200)
+#else
+# define machine_is_hw90200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONDOR
+# endif
+# define machine_is_condor()	(machine_arch_type == MACH_TYPE_CONDOR)
+#else
+# define machine_is_condor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CUP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CUP
+# endif
+# define machine_is_cup()	(machine_arch_type == MACH_TYPE_CUP)
+#else
+# define machine_is_cup()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KITE
+# endif
+# define machine_is_kite()	(machine_arch_type == MACH_TYPE_KITE)
+#else
+# define machine_is_kite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N10
+# endif
+# define machine_is_n10()	(machine_arch_type == MACH_TYPE_N10)
+#else
+# define machine_is_n10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONTAJADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONTAJADE
+# endif
+# define machine_is_montejade()	(machine_arch_type == MACH_TYPE_MONTAJADE)
+#else
+# define machine_is_montejade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560
+# endif
+# define machine_is_sg560()	(machine_arch_type == MACH_TYPE_SG560)
+#else
+# define machine_is_sg560()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP1000
+# endif
+# define machine_is_dp1000()	(machine_arch_type == MACH_TYPE_DP1000)
+#else
+# define machine_is_dp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RG100V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RG100V3
+# endif
+# define machine_is_rg100v3()	(machine_arch_type == MACH_TYPE_RG100V3)
+#else
+# define machine_is_rg100v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2ADS
+# endif
+# define machine_is_mx2ads()	(machine_arch_type == MACH_TYPE_MX2ADS)
+#else
+# define machine_is_mx2ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KILO
+# endif
+# define machine_is_pxa_kilo()	(machine_arch_type == MACH_TYPE_PXA_KILO)
+#else
+# define machine_is_pxa_kilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP4XX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_EAGLE
+# endif
+# define machine_is_ixp4xx_eagle()	(machine_arch_type == MACH_TYPE_IXP4XX_EAGLE)
+#else
+# define machine_is_ixp4xx_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB2520F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB2520F
+# endif
+# define machine_is_mb2520f()	(machine_arch_type == MACH_TYPE_MB2520F)
+#else
+# define machine_is_mb2520f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMC1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMC1000
+# endif
+# define machine_is_emc1000()	(machine_arch_type == MACH_TYPE_EMC1000)
+#else
+# define machine_is_emc1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIDSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIDSC25
+# endif
+# define machine_is_tidsc25()	(machine_arch_type == MACH_TYPE_TIDSC25)
+#else
+# define machine_is_tidsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKCPMXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKCPMXL
+# endif
+# define machine_is_akcpmxl()	(machine_arch_type == MACH_TYPE_AKCPMXL)
+#else
+# define machine_is_akcpmxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AV3XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV3XX
+# endif
+# define machine_is_av3xx()	(machine_arch_type == MACH_TYPE_AV3XX)
+#else
+# define machine_is_av3xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_MPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MPM10
+# endif
+# define machine_is_pxa_mpm10()	(machine_arch_type == MACH_TYPE_PXA_MPM10)
+#else
+# define machine_is_pxa_mpm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KYANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KYANITE
+# endif
+# define machine_is_pxa_kyanite()	(machine_arch_type == MACH_TYPE_PXA_KYANITE)
+#else
+# define machine_is_pxa_kyanite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGOLD
+# endif
+# define machine_is_sgold()	(machine_arch_type == MACH_TYPE_SGOLD)
+#else
+# define machine_is_sgold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSCAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSCAR
+# endif
+# define machine_is_oscar()	(machine_arch_type == MACH_TYPE_OSCAR)
+#else
+# define machine_is_oscar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPXA4USB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPXA4USB2
+# endif
+# define machine_is_epxa4usb2()	(machine_arch_type == MACH_TYPE_EPXA4USB2)
+#else
+# define machine_is_epxa4usb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSENGINE
+# endif
+# define machine_is_xsengine()	(machine_arch_type == MACH_TYPE_XSENGINE)
+#else
+# define machine_is_xsengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP600
+# endif
+# define machine_is_ip600()	(machine_arch_type == MACH_TYPE_IP600)
+#else
+# define machine_is_ip600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCAN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCAN2
+# endif
+# define machine_is_mcan2()	(machine_arch_type == MACH_TYPE_MCAN2)
+#else
+# define machine_is_mcan2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDI_BLUERIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDI_BLUERIDGE
+# endif
+# define machine_is_ddi_blueridge()	(machine_arch_type == MACH_TYPE_DDI_BLUERIDGE)
+#else
+# define machine_is_ddi_blueridge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMINDER
+# endif
+# define machine_is_skyminder()	(machine_arch_type == MACH_TYPE_SKYMINDER)
+#else
+# define machine_is_skyminder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79520
+# endif
+# define machine_is_lpd79520()	(machine_arch_type == MACH_TYPE_LPD79520)
+#else
+# define machine_is_lpd79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90340
+# endif
+# define machine_is_hw90340()	(machine_arch_type == MACH_TYPE_HW90340)
+#else
+# define machine_is_hw90340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CIP_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CIP_BOX
+# endif
+# define machine_is_cip_box()	(machine_arch_type == MACH_TYPE_CIP_BOX)
+#else
+# define machine_is_cip_box()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IVPN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IVPN
+# endif
+# define machine_is_ivpn()	(machine_arch_type == MACH_TYPE_IVPN)
+#else
+# define machine_is_ivpn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSOC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSOC2
+# endif
+# define machine_is_rsoc2()	(machine_arch_type == MACH_TYPE_RSOC2)
+#else
+# define machine_is_rsoc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOXER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOXER
+# endif
+# define machine_is_boxer()	(machine_arch_type == MACH_TYPE_BOXER)
+#else
+# define machine_is_boxer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML42800AA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML42800AA
+# endif
+# define machine_is_aml42800aa()	(machine_arch_type == MACH_TYPE_AML42800AA)
+#else
+# define machine_is_aml42800aa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_TYPE_ML674001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_TYPE_ML674001
+# endif
+# define machine_is_ml674001()	(machine_arch_type == MACH_TYPE_MACH_TYPE_ML674001)
+#else
+# define machine_is_ml674001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC2294
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC2294
+# endif
+# define machine_is_lpc2294()	(machine_arch_type == MACH_TYPE_LPC2294)
+#else
+# define machine_is_lpc2294()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWITCHGRASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWITCHGRASS
+# endif
+# define machine_is_switchgrass()	(machine_arch_type == MACH_TYPE_SWITCHGRASS)
+#else
+# define machine_is_switchgrass()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENS_CMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENS_CMU
+# endif
+# define machine_is_ens_cmu()	(machine_arch_type == MACH_TYPE_ENS_CMU)
+#else
+# define machine_is_ens_cmu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MM6_SDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MM6_SDB
+# endif
+# define machine_is_mm6_sdb()	(machine_arch_type == MACH_TYPE_MM6_SDB)
+#else
+# define machine_is_mm6_sdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATURN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATURN
+# endif
+# define machine_is_saturn()	(machine_arch_type == MACH_TYPE_SATURN)
+#else
+# define machine_is_saturn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I30030EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I30030EVB
+# endif
+# define machine_is_i30030evb()	(machine_arch_type == MACH_TYPE_I30030EVB)
+#else
+# define machine_is_i30030evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27530EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27530EVB
+# endif
+# define machine_is_mxc27530evb()	(machine_arch_type == MACH_TYPE_MXC27530EVB)
+#else
+# define machine_is_mxc27530evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2800
+# endif
+# define machine_is_smdk2800()	(machine_arch_type == MACH_TYPE_SMDK2800)
+#else
+# define machine_is_smdk2800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTWILSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTWILSON
+# endif
+# define machine_is_mtwilson()	(machine_arch_type == MACH_TYPE_MTWILSON)
+#else
+# define machine_is_mtwilson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZITI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZITI
+# endif
+# define machine_is_ziti()	(machine_arch_type == MACH_TYPE_ZITI)
+#else
+# define machine_is_ziti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GRANDFATHER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANDFATHER
+# endif
+# define machine_is_grandfather()	(machine_arch_type == MACH_TYPE_GRANDFATHER)
+#else
+# define machine_is_grandfather()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TENGINE
+# endif
+# define machine_is_tengine()	(machine_arch_type == MACH_TYPE_TENGINE)
+#else
+# define machine_is_tengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2460
+# endif
+# define machine_is_s3c2460()	(machine_arch_type == MACH_TYPE_S3C2460)
+#else
+# define machine_is_s3c2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDM
+# endif
+# define machine_is_pdm()	(machine_arch_type == MACH_TYPE_PDM)
+#else
+# define machine_is_pdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6300
+# endif
+# define machine_is_h6300()	(machine_arch_type == MACH_TYPE_H6300)
+#else
+# define machine_is_h6300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RZ1700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RZ1700
+# endif
+# define machine_is_rz1700()	(machine_arch_type == MACH_TYPE_RZ1700)
+#else
+# define machine_is_rz1700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A716
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A716
+# endif
+# define machine_is_a716()	(machine_arch_type == MACH_TYPE_A716)
+#else
+# define machine_is_a716()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESTK2440A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESTK2440A
+# endif
+# define machine_is_estk2440a()	(machine_arch_type == MACH_TYPE_ESTK2440A)
+#else
+# define machine_is_estk2440a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATWIXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATWIXP425
+# endif
+# define machine_is_atwixp425()	(machine_arch_type == MACH_TYPE_ATWIXP425)
+#else
+# define machine_is_atwixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB336
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB336
+# endif
+# define machine_is_csb336()	(machine_arch_type == MACH_TYPE_CSB336)
+#else
+# define machine_is_csb336()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIRM2
+# endif
+# define machine_is_rirm2()	(machine_arch_type == MACH_TYPE_RIRM2)
+#else
+# define machine_is_rirm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX23518
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX23518
+# endif
+# define machine_is_cx23518()	(machine_arch_type == MACH_TYPE_CX23518)
+#else
+# define machine_is_cx23518()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX2351X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX2351X
+# endif
+# define machine_is_cx2351x()	(machine_arch_type == MACH_TYPE_CX2351X)
+#else
+# define machine_is_cx2351x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPUTIME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPUTIME
+# endif
+# define machine_is_computime()	(machine_arch_type == MACH_TYPE_COMPUTIME)
+#else
+# define machine_is_computime()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IZARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IZARUS
+# endif
+# define machine_is_izarus()	(machine_arch_type == MACH_TYPE_IZARUS)
+#else
+# define machine_is_izarus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RTS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RTS
+# endif
+# define machine_is_pxa_rts()	(machine_arch_type == MACH_TYPE_RTS)
+#else
+# define machine_is_pxa_rts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE5100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE5100
+# endif
+# define machine_is_se5100()	(machine_arch_type == MACH_TYPE_SE5100)
+#else
+# define machine_is_se5100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2510
+# endif
+# define machine_is_s3c2510()	(machine_arch_type == MACH_TYPE_S3C2510)
+#else
+# define machine_is_s3c2510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB437TL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB437TL
+# endif
+# define machine_is_csb437tl()	(machine_arch_type == MACH_TYPE_CSB437TL)
+#else
+# define machine_is_csb437tl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLAUSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLAUSON
+# endif
+# define machine_is_slauson()	(machine_arch_type == MACH_TYPE_SLAUSON)
+#else
+# define machine_is_slauson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEARLRIVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEARLRIVER
+# endif
+# define machine_is_pearlriver()	(machine_arch_type == MACH_TYPE_PEARLRIVER)
+#else
+# define machine_is_pearlriver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TDC_P210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TDC_P210
+# endif
+# define machine_is_tdc_p210()	(machine_arch_type == MACH_TYPE_TDC_P210)
+#else
+# define machine_is_tdc_p210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG580
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG580
+# endif
+# define machine_is_sg580()	(machine_arch_type == MACH_TYPE_SG580)
+#else
+# define machine_is_sg580()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRSBCARM7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRSBCARM7
+# endif
+# define machine_is_wrsbcarm7()	(machine_arch_type == MACH_TYPE_WRSBCARM7)
+#else
+# define machine_is_wrsbcarm7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPD
+# endif
+# define machine_is_ipd()	(machine_arch_type == MACH_TYPE_IPD)
+#else
+# define machine_is_ipd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_DNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_DNP2110
+# endif
+# define machine_is_pxa_dnp2110()	(machine_arch_type == MACH_TYPE_PXA_DNP2110)
+#else
+# define machine_is_pxa_dnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XAENIAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XAENIAX
+# endif
+# define machine_is_xaeniax()	(machine_arch_type == MACH_TYPE_XAENIAX)
+#else
+# define machine_is_xaeniax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOMN4250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOMN4250
+# endif
+# define machine_is_somn4250()	(machine_arch_type == MACH_TYPE_SOMN4250)
+#else
+# define machine_is_somn4250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLEB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB2
+# endif
+# define machine_is_pleb2()	(machine_arch_type == MACH_TYPE_PLEB2)
+#else
+# define machine_is_pleb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORNWALLIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORNWALLIS
+# endif
+# define machine_is_cornwallis()	(machine_arch_type == MACH_TYPE_CORNWALLIS)
+#else
+# define machine_is_cornwallis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURNEY_DRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURNEY_DRV
+# endif
+# define machine_is_gurney_drv()	(machine_arch_type == MACH_TYPE_GURNEY_DRV)
+#else
+# define machine_is_gurney_drv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHAFFEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHAFFEE
+# endif
+# define machine_is_chaffee()	(machine_arch_type == MACH_TYPE_CHAFFEE)
+#else
+# define machine_is_chaffee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS101
+# endif
+# define machine_is_rms101()	(machine_arch_type == MACH_TYPE_RMS101)
+#else
+# define machine_is_rms101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWIFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWIFT
+# endif
+# define machine_is_swift()	(machine_arch_type == MACH_TYPE_SWIFT)
+#else
+# define machine_is_swift()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP7
+# endif
+# define machine_is_roverp7()	(machine_arch_type == MACH_TYPE_ROVERP7)
+#else
+# define machine_is_roverp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PR818S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PR818S
+# endif
+# define machine_is_pr818s()	(machine_arch_type == MACH_TYPE_PR818S)
+#else
+# define machine_is_pr818s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRXPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRXPRO
+# endif
+# define machine_is_trxpro()	(machine_arch_type == MACH_TYPE_TRXPRO)
+#else
+# define machine_is_trxpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRAB
+# endif
+# define machine_is_trab()	(machine_arch_type == MACH_TYPE_TRAB)
+#else
+# define machine_is_trab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMC_PU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMC_PU2
+# endif
+# define machine_is_cmc_pu2()	(machine_arch_type == MACH_TYPE_CMC_PU2)
+#else
+# define machine_is_cmc_pu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FULCRUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FULCRUM
+# endif
+# define machine_is_fulcrum()	(machine_arch_type == MACH_TYPE_FULCRUM)
+#else
+# define machine_is_fulcrum()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETGATE42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATE42X
+# endif
+# define machine_is_netgate42x()	(machine_arch_type == MACH_TYPE_NETGATE42X)
+#else
+# define machine_is_netgate42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR710
+# endif
+# define machine_is_str710()	(machine_arch_type == MACH_TYPE_STR710)
+#else
+# define machine_is_str710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOMTOMGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOMTOMGO
+# endif
+# define machine_is_tomtomgo()	(machine_arch_type == MACH_TYPE_TOMTOMGO)
+#else
+# define machine_is_tomtomgo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG565
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG565
+# endif
+# define machine_is_sg565()	(machine_arch_type == MACH_TYPE_SG565)
+#else
+# define machine_is_sg565()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79524
+# endif
+# define machine_is_lpd79524()	(machine_arch_type == MACH_TYPE_LPD79524)
+#else
+# define machine_is_lpd79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79525
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79525
+# endif
+# define machine_is_lpd79525()	(machine_arch_type == MACH_TYPE_LPD79525)
+#else
+# define machine_is_lpd79525()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS100
+# endif
+# define machine_is_rms100()	(machine_arch_type == MACH_TYPE_RMS100)
+#else
+# define machine_is_rms100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMS39C7092
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMS39C7092
+# endif
+# define machine_is_hms39c7092()	(machine_arch_type == MACH_TYPE_HMS39C7092)
+#else
+# define machine_is_hms39c7092()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO
+# endif
+# define machine_is_armadillo()	(machine_arch_type == MACH_TYPE_ARMADILLO)
+#else
+# define machine_is_armadillo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPCU
+# endif
+# define machine_is_ipcu()	(machine_arch_type == MACH_TYPE_IPCU)
+#else
+# define machine_is_ipcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX720
+# endif
+# define machine_is_loox720()	(machine_arch_type == MACH_TYPE_LOOX720)
+#else
+# define machine_is_loox720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSVIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVIX
+# endif
+# define machine_is_adsvix()	(machine_arch_type == MACH_TYPE_ADSVIX)
+#else
+# define machine_is_adsvix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM270
+# endif
+# define machine_is_dm270()	(machine_arch_type == MACH_TYPE_DM270)
+#else
+# define machine_is_dm270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOCLTPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOCLTPLUS
+# endif
+# define machine_is_socltplus()	(machine_arch_type == MACH_TYPE_SOCLTPLUS)
+#else
+# define machine_is_socltplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECIA
+# endif
+# define machine_is_ecia()	(machine_arch_type == MACH_TYPE_ECIA)
+#else
+# define machine_is_ecia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4008
+# endif
+# define machine_is_cm4008()	(machine_arch_type == MACH_TYPE_CM4008)
+#else
+# define machine_is_cm4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P2001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P2001
+# endif
+# define machine_is_p2001()	(machine_arch_type == MACH_TYPE_P2001)
+#else
+# define machine_is_p2001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TWISTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TWISTER
+# endif
+# define machine_is_twister()	(machine_arch_type == MACH_TYPE_TWISTER)
+#else
+# define machine_is_twister()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MUDSHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MUDSHARK
+# endif
+# define machine_is_mudshark()	(machine_arch_type == MACH_TYPE_MUDSHARK)
+#else
+# define machine_is_mudshark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HB2
+# endif
+# define machine_is_hb2()	(machine_arch_type == MACH_TYPE_HB2)
+#else
+# define machine_is_hb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SENDT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SENDT
+# endif
+# define machine_is_sendt()	(machine_arch_type == MACH_TYPE_SENDT)
+#else
+# define machine_is_sendt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2JAZZ
+# endif
+# define machine_is_mx2jazz()	(machine_arch_type == MACH_TYPE_MX2JAZZ)
+#else
+# define machine_is_mx2jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIIO
+# endif
+# define machine_is_multiio()	(machine_arch_type == MACH_TYPE_MULTIIO)
+#else
+# define machine_is_multiio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HRDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HRDISPLAY
+# endif
+# define machine_is_hrdisplay()	(machine_arch_type == MACH_TYPE_HRDISPLAY)
+#else
+# define machine_is_hrdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27530ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27530ADS
+# endif
+# define machine_is_mxc27530ads()	(machine_arch_type == MACH_TYPE_MXC27530ADS)
+#else
+# define machine_is_mxc27530ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS3
+# endif
+# define machine_is_trizeps3()	(machine_arch_type == MACH_TYPE_TRIZEPS3)
+#else
+# define machine_is_trizeps3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZA
+# endif
+# define machine_is_zefeerdza()	(machine_arch_type == MACH_TYPE_ZEFEERDZA)
+#else
+# define machine_is_zefeerdza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZB
+# endif
+# define machine_is_zefeerdzb()	(machine_arch_type == MACH_TYPE_ZEFEERDZB)
+#else
+# define machine_is_zefeerdzb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZG
+# endif
+# define machine_is_zefeerdzg()	(machine_arch_type == MACH_TYPE_ZEFEERDZG)
+#else
+# define machine_is_zefeerdzg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZN
+# endif
+# define machine_is_zefeerdzn()	(machine_arch_type == MACH_TYPE_ZEFEERDZN)
+#else
+# define machine_is_zefeerdzn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZQ
+# endif
+# define machine_is_zefeerdzq()	(machine_arch_type == MACH_TYPE_ZEFEERDZQ)
+#else
+# define machine_is_zefeerdzq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASTRO_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASTRO_JACK
+# endif
+# define machine_is_astro_jack()	(machine_arch_type == MACH_TYPE_ASTRO_JACK)
+#else
+# define machine_is_astro_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIP03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIP03
+# endif
+# define machine_is_tip03()	(machine_arch_type == MACH_TYPE_TIP03)
+#else
+# define machine_is_tip03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9200EC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9200EC
+# endif
+# define machine_is_a9200ec()	(machine_arch_type == MACH_TYPE_A9200EC)
+#else
+# define machine_is_a9200ec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0105
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0105
+# endif
+# define machine_is_pnx0105()	(machine_arch_type == MACH_TYPE_PNX0105)
+#else
+# define machine_is_pnx0105()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADCPOECPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADCPOECPU
+# endif
+# define machine_is_adcpoecpu()	(machine_arch_type == MACH_TYPE_ADCPOECPU)
+#else
+# define machine_is_adcpoecpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML69Q6203
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML69Q6203
+# endif
+# define machine_is_ml69q6203()	(machine_arch_type == MACH_TYPE_ML69Q6203)
+#else
+# define machine_is_ml69q6203()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9200
+# endif
+# define machine_is_mb9200()	(machine_arch_type == MACH_TYPE_MB9200)
+#else
+# define machine_is_mb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KULUN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KULUN
+# endif
+# define machine_is_kulun()	(machine_arch_type == MACH_TYPE_KULUN)
+#else
+# define machine_is_kulun()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER
+# endif
+# define machine_is_snapper()	(machine_arch_type == MACH_TYPE_SNAPPER)
+#else
+# define machine_is_snapper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTIMA
+# endif
+# define machine_is_optima()	(machine_arch_type == MACH_TYPE_OPTIMA)
+#else
+# define machine_is_optima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLHSBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLHSBC
+# endif
+# define machine_is_dlhsbc()	(machine_arch_type == MACH_TYPE_DLHSBC)
+#else
+# define machine_is_dlhsbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X30
+# endif
+# define machine_is_x30()	(machine_arch_type == MACH_TYPE_X30)
+#else
+# define machine_is_x30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANGA_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANGA_KS8695
+# endif
+# define machine_is_manga_ks8695()	(machine_arch_type == MACH_TYPE_MANGA_KS8695)
+#else
+# define machine_is_manga_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX
+# endif
+# define machine_is_ajax()	(machine_arch_type == MACH_TYPE_AJAX)
+#else
+# define machine_is_ajax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK1000
+# endif
+# define machine_is_vvtk1000()	(machine_arch_type == MACH_TYPE_VVTK1000)
+#else
+# define machine_is_vvtk1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK3000
+# endif
+# define machine_is_vvtk3000()	(machine_arch_type == MACH_TYPE_VVTK3000)
+#else
+# define machine_is_vvtk3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIMX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIMX1
+# endif
+# define machine_is_pimx1()	(machine_arch_type == MACH_TYPE_PIMX1)
+#else
+# define machine_is_pimx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLLIE
+# endif
+# define machine_is_ollie()	(machine_arch_type == MACH_TYPE_OLLIE)
+#else
+# define machine_is_ollie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMAX
+# endif
+# define machine_is_skymax()	(machine_arch_type == MACH_TYPE_SKYMAX)
+#else
+# define machine_is_skymax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JAZZ
+# endif
+# define machine_is_jazz()	(machine_arch_type == MACH_TYPE_JAZZ)
+#else
+# define machine_is_jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEL_T3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEL_T3
+# endif
+# define machine_is_tel_t3()	(machine_arch_type == MACH_TYPE_TEL_T3)
+#else
+# define machine_is_tel_t3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AISINO_FCR255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AISINO_FCR255
+# endif
+# define machine_is_aisino_fcr255()	(machine_arch_type == MACH_TYPE_AISINO_FCR255)
+#else
+# define machine_is_aisino_fcr255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTWEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTWEB
+# endif
+# define machine_is_btweb()	(machine_arch_type == MACH_TYPE_BTWEB)
+#else
+# define machine_is_btweb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DBG_LH79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DBG_LH79520
+# endif
+# define machine_is_dbg_lh79520()	(machine_arch_type == MACH_TYPE_DBG_LH79520)
+#else
+# define machine_is_dbg_lh79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM41XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM41XX
+# endif
+# define machine_is_cm41xx()	(machine_arch_type == MACH_TYPE_CM41XX)
+#else
+# define machine_is_cm41xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NGGPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NGGPXA
+# endif
+# define machine_is_nggpxa()	(machine_arch_type == MACH_TYPE_NGGPXA)
+#else
+# define machine_is_nggpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB535
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB535
+# endif
+# define machine_is_csb535()	(machine_arch_type == MACH_TYPE_CSB535)
+#else
+# define machine_is_csb535()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB536
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB536
+# endif
+# define machine_is_csb536()	(machine_arch_type == MACH_TYPE_CSB536)
+#else
+# define machine_is_csb536()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_TRAKPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_TRAKPOD
+# endif
+# define machine_is_pxa_trakpod()	(machine_arch_type == MACH_TYPE_PXA_TRAKPOD)
+#else
+# define machine_is_pxa_trakpod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRAXIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAXIS
+# endif
+# define machine_is_praxis()	(machine_arch_type == MACH_TYPE_PRAXIS)
+#else
+# define machine_is_praxis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LH75411
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LH75411
+# endif
+# define machine_is_lh75411()	(machine_arch_type == MACH_TYPE_LH75411)
+#else
+# define machine_is_lh75411()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX410
+# endif
+# define machine_is_loox410()	(machine_arch_type == MACH_TYPE_LOOX410)
+#else
+# define machine_is_loox410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WESTLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WESTLAKE
+# endif
+# define machine_is_westlake()	(machine_arch_type == MACH_TYPE_WESTLAKE)
+#else
+# define machine_is_westlake()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB
+# endif
+# define machine_is_nsb()	(machine_arch_type == MACH_TYPE_NSB)
+#else
+# define machine_is_nsb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_STN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_STN
+# endif
+# define machine_is_esl_sarva_stn()	(machine_arch_type == MACH_TYPE_ESL_SARVA_STN)
+#else
+# define machine_is_esl_sarva_stn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_TFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_TFT
+# endif
+# define machine_is_esl_sarva_tft()	(machine_arch_type == MACH_TYPE_ESL_SARVA_TFT)
+#else
+# define machine_is_esl_sarva_tft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_IAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_IAD
+# endif
+# define machine_is_esl_sarva_iad()	(machine_arch_type == MACH_TYPE_ESL_SARVA_IAD)
+#else
+# define machine_is_esl_sarva_iad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_ACC
+# endif
+# define machine_is_esl_sarva_acc()	(machine_arch_type == MACH_TYPE_ESL_SARVA_ACC)
+#else
+# define machine_is_esl_sarva_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TYPHOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TYPHOON
+# endif
+# define machine_is_typhoon()	(machine_arch_type == MACH_TYPE_TYPHOON)
+#else
+# define machine_is_typhoon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNAV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNAV
+# endif
+# define machine_is_cnav()	(machine_arch_type == MACH_TYPE_CNAV)
+#else
+# define machine_is_cnav()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A730
+# endif
+# define machine_is_a730()	(machine_arch_type == MACH_TYPE_A730)
+#else
+# define machine_is_a730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSTAR
+# endif
+# define machine_is_netstar()	(machine_arch_type == MACH_TYPE_NETSTAR)
+#else
+# define machine_is_netstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHASEFALE_SUPERCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHASEFALE_SUPERCON
+# endif
+# define machine_is_supercon()	(machine_arch_type == MACH_TYPE_PHASEFALE_SUPERCON)
+#else
+# define machine_is_supercon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHIVA1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHIVA1100
+# endif
+# define machine_is_shiva1100()	(machine_arch_type == MACH_TYPE_SHIVA1100)
+#else
+# define machine_is_shiva1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETEXSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETEXSC
+# endif
+# define machine_is_etexsc()	(machine_arch_type == MACH_TYPE_ETEXSC)
+#else
+# define machine_is_etexsc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG465
+# endif
+# define machine_is_ixdpg465()	(machine_arch_type == MACH_TYPE_IXDPG465)
+#else
+# define machine_is_ixdpg465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2410
+# endif
+# define machine_is_a9m2410()	(machine_arch_type == MACH_TYPE_A9M2410)
+#else
+# define machine_is_a9m2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2440
+# endif
+# define machine_is_a9m2440()	(machine_arch_type == MACH_TYPE_A9M2440)
+#else
+# define machine_is_a9m2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9750
+# endif
+# define machine_is_a9m9750()	(machine_arch_type == MACH_TYPE_A9M9750)
+#else
+# define machine_is_a9m9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9360
+# endif
+# define machine_is_a9m9360()	(machine_arch_type == MACH_TYPE_A9M9360)
+#else
+# define machine_is_a9m9360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNC90
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNC90
+# endif
+# define machine_is_unc90()	(machine_arch_type == MACH_TYPE_UNC90)
+#else
+# define machine_is_unc90()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATVIEW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATVIEW
+# endif
+# define machine_is_satview()	(machine_arch_type == MACH_TYPE_SATVIEW)
+#else
+# define machine_is_satview()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GP32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GP32
+# endif
+# define machine_is_gp32()	(machine_arch_type == MACH_TYPE_GP32)
+#else
+# define machine_is_gp32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEM
+# endif
+# define machine_is_gem()	(machine_arch_type == MACH_TYPE_GEM)
+#else
+# define machine_is_gem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I858
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I858
+# endif
+# define machine_is_i858()	(machine_arch_type == MACH_TYPE_I858)
+#else
+# define machine_is_i858()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX2750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX2750
+# endif
+# define machine_is_hx2750()	(machine_arch_type == MACH_TYPE_HX2750)
+#else
+# define machine_is_hx2750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC91131EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC91131EVB
+# endif
+# define machine_is_mxc91131evb()	(machine_arch_type == MACH_TYPE_MXC91131EVB)
+#else
+# define machine_is_mxc91131evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P700
+# endif
+# define machine_is_p700()	(machine_arch_type == MACH_TYPE_P700)
+#else
+# define machine_is_p700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPE
+# endif
+# define machine_is_cpe()	(machine_arch_type == MACH_TYPE_CPE)
+#else
+# define machine_is_cpe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NIMBRA340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA340
+# endif
+# define machine_is_nimbra340()	(machine_arch_type == MACH_TYPE_NIMBRA340)
+#else
+# define machine_is_nimbra340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC22XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC22XX
+# endif
+# define machine_is_lpc22xx()	(machine_arch_type == MACH_TYPE_LPC22XX)
+#else
+# define machine_is_lpc22xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET3
+# endif
+# define machine_is_omap_comet3()	(machine_arch_type == MACH_TYPE_COMET3)
+#else
+# define machine_is_omap_comet3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET4
+# endif
+# define machine_is_omap_comet4()	(machine_arch_type == MACH_TYPE_COMET4)
+#else
+# define machine_is_omap_comet4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB625
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB625
+# endif
+# define machine_is_csb625()	(machine_arch_type == MACH_TYPE_CSB625)
+#else
+# define machine_is_csb625()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FORTUNET2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET2
+# endif
+# define machine_is_fortunet2()	(machine_arch_type == MACH_TYPE_FORTUNET2)
+#else
+# define machine_is_fortunet2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5H2200
+# endif
+# define machine_is_s5h2200()	(machine_arch_type == MACH_TYPE_S5H2200)
+#else
+# define machine_is_s5h2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTORM920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTORM920
+# endif
+# define machine_is_optorm920()	(machine_arch_type == MACH_TYPE_OPTORM920)
+#else
+# define machine_is_optorm920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSBITSYXB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYXB
+# endif
+# define machine_is_adsbitsyxb()	(machine_arch_type == MACH_TYPE_ADSBITSYXB)
+#else
+# define machine_is_adsbitsyxb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSPORTAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSPORTAL
+# endif
+# define machine_is_adsportal()	(machine_arch_type == MACH_TYPE_ADSPORTAL)
+#else
+# define machine_is_adsportal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LN2410SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LN2410SBC
+# endif
+# define machine_is_ln2410sbc()	(machine_arch_type == MACH_TYPE_LN2410SBC)
+#else
+# define machine_is_ln2410sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CB3RUFC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CB3RUFC
+# endif
+# define machine_is_cb3rufc()	(machine_arch_type == MACH_TYPE_CB3RUFC)
+#else
+# define machine_is_cb3rufc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP2USB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP2USB
+# endif
+# define machine_is_mp2usb()	(machine_arch_type == MACH_TYPE_MP2USB)
+#else
+# define machine_is_mp2usb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NTNP425C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTNP425C
+# endif
+# define machine_is_ntnp425c()	(machine_arch_type == MACH_TYPE_NTNP425C)
+#else
+# define machine_is_ntnp425c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM7220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7220
+# endif
+# define machine_is_pcm7220()	(machine_arch_type == MACH_TYPE_PCM7220)
+#else
+# define machine_is_pcm7220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA
+# endif
+# define machine_is_cmpxa()	(machine_arch_type == MACH_TYPE_CMPXA)
+#else
+# define machine_is_cmpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ITE8152
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITE8152
+# endif
+# define machine_is_ite8152()	(machine_arch_type == MACH_TYPE_ITE8152)
+#else
+# define machine_is_ite8152()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC3XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC3XXX
+# endif
+# define machine_is_lpc3xxx()	(machine_arch_type == MACH_TYPE_LPC3XXX)
+#else
+# define machine_is_lpc3xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUPPETEER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPETEER
+# endif
+# define machine_is_puppeteer()	(machine_arch_type == MACH_TYPE_PUPPETEER)
+#else
+# define machine_is_puppeteer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_VADATECH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_VADATECH
+# endif
+# define machine_is_vt001()	(machine_arch_type == MACH_TYPE_MACH_VADATECH)
+#else
+# define machine_is_vt001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E570
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E570
+# endif
+# define machine_is_e570()	(machine_arch_type == MACH_TYPE_E570)
+#else
+# define machine_is_e570()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X50
+# endif
+# define machine_is_x50()	(machine_arch_type == MACH_TYPE_X50)
+#else
+# define machine_is_x50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECON
+# endif
+# define machine_is_recon()	(machine_arch_type == MACH_TYPE_RECON)
+#else
+# define machine_is_recon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XBOARDGP8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XBOARDGP8
+# endif
+# define machine_is_xboardgp8()	(machine_arch_type == MACH_TYPE_XBOARDGP8)
+#else
+# define machine_is_xboardgp8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FPIC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC2
+# endif
+# define machine_is_fpic2()	(machine_arch_type == MACH_TYPE_FPIC2)
+#else
+# define machine_is_fpic2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A81
+# endif
+# define machine_is_a81()	(machine_arch_type == MACH_TYPE_A81)
+#else
+# define machine_is_a81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVM_SC25X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVM_SC25X
+# endif
+# define machine_is_svm_sc25x()	(machine_arch_type == MACH_TYPE_SVM_SC25X)
+#else
+# define machine_is_svm_sc25x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VADATECH020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VADATECH020
+# endif
+# define machine_is_vt020()	(machine_arch_type == MACH_TYPE_VADATECH020)
+#else
+# define machine_is_vt020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TLI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TLI
+# endif
+# define machine_is_tli()	(machine_arch_type == MACH_TYPE_TLI)
+#else
+# define machine_is_tli()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315LC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315LC
+# endif
+# define machine_is_edb9315lc()	(machine_arch_type == MACH_TYPE_EDB9315LC)
+#else
+# define machine_is_edb9315lc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSEC
+# endif
+# define machine_is_passec()	(machine_arch_type == MACH_TYPE_PASSEC)
+#else
+# define machine_is_passec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS_TIGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS_TIGER
+# endif
+# define machine_is_ds_tiger()	(machine_arch_type == MACH_TYPE_DS_TIGER)
+#else
+# define machine_is_ds_tiger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E310
+# endif
+# define machine_is_e310()	(machine_arch_type == MACH_TYPE_E310)
+#else
+# define machine_is_e310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RT3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RT3000
+# endif
+# define machine_is_rt3000()	(machine_arch_type == MACH_TYPE_RT3000)
+#else
+# define machine_is_rt3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0106
+# endif
+# define machine_is_pnx0106()	(machine_arch_type == MACH_TYPE_PNX0106)
+#else
+# define machine_is_pnx0106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX21XX
+# endif
+# define machine_is_hx21xx()	(machine_arch_type == MACH_TYPE_HX21XX)
+#else
+# define machine_is_hx21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARADAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARADAY
+# endif
+# define machine_is_faraday()	(machine_arch_type == MACH_TYPE_FARADAY)
+#else
+# define machine_is_faraday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC9312
+# endif
+# define machine_is_sbc9312()	(machine_arch_type == MACH_TYPE_SBC9312)
+#else
+# define machine_is_sbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BATMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BATMAN
+# endif
+# define machine_is_batman()	(machine_arch_type == MACH_TYPE_BATMAN)
+#else
+# define machine_is_batman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JPD201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JPD201
+# endif
+# define machine_is_jpd201()	(machine_arch_type == MACH_TYPE_JPD201)
+#else
+# define machine_is_jpd201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIPSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIPSA
+# endif
+# define machine_is_mipsa()	(machine_arch_type == MACH_TYPE_MIPSA)
+#else
+# define machine_is_mipsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KACOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KACOM
+# endif
+# define machine_is_kacom()	(machine_arch_type == MACH_TYPE_KACOM)
+#else
+# define machine_is_kacom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOCPU
+# endif
+# define machine_is_swarcocpu()	(machine_arch_type == MACH_TYPE_SWARCOCPU)
+#else
+# define machine_is_swarcocpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCODSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCODSL
+# endif
+# define machine_is_swarcodsl()	(machine_arch_type == MACH_TYPE_SWARCODSL)
+#else
+# define machine_is_swarcodsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEANGEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEANGEL
+# endif
+# define machine_is_blueangel()	(machine_arch_type == MACH_TYPE_BLUEANGEL)
+#else
+# define machine_is_blueangel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAIRYGRAMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAIRYGRAMA
+# endif
+# define machine_is_hairygrama()	(machine_arch_type == MACH_TYPE_HAIRYGRAMA)
+#else
+# define machine_is_hairygrama()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BANFF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANFF
+# endif
+# define machine_is_banff()	(machine_arch_type == MACH_TYPE_BANFF)
+#else
+# define machine_is_banff()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM255
+# endif
+# define machine_is_sam255()	(machine_arch_type == MACH_TYPE_SAM255)
+#else
+# define machine_is_sam255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PPM10
+# endif
+# define machine_is_ppm10()	(machine_arch_type == MACH_TYPE_PPM10)
+#else
+# define machine_is_ppm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNSET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNSET
+# endif
+# define machine_is_sunset()	(machine_arch_type == MACH_TYPE_SUNSET)
+#else
+# define machine_is_sunset()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE2
+# endif
+# define machine_is_mainstone2()	(machine_arch_type == MACH_TYPE_MAINSTONE2)
+#else
+# define machine_is_mainstone2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_IXP42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_IXP42X
+# endif
+# define machine_is_ez_ixp42x()	(machine_arch_type == MACH_TYPE_EZ_IXP42X)
+#else
+# define machine_is_ez_ixp42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAPWAVE_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAPWAVE_ZODIAC
+# endif
+# define machine_is_tapwave_zodiac()	(machine_arch_type == MACH_TYPE_TAPWAVE_ZODIAC)
+#else
+# define machine_is_tapwave_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSALMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSALMETER
+# endif
+# define machine_is_universalmeter()	(machine_arch_type == MACH_TYPE_UNIVERSALMETER)
+#else
+# define machine_is_universalmeter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HICOARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HICOARM9
+# endif
+# define machine_is_hicoarm9()	(machine_arch_type == MACH_TYPE_HICOARM9)
+#else
+# define machine_is_hicoarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KWS6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KWS6000
+# endif
+# define machine_is_kws6000()	(machine_arch_type == MACH_TYPE_KWS6000)
+#else
+# define machine_is_kws6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUX920T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUX920T
+# endif
+# define machine_is_portux920t()	(machine_arch_type == MACH_TYPE_PORTUX920T)
+#else
+# define machine_is_portux920t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_X5
+# endif
+# define machine_is_ez_x5()	(machine_arch_type == MACH_TYPE_EZ_X5)
+#else
+# define machine_is_ez_x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_RUDOLPH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_RUDOLPH
+# endif
+# define machine_is_omap_rudolph()	(machine_arch_type == MACH_TYPE_OMAP_RUDOLPH)
+#else
+# define machine_is_omap_rudolph()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA9200
+# endif
+# define machine_is_rea9200()	(machine_arch_type == MACH_TYPE_REA9200)
+#else
+# define machine_is_rea9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTS_PUNE_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTS_PUNE_SA1110
+# endif
+# define machine_is_acts_pune_sa1110()	(machine_arch_type == MACH_TYPE_ACTS_PUNE_SA1110)
+#else
+# define machine_is_acts_pune_sa1110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425
+# endif
+# define machine_is_ixp425()	(machine_arch_type == MACH_TYPE_IXP425)
+#else
+# define machine_is_ixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I30030ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I30030ADS
+# endif
+# define machine_is_i30030ads()	(machine_arch_type == MACH_TYPE_I30030ADS)
+#else
+# define machine_is_i30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PERCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERCH
+# endif
+# define machine_is_perch()	(machine_arch_type == MACH_TYPE_PERCH)
+#else
+# define machine_is_perch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIS05R1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIS05R1
+# endif
+# define machine_is_eis05r1()	(machine_arch_type == MACH_TYPE_EIS05R1)
+#else
+# define machine_is_eis05r1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEPPERPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEPPERPAD
+# endif
+# define machine_is_pepperpad()	(machine_arch_type == MACH_TYPE_PEPPERPAD)
+#else
+# define machine_is_pepperpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SB3010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SB3010
+# endif
+# define machine_is_sb3010()	(machine_arch_type == MACH_TYPE_SB3010)
+#else
+# define machine_is_sb3010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RM9200
+# endif
+# define machine_is_rm9200()	(machine_arch_type == MACH_TYPE_RM9200)
+#else
+# define machine_is_rm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA03
+# endif
+# define machine_is_dma03()	(machine_arch_type == MACH_TYPE_DMA03)
+#else
+# define machine_is_dma03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROAD_S101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROAD_S101
+# endif
+# define machine_is_road_s101()	(machine_arch_type == MACH_TYPE_ROAD_S101)
+#else
+# define machine_is_road_s101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340SC
+# endif
+# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
+#else
+# define machine_is_iq81340sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_B
+# endif
+# define machine_is_iq_nextgen_b()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_B)
+#else
+# define machine_is_iq_nextgen_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340MC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340MC
+# endif
+# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
+#else
+# define machine_is_iq81340mc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_D
+# endif
+# define machine_is_iq_nextgen_d()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_D)
+#else
+# define machine_is_iq_nextgen_d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_E
+# endif
+# define machine_is_iq_nextgen_e()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_E)
+#else
+# define machine_is_iq_nextgen_e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MALLOW_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MALLOW_AT91
+# endif
+# define machine_is_mallow_at91()	(machine_arch_type == MACH_TYPE_MALLOW_AT91)
+#else
+# define machine_is_mallow_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_I
+# endif
+# define machine_is_cybertracker_i()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_I)
+#else
+# define machine_is_cybertracker_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC931X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC931X
+# endif
+# define machine_is_gesbc931x()	(machine_arch_type == MACH_TYPE_GESBC931X)
+#else
+# define machine_is_gesbc931x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTIPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTIPAD
+# endif
+# define machine_is_centipad()	(machine_arch_type == MACH_TYPE_CENTIPAD)
+#else
+# define machine_is_centipad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSOC
+# endif
+# define machine_is_armsoc()	(machine_arch_type == MACH_TYPE_ARMSOC)
+#else
+# define machine_is_armsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE4200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4200
+# endif
+# define machine_is_se4200()	(machine_arch_type == MACH_TYPE_SE4200)
+#else
+# define machine_is_se4200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMS197A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMS197A
+# endif
+# define machine_is_ems197a()	(machine_arch_type == MACH_TYPE_EMS197A)
+#else
+# define machine_is_ems197a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UC5471DSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UC5471DSP
+# endif
+# define machine_is_uc5471dsp()	(machine_arch_type == MACH_TYPE_UC5471DSP)
+#else
+# define machine_is_uc5471dsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SJ5471ENG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SJ5471ENG
+# endif
+# define machine_is_sj5471eng()	(machine_arch_type == MACH_TYPE_SJ5471ENG)
+#else
+# define machine_is_sj5471eng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA26X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA26X
+# endif
+# define machine_is_none()	(machine_arch_type == MACH_TYPE_CMPXA26X)
+#else
+# define machine_is_none()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NC
+# endif
+# define machine_is_nc1()	(machine_arch_type == MACH_TYPE_NC)
+#else
+# define machine_is_nc1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX52X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX52X
+# endif
+# define machine_is_ajax52x()	(machine_arch_type == MACH_TYPE_AJAX52X)
+#else
+# define machine_is_ajax52x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIRIUSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIRIUSTAR
+# endif
+# define machine_is_siriustar()	(machine_arch_type == MACH_TYPE_SIRIUSTAR)
+#else
+# define machine_is_siriustar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IODATA_HDLG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IODATA_HDLG
+# endif
+# define machine_is_iodata_hdlg()	(machine_arch_type == MACH_TYPE_IODATA_HDLG)
+#else
+# define machine_is_iodata_hdlg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200UTL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200UTL
+# endif
+# define machine_is_at91rm9200utl()	(machine_arch_type == MACH_TYPE_AT91RM9200UTL)
+#else
+# define machine_is_at91rm9200utl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIOSAFE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIOSAFE
+# endif
+# define machine_is_biosafe()	(machine_arch_type == MACH_TYPE_BIOSAFE)
+#else
+# define machine_is_biosafe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1000
+# endif
+# define machine_is_mp1000()	(machine_arch_type == MACH_TYPE_MP1000)
+#else
+# define machine_is_mp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PARSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PARSY
+# endif
+# define machine_is_parsy()	(machine_arch_type == MACH_TYPE_PARSY)
+#else
+# define machine_is_parsy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCXP
+# endif
+# define machine_is_ccxp270()	(machine_arch_type == MACH_TYPE_CCXP)
+#else
+# define machine_is_ccxp270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GSAMPLE
+# endif
+# define machine_is_omap_gsample()	(machine_arch_type == MACH_TYPE_OMAP_GSAMPLE)
+#else
+# define machine_is_omap_gsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMOA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMOA
+# endif
+# define machine_is_samoa()	(machine_arch_type == MACH_TYPE_SAMOA)
+#else
+# define machine_is_samoa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T3XSCALE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T3XSCALE
+# endif
+# define machine_is_t3xscale()	(machine_arch_type == MACH_TYPE_T3XSCALE)
+#else
+# define machine_is_t3xscale()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I878
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I878
+# endif
+# define machine_is_i878()	(machine_arch_type == MACH_TYPE_I878)
+#else
+# define machine_is_i878()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GECKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GECKO
+# endif
+# define machine_is_gecko()	(machine_arch_type == MACH_TYPE_GECKO)
+#else
+# define machine_is_gecko()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101
+# endif
+# define machine_is_ds101()	(machine_arch_type == MACH_TYPE_DS101)
+#else
+# define machine_is_ds101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT2
+# endif
+# define machine_is_omap_palmtt2()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT2)
+#else
+# define machine_is_omap_palmtt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMLD
+# endif
+# define machine_is_xscale_palmld()	(machine_arch_type == MACH_TYPE_XSCALE_PALMLD)
+#else
+# define machine_is_xscale_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9C
+# endif
+# define machine_is_cc9c()	(machine_arch_type == MACH_TYPE_CC9C)
+#else
+# define machine_is_cc9c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC1670
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC1670
+# endif
+# define machine_is_sbc1670()	(machine_arch_type == MACH_TYPE_SBC1670)
+#else
+# define machine_is_sbc1670()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML696K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML696K
+# endif
+# define machine_is_ml696k()	(machine_arch_type == MACH_TYPE_ML696K)
+#else
+# define machine_is_ml696k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAESTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAESTRO
+# endif
+# define machine_is_maestro()	(machine_arch_type == MACH_TYPE_MAESTRO)
+#else
+# define machine_is_maestro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUNGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUNGE2
+# endif
+# define machine_is_tunge2()	(machine_arch_type == MACH_TYPE_TUNGE2)
+#else
+# define machine_is_tunge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXBBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXBBM
+# endif
+# define machine_is_ixbbm()	(machine_arch_type == MACH_TYPE_IXBBM)
+#else
+# define machine_is_ixbbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27ADS
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX8004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX8004
+# endif
+# define machine_is_ax8004()	(machine_arch_type == MACH_TYPE_AX8004)
+#else
+# define machine_is_ax8004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGPIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGPIE
+# endif
+# define machine_is_magpie()	(machine_arch_type == MACH_TYPE_MAGPIE)
+#else
+# define machine_is_magpie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21ADS
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB87M3400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB87M3400
+# endif
+# define machine_is_mb87m3400()	(machine_arch_type == MACH_TYPE_MB87M3400)
+#else
+# define machine_is_mb87m3400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MGUARD_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MGUARD_DELTA
+# endif
+# define machine_is_mguard_delta()	(machine_arch_type == MACH_TYPE_MGUARD_DELTA)
+#else
+# define machine_is_mguard_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DVDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DVDP
+# endif
+# define machine_is_davinci_dvdp()	(machine_arch_type == MACH_TYPE_DAVINCI_DVDP)
+#else
+# define machine_is_davinci_dvdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCUNIVERSAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCUNIVERSAL
+# endif
+# define machine_is_htcuniversal()	(machine_arch_type == MACH_TYPE_HTCUNIVERSAL)
+#else
+# define machine_is_htcuniversal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPAD
+# endif
+# define machine_is_tpad()	(machine_arch_type == MACH_TYPE_TPAD)
+#else
+# define machine_is_tpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP3
+# endif
+# define machine_is_roverp3()	(machine_arch_type == MACH_TYPE_ROVERP3)
+#else
+# define machine_is_roverp3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JORNADA928
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA928
+# endif
+# define machine_is_jornada928()	(machine_arch_type == MACH_TYPE_JORNADA928)
+#else
+# define machine_is_jornada928()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88FXX81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88FXX81
+# endif
+# define machine_is_mv88fxx81()	(machine_arch_type == MACH_TYPE_MV88FXX81)
+#else
+# define machine_is_mv88fxx81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP36XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP36XX
+# endif
+# define machine_is_stmp36xx()	(machine_arch_type == MACH_TYPE_STMP36XX)
+#else
+# define machine_is_stmp36xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SXNI79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SXNI79524
+# endif
+# define machine_is_sxni79524()	(machine_arch_type == MACH_TYPE_SXNI79524)
+#else
+# define machine_is_sxni79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_URANIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_URANIUM
+# endif
+# define machine_is_uranium()	(machine_arch_type == MACH_TYPE_URANIUM)
+#else
+# define machine_is_uranium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCON
+# endif
+# define machine_is_ucon()	(machine_arch_type == MACH_TYPE_UCON)
+#else
+# define machine_is_ucon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_L083_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L083_1000
+# endif
+# define machine_is_l083()	(machine_arch_type == MACH_TYPE_L083_1000)
+#else
+# define machine_is_l083()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX
+# endif
+# define machine_is_ezx()	(machine_arch_type == MACH_TYPE_EZX)
+#else
+# define machine_is_ezx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX5220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX5220
+# endif
+# define machine_is_pnx5220()	(machine_arch_type == MACH_TYPE_PNX5220)
+#else
+# define machine_is_pnx5220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUTTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUTTE
+# endif
+# define machine_is_butte()	(machine_arch_type == MACH_TYPE_BUTTE)
+#else
+# define machine_is_butte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SRM2
+# endif
+# define machine_is_srm2()	(machine_arch_type == MACH_TYPE_SRM2)
+#else
+# define machine_is_srm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSBR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSBR
+# endif
+# define machine_is_dsbr()	(machine_arch_type == MACH_TYPE_DSBR)
+#else
+# define machine_is_dsbr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRYSTALBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRYSTALBALL
+# endif
+# define machine_is_crystalball()	(machine_arch_type == MACH_TYPE_CRYSTALBALL)
+#else
+# define machine_is_crystalball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINYPXA27X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINYPXA27X
+# endif
+# define machine_is_tinypxa27x()	(machine_arch_type == MACH_TYPE_TINYPXA27X)
+#else
+# define machine_is_tinypxa27x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERBIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERBIE
+# endif
+# define machine_is_herbie()	(machine_arch_type == MACH_TYPE_HERBIE)
+#else
+# define machine_is_herbie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4002
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4002
+# endif
+# define machine_is_cm4002()	(machine_arch_type == MACH_TYPE_CM4002)
+#else
+# define machine_is_cm4002()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B4
+# endif
+# define machine_is_b4()	(machine_arch_type == MACH_TYPE_B4)
+#else
+# define machine_is_b4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAUI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAUI
+# endif
+# define machine_is_maui()	(machine_arch_type == MACH_TYPE_MAUI)
+#else
+# define machine_is_maui()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_G
+# endif
+# define machine_is_cybertracker_g()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_G)
+#else
+# define machine_is_cybertracker_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIO8390
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIO8390
+# endif
+# define machine_is_mio8390()	(machine_arch_type == MACH_TYPE_MIO8390)
+#else
+# define machine_is_mio8390()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMI_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMI_BOARD
+# endif
+# define machine_is_omi_board()	(machine_arch_type == MACH_TYPE_OMI_BOARD)
+#else
+# define machine_is_omi_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21CIV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21CIV
+# endif
+# define machine_is_mx21civ()	(machine_arch_type == MACH_TYPE_MX21CIV)
+#else
+# define machine_is_mx21civ()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHI_CDAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHI_CDAC
+# endif
+# define machine_is_mahi_cdac()	(machine_arch_type == MACH_TYPE_MAHI_CDAC)
+#else
+# define machine_is_mahi_cdac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTX
+# endif
+# define machine_is_xscale_palmtx()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTX)
+#else
+# define machine_is_xscale_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMSYS_EP0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMSYS_EP0
+# endif
+# define machine_is_samsys_ep0()	(machine_arch_type == MACH_TYPE_SAMSYS_EP0)
+#else
+# define machine_is_samsys_ep0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V1
+# endif
+# define machine_is_wg302v1()	(machine_arch_type == MACH_TYPE_WG302V1)
+#else
+# define machine_is_wg302v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB42X
+# endif
+# define machine_is_eb42x()	(machine_arch_type == MACH_TYPE_EB42X)
+#else
+# define machine_is_eb42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ331ES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ331ES
+# endif
+# define machine_is_iq331es()	(machine_arch_type == MACH_TYPE_IQ331ES)
+#else
+# define machine_is_iq331es()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COSYDSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COSYDSP
+# endif
+# define machine_is_cosydsp()	(machine_arch_type == MACH_TYPE_COSYDSP)
+#else
+# define machine_is_cosydsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UPLAT7D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UPLAT7D
+# endif
+# define machine_is_uplat7d_proto()	(machine_arch_type == MACH_TYPE_UPLAT7D)
+#else
+# define machine_is_uplat7d_proto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTDAVINCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTDAVINCI
+# endif
+# define machine_is_ptdavinci()	(machine_arch_type == MACH_TYPE_PTDAVINCI)
+#else
+# define machine_is_ptdavinci()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBUS
+# endif
+# define machine_is_mbus()	(machine_arch_type == MACH_TYPE_MBUS)
+#else
+# define machine_is_mbus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NADIA2VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NADIA2VB
+# endif
+# define machine_is_nadia2vb()	(machine_arch_type == MACH_TYPE_NADIA2VB)
+#else
+# define machine_is_nadia2vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1000
+# endif
+# define machine_is_r1000()	(machine_arch_type == MACH_TYPE_R1000)
+#else
+# define machine_is_r1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90250
+# endif
+# define machine_is_hw90250()	(machine_arch_type == MACH_TYPE_HW90250)
+#else
+# define machine_is_hw90250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TORNADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TORNADO
+# endif
+# define machine_is_omap_tornado()	(machine_arch_type == MACH_TYPE_OMAP_TORNADO)
+#else
+# define machine_is_omap_tornado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLOCREEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLOCREEK
+# endif
+# define machine_is_olocreek()	(machine_arch_type == MACH_TYPE_OLOCREEK)
+#else
+# define machine_is_olocreek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF9328
+# endif
+# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
+#else
+# define machine_is_apf9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_WIPOQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_WIPOQ
+# endif
+# define machine_is_omap_wipoq()	(machine_arch_type == MACH_TYPE_OMAP_WIPOQ)
+#else
+# define machine_is_omap_wipoq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TWIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TWIP
+# endif
+# define machine_is_omap_twip()	(machine_arch_type == MACH_TYPE_OMAP_TWIP)
+#else
+# define machine_is_omap_twip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTREO650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTREO650
+# endif
+# define machine_is_xscale_treo650()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTREO650)
+#else
+# define machine_is_xscale_treo650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACUMEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACUMEN
+# endif
+# define machine_is_acumen()	(machine_arch_type == MACH_TYPE_ACUMEN)
+#else
+# define machine_is_acumen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XP100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP100
+# endif
+# define machine_is_xp100()	(machine_arch_type == MACH_TYPE_XP100)
+#else
+# define machine_is_xp100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FS2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FS2410
+# endif
+# define machine_is_fs2410()	(machine_arch_type == MACH_TYPE_FS2410)
+#else
+# define machine_is_fs2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA270_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA270_CERF
+# endif
+# define machine_is_pxa270_cerf()	(machine_arch_type == MACH_TYPE_PXA270_CERF)
+#else
+# define machine_is_pxa270_cerf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SQ2FTLPALM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SQ2FTLPALM
+# endif
+# define machine_is_sq2ftlpalm()	(machine_arch_type == MACH_TYPE_SQ2FTLPALM)
+#else
+# define machine_is_sq2ftlpalm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSEMSERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSEMSERVER
+# endif
+# define machine_is_bsemserver()	(machine_arch_type == MACH_TYPE_BSEMSERVER)
+#else
+# define machine_is_bsemserver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETCLIENT
+# endif
+# define machine_is_netclient()	(machine_arch_type == MACH_TYPE_NETCLIENT)
+#else
+# define machine_is_netclient()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTT5
+# endif
+# define machine_is_xscale_palmtt5()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTT5)
+#else
+# define machine_is_xscale_palmtt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTC
+# endif
+# define machine_is_xscale_palmtc()	(machine_arch_type == MACH_TYPE_OMAP_PALMTC)
+#else
+# define machine_is_xscale_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030EVB
+# endif
+# define machine_is_mxc30030evb()	(machine_arch_type == MACH_TYPE_MXC30030EVB)
+#else
+# define machine_is_mxc30030evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA_2D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_2D
+# endif
+# define machine_is_rea_2d()	(machine_arch_type == MACH_TYPE_REA_2D)
+#else
+# define machine_is_rea_2d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI3E524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI3E524
+# endif
+# define machine_is_eti3e524()	(machine_arch_type == MACH_TYPE_TI3E524)
+#else
+# define machine_is_eti3e524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AUCKLAND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUCKLAND
+# endif
+# define machine_is_auckland()	(machine_arch_type == MACH_TYPE_AUCKLAND)
+#else
+# define machine_is_auckland()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AK3320M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AK3320M
+# endif
+# define machine_is_ak3220m()	(machine_arch_type == MACH_TYPE_AK3320M)
+#else
+# define machine_is_ak3220m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DURAMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DURAMAX
+# endif
+# define machine_is_duramax()	(machine_arch_type == MACH_TYPE_DURAMAX)
+#else
+# define machine_is_duramax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRONGHORN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRONGHORN
+# endif
+# define machine_is_pronghorn()	(machine_arch_type == MACH_TYPE_PRONGHORN)
+#else
+# define machine_is_pronghorn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUNDY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUNDY
+# endif
+# define machine_is_fundy()	(machine_arch_type == MACH_TYPE_FUNDY)
+#else
+# define machine_is_fundy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPU777
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU777
+# endif
+# define machine_is_cpu777()	(machine_arch_type == MACH_TYPE_CPU777)
+#else
+# define machine_is_cpu777()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMICON9201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMICON9201
+# endif
+# define machine_is_simicon9201()	(machine_arch_type == MACH_TYPE_SIMICON9201)
+#else
+# define machine_is_simicon9201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEAP2_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEAP2_HPM
+# endif
+# define machine_is_leap2_hpm()	(machine_arch_type == MACH_TYPE_LEAP2_HPM)
+#else
+# define machine_is_leap2_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM922TXA10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM922TXA10
+# endif
+# define machine_is_cm922txa10()	(machine_arch_type == MACH_TYPE_CM922TXA10)
+#else
+# define machine_is_cm922txa10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA
+# endif
+# define machine_is_sandgate()	(machine_arch_type == MACH_TYPE_PXA)
+#else
+# define machine_is_sandgate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2
+# endif
+# define machine_is_sandgate2()	(machine_arch_type == MACH_TYPE_SANDGATE2)
+#else
+# define machine_is_sandgate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2G
+# endif
+# define machine_is_sandgate2g()	(machine_arch_type == MACH_TYPE_SANDGATE2G)
+#else
+# define machine_is_sandgate2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2P
+# endif
+# define machine_is_sandgate2p()	(machine_arch_type == MACH_TYPE_SANDGATE2P)
+#else
+# define machine_is_sandgate2p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRED_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRED_JACK
+# endif
+# define machine_is_fred_jack()	(machine_arch_type == MACH_TYPE_FRED_JACK)
+#else
+# define machine_is_fred_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTG_COLOR1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTG_COLOR1
+# endif
+# define machine_is_ttg_color1()	(machine_arch_type == MACH_TYPE_TTG_COLOR1)
+#else
+# define machine_is_ttg_color1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU8
+# endif
+# define machine_is_netdcu8()	(machine_arch_type == MACH_TYPE_NETDCU8)
+#else
+# define machine_is_netdcu8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML675050_CPU_BOA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML675050_CPU_BOA
+# endif
+# define machine_is_ml675050_cpu_boa()	(machine_arch_type == MACH_TYPE_ML675050_CPU_BOA)
+#else
+# define machine_is_ml675050_cpu_boa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVX538
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVX538
+# endif
+# define machine_is_ng_fvx538()	(machine_arch_type == MACH_TYPE_NG_FVX538)
+#else
+# define machine_is_ng_fvx538()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVS338
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVS338
+# endif
+# define machine_is_ng_fvs338()	(machine_arch_type == MACH_TYPE_NG_FVS338)
+#else
+# define machine_is_ng_fvs338()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4103
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4103
+# endif
+# define machine_is_pnx4103()	(machine_arch_type == MACH_TYPE_PNX4103)
+#else
+# define machine_is_pnx4103()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HESDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HESDB
+# endif
+# define machine_is_hesdb()	(machine_arch_type == MACH_TYPE_HESDB)
+#else
+# define machine_is_hesdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSILO
+# endif
+# define machine_is_xsilo()	(machine_arch_type == MACH_TYPE_XSILO)
+#else
+# define machine_is_xsilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMLC
+# endif
+# define machine_is_emlc()	(machine_arch_type == MACH_TYPE_EMLC)
+#else
+# define machine_is_emlc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SISTERON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SISTERON
+# endif
+# define machine_is_sisteron()	(machine_arch_type == MACH_TYPE_SISTERON)
+#else
+# define machine_is_sisteron()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSC_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSC_VENUS
+# endif
+# define machine_is_tsc_venus()	(machine_arch_type == MACH_TYPE_TSC_VENUS)
+#else
+# define machine_is_tsc_venus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101J
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101J
+# endif
+# define machine_is_ds101j()	(machine_arch_type == MACH_TYPE_DS101J)
+#else
+# define machine_is_ds101j()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030ADS
+# endif
+# define machine_is_mxc30030ads()	(machine_arch_type == MACH_TYPE_MXC30030ADS)
+#else
+# define machine_is_mxc30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJITSU_WIMAXSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_WIMAXSOC
+# endif
+# define machine_is_fujitsu_wimaxsoc()	(machine_arch_type == MACH_TYPE_FUJITSU_WIMAXSOC)
+#else
+# define machine_is_fujitsu_wimaxsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DUALPCMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DUALPCMODEM
+# endif
+# define machine_is_dualpcmodem()	(machine_arch_type == MACH_TYPE_DUALPCMODEM)
+#else
+# define machine_is_dualpcmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCAPACHE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCAPACHE
+# endif
+# define machine_is_htcapache()	(machine_arch_type == MACH_TYPE_HTCAPACHE)
+#else
+# define machine_is_htcapache()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP435
+# endif
+# define machine_is_ixdp435()	(machine_arch_type == MACH_TYPE_IXDP435)
+#else
+# define machine_is_ixdp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CATPROVT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATPROVT100
+# endif
+# define machine_is_catprovt100()	(machine_arch_type == MACH_TYPE_CATPROVT100)
+#else
+# define machine_is_catprovt100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX1XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX1XX
+# endif
+# define machine_is_picotux1xx()	(machine_arch_type == MACH_TYPE_PICOTUX1XX)
+#else
+# define machine_is_picotux1xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPC2
+# endif
+# define machine_is_empc2()	(machine_arch_type == MACH_TYPE_EMPC2)
+#else
+# define machine_is_empc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VENTURA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENTURA
+# endif
+# define machine_is_ventura()	(machine_arch_type == MACH_TYPE_VENTURA)
+#else
+# define machine_is_ventura()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC
+# endif
+# define machine_is_phidget_sbc()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC)
+#else
+# define machine_is_phidget_sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IJ3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IJ3K
+# endif
+# define machine_is_ij3k()	(machine_arch_type == MACH_TYPE_IJ3K)
+#else
+# define machine_is_ij3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PISGAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PISGAH
+# endif
+# define machine_is_pisgah()	(machine_arch_type == MACH_TYPE_PISGAH)
+#else
+# define machine_is_pisgah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG720
+# endif
+# define machine_is_sg720()	(machine_arch_type == MACH_TYPE_SG720)
+#else
+# define machine_is_sg720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REDFOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REDFOX
+# endif
+# define machine_is_redfox()	(machine_arch_type == MACH_TYPE_REDFOX)
+#else
+# define machine_is_redfox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MYSH_EP9315_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MYSH_EP9315_1
+# endif
+# define machine_is_mysh_ep9315_1()	(machine_arch_type == MACH_TYPE_MYSH_EP9315_1)
+#else
+# define machine_is_mysh_ep9315_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPF106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPF106
+# endif
+# define machine_is_tpf106()	(machine_arch_type == MACH_TYPE_TPF106)
+#else
+# define machine_is_tpf106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KG
+# endif
+# define machine_is_at91rm9200kg()	(machine_arch_type == MACH_TYPE_AT91RM9200KG)
+#else
+# define machine_is_at91rm9200kg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLEDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLEDB
+# endif
+# define machine_is_rcmt2()	(machine_arch_type == MACH_TYPE_SLEDB)
+#else
+# define machine_is_rcmt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONTRACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONTRACK
+# endif
+# define machine_is_ontrack()	(machine_arch_type == MACH_TYPE_ONTRACK)
+#else
+# define machine_is_ontrack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM1200
+# endif
+# define machine_is_pm1200()	(machine_arch_type == MACH_TYPE_PM1200)
+#else
+# define machine_is_pm1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS24XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS24XXX
+# endif
+# define machine_is_ess24562()	(machine_arch_type == MACH_TYPE_ESS24XXX)
+#else
+# define machine_is_ess24562()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COREMP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COREMP7
+# endif
+# define machine_is_coremp7()	(machine_arch_type == MACH_TYPE_COREMP7)
+#else
+# define machine_is_coremp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_6446
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_6446
+# endif
+# define machine_is_nexcoder_6446()	(machine_arch_type == MACH_TYPE_NEXCODER_6446)
+#else
+# define machine_is_nexcoder_6446()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STVC8380
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STVC8380
+# endif
+# define machine_is_stvc8380()	(machine_arch_type == MACH_TYPE_STVC8380)
+#else
+# define machine_is_stvc8380()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEKLYNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEKLYNX
+# endif
+# define machine_is_teklynx()	(machine_arch_type == MACH_TYPE_TEKLYNX)
+#else
+# define machine_is_teklynx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARBONADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARBONADO
+# endif
+# define machine_is_carbonado()	(machine_arch_type == MACH_TYPE_CARBONADO)
+#else
+# define machine_is_carbonado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYSMOS_MP730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYSMOS_MP730
+# endif
+# define machine_is_sysmos_mp730()	(machine_arch_type == MACH_TYPE_SYSMOS_MP730)
+#else
+# define machine_is_sysmos_mp730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PGIGIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PGIGIM
+# endif
+# define machine_is_pgigim()	(machine_arch_type == MACH_TYPE_PGIGIM)
+#else
+# define machine_is_pgigim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX9160P2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX9160P2
+# endif
+# define machine_is_ptx9160p2()	(machine_arch_type == MACH_TYPE_PTX9160P2)
+#else
+# define machine_is_ptx9160p2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DCORE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DCORE1
+# endif
+# define machine_is_dcore1()	(machine_arch_type == MACH_TYPE_DCORE1)
+#else
+# define machine_is_dcore1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VICTORPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTORPXA
+# endif
+# define machine_is_victorpxa()	(machine_arch_type == MACH_TYPE_VICTORPXA)
+#else
+# define machine_is_victorpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2DTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2DTB
+# endif
+# define machine_is_mx2dtb()	(machine_arch_type == MACH_TYPE_MX2DTB)
+#else
+# define machine_is_mx2dtb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_IREX_ER0100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IREX_ER0100
+# endif
+# define machine_is_pxa_irex_er0100()	(machine_arch_type == MACH_TYPE_PXA_IREX_ER0100)
+#else
+# define machine_is_pxa_irex_er0100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_DEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_DEG
+# endif
+# define machine_is_bartec_deg()	(machine_arch_type == MACH_TYPE_BARTEC_DEG)
+#else
+# define machine_is_bartec_deg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW50251
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW50251
+# endif
+# define machine_is_hw50251()	(machine_arch_type == MACH_TYPE_HW50251)
+#else
+# define machine_is_hw50251()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IBOX
+# endif
+# define machine_is_ibox()	(machine_arch_type == MACH_TYPE_IBOX)
+#else
+# define machine_is_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLASLH7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLASLH7A404
+# endif
+# define machine_is_atlaslh7a404()	(machine_arch_type == MACH_TYPE_ATLASLH7A404)
+#else
+# define machine_is_atlaslh7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PT2026
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT2026
+# endif
+# define machine_is_pt2026()	(machine_arch_type == MACH_TYPE_PT2026)
+#else
+# define machine_is_pt2026()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCALPINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCALPINE
+# endif
+# define machine_is_htcalpine()	(machine_arch_type == MACH_TYPE_HTCALPINE)
+#else
+# define machine_is_htcalpine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_VTU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_VTU
+# endif
+# define machine_is_bartec_vtu()	(machine_arch_type == MACH_TYPE_BARTEC_VTU)
+#else
+# define machine_is_bartec_vtu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCOREII
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCOREII
+# endif
+# define machine_is_vcoreii()	(machine_arch_type == MACH_TYPE_VCOREII)
+#else
+# define machine_is_vcoreii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDNB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDNB3
+# endif
+# define machine_is_pdnb3()	(machine_arch_type == MACH_TYPE_PDNB3)
+#else
+# define machine_is_pdnb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCBEETLES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCBEETLES
+# endif
+# define machine_is_htcbeetles()	(machine_arch_type == MACH_TYPE_HTCBEETLES)
+#else
+# define machine_is_htcbeetles()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C6400
+# endif
+# define machine_is_s3c6400()	(machine_arch_type == MACH_TYPE_S3C6400)
+#else
+# define machine_is_s3c6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2443
+# endif
+# define machine_is_s3c2443()	(machine_arch_type == MACH_TYPE_S3C2443)
+#else
+# define machine_is_s3c2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDK
+# endif
+# define machine_is_omap_ldk()	(machine_arch_type == MACH_TYPE_OMAP_LDK)
+#else
+# define machine_is_omap_ldk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2460
+# endif
+# define machine_is_smdk2460()	(machine_arch_type == MACH_TYPE_SMDK2460)
+#else
+# define machine_is_smdk2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2440
+# endif
+# define machine_is_smdk2440()	(machine_arch_type == MACH_TYPE_SMDK2440)
+#else
+# define machine_is_smdk2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBBOX
+# endif
+# define machine_is_webbox()	(machine_arch_type == MACH_TYPE_WEBBOX)
+#else
+# define machine_is_webbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWWNDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWWNDP
+# endif
+# define machine_is_cwwndp()	(machine_arch_type == MACH_TYPE_CWWNDP)
+#else
+# define machine_is_cwwndp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON
+# endif
+# define machine_is_i839()	(machine_arch_type == MACH_TYPE_DRAGON)
+#else
+# define machine_is_i839()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENDO_CPU_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENDO_CPU_BOARD
+# endif
+# define machine_is_opendo_cpu_board()	(machine_arch_type == MACH_TYPE_OPENDO_CPU_BOARD)
+#else
+# define machine_is_opendo_cpu_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCM2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCM2200
+# endif
+# define machine_is_ccm2200()	(machine_arch_type == MACH_TYPE_CCM2200)
+#else
+# define machine_is_ccm2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETWARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETWARM
+# endif
+# define machine_is_etwarm()	(machine_arch_type == MACH_TYPE_ETWARM)
+#else
+# define machine_is_etwarm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M93030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M93030
+# endif
+# define machine_is_m93030()	(machine_arch_type == MACH_TYPE_M93030)
+#else
+# define machine_is_m93030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC7U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC7U
+# endif
+# define machine_is_cc7u()	(machine_arch_type == MACH_TYPE_CC7U)
+#else
+# define machine_is_cc7u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT_RANGER
+# endif
+# define machine_is_mtt_ranger()	(machine_arch_type == MACH_TYPE_MTT_RANGER)
+#else
+# define machine_is_mtt_ranger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUS
+# endif
+# define machine_is_nexus()	(machine_arch_type == MACH_TYPE_NEXUS)
+#else
+# define machine_is_nexus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DESMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DESMAN
+# endif
+# define machine_is_desman()	(machine_arch_type == MACH_TYPE_DESMAN)
+#else
+# define machine_is_desman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BKDE303
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BKDE303
+# endif
+# define machine_is_bkde303()	(machine_arch_type == MACH_TYPE_BKDE303)
+#else
+# define machine_is_bkde303()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M7200
+# endif
+# define machine_is_aml_m7200()	(machine_arch_type == MACH_TYPE_AML_M7200)
+#else
+# define machine_is_aml_m7200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG640
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG640
+# endif
+# define machine_is_sg640()	(machine_arch_type == MACH_TYPE_SG640)
+#else
+# define machine_is_sg640()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDG79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDG79524
+# endif
+# define machine_is_edg79524()	(machine_arch_type == MACH_TYPE_EDG79524)
+#else
+# define machine_is_edg79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AI2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AI2410
+# endif
+# define machine_is_ai2410()	(machine_arch_type == MACH_TYPE_AI2410)
+#else
+# define machine_is_ai2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP465
+# endif
+# define machine_is_ixp465()	(machine_arch_type == MACH_TYPE_IXP465)
+#else
+# define machine_is_ixp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HEINS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HEINS
+# endif
+# define machine_is_heins()	(machine_arch_type == MACH_TYPE_HEINS)
+#else
+# define machine_is_heins()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPLUSEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPLUSEVA
+# endif
+# define machine_is_mpluseva()	(machine_arch_type == MACH_TYPE_MPLUSEVA)
+#else
+# define machine_is_mpluseva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RT042
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RT042
+# endif
+# define machine_is_rt042()	(machine_arch_type == MACH_TYPE_RT042)
+#else
+# define machine_is_rt042()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWIEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWIEM
+# endif
+# define machine_is_cwiem()	(machine_arch_type == MACH_TYPE_CWIEM)
+#else
+# define machine_is_cwiem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X270
+# endif
+# define machine_is_cm_x270()	(machine_arch_type == MACH_TYPE_CM_X270)
+#else
+# define machine_is_cm_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X255
+# endif
+# define machine_is_cm_x255()	(machine_arch_type == MACH_TYPE_CM_X255)
+#else
+# define machine_is_cm_x255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESH_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESH_AT91
+# endif
+# define machine_is_esh_at91()	(machine_arch_type == MACH_TYPE_ESH_AT91)
+#else
+# define machine_is_esh_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE3
+# endif
+# define machine_is_sandgate3()	(machine_arch_type == MACH_TYPE_SANDGATE3)
+#else
+# define machine_is_sandgate3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMO
+# endif
+# define machine_is_primo()	(machine_arch_type == MACH_TYPE_PRIMO)
+#else
+# define machine_is_primo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMSTONE
+# endif
+# define machine_is_gemstone()	(machine_arch_type == MACH_TYPE_GEMSTONE)
+#else
+# define machine_is_gemstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRONGHORNMETRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRONGHORNMETRO
+# endif
+# define machine_is_pronghorn_metro()	(machine_arch_type == MACH_TYPE_PRONGHORNMETRO)
+#else
+# define machine_is_pronghorn_metro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIDEWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEWINDER
+# endif
+# define machine_is_sidewinder()	(machine_arch_type == MACH_TYPE_SIDEWINDER)
+#else
+# define machine_is_sidewinder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOMOD1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOMOD1
+# endif
+# define machine_is_picomod1()	(machine_arch_type == MACH_TYPE_PICOMOD1)
+#else
+# define machine_is_picomod1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG590
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG590
+# endif
+# define machine_is_sg590()	(machine_arch_type == MACH_TYPE_SG590)
+#else
+# define machine_is_sg590()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKAI9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKAI9307
+# endif
+# define machine_is_akai9307()	(machine_arch_type == MACH_TYPE_AKAI9307)
+#else
+# define machine_is_akai9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FONTAINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FONTAINE
+# endif
+# define machine_is_fontaine()	(machine_arch_type == MACH_TYPE_FONTAINE)
+#else
+# define machine_is_fontaine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WOMBAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WOMBAT
+# endif
+# define machine_is_wombat()	(machine_arch_type == MACH_TYPE_WOMBAT)
+#else
+# define machine_is_wombat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ300
+# endif
+# define machine_is_acq300()	(machine_arch_type == MACH_TYPE_ACQ300)
+#else
+# define machine_is_acq300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOD_270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOD_270
+# endif
+# define machine_is_mod272()	(machine_arch_type == MACH_TYPE_MOD_270)
+#else
+# define machine_is_mod272()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC0820
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC0820
+# endif
+# define machine_is_vmc_vc0820()	(machine_arch_type == MACH_TYPE_VC0820)
+#else
+# define machine_is_vmc_vc0820()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANI_AIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANI_AIM
+# endif
+# define machine_is_ani_aim()	(machine_arch_type == MACH_TYPE_ANI_AIM)
+#else
+# define machine_is_ani_aim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JELLYFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JELLYFISH
+# endif
+# define machine_is_jellyfish()	(machine_arch_type == MACH_TYPE_JELLYFISH)
+#else
+# define machine_is_jellyfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMANITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMANITA
+# endif
+# define machine_is_amanita()	(machine_arch_type == MACH_TYPE_AMANITA)
+#else
+# define machine_is_amanita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VLINK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VLINK
+# endif
+# define machine_is_vlink()	(machine_arch_type == MACH_TYPE_VLINK)
+#else
+# define machine_is_vlink()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEXFLEX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEXFLEX
+# endif
+# define machine_is_dexflex()	(machine_arch_type == MACH_TYPE_DEXFLEX)
+#else
+# define machine_is_dexflex()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIGEN_TTQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIGEN_TTQ
+# endif
+# define machine_is_eigen_ttq()	(machine_arch_type == MACH_TYPE_EIGEN_TTQ)
+#else
+# define machine_is_eigen_ttq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_TITAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_TITAN
+# endif
+# define machine_is_arcom_titan()	(machine_arch_type == MACH_TYPE_ARCOM_TITAN)
+#else
+# define machine_is_arcom_titan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TABLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TABLA
+# endif
+# define machine_is_tabla()	(machine_arch_type == MACH_TYPE_TABLA)
+#else
+# define machine_is_tabla()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MDIRAC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MDIRAC3
+# endif
+# define machine_is_mdirac3()	(machine_arch_type == MACH_TYPE_MDIRAC3)
+#else
+# define machine_is_mdirac3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRHFBP2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRHFBP2
+# endif
+# define machine_is_mrhfbp2()	(machine_arch_type == MACH_TYPE_MRHFBP2)
+#else
+# define machine_is_mrhfbp2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200RB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200RB
+# endif
+# define machine_is_at91rm9200rb()	(machine_arch_type == MACH_TYPE_AT91RM9200RB)
+#else
+# define machine_is_at91rm9200rb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANI_APM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANI_APM
+# endif
+# define machine_is_ani_apm()	(machine_arch_type == MACH_TYPE_ANI_APM)
+#else
+# define machine_is_ani_apm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELLA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELLA1
+# endif
+# define machine_is_ella1()	(machine_arch_type == MACH_TYPE_ELLA1)
+#else
+# define machine_is_ella1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_PXA27X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_PXA27X
+# endif
+# define machine_is_inhand_pxa27x()	(machine_arch_type == MACH_TYPE_INHAND_PXA27X)
+#else
+# define machine_is_inhand_pxa27x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_PXA25X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_PXA25X
+# endif
+# define machine_is_inhand_pxa25x()	(machine_arch_type == MACH_TYPE_INHAND_PXA25X)
+#else
+# define machine_is_inhand_pxa25x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_XM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_XM
+# endif
+# define machine_is_empos_xm()	(machine_arch_type == MACH_TYPE_EMPOS_XM)
+#else
+# define machine_is_empos_xm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS
+# endif
+# define machine_is_empos()	(machine_arch_type == MACH_TYPE_EMPOS)
+#else
+# define machine_is_empos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_TINY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_TINY
+# endif
+# define machine_is_empos_tiny()	(machine_arch_type == MACH_TYPE_EMPOS_TINY)
+#else
+# define machine_is_empos_tiny()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_SM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_SM
+# endif
+# define machine_is_empos_sm()	(machine_arch_type == MACH_TYPE_EMPOS_SM)
+#else
+# define machine_is_empos_sm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EGRET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EGRET
+# endif
+# define machine_is_egret()	(machine_arch_type == MACH_TYPE_EGRET)
+#else
+# define machine_is_egret()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSTRICH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSTRICH
+# endif
+# define machine_is_ostrich()	(machine_arch_type == MACH_TYPE_OSTRICH)
+#else
+# define machine_is_ostrich()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N50
+# endif
+# define machine_is_n50()	(machine_arch_type == MACH_TYPE_N50)
+#else
+# define machine_is_n50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECBAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECBAT91
+# endif
+# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
+#else
+# define machine_is_ecbat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAREAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAREAST
+# endif
+# define machine_is_stareast()	(machine_arch_type == MACH_TYPE_STAREAST)
+#else
+# define machine_is_stareast()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DW
+# endif
+# define machine_is_dspg_dw()	(machine_arch_type == MACH_TYPE_DSPG_DW)
+#else
+# define machine_is_dspg_dw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONEARM
+# endif
+# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
+#else
+# define machine_is_onearm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRG110_6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRG110_6
+# endif
+# define machine_is_mrg110_6()	(machine_arch_type == MACH_TYPE_MRG110_6)
+#else
+# define machine_is_mrg110_6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT300NV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT300NV2
+# endif
+# define machine_is_wrt300nv2()	(machine_arch_type == MACH_TYPE_WRT300NV2)
+#else
+# define machine_is_wrt300nv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XM_BULVERDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XM_BULVERDE
+# endif
+# define machine_is_xm_bulverde()	(machine_arch_type == MACH_TYPE_XM_BULVERDE)
+#else
+# define machine_is_xm_bulverde()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM6100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM6100
+# endif
+# define machine_is_msm6100()	(machine_arch_type == MACH_TYPE_MSM6100)
+#else
+# define machine_is_msm6100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_B1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_B1
+# endif
+# define machine_is_eti_b1()	(machine_arch_type == MACH_TYPE_ETI_B1)
+#else
+# define machine_is_eti_b1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZILOG_ZA9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZILOG_ZA9L
+# endif
+# define machine_is_za9l_series()	(machine_arch_type == MACH_TYPE_ZILOG_ZA9L)
+#else
+# define machine_is_za9l_series()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIT2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIT2440
+# endif
+# define machine_is_bit2440()	(machine_arch_type == MACH_TYPE_BIT2440)
+#else
+# define machine_is_bit2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NBI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NBI
+# endif
+# define machine_is_nbi()	(machine_arch_type == MACH_TYPE_NBI)
+#else
+# define machine_is_nbi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2443
+# endif
+# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
+#else
+# define machine_is_smdk2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VDAVINCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VDAVINCI
+# endif
+# define machine_is_vdavinci()	(machine_arch_type == MACH_TYPE_VDAVINCI)
+#else
+# define machine_is_vdavinci()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATC6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATC6
+# endif
+# define machine_is_atc6()	(machine_arch_type == MACH_TYPE_ATC6)
+#else
+# define machine_is_atc6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTMDW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTMDW
+# endif
+# define machine_is_multmdw()	(machine_arch_type == MACH_TYPE_MULTMDW)
+#else
+# define machine_is_multmdw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBA2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBA2440
+# endif
+# define machine_is_mba2440()	(machine_arch_type == MACH_TYPE_MBA2440)
+#else
+# define machine_is_mba2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECSD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECSD
+# endif
+# define machine_is_ecsd()	(machine_arch_type == MACH_TYPE_ECSD)
+#else
+# define machine_is_ecsd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIRE31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIRE31
+# endif
+# define machine_is_zire31()	(machine_arch_type == MACH_TYPE_ZIRE31)
+#else
+# define machine_is_zire31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSG
+# endif
+# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
+#else
+# define machine_is_fsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAZOR101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAZOR101
+# endif
+# define machine_is_razor101()	(machine_arch_type == MACH_TYPE_RAZOR101)
+#else
+# define machine_is_razor101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPERA_TDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPERA_TDM
+# endif
+# define machine_is_opera_tdm()	(machine_arch_type == MACH_TYPE_OPERA_TDM)
+#else
+# define machine_is_opera_tdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMCERTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMCERTO
+# endif
+# define machine_is_comcerto()	(machine_arch_type == MACH_TYPE_COMCERTO)
+#else
+# define machine_is_comcerto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TB0319
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TB0319
+# endif
+# define machine_is_tb0319()	(machine_arch_type == MACH_TYPE_TB0319)
+#else
+# define machine_is_tb0319()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KWS8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KWS8000
+# endif
+# define machine_is_kws8000()	(machine_arch_type == MACH_TYPE_KWS8000)
+#else
+# define machine_is_kws8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B2
+# endif
+# define machine_is_b2()	(machine_arch_type == MACH_TYPE_B2)
+#else
+# define machine_is_b2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LCL54
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LCL54
+# endif
+# define machine_is_lcl54()	(machine_arch_type == MACH_TYPE_LCL54)
+#else
+# define machine_is_lcl54()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
+# endif
+# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
+#else
+# define machine_is_at91sam9260ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLANTANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLANTANK
+# endif
+# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
+#else
+# define machine_is_glantank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N2100
+# endif
+# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
+#else
+# define machine_is_n2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N4100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N4100
+# endif
+# define machine_is_n4100()	(machine_arch_type == MACH_TYPE_N4100)
+#else
+# define machine_is_n4100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERTICAL_RSC4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERTICAL_RSC4
+# endif
+# define machine_is_rsc4()	(machine_arch_type == MACH_TYPE_VERTICAL_RSC4)
+#else
+# define machine_is_rsc4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG8100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG8100
+# endif
+# define machine_is_sg8100()	(machine_arch_type == MACH_TYPE_SG8100)
+#else
+# define machine_is_sg8100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IM42XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IM42XX
+# endif
+# define machine_is_im42xx()	(machine_arch_type == MACH_TYPE_IM42XX)
+#else
+# define machine_is_im42xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FTXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FTXX
+# endif
+# define machine_is_ftxx()	(machine_arch_type == MACH_TYPE_FTXX)
+#else
+# define machine_is_ftxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LWFUSION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LWFUSION
+# endif
+# define machine_is_lwfusion()	(machine_arch_type == MACH_TYPE_LWFUSION)
+#else
+# define machine_is_lwfusion()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXRP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXRP435
+# endif
+# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
+#else
+# define machine_is_kixrp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9C
+# endif
+# define machine_is_ccw9c()	(machine_arch_type == MACH_TYPE_CCW9C)
+#else
+# define machine_is_ccw9c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DABHS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DABHS
+# endif
+# define machine_is_dabhs()	(machine_arch_type == MACH_TYPE_DABHS)
+#else
+# define machine_is_dabhs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GZMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GZMX
+# endif
+# define machine_is_gzmx()	(machine_arch_type == MACH_TYPE_GZMX)
+#else
+# define machine_is_gzmx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPNW100AP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPNW100AP
+# endif
+# define machine_is_ipnw100ap()	(machine_arch_type == MACH_TYPE_IPNW100AP)
+#else
+# define machine_is_ipnw100ap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
+# endif
+# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
+#else
+# define machine_is_cc9p9360dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9750DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9750DEV
+# endif
+# define machine_is_cc9p9750dev()	(machine_arch_type == MACH_TYPE_CC9P9750DEV)
+#else
+# define machine_is_cc9p9750dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360VAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360VAL
+# endif
+# define machine_is_cc9p9360val()	(machine_arch_type == MACH_TYPE_CC9P9360VAL)
+#else
+# define machine_is_cc9p9360val()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9750VAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9750VAL
+# endif
+# define machine_is_cc9p9750val()	(machine_arch_type == MACH_TYPE_CC9P9750VAL)
+#else
+# define machine_is_cc9p9750val()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX70V
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX70V
+# endif
+# define machine_is_nx70v()	(machine_arch_type == MACH_TYPE_NX70V)
+#else
+# define machine_is_nx70v()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200DF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DF
+# endif
+# define machine_is_at91rm9200df()	(machine_arch_type == MACH_TYPE_AT91RM9200DF)
+#else
+# define machine_is_at91rm9200df()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE_PILOT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE_PILOT2
+# endif
+# define machine_is_se_pilot2()	(machine_arch_type == MACH_TYPE_SE_PILOT2)
+#else
+# define machine_is_se_pilot2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTCN_T800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTCN_T800
+# endif
+# define machine_is_mtcn_t800()	(machine_arch_type == MACH_TYPE_MTCN_T800)
+#else
+# define machine_is_mtcn_t800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCMX212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCMX212
+# endif
+# define machine_is_vcmx212()	(machine_arch_type == MACH_TYPE_VCMX212)
+#else
+# define machine_is_vcmx212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LYNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LYNX
+# endif
+# define machine_is_lynx()	(machine_arch_type == MACH_TYPE_LYNX)
+#else
+# define machine_is_lynx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260ID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260ID
+# endif
+# define machine_is_at91sam9260id()	(machine_arch_type == MACH_TYPE_AT91SAM9260ID)
+#else
+# define machine_is_at91sam9260id()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW86052
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW86052
+# endif
+# define machine_is_hw86052()	(machine_arch_type == MACH_TYPE_HW86052)
+#else
+# define machine_is_hw86052()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI3
+# endif
+# define machine_is_pilz_pmi3()	(machine_arch_type == MACH_TYPE_PILZ_PMI3)
+#else
+# define machine_is_pilz_pmi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302A
+# endif
+# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
+#else
+# define machine_is_edb9302a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307A
+# endif
+# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
+#else
+# define machine_is_edb9307a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT_DFS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT_DFS
+# endif
+# define machine_is_ct_dfs()	(machine_arch_type == MACH_TYPE_CT_DFS)
+#else
+# define machine_is_ct_dfs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI4
+# endif
+# define machine_is_pilz_pmi4()	(machine_arch_type == MACH_TYPE_PILZ_PMI4)
+#else
+# define machine_is_pilz_pmi4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEEDNP_IXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEEDNP_IXP
+# endif
+# define machine_is_xceednp_ixp()	(machine_arch_type == MACH_TYPE_XCEEDNP_IXP)
+#else
+# define machine_is_xceednp_ixp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2442B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2442B
+# endif
+# define machine_is_smdk2442b()	(machine_arch_type == MACH_TYPE_SMDK2442B)
+#else
+# define machine_is_smdk2442b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XNODE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XNODE
+# endif
+# define machine_is_xnode()	(machine_arch_type == MACH_TYPE_XNODE)
+#else
+# define machine_is_xnode()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIDX270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIDX270
+# endif
+# define machine_is_aidx270()	(machine_arch_type == MACH_TYPE_AIDX270)
+#else
+# define machine_is_aidx270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REMA
+# endif
+# define machine_is_rema()	(machine_arch_type == MACH_TYPE_REMA)
+#else
+# define machine_is_rema()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BPS1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BPS1000
+# endif
+# define machine_is_bps1000()	(machine_arch_type == MACH_TYPE_BPS1000)
+#else
+# define machine_is_bps1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90350
+# endif
+# define machine_is_hw90350()	(machine_arch_type == MACH_TYPE_HW90350)
+#else
+# define machine_is_hw90350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_SDP3430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_SDP3430
+# endif
+# define machine_is_omap_sdp3430()	(machine_arch_type == MACH_TYPE_OMAP_SDP3430)
+#else
+# define machine_is_omap_sdp3430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUETOUCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUETOUCH
+# endif
+# define machine_is_bluetouch()	(machine_arch_type == MACH_TYPE_BLUETOUCH)
+#else
+# define machine_is_bluetouch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSTMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSTMS
+# endif
+# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
+#else
+# define machine_is_vstms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSBASE270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSBASE270
+# endif
+# define machine_is_xsbase270()	(machine_arch_type == MACH_TYPE_XSBASE270)
+#else
+# define machine_is_xsbase270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK_CN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK_CN
+# endif
+# define machine_is_at91sam9260ek_cn()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK_CN)
+#else
+# define machine_is_at91sam9260ek_cn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSTURBOXB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSTURBOXB
+# endif
+# define machine_is_adsturboxb()	(machine_arch_type == MACH_TYPE_ADSTURBOXB)
+#else
+# define machine_is_adsturboxb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTI4110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTI4110
+# endif
+# define machine_is_oti4110()	(machine_arch_type == MACH_TYPE_OTI4110)
+#else
+# define machine_is_oti4110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HME_PXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HME_PXA
+# endif
+# define machine_is_hme_pxa()	(machine_arch_type == MACH_TYPE_HME_PXA)
+#else
+# define machine_is_hme_pxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTERDCA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTERDCA
+# endif
+# define machine_is_deisterdca()	(machine_arch_type == MACH_TYPE_DEISTERDCA)
+#else
+# define machine_is_deisterdca()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CES_SSEM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CES_SSEM2
+# endif
+# define machine_is_ces_ssem2()	(machine_arch_type == MACH_TYPE_CES_SSEM2)
+#else
+# define machine_is_ces_ssem2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CES_MTR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CES_MTR
+# endif
+# define machine_is_ces_mtr()	(machine_arch_type == MACH_TYPE_CES_MTR)
+#else
+# define machine_is_ces_mtr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TDS_AVNG_SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TDS_AVNG_SBC
+# endif
+# define machine_is_tds_avng_sbc()	(machine_arch_type == MACH_TYPE_TDS_AVNG_SBC)
+#else
+# define machine_is_tds_avng_sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVEREST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVEREST
+# endif
+# define machine_is_everest()	(machine_arch_type == MACH_TYPE_EVEREST)
+#else
+# define machine_is_everest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4010
+# endif
+# define machine_is_pnx4010()	(machine_arch_type == MACH_TYPE_PNX4010)
+#else
+# define machine_is_pnx4010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OXNAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OXNAS
+# endif
+# define machine_is_oxnas()	(machine_arch_type == MACH_TYPE_OXNAS)
+#else
+# define machine_is_oxnas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIORI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIORI
+# endif
+# define machine_is_fiori()	(machine_arch_type == MACH_TYPE_FIORI)
+#else
+# define machine_is_fiori()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML1200
+# endif
+# define machine_is_ml1200()	(machine_arch_type == MACH_TYPE_ML1200)
+#else
+# define machine_is_ml1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PECOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PECOS
+# endif
+# define machine_is_pecos()	(machine_arch_type == MACH_TYPE_PECOS)
+#else
+# define machine_is_pecos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NB2XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NB2XXX
+# endif
+# define machine_is_nb2xxx()	(machine_arch_type == MACH_TYPE_NB2XXX)
+#else
+# define machine_is_nb2xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW6900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW6900
+# endif
+# define machine_is_hw6900()	(machine_arch_type == MACH_TYPE_HW6900)
+#else
+# define machine_is_hw6900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CDCS_QUOLL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDCS_QUOLL
+# endif
+# define machine_is_cdcs_quoll()	(machine_arch_type == MACH_TYPE_CDCS_QUOLL)
+#else
+# define machine_is_cdcs_quoll()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUICKSILVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUICKSILVER
+# endif
+# define machine_is_quicksilver()	(machine_arch_type == MACH_TYPE_QUICKSILVER)
+#else
+# define machine_is_quicksilver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UPLAT926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UPLAT926
+# endif
+# define machine_is_uplat926()	(machine_arch_type == MACH_TYPE_UPLAT926)
+#else
+# define machine_is_uplat926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410_THOMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410_THOMAS
+# endif
+# define machine_is_dep2410_dep2410()	(machine_arch_type == MACH_TYPE_DEP2410_THOMAS)
+#else
+# define machine_is_dep2410_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DTK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DTK2410
+# endif
+# define machine_is_dtk2410()	(machine_arch_type == MACH_TYPE_DTK2410)
+#else
+# define machine_is_dtk2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHILI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHILI
+# endif
+# define machine_is_chili()	(machine_arch_type == MACH_TYPE_CHILI)
+#else
+# define machine_is_chili()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEMETER
+# endif
+# define machine_is_demeter()	(machine_arch_type == MACH_TYPE_DEMETER)
+#else
+# define machine_is_demeter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIONYSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIONYSUS
+# endif
+# define machine_is_dionysus()	(machine_arch_type == MACH_TYPE_DIONYSUS)
+#else
+# define machine_is_dionysus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS352X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS352X
+# endif
+# define machine_is_as352x()	(machine_arch_type == MACH_TYPE_AS352X)
+#else
+# define machine_is_as352x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SERVICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SERVICE
+# endif
+# define machine_is_service()	(machine_arch_type == MACH_TYPE_SERVICE)
+#else
+# define machine_is_service()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CS_E9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS_E9301
+# endif
+# define machine_is_cs_e9301()	(machine_arch_type == MACH_TYPE_CS_E9301)
+#else
+# define machine_is_cs_e9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9M
+# endif
+# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
+#else
+# define machine_is_micro9m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_MOSPCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_MOSPCK
+# endif
+# define machine_is_ia_mospck()	(machine_arch_type == MACH_TYPE_IA_MOSPCK)
+#else
+# define machine_is_ia_mospck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL201B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL201B
+# endif
+# define machine_is_ql201b()	(machine_arch_type == MACH_TYPE_QL201B)
+#else
+# define machine_is_ql201b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BBM
+# endif
+# define machine_is_bbm()	(machine_arch_type == MACH_TYPE_BBM)
+#else
+# define machine_is_bbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXXX
+# endif
+# define machine_is_exxx()	(machine_arch_type == MACH_TYPE_EXXX)
+#else
+# define machine_is_exxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WMA11B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WMA11B
+# endif
+# define machine_is_wma11b()	(machine_arch_type == MACH_TYPE_WMA11B)
+#else
+# define machine_is_wma11b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ATLAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ATLAS
+# endif
+# define machine_is_pelco_atlas()	(machine_arch_type == MACH_TYPE_PELCO_ATLAS)
+#else
+# define machine_is_pelco_atlas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G500
+# endif
+# define machine_is_g500()	(machine_arch_type == MACH_TYPE_G500)
+#else
+# define machine_is_g500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG
+# endif
+# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
+#else
+# define machine_is_bug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX33ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX33ADS
+# endif
+# define machine_is_mx33ads()	(machine_arch_type == MACH_TYPE_MX33ADS)
+#else
+# define machine_is_mx33ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHUB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHUB
+# endif
+# define machine_is_chub()	(machine_arch_type == MACH_TYPE_CHUB)
+#else
+# define machine_is_chub()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA01
+# endif
+# define machine_is_neo1973_gta01()	(machine_arch_type == MACH_TYPE_NEO1973_GTA01)
+#else
+# define machine_is_neo1973_gta01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N740
+# endif
+# define machine_is_w90n740()	(machine_arch_type == MACH_TYPE_W90N740)
+#else
+# define machine_is_w90n740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEDALLION_SA2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEDALLION_SA2410
+# endif
+# define machine_is_medallion_sa2410()	(machine_arch_type == MACH_TYPE_MEDALLION_SA2410)
+#else
+# define machine_is_medallion_sa2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_CPU_9200_2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_CPU_9200_2
+# endif
+# define machine_is_ia_cpu_9200_2()	(machine_arch_type == MACH_TYPE_IA_CPU_9200_2)
+#else
+# define machine_is_ia_cpu_9200_2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMMRM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMMRM9200
+# endif
+# define machine_is_dimmrm9200()	(machine_arch_type == MACH_TYPE_DIMMRM9200)
+#else
+# define machine_is_dimmrm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM9261
+# endif
+# define machine_is_pm9261()	(machine_arch_type == MACH_TYPE_PM9261)
+#else
+# define machine_is_pm9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML7304
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML7304
+# endif
+# define machine_is_ml7304()	(machine_arch_type == MACH_TYPE_ML7304)
+#else
+# define machine_is_ml7304()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCP250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCP250
+# endif
+# define machine_is_ucp250()	(machine_arch_type == MACH_TYPE_UCP250)
+#else
+# define machine_is_ucp250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTBOARD
+# endif
+# define machine_is_intboard()	(machine_arch_type == MACH_TYPE_INTBOARD)
+#else
+# define machine_is_intboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GULFSTREAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GULFSTREAM
+# endif
+# define machine_is_gulfstream()	(machine_arch_type == MACH_TYPE_GULFSTREAM)
+#else
+# define machine_is_gulfstream()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LABQUEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LABQUEST
+# endif
+# define machine_is_labquest()	(machine_arch_type == MACH_TYPE_LABQUEST)
+#else
+# define machine_is_labquest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCMX313
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCMX313
+# endif
+# define machine_is_vcmx313()	(machine_arch_type == MACH_TYPE_VCMX313)
+#else
+# define machine_is_vcmx313()	(0)
+#endif
+
+#ifdef CONFIG_MACH_URG200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_URG200
+# endif
+# define machine_is_urg200()	(machine_arch_type == MACH_TYPE_URG200)
+#else
+# define machine_is_urg200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUX255LCDNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUX255LCDNET
+# endif
+# define machine_is_cpux255lcdnet()	(machine_arch_type == MACH_TYPE_CPUX255LCDNET)
+#else
+# define machine_is_cpux255lcdnet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU9
+# endif
+# define machine_is_netdcu9()	(machine_arch_type == MACH_TYPE_NETDCU9)
+#else
+# define machine_is_netdcu9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU10
+# endif
+# define machine_is_netdcu10()	(machine_arch_type == MACH_TYPE_NETDCU10)
+#else
+# define machine_is_netdcu10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DGA
+# endif
+# define machine_is_dspg_dga()	(machine_arch_type == MACH_TYPE_DSPG_DGA)
+#else
+# define machine_is_dspg_dga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DVW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DVW
+# endif
+# define machine_is_dspg_dvw()	(machine_arch_type == MACH_TYPE_DSPG_DVW)
+#else
+# define machine_is_dspg_dvw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOLOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOLOS
+# endif
+# define machine_is_solos()	(machine_arch_type == MACH_TYPE_SOLOS)
+#else
+# define machine_is_solos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
+# endif
+# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
+#else
+# define machine_is_at91sam9263ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSSTBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSSTBOX
+# endif
+# define machine_is_osstbox()	(machine_arch_type == MACH_TYPE_OSSTBOX)
+#else
+# define machine_is_osstbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KBAT9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KBAT9261
+# endif
+# define machine_is_kbat9261()	(machine_arch_type == MACH_TYPE_KBAT9261)
+#else
+# define machine_is_kbat9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT1100
+# endif
+# define machine_is_ct1100()	(machine_arch_type == MACH_TYPE_CT1100)
+#else
+# define machine_is_ct1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKCPPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKCPPXA
+# endif
+# define machine_is_akcppxa()	(machine_arch_type == MACH_TYPE_AKCPPXA)
+#else
+# define machine_is_akcppxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEVIO_1020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEVIO_1020
+# endif
+# define machine_is_zevio_1020()	(machine_arch_type == MACH_TYPE_ZEVIO_1020)
+#else
+# define machine_is_zevio_1020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HITRACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HITRACK
+# endif
+# define machine_is_hitrack()	(machine_arch_type == MACH_TYPE_HITRACK)
+#else
+# define machine_is_hitrack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYME1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYME1
+# endif
+# define machine_is_syme1()	(machine_arch_type == MACH_TYPE_SYME1)
+#else
+# define machine_is_syme1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYHL1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYHL1
+# endif
+# define machine_is_syhl1()	(machine_arch_type == MACH_TYPE_SYHL1)
+#else
+# define machine_is_syhl1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPCA400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPCA400
+# endif
+# define machine_is_empca400()	(machine_arch_type == MACH_TYPE_EMPCA400)
+#else
+# define machine_is_empca400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM7210
+# endif
+# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
+#else
+# define machine_is_em7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCHERMES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCHERMES
+# endif
+# define machine_is_htchermes()	(machine_arch_type == MACH_TYPE_HTCHERMES)
+#else
+# define machine_is_htchermes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_C1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_C1
+# endif
+# define machine_is_eti_c1()	(machine_arch_type == MACH_TYPE_ETI_C1)
+#else
+# define machine_is_eti_c1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_DEP2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_DEP2410
+# endif
+# define machine_is_mach_dep2410()	(machine_arch_type == MACH_TYPE_MACH_DEP2410)
+#else
+# define machine_is_mach_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AC100
+# endif
+# define machine_is_ac100()	(machine_arch_type == MACH_TYPE_AC100)
+#else
+# define machine_is_ac100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNEETCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNEETCH
+# endif
+# define machine_is_sneetch()	(machine_arch_type == MACH_TYPE_SNEETCH)
+#else
+# define machine_is_sneetch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STUDENTMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STUDENTMATE
+# endif
+# define machine_is_studentmate()	(machine_arch_type == MACH_TYPE_STUDENTMATE)
+#else
+# define machine_is_studentmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2410
+# endif
+# define machine_is_zir2410()	(machine_arch_type == MACH_TYPE_ZIR2410)
+#else
+# define machine_is_zir2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2413
+# endif
+# define machine_is_zir2413()	(machine_arch_type == MACH_TYPE_ZIR2413)
+#else
+# define machine_is_zir2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLONIP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLONIP3
+# endif
+# define machine_is_dlonip3()	(machine_arch_type == MACH_TYPE_DLONIP3)
+#else
+# define machine_is_dlonip3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INSTREAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INSTREAM
+# endif
+# define machine_is_instream()	(machine_arch_type == MACH_TYPE_INSTREAM)
+#else
+# define machine_is_instream()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMBARELLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMBARELLA
+# endif
+# define machine_is_ambarella()	(machine_arch_type == MACH_TYPE_AMBARELLA)
+#else
+# define machine_is_ambarella()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEVIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEVIS
+# endif
+# define machine_is_nevis()	(machine_arch_type == MACH_TYPE_NEVIS)
+#else
+# define machine_is_nevis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_TRINITY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_TRINITY
+# endif
+# define machine_is_htc_trinity()	(machine_arch_type == MACH_TYPE_HTC_TRINITY)
+#else
+# define machine_is_htc_trinity()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL202B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL202B
+# endif
+# define machine_is_ql202b()	(machine_arch_type == MACH_TYPE_QL202B)
+#else
+# define machine_is_ql202b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPAC270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPAC270
+# endif
+# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
+#else
+# define machine_is_vpac270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD129
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD129
+# endif
+# define machine_is_rd129()	(machine_arch_type == MACH_TYPE_RD129)
+#else
+# define machine_is_rd129()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCWIZARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCWIZARD
+# endif
+# define machine_is_htcwizard()	(machine_arch_type == MACH_TYPE_HTCWIZARD)
+#else
+# define machine_is_htcwizard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_TREO680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_TREO680
+# endif
+# define machine_is_xscale_treo680()	(machine_arch_type == MACH_TYPE_XSCALE_TREO680)
+#else
+# define machine_is_xscale_treo680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TECON_TMEZON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TECON_TMEZON
+# endif
+# define machine_is_tecon_tmezon()	(machine_arch_type == MACH_TYPE_TECON_TMEZON)
+#else
+# define machine_is_tecon_tmezon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE
+# endif
+# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
+#else
+# define machine_is_zylonite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENE1270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENE1270
+# endif
+# define machine_is_gene1270()	(machine_arch_type == MACH_TYPE_GENE1270)
+#else
+# define machine_is_gene1270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2412
+# endif
+# define machine_is_zir2412()	(machine_arch_type == MACH_TYPE_ZIR2412)
+#else
+# define machine_is_zir2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31LITE
+# endif
+# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
+#else
+# define machine_is_mx31lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T700WX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T700WX
+# endif
+# define machine_is_t700wx()	(machine_arch_type == MACH_TYPE_T700WX)
+#else
+# define machine_is_t700wx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VF100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VF100
+# endif
+# define machine_is_vf100()	(machine_arch_type == MACH_TYPE_VF100)
+#else
+# define machine_is_vf100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB2
+# endif
+# define machine_is_nsb2()	(machine_arch_type == MACH_TYPE_NSB2)
+#else
+# define machine_is_nsb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXHMI_BB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXHMI_BB
+# endif
+# define machine_is_nxhmi_bb()	(machine_arch_type == MACH_TYPE_NXHMI_BB)
+#else
+# define machine_is_nxhmi_bb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXHMI_RE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXHMI_RE
+# endif
+# define machine_is_nxhmi_re()	(machine_arch_type == MACH_TYPE_NXHMI_RE)
+#else
+# define machine_is_nxhmi_re()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N4100PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N4100PRO
+# endif
+# define machine_is_n4100pro()	(machine_arch_type == MACH_TYPE_N4100PRO)
+#else
+# define machine_is_n4100pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9260
+# endif
+# define machine_is_sam9260()	(machine_arch_type == MACH_TYPE_SAM9260)
+#else
+# define machine_is_sam9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TREO600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TREO600
+# endif
+# define machine_is_omap_treo600()	(machine_arch_type == MACH_TYPE_OMAP_TREO600)
+#else
+# define machine_is_omap_treo600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INDY2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INDY2410
+# endif
+# define machine_is_indy2410()	(machine_arch_type == MACH_TYPE_INDY2410)
+#else
+# define machine_is_indy2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NELT_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NELT_A
+# endif
+# define machine_is_nelt_a()	(machine_arch_type == MACH_TYPE_NELT_A)
+#else
+# define machine_is_nelt_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N311
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N311
+# endif
+# define machine_is_n311()	(machine_arch_type == MACH_TYPE_N311)
+#else
+# define machine_is_n311()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260VGK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260VGK
+# endif
+# define machine_is_at91sam9260vgk()	(machine_arch_type == MACH_TYPE_AT91SAM9260VGK)
+#else
+# define machine_is_at91sam9260vgk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91LEPPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91LEPPE
+# endif
+# define machine_is_at91leppe()	(machine_arch_type == MACH_TYPE_AT91LEPPE)
+#else
+# define machine_is_at91leppe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91LEPCCN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91LEPCCN
+# endif
+# define machine_is_at91lepccn()	(machine_arch_type == MACH_TYPE_AT91LEPCCN)
+#else
+# define machine_is_at91lepccn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APC7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APC7100
+# endif
+# define machine_is_apc7100()	(machine_arch_type == MACH_TYPE_APC7100)
+#else
+# define machine_is_apc7100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGAZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGAZER
+# endif
+# define machine_is_stargazer()	(machine_arch_type == MACH_TYPE_STARGAZER)
+#else
+# define machine_is_stargazer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONATA
+# endif
+# define machine_is_sonata()	(machine_arch_type == MACH_TYPE_SONATA)
+#else
+# define machine_is_sonata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCHMOOGIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCHMOOGIE
+# endif
+# define machine_is_schmoogie()	(machine_arch_type == MACH_TYPE_SCHMOOGIE)
+#else
+# define machine_is_schmoogie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AZTOOL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AZTOOL
+# endif
+# define machine_is_aztool()	(machine_arch_type == MACH_TYPE_AZTOOL)
+#else
+# define machine_is_aztool()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA701
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA701
+# endif
+# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
+#else
+# define machine_is_mioa701()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SXNI9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SXNI9260
+# endif
+# define machine_is_sxni9260()	(machine_arch_type == MACH_TYPE_SXNI9260)
+#else
+# define machine_is_sxni9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27520EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27520EVB
+# endif
+# define machine_is_mxc27520evb()	(machine_arch_type == MACH_TYPE_MXC27520EVB)
+#else
+# define machine_is_mxc27520evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO5X0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
+# endif
+# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
+#else
+# define machine_is_armadillo5x0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9260
+# endif
+# define machine_is_mb9260()	(machine_arch_type == MACH_TYPE_MB9260)
+#else
+# define machine_is_mb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9263
+# endif
+# define machine_is_mb9263()	(machine_arch_type == MACH_TYPE_MB9263)
+#else
+# define machine_is_mb9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPAC9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPAC9302
+# endif
+# define machine_is_ipac9302()	(machine_arch_type == MACH_TYPE_IPAC9302)
+#else
+# define machine_is_ipac9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360JS
+# endif
+# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
+#else
+# define machine_is_cc9p9360js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GALLIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GALLIUM
+# endif
+# define machine_is_gallium()	(machine_arch_type == MACH_TYPE_GALLIUM)
+#else
+# define machine_is_gallium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSC2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSC2410
+# endif
+# define machine_is_msc2410()	(machine_arch_type == MACH_TYPE_MSC2410)
+#else
+# define machine_is_msc2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GHI270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GHI270
+# endif
+# define machine_is_ghi270()	(machine_arch_type == MACH_TYPE_GHI270)
+#else
+# define machine_is_ghi270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_LEONARDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_LEONARDO
+# endif
+# define machine_is_davinci_leonardo()	(machine_arch_type == MACH_TYPE_DAVINCI_LEONARDO)
+#else
+# define machine_is_davinci_leonardo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OIAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OIAB
+# endif
+# define machine_is_oiab()	(machine_arch_type == MACH_TYPE_OIAB)
+#else
+# define machine_is_oiab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6400
+# endif
+# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
+#else
+# define machine_is_smdk6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N800
+# endif
+# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
+#else
+# define machine_is_nokia_n800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GREENPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREENPHONE
+# endif
+# define machine_is_greenphone()	(machine_arch_type == MACH_TYPE_GREENPHONE)
+#else
+# define machine_is_greenphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPEXWP18
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPEXWP18
+# endif
+# define machine_is_compex42x()	(machine_arch_type == MACH_TYPE_COMPEXWP18)
+#else
+# define machine_is_compex42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XMATE
+# endif
+# define machine_is_xmate()	(machine_arch_type == MACH_TYPE_XMATE)
+#else
+# define machine_is_xmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENERGIZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENERGIZER
+# endif
+# define machine_is_energizer()	(machine_arch_type == MACH_TYPE_ENERGIZER)
+#else
+# define machine_is_energizer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IME1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IME1
+# endif
+# define machine_is_ime1()	(machine_arch_type == MACH_TYPE_IME1)
+#else
+# define machine_is_ime1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWEDATMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWEDATMS
+# endif
+# define machine_is_sweda_tms()	(machine_arch_type == MACH_TYPE_SWEDATMS)
+#else
+# define machine_is_sweda_tms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NTNP435C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTNP435C
+# endif
+# define machine_is_ntnp435c()	(machine_arch_type == MACH_TYPE_NTNP435C)
+#else
+# define machine_is_ntnp435c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPECTRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPECTRO2
+# endif
+# define machine_is_spectro2()	(machine_arch_type == MACH_TYPE_SPECTRO2)
+#else
+# define machine_is_spectro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6039
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6039
+# endif
+# define machine_is_h6039()	(machine_arch_type == MACH_TYPE_H6039)
+#else
+# define machine_is_h6039()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP80219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP80219
+# endif
+# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
+#else
+# define machine_is_ep80219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMOA_II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMOA_II
+# endif
+# define machine_is_samoa_ii()	(machine_arch_type == MACH_TYPE_SAMOA_II)
+#else
+# define machine_is_samoa_ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMXL
+# endif
+# define machine_is_cwmxl()	(machine_arch_type == MACH_TYPE_CWMXL)
+#else
+# define machine_is_cwmxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS9200
+# endif
+# define machine_is_as9200()	(machine_arch_type == MACH_TYPE_AS9200)
+#else
+# define machine_is_as9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFX1149
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFX1149
+# endif
+# define machine_is_sfx1149()	(machine_arch_type == MACH_TYPE_SFX1149)
+#else
+# define machine_is_sfx1149()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAVI010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAVI010
+# endif
+# define machine_is_navi010()	(machine_arch_type == MACH_TYPE_NAVI010)
+#else
+# define machine_is_navi010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTMDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTMDP
+# endif
+# define machine_is_multmdp()	(machine_arch_type == MACH_TYPE_MULTMDP)
+#else
+# define machine_is_multmdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9520
+# endif
+# define machine_is_scb9520()	(machine_arch_type == MACH_TYPE_SCB9520)
+#else
+# define machine_is_scb9520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCATHENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCATHENA
+# endif
+# define machine_is_htcathena()	(machine_arch_type == MACH_TYPE_HTCATHENA)
+#else
+# define machine_is_htcathena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XP179
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP179
+# endif
+# define machine_is_xp179()	(machine_arch_type == MACH_TYPE_XP179)
+#else
+# define machine_is_xp179()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4300
+# endif
+# define machine_is_h4300()	(machine_arch_type == MACH_TYPE_H4300)
+#else
+# define machine_is_h4300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GORAMO_MLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
+# endif
+# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
+#else
+# define machine_is_goramo_mlr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30020EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30020EVB
+# endif
+# define machine_is_mxc30020evb()	(machine_arch_type == MACH_TYPE_MXC30020EVB)
+#else
+# define machine_is_mxc30020evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSBITSIMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSIMX
+# endif
+# define machine_is_adsbitsymx()	(machine_arch_type == MACH_TYPE_ADSBITSIMX)
+#else
+# define machine_is_adsbitsymx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSPORTALPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSPORTALPLUS
+# endif
+# define machine_is_adsportalplus()	(machine_arch_type == MACH_TYPE_ADSPORTALPLUS)
+#else
+# define machine_is_adsportalplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMSP2PLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMSP2PLUS
+# endif
+# define machine_is_mmsp2plus()	(machine_arch_type == MACH_TYPE_MMSP2PLUS)
+#else
+# define machine_is_mmsp2plus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_X270
+# endif
+# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
+#else
+# define machine_is_em_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPP302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPP302
+# endif
+# define machine_is_tpp302()	(machine_arch_type == MACH_TYPE_TPP302)
+#else
+# define machine_is_tpp302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM104
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM104
+# endif
+# define machine_is_tpp104()	(machine_arch_type == MACH_TYPE_TPM104)
+#else
+# define machine_is_tpp104()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM102
+# endif
+# define machine_is_tpm102()	(machine_arch_type == MACH_TYPE_TPM102)
+#else
+# define machine_is_tpm102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM109
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM109
+# endif
+# define machine_is_tpm109()	(machine_arch_type == MACH_TYPE_TPM109)
+#else
+# define machine_is_tpm109()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FBXO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FBXO1
+# endif
+# define machine_is_fbxo1()	(machine_arch_type == MACH_TYPE_FBXO1)
+#else
+# define machine_is_fbxo1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HXD8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HXD8
+# endif
+# define machine_is_hxd8()	(machine_arch_type == MACH_TYPE_HXD8)
+#else
+# define machine_is_hxd8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
+# endif
+# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
+#else
+# define machine_is_neo1973_gta02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMTEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMTEST
+# endif
+# define machine_is_emtest()	(machine_arch_type == MACH_TYPE_EMTEST)
+#else
+# define machine_is_emtest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AD6900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AD6900
+# endif
+# define machine_is_ad6900()	(machine_arch_type == MACH_TYPE_AD6900)
+#else
+# define machine_is_ad6900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUROPA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUROPA
+# endif
+# define machine_is_europa()	(machine_arch_type == MACH_TYPE_EUROPA)
+#else
+# define machine_is_europa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_METROCONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_METROCONNECT
+# endif
+# define machine_is_metroconnect()	(machine_arch_type == MACH_TYPE_METROCONNECT)
+#else
+# define machine_is_metroconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_S2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_S2410
+# endif
+# define machine_is_ez_s2410()	(machine_arch_type == MACH_TYPE_EZ_S2410)
+#else
+# define machine_is_ez_s2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_S2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_S2440
+# endif
+# define machine_is_ez_s2440()	(machine_arch_type == MACH_TYPE_EZ_S2440)
+#else
+# define machine_is_ez_s2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_EP9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_EP9312
+# endif
+# define machine_is_ez_ep9312()	(machine_arch_type == MACH_TYPE_EZ_EP9312)
+#else
+# define machine_is_ez_ep9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_EP9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_EP9315
+# endif
+# define machine_is_ez_ep9315()	(machine_arch_type == MACH_TYPE_EZ_EP9315)
+#else
+# define machine_is_ez_ep9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_X7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_X7
+# endif
+# define machine_is_ez_x7()	(machine_arch_type == MACH_TYPE_EZ_X7)
+#else
+# define machine_is_ez_x7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GODOTDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GODOTDB
+# endif
+# define machine_is_godotdb()	(machine_arch_type == MACH_TYPE_GODOTDB)
+#else
+# define machine_is_godotdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MISTRAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MISTRAL
+# endif
+# define machine_is_mistral()	(machine_arch_type == MACH_TYPE_MISTRAL)
+#else
+# define machine_is_mistral()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM
+# endif
+# define machine_is_msm()	(machine_arch_type == MACH_TYPE_MSM)
+#else
+# define machine_is_msm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT5910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT5910
+# endif
+# define machine_is_ct5910()	(machine_arch_type == MACH_TYPE_CT5910)
+#else
+# define machine_is_ct5910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT5912
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT5912
+# endif
+# define machine_is_ct5912()	(machine_arch_type == MACH_TYPE_CT5912)
+#else
+# define machine_is_ct5912()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYNET_INE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYNET_INE
+# endif
+# define machine_is_hynet_ine()	(machine_arch_type == MACH_TYPE_HYNET_INE)
+#else
+# define machine_is_hynet_ine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYNET_APP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYNET_APP
+# endif
+# define machine_is_hynet_app()	(machine_arch_type == MACH_TYPE_HYNET_APP)
+#else
+# define machine_is_hynet_app()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7200
+# endif
+# define machine_is_msm7200()	(machine_arch_type == MACH_TYPE_MSM7200)
+#else
+# define machine_is_msm7200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7600
+# endif
+# define machine_is_msm7600()	(machine_arch_type == MACH_TYPE_MSM7600)
+#else
+# define machine_is_msm7600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEB255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEB255
+# endif
+# define machine_is_ceb255()	(machine_arch_type == MACH_TYPE_CEB255)
+#else
+# define machine_is_ceb255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CIEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CIEL
+# endif
+# define machine_is_ciel()	(machine_arch_type == MACH_TYPE_CIEL)
+#else
+# define machine_is_ciel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLM5650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLM5650
+# endif
+# define machine_is_slm5650()	(machine_arch_type == MACH_TYPE_SLM5650)
+#else
+# define machine_is_slm5650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9RLEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
+# endif
+# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
+#else
+# define machine_is_at91sam9rlek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMTECH_ROUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMTECH_ROUTER
+# endif
+# define machine_is_comtech_router()	(machine_arch_type == MACH_TYPE_COMTECH_ROUTER)
+#else
+# define machine_is_comtech_router()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2410X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2410X
+# endif
+# define machine_is_sbc2410x()	(machine_arch_type == MACH_TYPE_SBC2410X)
+#else
+# define machine_is_sbc2410x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT4X0BD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT4X0BD
+# endif
+# define machine_is_at4x0bd()	(machine_arch_type == MACH_TYPE_AT4X0BD)
+#else
+# define machine_is_at4x0bd()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+/* #define MACH_TYPE_367                  <<not registered>> */
+#define machine_is_esl_wireless_tab()	(0)
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
Index: build_tree/linux/include/asm/mc146818rtc.h
diff -u /dev/null build_tree/linux/include/asm/mc146818rtc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mc146818rtc.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,28 @@
+/*
+ * Machine dependent access functions for RTC registers.
+ */
+#ifndef _ASM_MC146818RTC_H
+#define _ASM_MC146818RTC_H
+
+#include <asm/arch/irqs.h>
+#include <asm/io.h>
+
+#ifndef RTC_PORT
+#define RTC_PORT(x)	(0x70 + (x))
+#define RTC_ALWAYS_BCD	1	/* RTC operates in binary mode */
+#endif
+
+/*
+ * The yet supported machines all access the RTC index register via
+ * an ISA port access but the way to access the date register differs ...
+ */
+#define CMOS_READ(addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+inb_p(RTC_PORT(1)); \
+})
+#define CMOS_WRITE(val, addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+outb_p((val),RTC_PORT(1)); \
+})
+
+#endif /* _ASM_MC146818RTC_H */
Index: build_tree/linux/include/asm/memory.h
diff -u /dev/null build_tree/linux/include/asm/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/memory.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,331 @@
+/*
+ *  linux/include/asm-arm/memory.h
+ *
+ *  Copyright (C) 2000-2002 Russell King
+ *  modification for nommu, Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Note: this file should not be included by non-asm/.h files
+ */
+#ifndef __ASM_ARM_MEMORY_H
+#define __ASM_ARM_MEMORY_H
+
+/*
+ * Allow for constants defined here to be used from assembly code
+ * by prepending the UL suffix only with actual C code compilation.
+ */
+#ifndef __ASSEMBLY__
+#define UL(x) (x##UL)
+#else
+#define UL(x) (x)
+#endif
+
+#include <linux/compiler.h>
+#include <asm/arch/memory.h>
+#include <asm/sizes.h>
+
+#ifdef CONFIG_MMU
+
+#ifndef TASK_SIZE
+/*
+ * TASK_SIZE - the maximum size of a user space task.
+ * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area
+ */
+#define TASK_SIZE		UL(0xbf000000)
+#define TASK_UNMAPPED_BASE	UL(0x40000000)
+#endif
+
+/*
+ * The maximum size of a 26-bit user space task.
+ */
+#define TASK_SIZE_26		UL(0x04000000)
+
+/*
+ * Page offset: 3GB
+ */
+#ifndef PAGE_OFFSET
+#define PAGE_OFFSET		UL(0xc0000000)
+#endif
+
+/*
+ * The module space lives between the addresses given by TASK_SIZE
+ * and PAGE_OFFSET - it must be within 32MB of the kernel text.
+ */
+#define MODULE_END		(PAGE_OFFSET)
+#define MODULE_START		(MODULE_END - 16*1048576)
+
+#if TASK_SIZE > MODULE_START
+#error Top of user space clashes with start of module space
+#endif
+
+/*
+ * The XIP kernel gets mapped at the bottom of the module vm area.
+ * Since we use sections to map it, this macro replaces the physical address
+ * with its virtual address while keeping offset from the base section.
+ */
+#define XIP_VIRT_ADDR(physaddr)  (MODULE_START + ((physaddr) & 0x000fffff))
+
+/*
+ * Allow 16MB-aligned ioremap pages
+ */
+#define IOREMAP_MAX_ORDER	24
+
+#else /* CONFIG_MMU */
+
+/*
+ * The limitation of user task size can grow up to the end of free ram region.
+ * It is difficult to define and perhaps will never meet the original meaning
+ * of this define that was meant to.
+ * Fortunately, there is no reference for this in noMMU mode, for now.
+ */
+#ifndef TASK_SIZE
+#define TASK_SIZE		(CONFIG_DRAM_SIZE)
+#endif
+
+#ifndef TASK_UNMAPPED_BASE
+#define TASK_UNMAPPED_BASE	UL(0x00000000)
+#endif
+
+#ifndef PHYS_OFFSET
+#define PHYS_OFFSET 		(CONFIG_DRAM_BASE)
+#endif
+
+#ifndef END_MEM
+#define END_MEM     		(CONFIG_DRAM_BASE + CONFIG_DRAM_SIZE)
+#endif
+
+#ifndef PAGE_OFFSET
+#define PAGE_OFFSET		(PHYS_OFFSET)
+#endif
+
+/*
+ * The module can be at any place in ram in nommu mode.
+ */
+#define MODULE_END		(END_MEM)
+#define MODULE_START		(PHYS_OFFSET)
+
+#endif /* !CONFIG_MMU */
+
+/*
+ * Size of DMA-consistent memory region.  Must be multiple of 2M,
+ * between 2MB and 14MB inclusive.
+ */
+#ifndef CONSISTENT_DMA_SIZE
+#define CONSISTENT_DMA_SIZE SZ_2M
+#endif
+
+/*
+ * Physical vs virtual RAM address space conversion.  These are
+ * private definitions which should NOT be used outside memory.h
+ * files.  Use virt_to_phys/phys_to_virt/__pa/__va instead.
+ */
+#ifndef __virt_to_phys
+#define __virt_to_phys(x)	((x) - PAGE_OFFSET + PHYS_OFFSET)
+#define __phys_to_virt(x)	((x) - PHYS_OFFSET + PAGE_OFFSET)
+#endif
+
+/*
+ * Convert a physical address to a Page Frame Number and back
+ */
+#define	__phys_to_pfn(paddr)	((paddr) >> PAGE_SHIFT)
+#define	__pfn_to_phys(pfn)	((pfn) << PAGE_SHIFT)
+
+#ifndef __ASSEMBLY__
+
+/*
+ * The DMA mask corresponding to the maximum bus address allocatable
+ * using GFP_DMA.  The default here places no restriction on DMA
+ * allocations.  This must be the smallest DMA mask in the system,
+ * so a successful GFP_DMA allocation will always satisfy this.
+ */
+#ifndef ISA_DMA_THRESHOLD
+#define ISA_DMA_THRESHOLD	(0xffffffffULL)
+#endif
+
+#ifndef arch_adjust_zones
+#define arch_adjust_zones(node,size,holes) do { } while (0)
+#endif
+
+/*
+ * PFNs are used to describe any physical page; this means
+ * PFN 0 == physical address 0.
+ *
+ * This is the PFN of the first RAM page in the kernel
+ * direct-mapped view.  We assume this is the first page
+ * of RAM in the mem_map as well.
+ */
+#define PHYS_PFN_OFFSET	(PHYS_OFFSET >> PAGE_SHIFT)
+
+/*
+ * These are *only* valid on the kernel direct mapped RAM memory.
+ * Note: Drivers should NOT use these.  They are the wrong
+ * translation for translating DMA addresses.  Use the driver
+ * DMA support - see dma-mapping.h.
+ */
+static inline unsigned long virt_to_phys(void *x)
+{
+	return __virt_to_phys((unsigned long)(x));
+}
+
+static inline void *phys_to_virt(unsigned long x)
+{
+	return (void *)(__phys_to_virt((unsigned long)(x)));
+}
+
+/*
+ * Drivers should NOT use these either.
+ */
+#define __pa(x)			__virt_to_phys((unsigned long)(x))
+#define __va(x)			((void *)__phys_to_virt((unsigned long)(x)))
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
+
+/*
+ * Virtual <-> DMA view memory address translations
+ * Again, these are *only* valid on the kernel direct mapped RAM
+ * memory.  Use of these is *deprecated* (and that doesn't mean
+ * use the __ prefixed forms instead.)  See dma-mapping.h.
+ */
+static inline __deprecated unsigned long virt_to_bus(void *x)
+{
+	return __virt_to_bus((unsigned long)x);
+}
+
+static inline __deprecated void *bus_to_virt(unsigned long x)
+{
+	return (void *)__bus_to_virt(x);
+}
+
+/*
+ * Conversion between a struct page and a physical address.
+ *
+ * Note: when converting an unknown physical address to a
+ * struct page, the resulting pointer must be validated
+ * using VALID_PAGE().  It must return an invalid struct page
+ * for any physical address not corresponding to a system
+ * RAM address.
+ *
+ *  page_to_pfn(page)	convert a struct page * to a PFN number
+ *  pfn_to_page(pfn)	convert a _valid_ PFN number to struct page *
+ *  pfn_valid(pfn)	indicates whether a PFN number is valid
+ *
+ *  virt_to_page(k)	convert a _valid_ virtual address to struct page *
+ *  virt_addr_valid(k)	indicates whether a virtual address is valid
+ */
+#ifndef CONFIG_DISCONTIGMEM
+
+#define ARCH_PFN_OFFSET		PHYS_PFN_OFFSET
+#define pfn_valid(pfn)		((pfn) >= PHYS_PFN_OFFSET && (pfn) < (PHYS_PFN_OFFSET + max_mapnr))
+
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define virt_addr_valid(kaddr)	((unsigned long)(kaddr) >= PAGE_OFFSET && (unsigned long)(kaddr) < (unsigned long)high_memory)
+
+#define PHYS_TO_NID(addr)	(0)
+
+#else /* CONFIG_DISCONTIGMEM */
+
+/*
+ * This is more complex.  We have a set of mem_map arrays spread
+ * around in memory.
+ */
+#include <linux/numa.h>
+
+#define arch_pfn_to_nid(pfn)	PFN_TO_NID(pfn)
+#define arch_local_page_offset(pfn, nid) LOCAL_MAP_NR((pfn) << PAGE_SHIFT)
+
+#define pfn_valid(pfn)						\
+	({							\
+		unsigned int nid = PFN_TO_NID(pfn);		\
+		int valid = nid < MAX_NUMNODES;			\
+		if (valid) {					\
+			pg_data_t *node = NODE_DATA(nid);	\
+			valid = (pfn - node->node_start_pfn) <	\
+				node->node_spanned_pages;	\
+		}						\
+		valid;						\
+	})
+
+#define virt_to_page(kaddr)					\
+	(ADDR_TO_MAPBASE(kaddr) + LOCAL_MAP_NR(kaddr))
+
+#define virt_addr_valid(kaddr)	(KVADDR_TO_NID(kaddr) < MAX_NUMNODES)
+
+/*
+ * Common discontigmem stuff.
+ *  PHYS_TO_NID is used by the ARM kernel/setup.c
+ */
+#define PHYS_TO_NID(addr)	PFN_TO_NID((addr) >> PAGE_SHIFT)
+
+/*
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr)	NODE_MEM_MAP(KVADDR_TO_NID(kaddr))
+
+/*
+ * Given a page frame number, find the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define PFN_TO_MAPBASE(pfn)	NODE_MEM_MAP(PFN_TO_NID(pfn))
+
+#ifdef NODE_MEM_SIZE_BITS
+#define NODE_MEM_SIZE_MASK	((1 << NODE_MEM_SIZE_BITS) - 1)
+
+/*
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr) \
+	(((unsigned long)(addr) - PAGE_OFFSET) >> NODE_MEM_SIZE_BITS)
+
+/*
+ * Given a page frame number, convert it to a node id.
+ */
+#define PFN_TO_NID(pfn) \
+	(((pfn) - PHYS_PFN_OFFSET) >> (NODE_MEM_SIZE_BITS - PAGE_SHIFT))
+
+/*
+ * Given a kaddr, LOCAL_MEM_MAP finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+#define LOCAL_MAP_NR(addr) \
+	(((unsigned long)(addr) & NODE_MEM_SIZE_MASK) >> PAGE_SHIFT)
+
+#endif /* NODE_MEM_SIZE_BITS */
+
+#endif /* !CONFIG_DISCONTIGMEM */
+
+/*
+ * For BIO.  "will die".  Kill me when bio_to_phys() and bvec_to_phys() die.
+ */
+#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
+
+/*
+ * Optional device DMA address remapping. Do _not_ use directly!
+ * We should really eliminate virt_to_bus() here - it's deprecated.
+ */
+#ifndef __arch_page_to_dma
+#define page_to_dma(dev, page)		((dma_addr_t)__virt_to_bus((unsigned long)page_address(page)))
+#define dma_to_virt(dev, addr)		((void *)__bus_to_virt(addr))
+#define virt_to_dma(dev, addr)		((dma_addr_t)__virt_to_bus((unsigned long)(addr)))
+#else
+#define page_to_dma(dev, page)		(__arch_page_to_dma(dev, page))
+#define dma_to_virt(dev, addr)		(__arch_dma_to_virt(dev, addr))
+#define virt_to_dma(dev, addr)		(__arch_virt_to_dma(dev, addr))
+#endif
+
+/*
+ * Optional coherency support.  Currently used only by selected
+ * Intel XSC3-based systems.
+ */
+#ifndef arch_is_coherent
+#define arch_is_coherent()		0
+#endif
+
+#endif
+
+#include <asm-generic/memory_model.h>
+
+#endif
Index: build_tree/linux/include/asm/mman.h
diff -u /dev/null build_tree/linux/include/asm/mman.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mman.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,17 @@
+#ifndef __ARM_MMAN_H__
+#define __ARM_MMAN_H__
+
+#include <asm-generic/mman.h>
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+#define MAP_NORESERVE	0x4000		/* don't check for reservations */
+#define MAP_POPULATE	0x8000		/* populate (prefault) page tables */
+#define MAP_NONBLOCK	0x10000		/* do not block on IO */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#endif /* __ARM_MMAN_H__ */
Index: build_tree/linux/include/asm/mmu.h
diff -u /dev/null build_tree/linux/include/asm/mmu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mmu.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,33 @@
+#ifndef __ARM_MMU_H
+#define __ARM_MMU_H
+
+#ifdef CONFIG_MMU
+
+typedef struct {
+#if __LINUX_ARM_ARCH__ >= 6
+	unsigned int id;
+#endif
+	unsigned int kvm_seq;
+} mm_context_t;
+
+#if __LINUX_ARM_ARCH__ >= 6
+#define ASID(mm)	((mm)->context.id & 255)
+#else
+#define ASID(mm)	(0)
+#endif
+
+#else
+
+/*
+ * From nommu.h:
+ *  Copyright (C) 2002, David McCullough <davidm@snapgear.com>
+ *  modified for 2.6 by Hyok S. Choi <hyok.choi@samsung.com>
+ */
+typedef struct {
+	struct vm_list_struct	*vmlist;
+	unsigned long		end_brk;
+} mm_context_t;
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/mmu_context.h
diff -u /dev/null build_tree/linux/include/asm/mmu_context.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mmu_context.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,111 @@
+/*
+ *  linux/include/asm-arm/mmu_context.h
+ *
+ *  Copyright (C) 1996 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   27-06-1996	RMK	Created
+ */
+#ifndef __ASM_ARM_MMU_CONTEXT_H
+#define __ASM_ARM_MMU_CONTEXT_H
+
+#include <linux/compiler.h>
+#include <asm/cacheflush.h>
+#include <asm/proc-fns.h>
+
+void __check_kvm_seq(struct mm_struct *mm);
+
+#if __LINUX_ARM_ARCH__ >= 6
+
+/*
+ * On ARMv6, we have the following structure in the Context ID:
+ *
+ * 31                         7          0
+ * +-------------------------+-----------+
+ * |      process ID         |   ASID    |
+ * +-------------------------+-----------+
+ * |              context ID             |
+ * +-------------------------------------+
+ *
+ * The ASID is used to tag entries in the CPU caches and TLBs.
+ * The context ID is used by debuggers and trace logic, and
+ * should be unique within all running processes.
+ */
+#define ASID_BITS	8
+#define ASID_MASK	((~0) << ASID_BITS)
+
+extern unsigned int cpu_last_asid;
+
+void __init_new_context(struct task_struct *tsk, struct mm_struct *mm);
+void __new_context(struct mm_struct *mm);
+
+static inline void check_context(struct mm_struct *mm)
+{
+	if (unlikely((mm->context.id ^ cpu_last_asid) >> ASID_BITS))
+		__new_context(mm);
+
+	if (unlikely(mm->context.kvm_seq != init_mm.context.kvm_seq))
+		__check_kvm_seq(mm);
+}
+
+#define init_new_context(tsk,mm)	(__init_new_context(tsk,mm),0)
+
+#else
+
+static inline void check_context(struct mm_struct *mm)
+{
+	if (unlikely(mm->context.kvm_seq != init_mm.context.kvm_seq))
+		__check_kvm_seq(mm);
+}
+
+#define init_new_context(tsk,mm)	0
+
+#endif
+
+#define destroy_context(mm)		do { } while(0)
+
+/*
+ * This is called when "tsk" is about to enter lazy TLB mode.
+ *
+ * mm:  describes the currently active mm context
+ * tsk: task which is entering lazy tlb
+ * cpu: cpu number which is entering lazy tlb
+ *
+ * tsk->mm will be NULL
+ */
+static inline void
+enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+/*
+ * This is the actual mm switch as far as the scheduler
+ * is concerned.  No registers are touched.  We avoid
+ * calling the CPU specific function when the mm hasn't
+ * actually changed.
+ */
+static inline void
+switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	  struct task_struct *tsk)
+{
+#ifdef CONFIG_MMU
+	unsigned int cpu = smp_processor_id();
+
+	if (prev != next) {
+		cpu_set(cpu, next->cpu_vm_mask);
+		check_context(next);
+		cpu_switch_mm(next->pgd, next);
+		if (cache_is_vivt())
+			cpu_clear(cpu, prev->cpu_vm_mask);
+	}
+#endif
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+#define activate_mm(prev,next)	switch_mm(prev, next, NULL)
+
+#endif
Index: build_tree/linux/include/asm/mmzone.h
diff -u /dev/null build_tree/linux/include/asm/mmzone.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mmzone.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-arm/mmzone.h
+ *
+ *  1999-12-29	Nicolas Pitre		Created
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_MMZONE_H
+#define __ASM_MMZONE_H
+
+/*
+ * Currently defined in arch/arm/mm/discontig.c
+ */
+extern pg_data_t discontig_node_data[];
+
+/*
+ * Return a pointer to the node data for node n.
+ */
+#define NODE_DATA(nid)		(&discontig_node_data[nid])
+
+/*
+ * NODE_MEM_MAP gives the kaddr for the mem_map of the node.
+ */
+#define NODE_MEM_MAP(nid)	(NODE_DATA(nid)->node_mem_map)
+
+#include <asm/arch/memory.h>
+
+#endif
Index: build_tree/linux/include/asm/module.h
diff -u /dev/null build_tree/linux/include/asm/module.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/module.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,18 @@
+#ifndef _ASM_ARM_MODULE_H
+#define _ASM_ARM_MODULE_H
+
+struct mod_arch_specific
+{
+	int foo;
+};
+
+#define Elf_Shdr	Elf32_Shdr
+#define Elf_Sym		Elf32_Sym
+#define Elf_Ehdr	Elf32_Ehdr
+
+/*
+ * Include the ARM architecture version.
+ */
+#define MODULE_ARCH_VERMAGIC	"ARMv" __stringify(__LINUX_ARM_ARCH__) " "
+
+#endif /* _ASM_ARM_MODULE_H */
Index: build_tree/linux/include/asm/msgbuf.h
diff -u /dev/null build_tree/linux/include/asm/msgbuf.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/msgbuf.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,31 @@
+#ifndef _ASMARM_MSGBUF_H
+#define _ASMARM_MSGBUF_H
+
+/* 
+ * The msqid64_ds structure for arm architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long	__unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long	__unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long	__unused3;
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif /* _ASMARM_MSGBUF_H */
Index: build_tree/linux/include/asm/mtd-xip.h
diff -u /dev/null build_tree/linux/include/asm/mtd-xip.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mtd-xip.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,26 @@
+/*
+ * MTD primitives for XIP support. Architecture specific functions
+ *
+ * Do not include this file directly. It's included from linux/mtd/xip.h
+ * 
+ * Author:	Nicolas Pitre
+ * Created:	Nov 2, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * $Id: xip.h,v 1.2 2004/12/01 15:49:10 nico Exp $
+ */
+
+#ifndef __ARM_MTD_XIP_H__
+#define __ARM_MTD_XIP_H__
+
+#include <asm/hardware.h>
+#include <asm/arch/mtd-xip.h>
+
+/* fill instruction prefetch */
+#define xip_iprefetch() 	do { asm volatile (".rep 8; nop; .endr"); } while (0)
+
+#endif /* __ARM_MTD_XIP_H__ */
Index: build_tree/linux/include/asm/mutex.h
diff -u /dev/null build_tree/linux/include/asm/mutex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/mutex.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,127 @@
+/*
+ * include/asm-arm/mutex.h
+ *
+ * ARM optimized mutex locking primitives
+ *
+ * Please look into asm-generic/mutex-xchg.h for a formal definition.
+ */
+#ifndef _ASM_MUTEX_H
+#define _ASM_MUTEX_H
+
+#if __LINUX_ARM_ARCH__ < 6
+/* On pre-ARMv6 hardware the swp based implementation is the most efficient. */
+# include <asm-generic/mutex-xchg.h>
+#else
+
+/*
+ * Attempting to lock a mutex on ARMv6+ can be done with a bastardized
+ * atomic decrement (it is not a reliable atomic decrement but it satisfies
+ * the defined semantics for our purpose, while being smaller and faster
+ * than a real atomic decrement or atomic swap.  The idea is to attempt
+ * decrementing the lock value only once.  If once decremented it isn't zero,
+ * or if its store-back fails due to a dispute on the exclusive store, we
+ * simply bail out immediately through the slow path where the lock will be
+ * reattempted until it succeeds.
+ */
+static inline void
+__mutex_fastpath_lock(atomic_t *count, fastcall void (*fail_fn)(atomic_t *))
+{
+	int __ex_flag, __res;
+
+	__asm__ (
+
+		"ldrex	%0, [%2]	\n\t"
+		"sub	%0, %0, #1	\n\t"
+		"strex	%1, %0, [%2]	"
+
+		: "=&r" (__res), "=&r" (__ex_flag)
+		: "r" (&(count)->counter)
+		: "cc","memory" );
+
+	__res |= __ex_flag;
+	if (unlikely(__res != 0))
+		fail_fn(count);
+}
+
+static inline int
+__mutex_fastpath_lock_retval(atomic_t *count, fastcall int (*fail_fn)(atomic_t *))
+{
+	int __ex_flag, __res;
+
+	__asm__ (
+
+		"ldrex	%0, [%2]	\n\t"
+		"sub	%0, %0, #1	\n\t"
+		"strex	%1, %0, [%2]	"
+
+		: "=&r" (__res), "=&r" (__ex_flag)
+		: "r" (&(count)->counter)
+		: "cc","memory" );
+
+	__res |= __ex_flag;
+	if (unlikely(__res != 0))
+		__res = fail_fn(count);
+	return __res;
+}
+
+/*
+ * Same trick is used for the unlock fast path. However the original value,
+ * rather than the result, is used to test for success in order to have
+ * better generated assembly.
+ */
+static inline void
+__mutex_fastpath_unlock(atomic_t *count, fastcall void (*fail_fn)(atomic_t *))
+{
+	int __ex_flag, __res, __orig;
+
+	__asm__ (
+
+		"ldrex	%0, [%3]	\n\t"
+		"add	%1, %0, #1	\n\t"
+		"strex	%2, %1, [%3]	"
+
+		: "=&r" (__orig), "=&r" (__res), "=&r" (__ex_flag)
+		: "r" (&(count)->counter)
+		: "cc","memory" );
+
+	__orig |= __ex_flag;
+	if (unlikely(__orig != 0))
+		fail_fn(count);
+}
+
+/*
+ * If the unlock was done on a contended lock, or if the unlock simply fails
+ * then the mutex remains locked.
+ */
+#define __mutex_slowpath_needs_to_unlock()	1
+
+/*
+ * For __mutex_fastpath_trylock we use another construct which could be
+ * described as a "single value cmpxchg".
+ *
+ * This provides the needed trylock semantics like cmpxchg would, but it is
+ * lighter and less generic than a true cmpxchg implementation.
+ */
+static inline int
+__mutex_fastpath_trylock(atomic_t *count, int (*fail_fn)(atomic_t *))
+{
+	int __ex_flag, __res, __orig;
+
+	__asm__ (
+
+		"1: ldrex	%0, [%3]	\n\t"
+		"subs		%1, %0, #1	\n\t"
+		"strexeq	%2, %1, [%3]	\n\t"
+		"movlt		%0, #0		\n\t"
+		"cmpeq		%2, #0		\n\t"
+		"bgt		1b		"
+
+		: "=&r" (__orig), "=&r" (__res), "=&r" (__ex_flag)
+		: "r" (&count->counter)
+		: "cc", "memory" );
+
+	return __orig;
+}
+
+#endif
+#endif
Index: build_tree/linux/include/asm/namei.h
diff -u /dev/null build_tree/linux/include/asm/namei.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/namei.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,25 @@
+/* 
+ * linux/include/asm-arm/namei.h
+ *
+ * Routines to handle famous /usr/gnemul
+ * Derived from the Sparc version of this file
+ *
+ * Included from linux/fs/namei.c
+ */
+
+#ifndef __ASMARM_NAMEI_H
+#define __ASMARM_NAMEI_H
+
+#define ARM_BSD_EMUL "usr/gnemul/bsd/"
+
+static inline char *__emul_prefix(void)
+{
+	switch (current->personality) {
+	case PER_BSD:
+		return ARM_BSD_EMUL;
+	default:
+		return NULL;
+	}
+}
+
+#endif /* __ASMARM_NAMEI_H */
Index: build_tree/linux/include/asm/nwflash.h
diff -u /dev/null build_tree/linux/include/asm/nwflash.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/nwflash.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,9 @@
+#ifndef _FLASH_H
+#define _FLASH_H
+
+#define FLASH_MINOR		 160	/* MAJOR is 10 - miscdevice */
+#define CMD_WRITE_DISABLE	 0
+#define CMD_WRITE_ENABLE	 0x28
+#define CMD_WRITE_BASE64K_ENABLE 0x47
+
+#endif /* _FLASH_H */
Index: build_tree/linux/include/asm/page-nommu.h
diff -u /dev/null build_tree/linux/include/asm/page-nommu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/page-nommu.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,51 @@
+/*
+ *  linux/include/asm-arm/page-nommu.h
+ *
+ *  Copyright (C) 2004 Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PAGE_NOMMU_H
+#define _ASMARM_PAGE_NOMMU_H
+
+#if !defined(CONFIG_SMALL_TASKS) && PAGE_SHIFT < 13
+#define KTHREAD_SIZE (8192)
+#else
+#define KTHREAD_SIZE PAGE_SIZE
+#endif
+ 
+#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
+#define free_user_page(page, addr)	free_page(addr)
+
+#define clear_page(page)	memset((page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((to), (from), PAGE_SIZE)
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef unsigned long pte_t;
+typedef unsigned long pmd_t;
+typedef unsigned long pgd_t[2];
+typedef unsigned long pgprot_t;
+
+#define pte_val(x)      (x)
+#define pmd_val(x)      (x)
+#define pgd_val(x)	((x)[0])
+#define pgprot_val(x)   (x)
+
+#define __pte(x)        (x)
+#define __pmd(x)        (x)
+#define __pgprot(x)     (x)
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+#endif
Index: build_tree/linux/include/asm/page.h
diff -u /dev/null build_tree/linux/include/asm/page.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/page.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,197 @@
+/*
+ *  linux/include/asm-arm/page.h
+ *
+ *  Copyright (C) 1995-2003 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PAGE_H
+#define _ASMARM_PAGE_H
+
+
+#ifdef __KERNEL__
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT		12
+#define PAGE_SIZE		(1UL << PAGE_SHIFT)
+#define PAGE_MASK		(~(PAGE_SIZE-1))
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+#ifndef __ASSEMBLY__
+
+#ifndef CONFIG_MMU
+
+#include "page-nommu.h"
+
+#else
+
+#include <asm/glue.h>
+
+/*
+ *	User Space Model
+ *	================
+ *
+ *	This section selects the correct set of functions for dealing with
+ *	page-based copying and clearing for user space for the particular
+ *	processor(s) we're building for.
+ *
+ *	We have the following to choose from:
+ *	  v3		- ARMv3
+ *	  v4wt		- ARMv4 with writethrough cache, without minicache
+ *	  v4wb		- ARMv4 with writeback cache, without minicache
+ *	  v4_mc		- ARMv4 with minicache
+ *	  xscale	- Xscale
+ *	  xsc3		- XScalev3
+ */
+#undef _USER
+#undef MULTI_USER
+
+#ifdef CONFIG_CPU_COPY_V3
+# ifdef _USER
+#  define MULTI_USER 1
+# else
+#  define _USER v3
+# endif
+#endif
+
+#ifdef CONFIG_CPU_COPY_V4WT
+# ifdef _USER
+#  define MULTI_USER 1
+# else
+#  define _USER v4wt
+# endif
+#endif
+
+#ifdef CONFIG_CPU_COPY_V4WB
+# ifdef _USER
+#  define MULTI_USER 1
+# else
+#  define _USER v4wb
+# endif
+#endif
+
+#ifdef CONFIG_CPU_SA1100
+# ifdef _USER
+#  define MULTI_USER 1
+# else
+#  define _USER v4_mc
+# endif
+#endif
+
+#ifdef CONFIG_CPU_XSCALE
+# ifdef _USER
+#  define MULTI_USER 1
+# else
+#  define _USER xscale_mc
+# endif
+#endif
+
+#ifdef CONFIG_CPU_XSC3
+# ifdef _USER
+#  define MULTI_USER 1
+# else
+#  define _USER xsc3_mc
+# endif
+#endif
+
+#ifdef CONFIG_CPU_COPY_V6
+# define MULTI_USER 1
+#endif
+
+#if !defined(_USER) && !defined(MULTI_USER)
+#error Unknown user operations model
+#endif
+
+struct cpu_user_fns {
+	void (*cpu_clear_user_page)(void *p, unsigned long user);
+	void (*cpu_copy_user_page)(void *to, const void *from,
+				   unsigned long user);
+};
+
+#ifdef MULTI_USER
+extern struct cpu_user_fns cpu_user;
+
+#define __cpu_clear_user_page	cpu_user.cpu_clear_user_page
+#define __cpu_copy_user_page	cpu_user.cpu_copy_user_page
+
+#else
+
+#define __cpu_clear_user_page	__glue(_USER,_clear_user_page)
+#define __cpu_copy_user_page	__glue(_USER,_copy_user_page)
+
+extern void __cpu_clear_user_page(void *p, unsigned long user);
+extern void __cpu_copy_user_page(void *to, const void *from,
+				 unsigned long user);
+#endif
+
+#define clear_user_page(addr,vaddr,pg)	 __cpu_clear_user_page(addr, vaddr)
+#define copy_user_page(to,from,vaddr,pg) __cpu_copy_user_page(to, from, vaddr)
+
+#define clear_page(page)	memzero((void *)(page), PAGE_SIZE)
+extern void copy_page(void *to, const void *from);
+
+#undef STRICT_MM_TYPECHECKS
+
+#ifdef STRICT_MM_TYPECHECKS
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd; } pmd_t;
+typedef struct { unsigned long pgd[2]; } pgd_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+
+#define pte_val(x)      ((x).pte)
+#define pmd_val(x)      ((x).pmd)
+#define pgd_val(x)	((x).pgd[0])
+#define pgprot_val(x)   ((x).pgprot)
+
+#define __pte(x)        ((pte_t) { (x) } )
+#define __pmd(x)        ((pmd_t) { (x) } )
+#define __pgprot(x)     ((pgprot_t) { (x) } )
+
+#else
+/*
+ * .. while these make it easier on the compiler
+ */
+typedef unsigned long pte_t;
+typedef unsigned long pmd_t;
+typedef unsigned long pgd_t[2];
+typedef unsigned long pgprot_t;
+
+#define pte_val(x)      (x)
+#define pmd_val(x)      (x)
+#define pgd_val(x)	((x)[0])
+#define pgprot_val(x)   (x)
+
+#define __pte(x)        (x)
+#define __pmd(x)        (x)
+#define __pgprot(x)     (x)
+
+#endif /* STRICT_MM_TYPECHECKS */
+
+#endif /* CONFIG_MMU */
+
+#include <asm/memory.h>
+
+#endif /* !__ASSEMBLY__ */
+
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+/*
+ * With EABI on ARMv5 and above we must have 64-bit aligned slab pointers.
+ */
+#if defined(CONFIG_AEABI) && (__LINUX_ARM_ARCH__ >= 5)
+#define ARCH_SLAB_MINALIGN 8
+#endif
+
+#include <asm-generic/page.h>
+
+#endif /* __KERNEL__ */
+
+#endif
Index: build_tree/linux/include/asm/param.h
diff -u /dev/null build_tree/linux/include/asm/param.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/param.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,31 @@
+/*
+ *  linux/include/asm-arm/param.h
+ *
+ *  Copyright (C) 1995-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PARAM_H
+#define __ASM_PARAM_H
+
+#ifdef __KERNEL__
+# define HZ		CONFIG_HZ	/* Internal kernel timer frequency */
+# define USER_HZ	100		/* User interfaces are in "ticks" */
+# define CLOCKS_PER_SEC	(USER_HZ)	/* like times() */
+#else
+# define HZ		100
+#endif
+
+#define EXEC_PAGESIZE	4096
+
+#ifndef NOGROUP
+#define NOGROUP         (-1)
+#endif
+
+/* max length of hostname */
+#define MAXHOSTNAMELEN  64
+
+#endif
+
Index: build_tree/linux/include/asm/parport.h
diff -u /dev/null build_tree/linux/include/asm/parport.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/parport.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/parport.h: ARM-specific parport initialisation
+ *
+ *  Copyright (C) 1999, 2000  Tim Waugh <tim@cyberelk.demon.co.uk>
+ *
+ * This file should only be included by drivers/parport/parport_pc.c.
+ */
+
+#ifndef __ASMARM_PARPORT_H
+#define __ASMARM_PARPORT_H
+
+static int __devinit parport_pc_find_isa_ports (int autoirq, int autodma);
+static int __devinit parport_pc_find_nonpci_ports (int autoirq, int autodma)
+{
+	return parport_pc_find_isa_ports (autoirq, autodma);
+}
+
+#endif /* !(_ASMARM_PARPORT_H) */
Index: build_tree/linux/include/asm/pci.h
diff -u /dev/null build_tree/linux/include/asm/pci.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/pci.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,85 @@
+#ifndef ASMARM_PCI_H
+#define ASMARM_PCI_H
+
+#ifdef __KERNEL__
+#include <asm-generic/pci-dma-compat.h>
+
+#include <asm/hardware.h> /* for PCIBIOS_MIN_* */
+
+#define pcibios_scan_all_fns(a, b)	0
+
+static inline void pcibios_set_master(struct pci_dev *dev)
+{
+	/* No special bus mastering setup handling */
+}
+
+static inline void pcibios_penalize_isa_irq(int irq, int active)
+{
+	/* We don't do dynamic PCI IRQ allocation */
+}
+
+/*
+ * The PCI address space does equal the physical memory address space.
+ * The networking and block device layers use this boolean for bounce
+ * buffer decisions.
+ */
+#define PCI_DMA_BUS_IS_PHYS     (0)
+
+/*
+ * We don't support DAC DMA cycles.
+ */
+#define pci_dac_dma_supported(pci_dev, mask)	(0)
+
+/*
+ * Whether pci_unmap_{single,page} is a nop depends upon the
+ * configuration.
+ */
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME)	dma_addr_t ADDR_NAME;
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME)		__u32 LEN_NAME;
+#define pci_unmap_addr(PTR, ADDR_NAME)		((PTR)->ADDR_NAME)
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL)	(((PTR)->ADDR_NAME) = (VAL))
+#define pci_unmap_len(PTR, LEN_NAME)		((PTR)->LEN_NAME)
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL)	(((PTR)->LEN_NAME) = (VAL))
+
+#ifdef CONFIG_PCI
+static inline void pci_dma_burst_advice(struct pci_dev *pdev,
+					enum pci_dma_burst_strategy *strat,
+					unsigned long *strategy_parameter)
+{
+	*strat = PCI_DMA_BURST_INFINITY;
+	*strategy_parameter = ~0UL;
+}
+#endif
+
+#define HAVE_PCI_MMAP
+extern int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
+                               enum pci_mmap_state mmap_state, int write_combine);
+
+extern void
+pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+			 struct resource *res);
+
+extern void
+pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			struct pci_bus_region *region);
+
+static inline struct resource *
+pcibios_select_root(struct pci_dev *pdev, struct resource *res)
+{
+	struct resource *root = NULL;
+
+	if (res->flags & IORESOURCE_IO)
+		root = &ioport_resource;
+	if (res->flags & IORESOURCE_MEM)
+		root = &iomem_resource;
+
+	return root;
+}
+
+static inline void pcibios_add_platform_entries(struct pci_dev *dev)
+{
+}
+
+#endif /* __KERNEL__ */
+ 
+#endif
Index: build_tree/linux/include/asm/percpu.h
diff -u /dev/null build_tree/linux/include/asm/percpu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/percpu.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef __ARM_PERCPU
+#define __ARM_PERCPU
+
+#include <asm-generic/percpu.h>
+
+#endif
Index: build_tree/linux/include/asm/pgalloc.h
diff -u /dev/null build_tree/linux/include/asm/pgalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/pgalloc.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,133 @@
+/*
+ *  linux/include/asm-arm/pgalloc.h
+ *
+ *  Copyright (C) 2000-2001 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PGALLOC_H
+#define _ASMARM_PGALLOC_H
+
+#include <asm/domain.h>
+#include <asm/pgtable-hwdef.h>
+#include <asm/processor.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+
+#define check_pgt_cache()		do { } while (0)
+
+#ifdef CONFIG_MMU
+
+#define _PAGE_USER_TABLE	(PMD_TYPE_TABLE | PMD_BIT4 | PMD_DOMAIN(DOMAIN_USER))
+#define _PAGE_KERNEL_TABLE	(PMD_TYPE_TABLE | PMD_BIT4 | PMD_DOMAIN(DOMAIN_KERNEL))
+
+/*
+ * Since we have only two-level page tables, these are trivial
+ */
+#define pmd_alloc_one(mm,addr)		({ BUG(); ((pmd_t *)2); })
+#define pmd_free(pmd)			do { } while (0)
+#define pgd_populate(mm,pmd,pte)	BUG()
+
+extern pgd_t *get_pgd_slow(struct mm_struct *mm);
+extern void free_pgd_slow(pgd_t *pgd);
+
+#define pgd_alloc(mm)			get_pgd_slow(mm)
+#define pgd_free(pgd)			free_pgd_slow(pgd)
+
+/*
+ * Allocate one PTE table.
+ *
+ * This actually allocates two hardware PTE tables, but we wrap this up
+ * into one table thus:
+ *
+ *  +------------+
+ *  |  h/w pt 0  |
+ *  +------------+
+ *  |  h/w pt 1  |
+ *  +------------+
+ *  | Linux pt 0 |
+ *  +------------+
+ *  | Linux pt 1 |
+ *  +------------+
+ */
+static inline pte_t *
+pte_alloc_one_kernel(struct mm_struct *mm, unsigned long addr)
+{
+	pte_t *pte;
+
+	pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);
+	if (pte) {
+		clean_dcache_area(pte, sizeof(pte_t) * PTRS_PER_PTE);
+		pte += PTRS_PER_PTE;
+	}
+
+	return pte;
+}
+
+static inline struct page *
+pte_alloc_one(struct mm_struct *mm, unsigned long addr)
+{
+	struct page *pte;
+
+	pte = alloc_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO, 0);
+	if (pte) {
+		void *page = page_address(pte);
+		clean_dcache_area(page, sizeof(pte_t) * PTRS_PER_PTE);
+	}
+
+	return pte;
+}
+
+/*
+ * Free one PTE table.
+ */
+static inline void pte_free_kernel(pte_t *pte)
+{
+	if (pte) {
+		pte -= PTRS_PER_PTE;
+		free_page((unsigned long)pte);
+	}
+}
+
+static inline void pte_free(struct page *pte)
+{
+	__free_page(pte);
+}
+
+static inline void __pmd_populate(pmd_t *pmdp, unsigned long pmdval)
+{
+	pmdp[0] = __pmd(pmdval);
+	pmdp[1] = __pmd(pmdval + 256 * sizeof(pte_t));
+	flush_pmd_entry(pmdp);
+}
+
+/*
+ * Populate the pmdp entry with a pointer to the pte.  This pmd is part
+ * of the mm address space.
+ *
+ * Ensure that we always set both PMD entries.
+ */
+static inline void
+pmd_populate_kernel(struct mm_struct *mm, pmd_t *pmdp, pte_t *ptep)
+{
+	unsigned long pte_ptr = (unsigned long)ptep;
+
+	/*
+	 * The pmd must be loaded with the physical
+	 * address of the PTE table
+	 */
+	pte_ptr -= PTRS_PER_PTE * sizeof(void *);
+	__pmd_populate(pmdp, __pa(pte_ptr) | _PAGE_KERNEL_TABLE);
+}
+
+static inline void
+pmd_populate(struct mm_struct *mm, pmd_t *pmdp, struct page *ptep)
+{
+	__pmd_populate(pmdp, page_to_pfn(ptep) << PAGE_SHIFT | _PAGE_USER_TABLE);
+}
+
+#endif /* CONFIG_MMU */
+
+#endif
Index: build_tree/linux/include/asm/pgtable-hwdef.h
diff -u /dev/null build_tree/linux/include/asm/pgtable-hwdef.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/pgtable-hwdef.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,90 @@
+/*
+ *  linux/include/asm-arm/pgtable-hwdef.h
+ *
+ *  Copyright (C) 1995-2002 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PGTABLE_HWDEF_H
+#define _ASMARM_PGTABLE_HWDEF_H
+
+/*
+ * Hardware page table definitions.
+ *
+ * + Level 1 descriptor (PMD)
+ *   - common
+ */
+#define PMD_TYPE_MASK		(3 << 0)
+#define PMD_TYPE_FAULT		(0 << 0)
+#define PMD_TYPE_TABLE		(1 << 0)
+#define PMD_TYPE_SECT		(2 << 0)
+#define PMD_BIT4		(1 << 4)
+#define PMD_DOMAIN(x)		((x) << 5)
+#define PMD_PROTECTION		(1 << 9)	/* v5 */
+/*
+ *   - section
+ */
+#define PMD_SECT_BUFFERABLE	(1 << 2)
+#define PMD_SECT_CACHEABLE	(1 << 3)
+#define PMD_SECT_XN		(1 << 4)	/* v6 */
+#define PMD_SECT_AP_WRITE	(1 << 10)
+#define PMD_SECT_AP_READ	(1 << 11)
+#define PMD_SECT_TEX(x)		((x) << 12)	/* v5 */
+#define PMD_SECT_APX		(1 << 15)	/* v6 */
+#define PMD_SECT_S		(1 << 16)	/* v6 */
+#define PMD_SECT_nG		(1 << 17)	/* v6 */
+#define PMD_SECT_SUPER		(1 << 18)	/* v6 */
+
+#define PMD_SECT_UNCACHED	(0)
+#define PMD_SECT_BUFFERED	(PMD_SECT_BUFFERABLE)
+#define PMD_SECT_WT		(PMD_SECT_CACHEABLE)
+#define PMD_SECT_WB		(PMD_SECT_CACHEABLE | PMD_SECT_BUFFERABLE)
+#define PMD_SECT_MINICACHE	(PMD_SECT_TEX(1) | PMD_SECT_CACHEABLE)
+#define PMD_SECT_WBWA		(PMD_SECT_TEX(1) | PMD_SECT_CACHEABLE | PMD_SECT_BUFFERABLE)
+#define PMD_SECT_NONSHARED_DEV	(PMD_SECT_TEX(2))
+
+/*
+ *   - coarse table (not used)
+ */
+
+/*
+ * + Level 2 descriptor (PTE)
+ *   - common
+ */
+#define PTE_TYPE_MASK		(3 << 0)
+#define PTE_TYPE_FAULT		(0 << 0)
+#define PTE_TYPE_LARGE		(1 << 0)
+#define PTE_TYPE_SMALL		(2 << 0)
+#define PTE_TYPE_EXT		(3 << 0)	/* v5 */
+#define PTE_BUFFERABLE		(1 << 2)
+#define PTE_CACHEABLE		(1 << 3)
+
+/*
+ *   - extended small page/tiny page
+ */
+#define PTE_EXT_XN		(1 << 0)	/* v6 */
+#define PTE_EXT_AP_MASK		(3 << 4)
+#define PTE_EXT_AP0		(1 << 4)
+#define PTE_EXT_AP1		(2 << 4)
+#define PTE_EXT_AP_UNO_SRO	(0 << 4)
+#define PTE_EXT_AP_UNO_SRW	(PTE_EXT_AP0)
+#define PTE_EXT_AP_URO_SRW	(PTE_EXT_AP1)
+#define PTE_EXT_AP_URW_SRW	(PTE_EXT_AP1|PTE_EXT_AP0)
+#define PTE_EXT_TEX(x)		((x) << 6)	/* v5 */
+#define PTE_EXT_APX		(1 << 9)	/* v6 */
+#define PTE_EXT_COHERENT	(1 << 9)	/* XScale3 */
+#define PTE_EXT_SHARED		(1 << 10)	/* v6 */
+#define PTE_EXT_NG		(1 << 11)	/* v6 */
+
+/*
+ *   - small page
+ */
+#define PTE_SMALL_AP_MASK	(0xff << 4)
+#define PTE_SMALL_AP_UNO_SRO	(0x00 << 4)
+#define PTE_SMALL_AP_UNO_SRW	(0x55 << 4)
+#define PTE_SMALL_AP_URO_SRW	(0xaa << 4)
+#define PTE_SMALL_AP_URW_SRW	(0xff << 4)
+
+#endif
Index: build_tree/linux/include/asm/pgtable-nommu.h
diff -u /dev/null build_tree/linux/include/asm/pgtable-nommu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/pgtable-nommu.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,121 @@
+/*
+ *  linux/include/asm-arm/pgtable-nommu.h
+ *
+ *  Copyright (C) 1995-2002 Russell King
+ *  Copyright (C) 2004  Hyok S. Choi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PGTABLE_NOMMU_H
+#define _ASMARM_PGTABLE_NOMMU_H
+
+#ifndef __ASSEMBLY__
+
+#include <linux/slab.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/io.h>
+
+/*
+ * Trivial page table functions.
+ */
+#define pgd_present(pgd)	(1)
+#define pgd_none(pgd)		(0)
+#define pgd_bad(pgd)		(0)
+#define pgd_clear(pgdp)
+#define kern_addr_valid(addr)	(1)
+#define	pmd_offset(a, b)	((void *)0)
+/* FIXME */
+/*
+ * PMD_SHIFT determines the size of the area a second-level page table can map
+ * PGDIR_SHIFT determines what a third-level page table entry can map
+ */
+#define PGDIR_SHIFT		21
+
+#define PGDIR_SIZE		(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK		(~(PGDIR_SIZE-1))
+/* FIXME */
+
+#define PAGE_NONE	__pgprot(0)
+#define PAGE_SHARED	__pgprot(0)
+#define PAGE_COPY	__pgprot(0)
+#define PAGE_READONLY	__pgprot(0)
+#define PAGE_KERNEL	__pgprot(0)
+
+#define swapper_pg_dir ((pgd_t *) 0)
+
+#define __swp_type(x)		(0)
+#define __swp_offset(x)		(0)
+#define __swp_entry(typ,off)	((swp_entry_t) { ((typ) | ((off) << 7)) })
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+
+typedef pte_t *pte_addr_t;
+
+static inline int pte_file(pte_t pte) { return 0; }
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+#define ZERO_PAGE(vaddr)	(virt_to_page(0))
+
+/*
+ * Mark the prot value as uncacheable and unbufferable.
+ */
+#define pgprot_noncached(prot)	__pgprot(0)
+#define pgprot_writecombine(prot) __pgprot(0)
+
+
+/*
+ * These would be in other places but having them here reduces the diffs.
+ */
+extern unsigned int kobjsize(const void *objp);
+extern int is_in_rom(unsigned long);
+
+/*
+ * No page table caches to initialise.
+ */
+#define pgtable_cache_init()	do { } while (0)
+#define io_remap_page_range	remap_page_range
+#define io_remap_pfn_range	remap_pfn_range
+
+#define MK_IOSPACE_PFN(space, pfn)	(pfn)
+#define GET_IOSPACE(pfn)		0
+#define GET_PFN(pfn)			(pfn)
+
+
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
+#define FIRST_USER_ADDRESS      (0)
+
+#else 
+
+/*
+ * dummy tlb and user structures.
+ */
+#define v3_tlb_fns	(0)
+#define v4_tlb_fns	(0)
+#define v4wb_tlb_fns	(0)
+#define v4wbi_tlb_fns	(0)
+#define v6_tlb_fns	(0)
+
+#define v3_user_fns	(0)
+#define v4_user_fns	(0)
+#define v4_mc_user_fns	(0)
+#define v4wb_user_fns	(0)
+#define v4wt_user_fns	(0)
+#define v6_user_fns	(0)
+#define xscale_mc_user_fns (0)
+
+#endif /*__ASSEMBLY__*/
+
+#endif /* _ASMARM_PGTABLE_H */
Index: build_tree/linux/include/asm/pgtable.h
diff -u /dev/null build_tree/linux/include/asm/pgtable.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/pgtable.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,408 @@
+/*
+ *  linux/include/asm-arm/pgtable.h
+ *
+ *  Copyright (C) 1995-2002 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_PGTABLE_H
+#define _ASMARM_PGTABLE_H
+
+#include <asm-generic/4level-fixup.h>
+#include <asm/proc-fns.h>
+
+#ifndef CONFIG_MMU
+
+#include "pgtable-nommu.h"
+
+#else
+
+#include <asm/memory.h>
+#include <asm/arch/vmalloc.h>
+#include <asm/pgtable-hwdef.h>
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ *
+ * Note that platforms may override VMALLOC_START, but they must provide
+ * VMALLOC_END.  VMALLOC_END defines the (exclusive) limit of this space,
+ * which may not overlap IO space.
+ */
+#ifndef VMALLOC_START
+#define VMALLOC_OFFSET		(8*1024*1024)
+#define VMALLOC_START		(((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#endif
+
+/*
+ * Hardware-wise, we have a two level page table structure, where the first
+ * level has 4096 entries, and the second level has 256 entries.  Each entry
+ * is one 32-bit word.  Most of the bits in the second level entry are used
+ * by hardware, and there aren't any "accessed" and "dirty" bits.
+ *
+ * Linux on the other hand has a three level page table structure, which can
+ * be wrapped to fit a two level page table structure easily - using the PGD
+ * and PTE only.  However, Linux also expects one "PTE" table per page, and
+ * at least a "dirty" bit.
+ *
+ * Therefore, we tweak the implementation slightly - we tell Linux that we
+ * have 2048 entries in the first level, each of which is 8 bytes (iow, two
+ * hardware pointers to the second level.)  The second level contains two
+ * hardware PTE tables arranged contiguously, followed by Linux versions
+ * which contain the state information Linux needs.  We, therefore, end up
+ * with 512 entries in the "PTE" level.
+ *
+ * This leads to the page tables having the following layout:
+ *
+ *    pgd             pte
+ * |        |
+ * +--------+ +0
+ * |        |-----> +------------+ +0
+ * +- - - - + +4    |  h/w pt 0  |
+ * |        |-----> +------------+ +1024
+ * +--------+ +8    |  h/w pt 1  |
+ * |        |       +------------+ +2048
+ * +- - - - +       | Linux pt 0 |
+ * |        |       +------------+ +3072
+ * +--------+       | Linux pt 1 |
+ * |        |       +------------+ +4096
+ *
+ * See L_PTE_xxx below for definitions of bits in the "Linux pt", and
+ * PTE_xxx for definitions of bits appearing in the "h/w pt".
+ *
+ * PMD_xxx definitions refer to bits in the first level page table.
+ *
+ * The "dirty" bit is emulated by only granting hardware write permission
+ * iff the page is marked "writable" and "dirty" in the Linux PTE.  This
+ * means that a write to a clean page will cause a permission fault, and
+ * the Linux MM layer will mark the page dirty via handle_pte_fault().
+ * For the hardware to notice the permission change, the TLB entry must
+ * be flushed, and ptep_establish() does that for us.
+ *
+ * The "accessed" or "young" bit is emulated by a similar method; we only
+ * allow accesses to the page if the "young" bit is set.  Accesses to the
+ * page will cause a fault, and handle_pte_fault() will set the young bit
+ * for us as long as the page is marked present in the corresponding Linux
+ * PTE entry.  Again, ptep_establish() will ensure that the TLB is up to
+ * date.
+ *
+ * However, when the "young" bit is cleared, we deny access to the page
+ * by clearing the hardware PTE.  Currently Linux does not flush the TLB
+ * for us in this case, which means the TLB will retain the transation
+ * until either the TLB entry is evicted under pressure, or a context
+ * switch which changes the user space mapping occurs.
+ */
+#define PTRS_PER_PTE		512
+#define PTRS_PER_PMD		1
+#define PTRS_PER_PGD		2048
+
+/*
+ * PMD_SHIFT determines the size of the area a second-level page table can map
+ * PGDIR_SHIFT determines what a third-level page table entry can map
+ */
+#define PMD_SHIFT		21
+#define PGDIR_SHIFT		21
+
+#define LIBRARY_TEXT_START	0x0c000000
+
+#ifndef __ASSEMBLY__
+extern void __pte_error(const char *file, int line, unsigned long val);
+extern void __pmd_error(const char *file, int line, unsigned long val);
+extern void __pgd_error(const char *file, int line, unsigned long val);
+
+#define pte_ERROR(pte)		__pte_error(__FILE__, __LINE__, pte_val(pte))
+#define pmd_ERROR(pmd)		__pmd_error(__FILE__, __LINE__, pmd_val(pmd))
+#define pgd_ERROR(pgd)		__pgd_error(__FILE__, __LINE__, pgd_val(pgd))
+#endif /* !__ASSEMBLY__ */
+
+#define PMD_SIZE		(1UL << PMD_SHIFT)
+#define PMD_MASK		(~(PMD_SIZE-1))
+#define PGDIR_SIZE		(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK		(~(PGDIR_SIZE-1))
+
+/*
+ * This is the lowest virtual address we can permit any user space
+ * mapping to be mapped at.  This is particularly important for
+ * non-high vector CPUs.
+ */
+#define FIRST_USER_ADDRESS	PAGE_SIZE
+
+#define FIRST_USER_PGD_NR	1
+#define USER_PTRS_PER_PGD	((TASK_SIZE/PGDIR_SIZE) - FIRST_USER_PGD_NR)
+
+/*
+ * section address mask and size definitions.
+ */
+#define SECTION_SHIFT		20
+#define SECTION_SIZE		(1UL << SECTION_SHIFT)
+#define SECTION_MASK		(~(SECTION_SIZE-1))
+
+/*
+ * ARMv6 supersection address mask and size definitions.
+ */
+#define SUPERSECTION_SHIFT	24
+#define SUPERSECTION_SIZE	(1UL << SUPERSECTION_SHIFT)
+#define SUPERSECTION_MASK	(~(SUPERSECTION_SIZE-1))
+
+/*
+ * "Linux" PTE definitions.
+ *
+ * We keep two sets of PTEs - the hardware and the linux version.
+ * This allows greater flexibility in the way we map the Linux bits
+ * onto the hardware tables, and allows us to have YOUNG and DIRTY
+ * bits.
+ *
+ * The PTE table pointer refers to the hardware entries; the "Linux"
+ * entries are stored 1024 bytes below.
+ */
+#define L_PTE_PRESENT		(1 << 0)
+#define L_PTE_FILE		(1 << 1)	/* only when !PRESENT */
+#define L_PTE_YOUNG		(1 << 1)
+#define L_PTE_BUFFERABLE	(1 << 2)	/* matches PTE */
+#define L_PTE_CACHEABLE		(1 << 3)	/* matches PTE */
+#define L_PTE_USER		(1 << 4)
+#define L_PTE_WRITE		(1 << 5)
+#define L_PTE_EXEC		(1 << 6)
+#define L_PTE_DIRTY		(1 << 7)
+#define L_PTE_SHARED		(1 << 10)	/* shared(v6), coherent(xsc3) */
+
+#ifndef __ASSEMBLY__
+
+/*
+ * The pgprot_* and protection_map entries will be fixed up in runtime
+ * to include the cachable and bufferable bits based on memory policy,
+ * as well as any architecture dependent bits like global/ASID and SMP
+ * shared mapping bits.
+ */
+#define _L_PTE_DEFAULT	L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_CACHEABLE | L_PTE_BUFFERABLE
+#define _L_PTE_READ	L_PTE_USER | L_PTE_EXEC
+
+extern pgprot_t		pgprot_user;
+extern pgprot_t		pgprot_kernel;
+
+#define PAGE_NONE	pgprot_user
+#define PAGE_COPY	__pgprot(pgprot_val(pgprot_user) | _L_PTE_READ)
+#define PAGE_SHARED	__pgprot(pgprot_val(pgprot_user) | _L_PTE_READ | \
+				 L_PTE_WRITE)
+#define PAGE_READONLY	__pgprot(pgprot_val(pgprot_user) | _L_PTE_READ)
+#define PAGE_KERNEL	pgprot_kernel
+
+#define __PAGE_NONE	__pgprot(_L_PTE_DEFAULT)
+#define __PAGE_COPY	__pgprot(_L_PTE_DEFAULT | _L_PTE_READ)
+#define __PAGE_SHARED	__pgprot(_L_PTE_DEFAULT | _L_PTE_READ | L_PTE_WRITE)
+#define __PAGE_READONLY	__pgprot(_L_PTE_DEFAULT | _L_PTE_READ)
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * The table below defines the page protection levels that we insert into our
+ * Linux page table version.  These get translated into the best that the
+ * architecture can perform.  Note that on most ARM hardware:
+ *  1) We cannot do execute protection
+ *  2) If we could do execute protection, then read is implied
+ *  3) write implies read permissions
+ */
+#define __P000  __PAGE_NONE
+#define __P001  __PAGE_READONLY
+#define __P010  __PAGE_COPY
+#define __P011  __PAGE_COPY
+#define __P100  __PAGE_READONLY
+#define __P101  __PAGE_READONLY
+#define __P110  __PAGE_COPY
+#define __P111  __PAGE_COPY
+
+#define __S000  __PAGE_NONE
+#define __S001  __PAGE_READONLY
+#define __S010  __PAGE_SHARED
+#define __S011  __PAGE_SHARED
+#define __S100  __PAGE_READONLY
+#define __S101  __PAGE_READONLY
+#define __S110  __PAGE_SHARED
+#define __S111  __PAGE_SHARED
+
+#ifndef __ASSEMBLY__
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+extern struct page *empty_zero_page;
+#define ZERO_PAGE(vaddr)	(empty_zero_page)
+
+#define pte_pfn(pte)		(pte_val(pte) >> PAGE_SHIFT)
+#define pfn_pte(pfn,prot)	(__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot)))
+
+#define pte_none(pte)		(!pte_val(pte))
+#define pte_clear(mm,addr,ptep)	set_pte_ext(ptep, __pte(0), 0)
+#define pte_page(pte)		(pfn_to_page(pte_pfn(pte)))
+#define pte_offset_kernel(dir,addr)	(pmd_page_vaddr(*(dir)) + __pte_index(addr))
+#define pte_offset_map(dir,addr)	(pmd_page_vaddr(*(dir)) + __pte_index(addr))
+#define pte_offset_map_nested(dir,addr)	(pmd_page_vaddr(*(dir)) + __pte_index(addr))
+#define pte_unmap(pte)		do { } while (0)
+#define pte_unmap_nested(pte)	do { } while (0)
+
+#define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)
+
+#define set_pte_at(mm,addr,ptep,pteval) do { \
+	set_pte_ext(ptep, pteval, (addr) >= PAGE_OFFSET ? 0 : PTE_EXT_NG); \
+ } while (0)
+
+/*
+ * The following only work if pte_present() is true.
+ * Undefined behaviour if not..
+ */
+#define pte_present(pte)	(pte_val(pte) & L_PTE_PRESENT)
+#define pte_read(pte)		(pte_val(pte) & L_PTE_USER)
+#define pte_write(pte)		(pte_val(pte) & L_PTE_WRITE)
+#define pte_exec(pte)		(pte_val(pte) & L_PTE_EXEC)
+#define pte_dirty(pte)		(pte_val(pte) & L_PTE_DIRTY)
+#define pte_young(pte)		(pte_val(pte) & L_PTE_YOUNG)
+
+/*
+ * The following only works if pte_present() is not true.
+ */
+#define pte_file(pte)		(pte_val(pte) & L_PTE_FILE)
+#define pte_to_pgoff(x)		(pte_val(x) >> 2)
+#define pgoff_to_pte(x)		__pte(((x) << 2) | L_PTE_FILE)
+
+#define PTE_FILE_MAX_BITS	30
+
+#define PTE_BIT_FUNC(fn,op) \
+static inline pte_t pte_##fn(pte_t pte) { pte_val(pte) op; return pte; }
+
+/*PTE_BIT_FUNC(rdprotect, &= ~L_PTE_USER);*/
+/*PTE_BIT_FUNC(mkread,    |= L_PTE_USER);*/
+PTE_BIT_FUNC(wrprotect, &= ~L_PTE_WRITE);
+PTE_BIT_FUNC(mkwrite,   |= L_PTE_WRITE);
+PTE_BIT_FUNC(exprotect, &= ~L_PTE_EXEC);
+PTE_BIT_FUNC(mkexec,    |= L_PTE_EXEC);
+PTE_BIT_FUNC(mkclean,   &= ~L_PTE_DIRTY);
+PTE_BIT_FUNC(mkdirty,   |= L_PTE_DIRTY);
+PTE_BIT_FUNC(mkold,     &= ~L_PTE_YOUNG);
+PTE_BIT_FUNC(mkyoung,   |= L_PTE_YOUNG);
+
+/*
+ * Mark the prot value as uncacheable and unbufferable.
+ */
+#define pgprot_noncached(prot)	__pgprot(pgprot_val(prot) & ~(L_PTE_CACHEABLE | L_PTE_BUFFERABLE))
+#define pgprot_writecombine(prot) __pgprot(pgprot_val(prot) & ~L_PTE_CACHEABLE)
+
+#define pmd_none(pmd)		(!pmd_val(pmd))
+#define pmd_present(pmd)	(pmd_val(pmd))
+#define pmd_bad(pmd)		(pmd_val(pmd) & 2)
+
+#define copy_pmd(pmdpd,pmdps)		\
+	do {				\
+		pmdpd[0] = pmdps[0];	\
+		pmdpd[1] = pmdps[1];	\
+		flush_pmd_entry(pmdpd);	\
+	} while (0)
+
+#define pmd_clear(pmdp)			\
+	do {				\
+		pmdp[0] = __pmd(0);	\
+		pmdp[1] = __pmd(0);	\
+		clean_pmd_entry(pmdp);	\
+	} while (0)
+
+static inline pte_t *pmd_page_vaddr(pmd_t pmd)
+{
+	unsigned long ptr;
+
+	ptr = pmd_val(pmd) & ~(PTRS_PER_PTE * sizeof(void *) - 1);
+	ptr += PTRS_PER_PTE * sizeof(void *);
+
+	return __va(ptr);
+}
+
+#define pmd_page(pmd) virt_to_page(__va(pmd_val(pmd)))
+
+/*
+ * Permanent address of a page. We never have highmem, so this is trivial.
+ */
+#define pages_to_mb(x)		((x) >> (20 - PAGE_SHIFT))
+
+/*
+ * Conversion functions: convert a page and protection to a page entry,
+ * and a page entry and page directory to the page they refer to.
+ */
+#define mk_pte(page,prot)	pfn_pte(page_to_pfn(page),prot)
+
+/*
+ * The "pgd_xxx()" functions here are trivial for a folded two-level
+ * setup: the pgd is never bad, and a pmd always exists (as it's folded
+ * into the pgd entry)
+ */
+#define pgd_none(pgd)		(0)
+#define pgd_bad(pgd)		(0)
+#define pgd_present(pgd)	(1)
+#define pgd_clear(pgdp)		do { } while (0)
+#define set_pgd(pgd,pgdp)	do { } while (0)
+
+/* to find an entry in a page-table-directory */
+#define pgd_index(addr)		((addr) >> PGDIR_SHIFT)
+
+#define pgd_offset(mm, addr)	((mm)->pgd+pgd_index(addr))
+
+/* to find an entry in a kernel page-table-directory */
+#define pgd_offset_k(addr)	pgd_offset(&init_mm, addr)
+
+/* Find an entry in the second-level page table.. */
+#define pmd_offset(dir, addr)	((pmd_t *)(dir))
+
+/* Find an entry in the third-level page table.. */
+#define __pte_index(addr)	(((addr) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	const unsigned long mask = L_PTE_EXEC | L_PTE_WRITE | L_PTE_USER;
+	pte_val(pte) = (pte_val(pte) & ~mask) | (pgprot_val(newprot) & mask);
+	return pte;
+}
+
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+
+/* Encode and decode a swap entry.
+ *
+ * We support up to 32GB of swap on 4k machines
+ */
+#define __swp_type(x)		(((x).val >> 2) & 0x7f)
+#define __swp_offset(x)		((x).val >> 9)
+#define __swp_entry(type,offset) ((swp_entry_t) { ((type) << 2) | ((offset) << 9) })
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(swp)	((pte_t) { (swp).val })
+
+/* Needs to be defined here and not in linux/mm.h, as it is arch dependent */
+/* FIXME: this is not correct */
+#define kern_addr_valid(addr)	(1)
+
+#include <asm-generic/pgtable.h>
+
+/*
+ * We provide our own arch_get_unmapped_area to cope with VIPT caches.
+ */
+#define HAVE_ARCH_UNMAPPED_AREA
+
+/*
+ * remap a physical page `pfn' of size `size' with page protection `prot'
+ * into virtual address `from'
+ */
+#define io_remap_pfn_range(vma,from,pfn,size,prot) \
+		remap_pfn_range(vma, from, pfn, size, prot)
+
+#define MK_IOSPACE_PFN(space, pfn)	(pfn)
+#define GET_IOSPACE(pfn)		0
+#define GET_PFN(pfn)			(pfn)
+
+#define pgtable_cache_init() do { } while (0)
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* CONFIG_MMU */
+
+#endif /* _ASMARM_PGTABLE_H */
Index: build_tree/linux/include/asm/poll.h
diff -u /dev/null build_tree/linux/include/asm/poll.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/poll.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,27 @@
+#ifndef __ASMARM_POLL_H
+#define __ASMARM_POLL_H
+
+/* These are specified by iBCS2 */
+#define POLLIN		0x0001
+#define POLLPRI		0x0002
+#define POLLOUT		0x0004
+#define POLLERR		0x0008
+#define POLLHUP		0x0010
+#define POLLNVAL	0x0020
+
+/* The rest seem to be more-or-less nonstandard. Check them! */
+#define POLLRDNORM	0x0040
+#define POLLRDBAND	0x0080
+#define POLLWRNORM	0x0100
+#define POLLWRBAND	0x0200
+#define POLLMSG		0x0400
+#define POLLREMOVE	0x1000
+#define POLLRDHUP       0x2000
+
+struct pollfd {
+	int fd;
+	short events;
+	short revents;
+};
+
+#endif
Index: build_tree/linux/include/asm/posix_types.h
diff -u /dev/null build_tree/linux/include/asm/posix_types.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/posix_types.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,81 @@
+/*
+ *  linux/include/asm-arm/posix_types.h
+ *
+ *  Copyright (C) 1996-1998 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   27-06-1996	RMK	Created
+ */
+#ifndef __ARCH_ARM_POSIX_TYPES_H
+#define __ARCH_ARM_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long		__kernel_ino_t;
+typedef unsigned short		__kernel_mode_t;
+typedef unsigned short		__kernel_nlink_t;
+typedef long			__kernel_off_t;
+typedef int			__kernel_pid_t;
+typedef unsigned short		__kernel_ipc_pid_t;
+typedef unsigned short		__kernel_uid_t;
+typedef unsigned short		__kernel_gid_t;
+typedef unsigned int		__kernel_size_t;
+typedef int			__kernel_ssize_t;
+typedef int			__kernel_ptrdiff_t;
+typedef long			__kernel_time_t;
+typedef long			__kernel_suseconds_t;
+typedef long			__kernel_clock_t;
+typedef int			__kernel_timer_t;
+typedef int			__kernel_clockid_t;
+typedef int			__kernel_daddr_t;
+typedef char *			__kernel_caddr_t;
+typedef unsigned short		__kernel_uid16_t;
+typedef unsigned short		__kernel_gid16_t;
+typedef unsigned int		__kernel_uid32_t;
+typedef unsigned int		__kernel_gid32_t;
+
+typedef unsigned short		__kernel_old_uid_t;
+typedef unsigned short		__kernel_old_gid_t;
+typedef unsigned short		__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long		__kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int	val[2];
+#else /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int	__val[2];
+#endif /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+#define __FD_SET(fd, fdsetp) \
+		(((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] |= (1<<((fd) & 31)))
+
+#undef	__FD_CLR
+#define __FD_CLR(fd, fdsetp) \
+		(((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] &= ~(1<<((fd) & 31)))
+
+#undef	__FD_ISSET
+#define __FD_ISSET(fd, fdsetp) \
+		((((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] & (1<<((fd) & 31))) != 0)
+
+#undef	__FD_ZERO
+#define __FD_ZERO(fdsetp) \
+		(memset (fdsetp, 0, sizeof (*(fd_set *)(fdsetp))))
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/proc-fns.h
diff -u /dev/null build_tree/linux/include/asm/proc-fns.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/proc-fns.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,225 @@
+/*
+ *  linux/include/asm-arm/proc-fns.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROCFNS_H
+#define __ASM_PROCFNS_H
+
+#ifdef __KERNEL__
+
+
+/*
+ * Work out if we need multiple CPU support
+ */
+#undef MULTI_CPU
+#undef CPU_NAME
+
+/*
+ * CPU_NAME - the prefix for CPU related functions
+ */
+
+#ifdef CONFIG_CPU_32
+# ifdef CONFIG_CPU_ARM610
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm6
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM7TDMI
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm7tdmi
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM710
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm7
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM720T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm720
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM740T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm740
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM9TDMI
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm9tdmi
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM920T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm920
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM922T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm922
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM925T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm925
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM926T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm926
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM940T
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm940
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM946E
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm946
+#  endif
+# endif
+# ifdef CONFIG_CPU_SA110
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_sa110
+#  endif
+# endif
+# ifdef CONFIG_CPU_SA1100
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_sa1100
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1020
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1020
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1020E
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1020e
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1022
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1022
+#  endif
+# endif
+# ifdef CONFIG_CPU_ARM1026
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_arm1026
+#  endif
+# endif
+# ifdef CONFIG_CPU_XSCALE
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_xscale
+#  endif
+# endif
+# ifdef CONFIG_CPU_XSC3
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_xsc3
+#  endif
+# endif
+# ifdef CONFIG_CPU_V6
+#  ifdef CPU_NAME
+#   undef  MULTI_CPU
+#   define MULTI_CPU
+#  else
+#   define CPU_NAME cpu_v6
+#  endif
+# endif
+#endif
+
+#ifndef __ASSEMBLY__
+
+#ifndef MULTI_CPU
+#include "asm/cpu-single.h"
+#else
+#include "asm/cpu-multi32.h"
+#endif
+
+#include <asm/memory.h>
+
+#ifdef CONFIG_MMU
+
+#define cpu_switch_mm(pgd,mm) cpu_do_switch_mm(virt_to_phys(pgd),mm)
+
+#define cpu_get_pgd()	\
+	({						\
+		unsigned long pg;			\
+		__asm__("mrc	p15, 0, %0, c2, c0, 0"	\
+			 : "=r" (pg) : : "cc");		\
+		pg &= ~0x3fff;				\
+		(pgd_t *)phys_to_virt(pg);		\
+	})
+
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __KERNEL__ */
+#endif /* __ASM_PROCFNS_H */
Index: build_tree/linux/include/asm/processor.h
diff -u /dev/null build_tree/linux/include/asm/processor.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/processor.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,125 @@
+/*
+ *  linux/include/asm-arm/processor.h
+ *
+ *  Copyright (C) 1995-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_PROCESSOR_H
+#define __ASM_ARM_PROCESSOR_H
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+#ifdef __KERNEL__
+
+#include <asm/ptrace.h>
+#include <asm/types.h>
+
+union debug_insn {
+	u32	arm;
+	u16	thumb;
+};
+
+struct debug_entry {
+	u32			address;
+	union debug_insn	insn;
+};
+
+struct debug_info {
+	int			nsaved;
+	struct debug_entry	bp[2];
+};
+
+struct thread_struct {
+							/* fault info	  */
+	unsigned long		address;
+	unsigned long		trap_no;
+	unsigned long		error_code;
+							/* debugging	  */
+	struct debug_info	debug;
+};
+
+#define INIT_THREAD  {	}
+
+#ifdef CONFIG_MMU
+#define nommu_start_thread(regs) do { } while (0)
+#else
+#define nommu_start_thread(regs) regs->ARM_r10 = current->mm->start_data
+#endif
+
+#define start_thread(regs,pc,sp)					\
+({									\
+	unsigned long *stack = (unsigned long *)sp;			\
+	set_fs(USER_DS);						\
+	memzero(regs->uregs, sizeof(regs->uregs));			\
+	if (current->personality & ADDR_LIMIT_32BIT)			\
+		regs->ARM_cpsr = USR_MODE;				\
+	else								\
+		regs->ARM_cpsr = USR26_MODE;				\
+	if (elf_hwcap & HWCAP_THUMB && pc & 1)				\
+		regs->ARM_cpsr |= PSR_T_BIT;				\
+	regs->ARM_pc = pc & ~1;		/* pc */			\
+	regs->ARM_sp = sp;		/* sp */			\
+	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
+	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
+	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
+	nommu_start_thread(regs);					\
+})
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+/* Prepare to copy thread state - unlazy all lazy status */
+#define prepare_to_copy(tsk)	do { } while (0)
+
+unsigned long get_wchan(struct task_struct *p);
+
+#define cpu_relax()			barrier()
+
+/*
+ * Create a new kernel thread
+ */
+extern int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
+
+#define task_pt_regs(p) \
+	((struct pt_regs *)(THREAD_START_SP + task_stack_page(p)) - 1)
+
+#define KSTK_EIP(tsk)	task_pt_regs(tsk)->ARM_pc
+#define KSTK_ESP(tsk)	task_pt_regs(tsk)->ARM_sp
+
+/*
+ * Prefetching support - only ARMv5.
+ */
+#if __LINUX_ARM_ARCH__ >= 5
+
+#define ARCH_HAS_PREFETCH
+static inline void prefetch(const void *ptr)
+{
+	__asm__ __volatile__(
+		"pld\t%0"
+		:
+		: "o" (*(char *)ptr)
+		: "cc");
+}
+
+#define ARCH_HAS_PREFETCHW
+#define prefetchw(ptr)	prefetch(ptr)
+
+#define ARCH_HAS_SPINLOCK_PREFETCH
+#define spin_lock_prefetch(x) do { } while (0)
+
+#endif
+
+#endif
+
+#endif /* __ASM_ARM_PROCESSOR_H */
Index: build_tree/linux/include/asm/procinfo.h
diff -u /dev/null build_tree/linux/include/asm/procinfo.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/procinfo.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-arm/procinfo.h
+ *
+ *  Copyright (C) 1996-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROCINFO_H
+#define __ASM_PROCINFO_H
+
+#ifdef __KERNEL__
+
+struct cpu_tlb_fns;
+struct cpu_user_fns;
+struct cpu_cache_fns;
+struct processor;
+
+/*
+ * Note!  struct processor is always defined if we're
+ * using MULTI_CPU, otherwise this entry is unused,
+ * but still exists.
+ *
+ * NOTE! The following structure is defined by assembly
+ * language, NOT C code.  For more information, check:
+ *  arch/arm/mm/proc-*.S and arch/arm/kernel/head.S
+ */
+struct proc_info_list {
+	unsigned int		cpu_val;
+	unsigned int		cpu_mask;
+	unsigned long		__cpu_mm_mmu_flags;	/* used by head.S */
+	unsigned long		__cpu_io_mmu_flags;	/* used by head.S */
+	unsigned long		__cpu_flush;		/* used by head.S */
+	const char		*arch_name;
+	const char		*elf_name;
+	unsigned int		elf_hwcap;
+	const char		*cpu_name;
+	struct processor	*proc;
+	struct cpu_tlb_fns	*tlb;
+	struct cpu_user_fns	*user;
+	struct cpu_cache_fns	*cache;
+};
+
+#else	/* __KERNEL__ */
+#include <asm/elf.h>
+#warning "Please include asm/elf.h instead"
+#endif	/* __KERNEL__ */
+#endif
Index: build_tree/linux/include/asm/ptrace.h
diff -u /dev/null build_tree/linux/include/asm/ptrace.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ptrace.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,161 @@
+/*
+ *  linux/include/asm-arm/ptrace.h
+ *
+ *  Copyright (C) 1996-2003 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_PTRACE_H
+#define __ASM_ARM_PTRACE_H
+
+
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+#define PTRACE_GETFPREGS	14
+#define PTRACE_SETFPREGS	15
+
+#define PTRACE_GETWMMXREGS	18
+#define PTRACE_SETWMMXREGS	19
+
+#define PTRACE_OLDSETOPTIONS	21
+
+#define PTRACE_GET_THREAD_AREA	22
+
+#define PTRACE_SET_SYSCALL	23
+
+/* PTRACE_SYSCALL is 24 */
+
+#define PTRACE_GETCRUNCHREGS	25
+#define PTRACE_SETCRUNCHREGS	26
+
+/*
+ * PSR bits
+ */
+#define USR26_MODE	0x00000000
+#define FIQ26_MODE	0x00000001
+#define IRQ26_MODE	0x00000002
+#define SVC26_MODE	0x00000003
+#define USR_MODE	0x00000010
+#define FIQ_MODE	0x00000011
+#define IRQ_MODE	0x00000012
+#define SVC_MODE	0x00000013
+#define ABT_MODE	0x00000017
+#define UND_MODE	0x0000001b
+#define SYSTEM_MODE	0x0000001f
+#define MODE32_BIT	0x00000010
+#define MODE_MASK	0x0000001f
+#define PSR_T_BIT	0x00000020
+#define PSR_F_BIT	0x00000040
+#define PSR_I_BIT	0x00000080
+#define PSR_J_BIT	0x01000000
+#define PSR_Q_BIT	0x08000000
+#define PSR_V_BIT	0x10000000
+#define PSR_C_BIT	0x20000000
+#define PSR_Z_BIT	0x40000000
+#define PSR_N_BIT	0x80000000
+#define PCMASK		0
+
+/*
+ * Groups of PSR bits
+ */
+#define PSR_f		0xff000000	/* Flags		*/
+#define PSR_s		0x00ff0000	/* Status		*/
+#define PSR_x		0x0000ff00	/* Extension		*/
+#define PSR_c		0x000000ff	/* Control		*/
+
+#ifndef __ASSEMBLY__
+
+/*
+ * This struct defines the way the registers are stored on the
+ * stack during a system call.  Note that sizeof(struct pt_regs)
+ * has to be a multiple of 8.
+ */
+struct pt_regs {
+	long uregs[18];
+};
+
+#define ARM_cpsr	uregs[16]
+#define ARM_pc		uregs[15]
+#define ARM_lr		uregs[14]
+#define ARM_sp		uregs[13]
+#define ARM_ip		uregs[12]
+#define ARM_fp		uregs[11]
+#define ARM_r10		uregs[10]
+#define ARM_r9		uregs[9]
+#define ARM_r8		uregs[8]
+#define ARM_r7		uregs[7]
+#define ARM_r6		uregs[6]
+#define ARM_r5		uregs[5]
+#define ARM_r4		uregs[4]
+#define ARM_r3		uregs[3]
+#define ARM_r2		uregs[2]
+#define ARM_r1		uregs[1]
+#define ARM_r0		uregs[0]
+#define ARM_ORIG_r0	uregs[17]
+
+#ifdef __KERNEL__
+
+#define user_mode(regs)	\
+	(((regs)->ARM_cpsr & 0xf) == 0)
+
+#ifdef CONFIG_ARM_THUMB
+#define thumb_mode(regs) \
+	(((regs)->ARM_cpsr & PSR_T_BIT))
+#else
+#define thumb_mode(regs) (0)
+#endif
+
+#define processor_mode(regs) \
+	((regs)->ARM_cpsr & MODE_MASK)
+
+#define interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & PSR_I_BIT))
+
+#define fast_interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & PSR_F_BIT))
+
+#define condition_codes(regs) \
+	((regs)->ARM_cpsr & (PSR_V_BIT|PSR_C_BIT|PSR_Z_BIT|PSR_N_BIT))
+	
+/* Are the current registers suitable for user mode?
+ * (used to maintain security in signal handlers)
+ */
+static inline int valid_user_regs(struct pt_regs *regs)
+{
+	if (user_mode(regs) &&
+	    (regs->ARM_cpsr & (PSR_F_BIT|PSR_I_BIT)) == 0)
+		return 1;
+
+	/*
+	 * Force CPSR to something logical...
+	 */
+	regs->ARM_cpsr &= PSR_f | PSR_s | PSR_x | PSR_T_BIT | MODE32_BIT;
+
+	return 0;
+}
+
+#endif	/* __KERNEL__ */
+
+#define pc_pointer(v) \
+	((v) & ~PCMASK)
+
+#define instruction_pointer(regs) \
+	(pc_pointer((regs)->ARM_pc))
+
+#ifdef CONFIG_SMP
+extern unsigned long profile_pc(struct pt_regs *regs);
+#else
+#define profile_pc(regs) instruction_pointer(regs)
+#endif
+
+#ifdef __KERNEL__
+#define predicate(x)		((x) & 0xf0000000)
+#define PREDICATE_ALWAYS	0xe0000000
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+#endif
+
Index: build_tree/linux/include/asm/resource.h
diff -u /dev/null build_tree/linux/include/asm/resource.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/resource.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef _ARM_RESOURCE_H
+#define _ARM_RESOURCE_H
+
+#include <asm-generic/resource.h>
+
+#endif
Index: build_tree/linux/include/asm/rtc.h
diff -u /dev/null build_tree/linux/include/asm/rtc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/rtc.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,43 @@
+/*
+ *  linux/include/asm-arm/rtc.h
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ASMARM_RTC_H
+#define ASMARM_RTC_H
+
+struct module;
+
+struct rtc_ops {
+	struct module	*owner;
+	int		(*open)(void);
+	void		(*release)(void);
+	int		(*ioctl)(unsigned int, unsigned long);
+
+	int		(*read_time)(struct rtc_time *);
+	int		(*set_time)(struct rtc_time *);
+	int		(*read_alarm)(struct rtc_wkalrm *);
+	int		(*set_alarm)(struct rtc_wkalrm *);
+	int		(*proc)(char *buf);
+};
+
+void rtc_next_alarm_time(struct rtc_time *, struct rtc_time *, struct rtc_time *);
+void rtc_update(unsigned long, unsigned long);
+int register_rtc(struct rtc_ops *);
+void unregister_rtc(struct rtc_ops *);
+
+static inline int rtc_periodic_alarm(struct rtc_time *tm)
+{
+	return  (tm->tm_year == -1) ||
+		((unsigned)tm->tm_mon >= 12) ||
+		((unsigned)(tm->tm_mday - 1) >= 31) ||
+		((unsigned)tm->tm_hour > 23) ||
+		((unsigned)tm->tm_min > 59) ||
+		((unsigned)tm->tm_sec > 59);
+}
+
+#endif
Index: build_tree/linux/include/asm/scatterlist.h
diff -u /dev/null build_tree/linux/include/asm/scatterlist.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/scatterlist.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,24 @@
+#ifndef _ASMARM_SCATTERLIST_H
+#define _ASMARM_SCATTERLIST_H
+
+#include <asm/memory.h>
+#include <asm/types.h>
+
+struct scatterlist {
+	struct page	*page;		/* buffer page			 */
+	unsigned int	offset;		/* buffer offset		 */
+	dma_addr_t	dma_address;	/* dma address			 */
+	unsigned int	length;		/* length			 */
+};
+
+/*
+ * These macros should be used after a pci_map_sg call has been done
+ * to get bus addresses of each of the SG entries and their lengths.
+ * You should only work with the number of sg entries pci_map_sg
+ * returns, or alternatively stop on the first sg_dma_len(sg) which
+ * is 0.
+ */
+#define sg_dma_address(sg)      ((sg)->dma_address)
+#define sg_dma_len(sg)          ((sg)->length)
+
+#endif /* _ASMARM_SCATTERLIST_H */
Index: build_tree/linux/include/asm/sections.h
diff -u /dev/null build_tree/linux/include/asm/sections.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/sections.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1 @@
+#include <asm-generic/sections.h>
Index: build_tree/linux/include/asm/segment.h
diff -u /dev/null build_tree/linux/include/asm/segment.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/segment.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,11 @@
+#ifndef __ASM_ARM_SEGMENT_H
+#define __ASM_ARM_SEGMENT_H
+
+#define __KERNEL_CS   0x0
+#define __KERNEL_DS   0x0
+
+#define __USER_CS     0x1
+#define __USER_DS     0x1
+
+#endif /* __ASM_ARM_SEGMENT_H */
+
Index: build_tree/linux/include/asm/semaphore-helper.h
diff -u /dev/null build_tree/linux/include/asm/semaphore-helper.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/semaphore-helper.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,84 @@
+#ifndef ASMARM_SEMAPHORE_HELPER_H
+#define ASMARM_SEMAPHORE_HELPER_H
+
+/*
+ * These two _must_ execute atomically wrt each other.
+ */
+static inline void wake_one_more(struct semaphore * sem)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (atomic_read(&sem->count) <= 0)
+		sem->waking++;
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+}
+
+static inline int waking_non_zero(struct semaphore *sem)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (sem->waking > 0) {
+		sem->waking--;
+		ret = 1;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+/*
+ * waking non zero interruptible
+ *	1	got the lock
+ *	0	go to sleep
+ *	-EINTR	interrupted
+ *
+ * We must undo the sem->count down_interruptible() increment while we are
+ * protected by the spinlock in order to make this atomic_inc() with the
+ * atomic_read() in wake_one_more(), otherwise we can race. -arca
+ */
+static inline int waking_non_zero_interruptible(struct semaphore *sem,
+						struct task_struct *tsk)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (sem->waking > 0) {
+		sem->waking--;
+		ret = 1;
+	} else if (signal_pending(tsk)) {
+		atomic_inc(&sem->count);
+		ret = -EINTR;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;	
+}
+
+/*
+ * waking_non_zero_try_lock:
+ *	1	failed to lock
+ *	0	got the lock
+ *
+ * We must undo the sem->count down_interruptible() increment while we are
+ * protected by the spinlock in order to make this atomic_inc() with the
+ * atomic_read() in wake_one_more(), otherwise we can race. -arca
+ */
+static inline int waking_non_zero_trylock(struct semaphore *sem)
+{
+	unsigned long flags;
+	int ret = 1;
+
+	spin_lock_irqsave(&semaphore_wake_lock, flags);
+	if (sem->waking <= 0)
+		atomic_inc(&sem->count);
+	else {
+		sem->waking--;
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&semaphore_wake_lock, flags);
+	return ret;
+}
+
+#endif
Index: build_tree/linux/include/asm/semaphore.h
diff -u /dev/null build_tree/linux/include/asm/semaphore.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/semaphore.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,99 @@
+/*
+ * linux/include/asm-arm/semaphore.h
+ */
+#ifndef __ASM_ARM_SEMAPHORE_H
+#define __ASM_ARM_SEMAPHORE_H
+
+#include <linux/linkage.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/rwsem.h>
+
+#include <asm/atomic.h>
+#include <asm/locks.h>
+
+struct semaphore {
+	atomic_t count;
+	int sleepers;
+	wait_queue_head_t wait;
+};
+
+#define __SEMAPHORE_INIT(name, cnt)				\
+{								\
+	.count	= ATOMIC_INIT(cnt),				\
+	.wait	= __WAIT_QUEUE_HEAD_INITIALIZER((name).wait),	\
+}
+
+#define __DECLARE_SEMAPHORE_GENERIC(name,count)	\
+	struct semaphore name = __SEMAPHORE_INIT(name,count)
+
+#define DECLARE_MUTEX(name)		__DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name)	__DECLARE_SEMAPHORE_GENERIC(name,0)
+
+static inline void sema_init(struct semaphore *sem, int val)
+{
+	atomic_set(&sem->count, val);
+	sem->sleepers = 0;
+	init_waitqueue_head(&sem->wait);
+}
+
+static inline void init_MUTEX(struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static inline void init_MUTEX_LOCKED(struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+/*
+ * special register calling convention
+ */
+asmlinkage void __down_failed(void);
+asmlinkage int  __down_interruptible_failed(void);
+asmlinkage int  __down_trylock_failed(void);
+asmlinkage void __up_wakeup(void);
+
+extern void __down(struct semaphore * sem);
+extern int  __down_interruptible(struct semaphore * sem);
+extern int  __down_trylock(struct semaphore * sem);
+extern void __up(struct semaphore * sem);
+
+/*
+ * This is ugly, but we want the default case to fall through.
+ * "__down" is the actual routine that waits...
+ */
+static inline void down(struct semaphore * sem)
+{
+	might_sleep();
+	__down_op(sem, __down_failed);
+}
+
+/*
+ * This is ugly, but we want the default case to fall through.
+ * "__down_interruptible" is the actual routine that waits...
+ */
+static inline int down_interruptible (struct semaphore * sem)
+{
+	might_sleep();
+	return __down_op_ret(sem, __down_interruptible_failed);
+}
+
+static inline int down_trylock(struct semaphore *sem)
+{
+	return __down_op_ret(sem, __down_trylock_failed);
+}
+
+/*
+ * Note! This is subtle. We jump to wake people up only if
+ * the semaphore was negative (== somebody was waiting on it).
+ * The default case (no contention) will result in NO
+ * jumps for both down() and up().
+ */
+static inline void up(struct semaphore * sem)
+{
+	__up_op(sem, __up_wakeup);
+}
+
+#endif
Index: build_tree/linux/include/asm/sembuf.h
diff -u /dev/null build_tree/linux/include/asm/sembuf.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/sembuf.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,25 @@
+#ifndef _ASMARM_SEMBUF_H
+#define _ASMARM_SEMBUF_H
+
+/* 
+ * The semid64_ds structure for arm architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;		/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;		/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASMARM_SEMBUF_H */
Index: build_tree/linux/include/asm/serial.h
diff -u /dev/null build_tree/linux/include/asm/serial.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/serial.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/serial.h
+ *
+ *  Copyright (C) 1996 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   15-10-1996	RMK	Created
+ */
+
+#ifndef __ASM_SERIAL_H
+#define __ASM_SERIAL_H
+
+#define BASE_BAUD	(1843200 / 16)
+
+#endif
Index: build_tree/linux/include/asm/setup.h
diff -u /dev/null build_tree/linux/include/asm/setup.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/setup.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,226 @@
+/*
+ *  linux/include/asm/setup.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Structure passed to kernel to tell it about the
+ *  hardware it's running on.  See Documentation/arm/Setup
+ *  for more info.
+ */
+#ifndef __ASMARM_SETUP_H
+#define __ASMARM_SETUP_H
+
+#include <asm/types.h>
+
+#define COMMAND_LINE_SIZE 1024
+
+/* The list ends with an ATAG_NONE node. */
+#define ATAG_NONE	0x00000000
+
+struct tag_header {
+	__u32 size;
+	__u32 tag;
+};
+
+/* The list must start with an ATAG_CORE node */
+#define ATAG_CORE	0x54410001
+
+struct tag_core {
+	__u32 flags;		/* bit 0 = read-only */
+	__u32 pagesize;
+	__u32 rootdev;
+};
+
+/* it is allowed to have multiple ATAG_MEM nodes */
+#define ATAG_MEM	0x54410002
+
+struct tag_mem32 {
+	__u32	size;
+	__u32	start;	/* physical start address */
+};
+
+/* VGA text type displays */
+#define ATAG_VIDEOTEXT	0x54410003
+
+struct tag_videotext {
+	__u8		x;
+	__u8		y;
+	__u16		video_page;
+	__u8		video_mode;
+	__u8		video_cols;
+	__u16		video_ega_bx;
+	__u8		video_lines;
+	__u8		video_isvga;
+	__u16		video_points;
+};
+
+/* describes how the ramdisk will be used in kernel */
+#define ATAG_RAMDISK	0x54410004
+
+struct tag_ramdisk {
+	__u32 flags;	/* bit 0 = load, bit 1 = prompt */
+	__u32 size;	/* decompressed ramdisk size in _kilo_ bytes */
+	__u32 start;	/* starting block of floppy-based RAM disk image */
+};
+
+/* describes where the compressed ramdisk image lives (virtual address) */
+/*
+ * this one accidentally used virtual addresses - as such,
+ * it's deprecated.
+ */
+#define ATAG_INITRD	0x54410005
+
+/* describes where the compressed ramdisk image lives (physical address) */
+#define ATAG_INITRD2	0x54420005
+
+struct tag_initrd {
+	__u32 start;	/* physical start address */
+	__u32 size;	/* size of compressed ramdisk image in bytes */
+};
+
+/* board serial number. "64 bits should be enough for everybody" */
+#define ATAG_SERIAL	0x54410006
+
+struct tag_serialnr {
+	__u32 low;
+	__u32 high;
+};
+
+/* board revision */
+#define ATAG_REVISION	0x54410007
+
+struct tag_revision {
+	__u32 rev;
+};
+
+/* initial values for vesafb-type framebuffers. see struct screen_info
+ * in include/linux/tty.h
+ */
+#define ATAG_VIDEOLFB	0x54410008
+
+struct tag_videolfb {
+	__u16		lfb_width;
+	__u16		lfb_height;
+	__u16		lfb_depth;
+	__u16		lfb_linelength;
+	__u32		lfb_base;
+	__u32		lfb_size;
+	__u8		red_size;
+	__u8		red_pos;
+	__u8		green_size;
+	__u8		green_pos;
+	__u8		blue_size;
+	__u8		blue_pos;
+	__u8		rsvd_size;
+	__u8		rsvd_pos;
+};
+
+/* command line: \0 terminated string */
+#define ATAG_CMDLINE	0x54410009
+
+struct tag_cmdline {
+	char	cmdline[1];	/* this is the minimum size */
+};
+
+/* acorn RiscPC specific information */
+#define ATAG_ACORN	0x41000101
+
+struct tag_acorn {
+	__u32 memc_control_reg;
+	__u32 vram_pages;
+	__u8 sounddefault;
+	__u8 adfsdrives;
+};
+
+/* footbridge memory clock, see arch/arm/mach-footbridge/arch.c */
+#define ATAG_MEMCLK	0x41000402
+
+struct tag_memclk {
+	__u32 fmemclk;
+};
+
+struct tag {
+	struct tag_header hdr;
+	union {
+		struct tag_core		core;
+		struct tag_mem32	mem;
+		struct tag_videotext	videotext;
+		struct tag_ramdisk	ramdisk;
+		struct tag_initrd	initrd;
+		struct tag_serialnr	serialnr;
+		struct tag_revision	revision;
+		struct tag_videolfb	videolfb;
+		struct tag_cmdline	cmdline;
+
+		/*
+		 * Acorn specific
+		 */
+		struct tag_acorn	acorn;
+
+		/*
+		 * DC21285 specific
+		 */
+		struct tag_memclk	memclk;
+	} u;
+};
+
+struct tagtable {
+	__u32 tag;
+	int (*parse)(const struct tag *);
+};
+
+#define tag_member_present(tag,member)				\
+	((unsigned long)(&((struct tag *)0L)->member + 1)	\
+		<= (tag)->hdr.size * 4)
+
+#define tag_next(t)	((struct tag *)((__u32 *)(t) + (t)->hdr.size))
+#define tag_size(type)	((sizeof(struct tag_header) + sizeof(struct type)) >> 2)
+
+#define for_each_tag(t,base)		\
+	for (t = base; t->hdr.size; t = tag_next(t))
+
+#ifdef __KERNEL__
+
+#define __tag __attribute_used__ __attribute__((__section__(".taglist.init")))
+#define __tagtable(tag, fn) \
+static struct tagtable __tagtable_##fn __tag = { tag, fn }
+
+/*
+ * Memory map description
+ */
+#ifdef CONFIG_ARCH_LH7A40X
+# define NR_BANKS 16
+#else
+# define NR_BANKS 8
+#endif
+
+struct membank {
+	unsigned long start;
+	unsigned long size;
+	int           node;
+};
+
+struct meminfo {
+	int nr_banks;
+	struct membank bank[NR_BANKS];
+};
+
+/*
+ * Early command line parameters.
+ */
+struct early_params {
+	const char *arg;
+	void (*fn)(char **p);
+};
+
+#define __early_param(name,fn)					\
+static struct early_params __early_##fn __attribute_used__	\
+__attribute__((__section__(".early_param.init"))) = { name, fn }
+
+#endif  /*  __KERNEL__  */
+
+#endif
Index: build_tree/linux/include/asm/shmbuf.h
diff -u /dev/null build_tree/linux/include/asm/shmbuf.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/shmbuf.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,42 @@
+#ifndef _ASMARM_SHMBUF_H
+#define _ASMARM_SHMBUF_H
+
+/* 
+ * The shmid64_ds structure for arm architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	unsigned long		__unused1;
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	unsigned long		__unused2;
+	__kernel_time_t		shm_ctime;	/* last change time */
+	unsigned long		__unused3;
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASMARM_SHMBUF_H */
Index: build_tree/linux/include/asm/shmparam.h
diff -u /dev/null build_tree/linux/include/asm/shmparam.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/shmparam.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,16 @@
+#ifndef _ASMARM_SHMPARAM_H
+#define _ASMARM_SHMPARAM_H
+
+/*
+ * This should be the size of the virtually indexed cache/ways,
+ * or page size, whichever is greater since the cache aliases
+ * every size/ways bytes.
+ */
+#define	SHMLBA	(4 * PAGE_SIZE)		 /* attach addr a multiple of this */
+
+/*
+ * Enforce SHMLBA in shmat
+ */
+#define __ARCH_FORCE_SHMLBA
+
+#endif /* _ASMARM_SHMPARAM_H */
Index: build_tree/linux/include/asm/sigcontext.h
diff -u /dev/null build_tree/linux/include/asm/sigcontext.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/sigcontext.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,34 @@
+#ifndef _ASMARM_SIGCONTEXT_H
+#define _ASMARM_SIGCONTEXT_H
+
+/*
+ * Signal context structure - contains all info to do with the state
+ * before the signal handler was invoked.  Note: only add new entries
+ * to the end of the structure.
+ */
+struct sigcontext {
+	unsigned long trap_no;
+	unsigned long error_code;
+	unsigned long oldmask;
+	unsigned long arm_r0;
+	unsigned long arm_r1;
+	unsigned long arm_r2;
+	unsigned long arm_r3;
+	unsigned long arm_r4;
+	unsigned long arm_r5;
+	unsigned long arm_r6;
+	unsigned long arm_r7;
+	unsigned long arm_r8;
+	unsigned long arm_r9;
+	unsigned long arm_r10;
+	unsigned long arm_fp;
+	unsigned long arm_ip;
+	unsigned long arm_sp;
+	unsigned long arm_lr;
+	unsigned long arm_pc;
+	unsigned long arm_cpsr;
+	unsigned long fault_address;
+};
+
+
+#endif
Index: build_tree/linux/include/asm/siginfo.h
diff -u /dev/null build_tree/linux/include/asm/siginfo.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/siginfo.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef _ASMARM_SIGINFO_H
+#define _ASMARM_SIGINFO_H
+
+#include <asm-generic/siginfo.h>
+
+#endif
Index: build_tree/linux/include/asm/signal.h
diff -u /dev/null build_tree/linux/include/asm/signal.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/signal.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,164 @@
+#ifndef _ASMARM_SIGNAL_H
+#define _ASMARM_SIGNAL_H
+
+#include <linux/types.h>
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+#ifdef __KERNEL__
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
+#define _NSIG		64
+#define _NSIG_BPW	32
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+typedef unsigned long old_sigset_t;		/* at least 32 bits */
+
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif /* __KERNEL__ */
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+#define SIGSWI		32
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_NOCLDSTOP		flag to turn off SIGCHLD when children stop.
+ * SA_NOCLDWAIT		flag on SIGCHLD to inhibit zombies.
+ * SA_SIGINFO		deliver the signal with SIGINFO structs
+ * SA_THIRTYTWO		delivers the signal in 32-bit mode, even if the task 
+ *			is running in 26-bit.
+ * SA_ONSTACK		allows alternate signal stacks (see sigaltstack(2)).
+ * SA_RESTART		flag to get restarting signals (which were the default long ago)
+ * SA_NODEFER		prevents the current signal from being masked in the handler.
+ * SA_RESETHAND		clears the handler when the signal is delivered.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001
+#define SA_NOCLDWAIT	0x00000002
+#define SA_SIGINFO	0x00000004
+#define SA_THIRTYTWO	0x02000000
+#define SA_RESTORER	0x04000000
+#define SA_ONSTACK	0x08000000
+#define SA_RESTART	0x10000000
+#define SA_NODEFER	0x40000000
+#define SA_RESETHAND	0x80000000
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+
+/* 
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#include <asm-generic/signal.h>
+
+#ifdef __KERNEL__
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	unsigned long sa_flags;
+	__sigrestore_t sa_restorer;
+};
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	__sigrestore_t sa_restorer;
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+struct sigaction {
+	union {
+	  __sighandler_t _sa_handler;
+	  void (*_sa_sigaction)(int, struct siginfo *, void *);
+	} _u;
+	sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+};
+
+#define sa_handler	_u._sa_handler
+#define sa_sigaction	_u._sa_sigaction
+
+#endif /* __KERNEL__ */
+
+typedef struct sigaltstack {
+	void __user *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#ifdef __KERNEL__
+#include <asm/sigcontext.h>
+#define ptrace_signal_deliver(regs, cookie) do { } while (0)
+#endif
+
+#endif
Index: build_tree/linux/include/asm/sizes.h
diff -u /dev/null build_tree/linux/include/asm/sizes.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/sizes.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
Index: build_tree/linux/include/asm/smp.h
diff -u /dev/null build_tree/linux/include/asm/smp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/smp.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,137 @@
+/*
+ *  linux/include/asm-arm/smp.h
+ *
+ *  Copyright (C) 2004-2005 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_SMP_H
+#define __ASM_ARM_SMP_H
+
+#include <linux/threads.h>
+#include <linux/cpumask.h>
+#include <linux/thread_info.h>
+
+#include <asm/arch/smp.h>
+
+#ifndef CONFIG_SMP
+# error "<asm-arm/smp.h> included in non-SMP build"
+#endif
+
+#define raw_smp_processor_id() (current_thread_info()->cpu)
+
+/*
+ * at the moment, there's not a big penalty for changing CPUs
+ * (the >big< penalty is running SMP in the first place)
+ */
+#define PROC_CHANGE_PENALTY		15
+
+struct seq_file;
+
+/*
+ * generate IPI list text
+ */
+extern void show_ipi_list(struct seq_file *p);
+
+/*
+ * Called from assembly code, this handles an IPI.
+ */
+asmlinkage void do_IPI(struct pt_regs *regs);
+
+/*
+ * Setup the SMP cpu_possible_map
+ */
+extern void smp_init_cpus(void);
+
+/*
+ * Move global data into per-processor storage.
+ */
+extern void smp_store_cpu_info(unsigned int cpuid);
+
+/*
+ * Raise an IPI cross call on CPUs in callmap.
+ */
+extern void smp_cross_call(cpumask_t callmap);
+
+/*
+ * Broadcast a timer interrupt to the other CPUs.
+ */
+extern void smp_send_timer(void);
+
+/*
+ * Boot a secondary CPU, and assign it the specified idle task.
+ * This also gives us the initial stack to use for this CPU.
+ */
+extern int boot_secondary(unsigned int cpu, struct task_struct *);
+
+/*
+ * Called from platform specific assembly code, this is the
+ * secondary CPU entry point.
+ */
+asmlinkage void secondary_start_kernel(void);
+
+/*
+ * Perform platform specific initialisation of the specified CPU.
+ */
+extern void platform_secondary_init(unsigned int cpu);
+
+/*
+ * Initial data for bringing up a secondary CPU.
+ */
+struct secondary_data {
+	unsigned long pgdir;
+	void *stack;
+};
+extern struct secondary_data secondary_data;
+
+extern int __cpu_disable(void);
+extern int mach_cpu_disable(unsigned int cpu);
+
+extern void __cpu_die(unsigned int cpu);
+extern void cpu_die(void);
+
+extern void platform_cpu_die(unsigned int cpu);
+extern int platform_cpu_kill(unsigned int cpu);
+extern void platform_cpu_enable(unsigned int cpu);
+
+#ifdef CONFIG_LOCAL_TIMERS
+/*
+ * Setup a local timer interrupt for a CPU.
+ */
+extern void local_timer_setup(unsigned int cpu);
+
+/*
+ * Stop a local timer interrupt.
+ */
+extern void local_timer_stop(unsigned int cpu);
+
+/*
+ * Platform provides this to acknowledge a local timer IRQ
+ */
+extern int local_timer_ack(void);
+
+#else
+
+static inline void local_timer_setup(unsigned int cpu)
+{
+}
+
+static inline void local_timer_stop(unsigned int cpu)
+{
+}
+
+#endif
+
+/*
+ * show local interrupt info
+ */
+extern void show_local_irqs(struct seq_file *);
+
+/*
+ * Called from assembly, this is the local timer IRQ handler
+ */
+asmlinkage void do_local_timer(struct pt_regs *);
+
+#endif /* ifndef __ASM_ARM_SMP_H */
Index: build_tree/linux/include/asm/socket.h
diff -u /dev/null build_tree/linux/include/asm/socket.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/socket.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,53 @@
+#ifndef _ASMARM_SOCKET_H
+#define _ASMARM_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockopt(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE 25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME             28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+
+#define SO_PEERSEC		31
+#define SO_PASSSEC		34
+
+#endif /* _ASM_SOCKET_H */
Index: build_tree/linux/include/asm/sockios.h
diff -u /dev/null build_tree/linux/include/asm/sockios.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/sockios.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,12 @@
+#ifndef __ARCH_ARM_SOCKIOS_H
+#define __ARCH_ARM_SOCKIOS_H
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN 	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906		/* Get stamp */
+
+#endif
Index: build_tree/linux/include/asm/spinlock.h
diff -u /dev/null build_tree/linux/include/asm/spinlock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/spinlock.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,224 @@
+#ifndef __ASM_SPINLOCK_H
+#define __ASM_SPINLOCK_H
+
+#if __LINUX_ARM_ARCH__ < 6
+#error SMP not supported on pre-ARMv6 CPUs
+#endif
+
+/*
+ * ARMv6 Spin-locking.
+ *
+ * We exclusively read the old value.  If it is zero, we may have
+ * won the lock, so we try exclusively storing it.  A memory barrier
+ * is required after we get a lock, and before we release it, because
+ * V6 CPUs are assumed to have weakly ordered memory.
+ *
+ * Unlocked value: 0
+ * Locked value: 1
+ */
+
+#define __raw_spin_is_locked(x)		((x)->lock != 0)
+#define __raw_spin_unlock_wait(lock) \
+	do { while (__raw_spin_is_locked(lock)) cpu_relax(); } while (0)
+
+#define __raw_spin_lock_flags(lock, flags) __raw_spin_lock(lock)
+
+static inline void __raw_spin_lock(raw_spinlock_t *lock)
+{
+	unsigned long tmp;
+
+	__asm__ __volatile__(
+"1:	ldrex	%0, [%1]\n"
+"	teq	%0, #0\n"
+#ifdef CONFIG_CPU_32v6K
+"	wfene\n"
+#endif
+"	strexeq	%0, %2, [%1]\n"
+"	teqeq	%0, #0\n"
+"	bne	1b"
+	: "=&r" (tmp)
+	: "r" (&lock->lock), "r" (1)
+	: "cc");
+
+	smp_mb();
+}
+
+static inline int __raw_spin_trylock(raw_spinlock_t *lock)
+{
+	unsigned long tmp;
+
+	__asm__ __volatile__(
+"	ldrex	%0, [%1]\n"
+"	teq	%0, #0\n"
+"	strexeq	%0, %2, [%1]"
+	: "=&r" (tmp)
+	: "r" (&lock->lock), "r" (1)
+	: "cc");
+
+	if (tmp == 0) {
+		smp_mb();
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static inline void __raw_spin_unlock(raw_spinlock_t *lock)
+{
+	smp_mb();
+
+	__asm__ __volatile__(
+"	str	%1, [%0]\n"
+#ifdef CONFIG_CPU_32v6K
+"	mcr	p15, 0, %1, c7, c10, 4\n" /* DSB */
+"	sev"
+#endif
+	:
+	: "r" (&lock->lock), "r" (0)
+	: "cc");
+}
+
+/*
+ * RWLOCKS
+ *
+ *
+ * Write locks are easy - we just set bit 31.  When unlocking, we can
+ * just write zero since the lock is exclusively held.
+ */
+
+static inline void __raw_write_lock(raw_rwlock_t *rw)
+{
+	unsigned long tmp;
+
+	__asm__ __volatile__(
+"1:	ldrex	%0, [%1]\n"
+"	teq	%0, #0\n"
+#ifdef CONFIG_CPU_32v6K
+"	wfene\n"
+#endif
+"	strexeq	%0, %2, [%1]\n"
+"	teq	%0, #0\n"
+"	bne	1b"
+	: "=&r" (tmp)
+	: "r" (&rw->lock), "r" (0x80000000)
+	: "cc");
+
+	smp_mb();
+}
+
+static inline int __raw_write_trylock(raw_rwlock_t *rw)
+{
+	unsigned long tmp;
+
+	__asm__ __volatile__(
+"1:	ldrex	%0, [%1]\n"
+"	teq	%0, #0\n"
+"	strexeq	%0, %2, [%1]"
+	: "=&r" (tmp)
+	: "r" (&rw->lock), "r" (0x80000000)
+	: "cc");
+
+	if (tmp == 0) {
+		smp_mb();
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static inline void __raw_write_unlock(raw_rwlock_t *rw)
+{
+	smp_mb();
+
+	__asm__ __volatile__(
+	"str	%1, [%0]\n"
+#ifdef CONFIG_CPU_32v6K
+"	mcr	p15, 0, %1, c7, c10, 4\n" /* DSB */
+"	sev\n"
+#endif
+	:
+	: "r" (&rw->lock), "r" (0)
+	: "cc");
+}
+
+/* write_can_lock - would write_trylock() succeed? */
+#define __raw_write_can_lock(x)		((x)->lock == 0x80000000)
+
+/*
+ * Read locks are a bit more hairy:
+ *  - Exclusively load the lock value.
+ *  - Increment it.
+ *  - Store new lock value if positive, and we still own this location.
+ *    If the value is negative, we've already failed.
+ *  - If we failed to store the value, we want a negative result.
+ *  - If we failed, try again.
+ * Unlocking is similarly hairy.  We may have multiple read locks
+ * currently active.  However, we know we won't have any write
+ * locks.
+ */
+static inline void __raw_read_lock(raw_rwlock_t *rw)
+{
+	unsigned long tmp, tmp2;
+
+	__asm__ __volatile__(
+"1:	ldrex	%0, [%2]\n"
+"	adds	%0, %0, #1\n"
+"	strexpl	%1, %0, [%2]\n"
+#ifdef CONFIG_CPU_32v6K
+"	wfemi\n"
+#endif
+"	rsbpls	%0, %1, #0\n"
+"	bmi	1b"
+	: "=&r" (tmp), "=&r" (tmp2)
+	: "r" (&rw->lock)
+	: "cc");
+
+	smp_mb();
+}
+
+static inline void __raw_read_unlock(raw_rwlock_t *rw)
+{
+	unsigned long tmp, tmp2;
+
+	smp_mb();
+
+	__asm__ __volatile__(
+"1:	ldrex	%0, [%2]\n"
+"	sub	%0, %0, #1\n"
+"	strex	%1, %0, [%2]\n"
+"	teq	%1, #0\n"
+"	bne	1b"
+#ifdef CONFIG_CPU_32v6K
+"\n	cmp	%0, #0\n"
+"	mcreq   p15, 0, %0, c7, c10, 4\n"
+"	seveq"
+#endif
+	: "=&r" (tmp), "=&r" (tmp2)
+	: "r" (&rw->lock)
+	: "cc");
+}
+
+static inline int __raw_read_trylock(raw_rwlock_t *rw)
+{
+	unsigned long tmp, tmp2 = 1;
+
+	__asm__ __volatile__(
+"1:	ldrex	%0, [%2]\n"
+"	adds	%0, %0, #1\n"
+"	strexpl	%1, %0, [%2]\n"
+	: "=&r" (tmp), "+r" (tmp2)
+	: "r" (&rw->lock)
+	: "cc");
+
+	smp_mb();
+	return tmp2 == 0;
+}
+
+/* read_can_lock - would read_trylock() succeed? */
+#define __raw_read_can_lock(x)		((x)->lock < 0x80000000)
+
+#define _raw_spin_relax(lock)	cpu_relax()
+#define _raw_read_relax(lock)	cpu_relax()
+#define _raw_write_relax(lock)	cpu_relax()
+
+#endif /* __ASM_SPINLOCK_H */
Index: build_tree/linux/include/asm/spinlock_types.h
diff -u /dev/null build_tree/linux/include/asm/spinlock_types.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/spinlock_types.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,20 @@
+#ifndef __ASM_SPINLOCK_TYPES_H
+#define __ASM_SPINLOCK_TYPES_H
+
+#ifndef __LINUX_SPINLOCK_TYPES_H
+# error "please don't include this file directly"
+#endif
+
+typedef struct {
+	volatile unsigned int lock;
+} raw_spinlock_t;
+
+#define __RAW_SPIN_LOCK_UNLOCKED	{ 0 }
+
+typedef struct {
+	volatile unsigned int lock;
+} raw_rwlock_t;
+
+#define __RAW_RW_LOCK_UNLOCKED		{ 0 }
+
+#endif
Index: build_tree/linux/include/asm/stat.h
diff -u /dev/null build_tree/linux/include/asm/stat.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/stat.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,87 @@
+#ifndef _ASMARM_STAT_H
+#define _ASMARM_STAT_H
+
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned long  st_size;
+	unsigned long  st_atime;
+	unsigned long  st_mtime;
+	unsigned long  st_ctime;
+};
+
+#define STAT_HAVE_NSEC 
+
+struct stat {
+#if defined(__ARMEB__)
+	unsigned short st_dev;
+	unsigned short __pad1;
+#else
+	unsigned long  st_dev;
+#endif
+	unsigned long  st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+#if defined(__ARMEB__)
+	unsigned short st_rdev;
+	unsigned short __pad2;
+#else
+	unsigned long  st_rdev;
+#endif
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+	unsigned long  st_atime_nsec;
+	unsigned long  st_mtime;
+	unsigned long  st_mtime_nsec;
+	unsigned long  st_ctime;
+	unsigned long  st_ctime_nsec;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ * Note: The kernel zero's the padded region because glibc might read them
+ * in the hope that the kernel has stretched to using larger sizes.
+ */
+struct stat64 {
+	unsigned long long	st_dev;
+	unsigned char   __pad0[4];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned long	__st_ino;
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long	st_rdev;
+	unsigned char   __pad3[4];
+
+	long long	st_size;
+	unsigned long	st_blksize;
+	unsigned long long st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long long	st_ino;
+};
+
+#endif
Index: build_tree/linux/include/asm/statfs.h
diff -u /dev/null build_tree/linux/include/asm/statfs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/statfs.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,42 @@
+#ifndef _ASMARM_STATFS_H
+#define _ASMARM_STATFS_H
+
+#ifndef __KERNEL_STRICT_NAMES
+# include <linux/types.h>
+typedef __kernel_fsid_t	fsid_t;
+#endif
+
+struct statfs {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u32 f_blocks;
+	__u32 f_bfree;
+	__u32 f_bavail;
+	__u32 f_files;
+	__u32 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
+/*
+ * With EABI there is 4 bytes of padding added to this structure.
+ * Let's pack it so the padding goes away to simplify dual ABI support.
+ * Note that user space does NOT have to pack this structure.
+ */
+struct statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+} __attribute__ ((packed,aligned(4)));
+
+#endif
Index: build_tree/linux/include/asm/string.h
diff -u /dev/null build_tree/linux/include/asm/string.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/string.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,50 @@
+#ifndef __ASM_ARM_STRING_H
+#define __ASM_ARM_STRING_H
+
+/*
+ * We don't do inline string functions, since the
+ * optimised inline asm versions are not small.
+ */
+
+#define __HAVE_ARCH_STRRCHR
+extern char * strrchr(const char * s, int c);
+
+#define __HAVE_ARCH_STRCHR
+extern char * strchr(const char * s, int c);
+
+#define __HAVE_ARCH_MEMCPY
+extern void * memcpy(void *, const void *, __kernel_size_t);
+
+#define __HAVE_ARCH_MEMMOVE
+extern void * memmove(void *, const void *, __kernel_size_t);
+
+#define __HAVE_ARCH_MEMCHR
+extern void * memchr(const void *, int, __kernel_size_t);
+
+#define __HAVE_ARCH_MEMZERO
+#define __HAVE_ARCH_MEMSET
+extern void * memset(void *, int, __kernel_size_t);
+
+extern void __memzero(void *ptr, __kernel_size_t n);
+
+#define memset(p,v,n)							\
+	({								\
+	 	void *__p = (p); size_t __n = n;			\
+		if ((__n) != 0) {					\
+			if (__builtin_constant_p((v)) && (v) == 0)	\
+				__memzero((__p),(__n));			\
+			else						\
+				memset((__p),(v),(__n));		\
+		}							\
+		(__p);							\
+	})
+
+#define memzero(p,n) 							\
+	({ 								\
+	 	void *__p = (p); size_t __n = n;			\
+	 	if ((__n) != 0) 					\
+	 		__memzero((__p),(__n)); 			\
+	 	(__p); 							\
+	 })
+
+#endif
Index: build_tree/linux/include/asm/suspend.h
diff -u /dev/null build_tree/linux/include/asm/suspend.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/suspend.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,4 @@
+#ifndef _ASMARM_SUSPEND_H
+#define _ASMARM_SUSPEND_H
+
+#endif
Index: build_tree/linux/include/asm/system.h
diff -u /dev/null build_tree/linux/include/asm/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/system.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,364 @@
+#ifndef __ASM_ARM_SYSTEM_H
+#define __ASM_ARM_SYSTEM_H
+
+#ifdef __KERNEL__
+
+#include <asm/memory.h>
+
+#define CPU_ARCH_UNKNOWN	0
+#define CPU_ARCH_ARMv3		1
+#define CPU_ARCH_ARMv4		2
+#define CPU_ARCH_ARMv4T		3
+#define CPU_ARCH_ARMv5		4
+#define CPU_ARCH_ARMv5T		5
+#define CPU_ARCH_ARMv5TE	6
+#define CPU_ARCH_ARMv5TEJ	7
+#define CPU_ARCH_ARMv6		8
+
+/*
+ * CR1 bits (CP#15 CR1)
+ */
+#define CR_M	(1 << 0)	/* MMU enable				*/
+#define CR_A	(1 << 1)	/* Alignment abort enable		*/
+#define CR_C	(1 << 2)	/* Dcache enable			*/
+#define CR_W	(1 << 3)	/* Write buffer enable			*/
+#define CR_P	(1 << 4)	/* 32-bit exception handler		*/
+#define CR_D	(1 << 5)	/* 32-bit data address range		*/
+#define CR_L	(1 << 6)	/* Implementation defined		*/
+#define CR_B	(1 << 7)	/* Big endian				*/
+#define CR_S	(1 << 8)	/* System MMU protection		*/
+#define CR_R	(1 << 9)	/* ROM MMU protection			*/
+#define CR_F	(1 << 10)	/* Implementation defined		*/
+#define CR_Z	(1 << 11)	/* Implementation defined		*/
+#define CR_I	(1 << 12)	/* Icache enable			*/
+#define CR_V	(1 << 13)	/* Vectors relocated to 0xffff0000	*/
+#define CR_RR	(1 << 14)	/* Round Robin cache replacement	*/
+#define CR_L4	(1 << 15)	/* LDR pc can set T bit			*/
+#define CR_DT	(1 << 16)
+#define CR_IT	(1 << 18)
+#define CR_ST	(1 << 19)
+#define CR_FI	(1 << 21)	/* Fast interrupt (lower latency mode)	*/
+#define CR_U	(1 << 22)	/* Unaligned access operation		*/
+#define CR_XP	(1 << 23)	/* Extended page tables			*/
+#define CR_VE	(1 << 24)	/* Vectored interrupts			*/
+
+#define CPUID_ID	0
+#define CPUID_CACHETYPE	1
+#define CPUID_TCM	2
+#define CPUID_TLBTYPE	3
+
+#ifdef CONFIG_CPU_CP15
+#define read_cpuid(reg)							\
+	({								\
+		unsigned int __val;					\
+		asm("mrc	p15, 0, %0, c0, c0, " __stringify(reg)	\
+		    : "=r" (__val)					\
+		    :							\
+		    : "cc");						\
+		__val;							\
+	})
+#else
+#define read_cpuid(reg) (processor_id)
+#endif
+
+/*
+ * This is used to ensure the compiler did actually allocate the register we
+ * asked it for some inline assembly sequences.  Apparently we can't trust
+ * the compiler from one version to another so a bit of paranoia won't hurt.
+ * This string is meant to be concatenated with the inline asm string and
+ * will cause compilation to stop on mismatch.
+ * (for details, see gcc PR 15089)
+ */
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+
+#ifndef __ASSEMBLY__
+
+#include <linux/linkage.h>
+#include <linux/irqflags.h>
+
+struct thread_info;
+struct task_struct;
+
+/* information about the system we're running on */
+extern unsigned int system_rev;
+extern unsigned int system_serial_low;
+extern unsigned int system_serial_high;
+extern unsigned int mem_fclk_21285;
+
+struct pt_regs;
+
+void die(const char *msg, struct pt_regs *regs, int err)
+		__attribute__((noreturn));
+
+struct siginfo;
+void notify_die(const char *str, struct pt_regs *regs, struct siginfo *info,
+		unsigned long err, unsigned long trap);
+
+void hook_fault_code(int nr, int (*fn)(unsigned long, unsigned int,
+				       struct pt_regs *),
+		     int sig, const char *name);
+
+#define xchg(ptr,x) \
+	((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+
+#define tas(ptr) (xchg((ptr),1))
+
+extern asmlinkage void __backtrace(void);
+extern asmlinkage void c_backtrace(unsigned long fp, int pmode);
+
+struct mm_struct;
+extern void show_pte(struct mm_struct *mm, unsigned long addr);
+extern void __show_regs(struct pt_regs *);
+
+extern int cpu_architecture(void);
+extern void cpu_init(void);
+
+void arm_machine_restart(char mode);
+extern void (*arm_pm_restart)(char str);
+
+/*
+ * Intel's XScale3 core supports some v6 features (supersections, L2)
+ * but advertises itself as v5 as it does not support the v6 ISA.  For
+ * this reason, we need a way to explicitly test for this type of CPU.
+ */
+#ifndef CONFIG_CPU_XSC3
+#define cpu_is_xsc3()	0
+#else
+static inline int cpu_is_xsc3(void)
+{
+	extern unsigned int processor_id;
+
+	if ((processor_id & 0xffffe000) == 0x69056000)
+		return 1;
+
+	return 0;
+}
+#endif
+
+#if !defined(CONFIG_CPU_XSCALE) && !defined(CONFIG_CPU_XSC3)
+#define	cpu_is_xscale()	0
+#else
+#define	cpu_is_xscale()	1
+#endif
+
+#define UDBG_UNDEFINED	(1 << 0)
+#define UDBG_SYSCALL	(1 << 1)
+#define UDBG_BADABORT	(1 << 2)
+#define UDBG_SEGV	(1 << 3)
+#define UDBG_BUS	(1 << 4)
+
+extern unsigned int user_debug;
+
+#if __LINUX_ARM_ARCH__ >= 4
+#define vectors_high()	(cr_alignment & CR_V)
+#else
+#define vectors_high()	(0)
+#endif
+
+#if defined(CONFIG_CPU_XSC3) || __LINUX_ARM_ARCH__ >= 6
+#define isb() __asm__ __volatile__ ("mcr p15, 0, %0, c7, c5, 4" \
+				    : : "r" (0) : "memory")
+#define dsb() __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" \
+				    : : "r" (0) : "memory")
+#define dmb() __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 5" \
+				    : : "r" (0) : "memory")
+#else
+#define isb() __asm__ __volatile__ ("" : : : "memory")
+#define dsb() __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" \
+				    : : "r" (0) : "memory")
+#define dmb() __asm__ __volatile__ ("" : : : "memory")
+#endif
+
+#ifndef CONFIG_SMP
+#define mb()	do { if (arch_is_coherent()) dmb(); else barrier(); } while (0)
+#define rmb()	do { if (arch_is_coherent()) dmb(); else barrier(); } while (0)
+#define wmb()	do { if (arch_is_coherent()) dmb(); else barrier(); } while (0)
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#else
+#define mb()		dmb()
+#define rmb()		dmb()
+#define wmb()		dmb()
+#define smp_mb()	dmb()
+#define smp_rmb()	dmb()
+#define smp_wmb()	dmb()
+#endif
+#define read_barrier_depends()		do { } while(0)
+#define smp_read_barrier_depends()	do { } while(0)
+
+#define set_mb(var, value)	do { var = value; smp_mb(); } while (0)
+#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");
+
+extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
+extern unsigned long cr_alignment;	/* defined in entry-armv.S */
+
+static inline unsigned int get_cr(void)
+{
+	unsigned int val;
+	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
+	return val;
+}
+
+static inline void set_cr(unsigned int val)
+{
+	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
+	  : : "r" (val) : "cc");
+	isb();
+}
+
+#ifndef CONFIG_SMP
+extern void adjust_cr(unsigned long mask, unsigned long set);
+#endif
+
+#define CPACC_FULL(n)		(3 << (n * 2))
+#define CPACC_SVC(n)		(1 << (n * 2))
+#define CPACC_DISABLE(n)	(0 << (n * 2))
+
+static inline unsigned int get_copro_access(void)
+{
+	unsigned int val;
+	asm("mrc p15, 0, %0, c1, c0, 2 @ get copro access"
+	  : "=r" (val) : : "cc");
+	return val;
+}
+
+static inline void set_copro_access(unsigned int val)
+{
+	asm volatile("mcr p15, 0, %0, c1, c0, 2 @ set copro access"
+	  : : "r" (val) : "cc");
+	isb();
+}
+
+/*
+ * switch_mm() may do a full cache flush over the context switch,
+ * so enable interrupts over the context switch to avoid high
+ * latency.
+ */
+#define __ARCH_WANT_INTERRUPTS_ON_CTXSW
+
+/*
+ * switch_to(prev, next) should switch from task `prev' to `next'
+ * `prev' will never be the same as `next'.  schedule() itself
+ * contains the memory barrier to tell GCC not to cache `current'.
+ */
+extern struct task_struct *__switch_to(struct task_struct *, struct thread_info *, struct thread_info *);
+
+#define switch_to(prev,next,last)					\
+do {									\
+	last = __switch_to(prev,task_thread_info(prev), task_thread_info(next));	\
+} while (0)
+
+/*
+ * On SMP systems, when the scheduler does migration-cost autodetection,
+ * it needs a way to flush as much of the CPU's caches as possible.
+ *
+ * TODO: fill this in!
+ */
+static inline void sched_cacheflush(void)
+{
+}
+
+#if defined(CONFIG_CPU_SA1100) || defined(CONFIG_CPU_SA110)
+/*
+ * On the StrongARM, "swp" is terminally broken since it bypasses the
+ * cache totally.  This means that the cache becomes inconsistent, and,
+ * since we use normal loads/stores as well, this is really bad.
+ * Typically, this causes oopsen in filp_close, but could have other,
+ * more disasterous effects.  There are two work-arounds:
+ *  1. Disable interrupts and emulate the atomic swap
+ *  2. Clean the cache, perform atomic swap, flush the cache
+ *
+ * We choose (1) since its the "easiest" to achieve here and is not
+ * dependent on the processor type.
+ *
+ * NOTE that this solution won't work on an SMP system, so explcitly
+ * forbid it here.
+ */
+#define swp_is_buggy
+#endif
+
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	extern void __bad_xchg(volatile void *, int);
+	unsigned long ret;
+#ifdef swp_is_buggy
+	unsigned long flags;
+#endif
+#if __LINUX_ARM_ARCH__ >= 6
+	unsigned int tmp;
+#endif
+
+	switch (size) {
+#if __LINUX_ARM_ARCH__ >= 6
+	case 1:
+		asm volatile("@	__xchg1\n"
+		"1:	ldrexb	%0, [%3]\n"
+		"	strexb	%1, %2, [%3]\n"
+		"	teq	%1, #0\n"
+		"	bne	1b"
+			: "=&r" (ret), "=&r" (tmp)
+			: "r" (x), "r" (ptr)
+			: "memory", "cc");
+		break;
+	case 4:
+		asm volatile("@	__xchg4\n"
+		"1:	ldrex	%0, [%3]\n"
+		"	strex	%1, %2, [%3]\n"
+		"	teq	%1, #0\n"
+		"	bne	1b"
+			: "=&r" (ret), "=&r" (tmp)
+			: "r" (x), "r" (ptr)
+			: "memory", "cc");
+		break;
+#elif defined(swp_is_buggy)
+#ifdef CONFIG_SMP
+#error SMP is not supported on this platform
+#endif
+	case 1:
+		raw_local_irq_save(flags);
+		ret = *(volatile unsigned char *)ptr;
+		*(volatile unsigned char *)ptr = x;
+		raw_local_irq_restore(flags);
+		break;
+
+	case 4:
+		raw_local_irq_save(flags);
+		ret = *(volatile unsigned long *)ptr;
+		*(volatile unsigned long *)ptr = x;
+		raw_local_irq_restore(flags);
+		break;
+#else
+	case 1:
+		asm volatile("@	__xchg1\n"
+		"	swpb	%0, %1, [%2]"
+			: "=&r" (ret)
+			: "r" (x), "r" (ptr)
+			: "memory", "cc");
+		break;
+	case 4:
+		asm volatile("@	__xchg4\n"
+		"	swp	%0, %1, [%2]"
+			: "=&r" (ret)
+			: "r" (x), "r" (ptr)
+			: "memory", "cc");
+		break;
+#endif
+	default:
+		__bad_xchg(ptr, size), ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+extern void disable_hlt(void);
+extern void enable_hlt(void);
+
+#endif /* __ASSEMBLY__ */
+
+#define arch_align_stack(x) (x)
+
+#endif /* __KERNEL__ */
+
+#endif
Index: build_tree/linux/include/asm/termbits.h
diff -u /dev/null build_tree/linux/include/asm/termbits.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/termbits.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,183 @@
+#ifndef __ASM_ARM_TERMBITS_H
+#define __ASM_ARM_TERMBITS_H
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+};
+
+struct ktermios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8	0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR    010000000000		/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000		/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif	/* __ASM_ARM_TERMBITS_H */
Index: build_tree/linux/include/asm/termios.h
diff -u /dev/null build_tree/linux/include/asm/termios.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/termios.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,90 @@
+#ifndef __ASM_ARM_TERMIOS_H
+#define __ASM_ARM_TERMIOS_H
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+#ifdef __KERNEL__
+/*	intr=^C		quit=^|		erase=del	kill=^U
+	eof=^D		vtime=\0	vmin=\1		sxtc=\0
+	start=^Q	stop=^S		susp=^Z		eol=\0
+	reprint=^R	discard=^U	werase=^W	lnext=^V
+	eol2=\0
+*/
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
+#endif
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+#ifdef __KERNEL__
+
+/*
+ * Translate a "termio" structure into a "termios". Ugh.
+ */
+#define SET_LOW_TERMIOS_BITS(termios, termio, x) {		\
+	unsigned short __tmp;					\
+	get_user(__tmp,&(termio)->x);				\
+	*(unsigned short *) &(termios)->x = __tmp;		\
+}
+
+#define user_termio_to_kernel_termios(termios, termio) \
+({ \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_iflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_oflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_cflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_lflag); \
+	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
+})
+
+/*
+ * Translate a "termios" structure into a "termio". Ugh.
+ */
+#define kernel_termios_to_user_termio(termio, termios) \
+({ \
+	put_user((termios)->c_iflag, &(termio)->c_iflag); \
+	put_user((termios)->c_oflag, &(termio)->c_oflag); \
+	put_user((termios)->c_cflag, &(termio)->c_cflag); \
+	put_user((termios)->c_lflag, &(termio)->c_lflag); \
+	put_user((termios)->c_line,  &(termio)->c_line); \
+	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
+})
+
+#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios))
+#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios))
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __ASM_ARM_TERMIOS_H */
Index: build_tree/linux/include/asm/therm.h
diff -u /dev/null build_tree/linux/include/asm/therm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/therm.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,28 @@
+/*
+ * linux/include/asm-arm/therm.h: Definitions for Dallas Semiconductor
+ *  DS1620 thermometer driver (as used in the Rebel.com NetWinder)
+ */
+#ifndef __ASM_THERM_H
+#define __ASM_THERM_H
+
+/* ioctl numbers for /dev/therm */
+#define CMD_SET_THERMOSTATE	0x53
+#define CMD_GET_THERMOSTATE	0x54
+#define CMD_GET_STATUS		0x56
+#define CMD_GET_TEMPERATURE	0x57
+#define CMD_SET_THERMOSTATE2	0x58
+#define CMD_GET_THERMOSTATE2	0x59
+#define CMD_GET_TEMPERATURE2	0x5a
+#define CMD_GET_FAN		0x5b
+#define CMD_SET_FAN		0x5c
+
+#define FAN_OFF			0
+#define FAN_ON			1
+#define FAN_ALWAYS_ON		2
+
+struct therm {
+	int hi;
+	int lo;
+};
+
+#endif
Index: build_tree/linux/include/asm/thread_info.h
diff -u /dev/null build_tree/linux/include/asm/thread_info.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/thread_info.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,166 @@
+/*
+ *  linux/include/asm-arm/thread_info.h
+ *
+ *  Copyright (C) 2002 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_THREAD_INFO_H
+#define __ASM_ARM_THREAD_INFO_H
+
+#ifdef __KERNEL__
+
+#include <linux/compiler.h>
+#include <asm/fpstate.h>
+
+#define THREAD_SIZE_ORDER	1
+#define THREAD_SIZE		8192
+#define THREAD_START_SP		(THREAD_SIZE - 8)
+
+#ifndef __ASSEMBLY__
+
+struct task_struct;
+struct exec_domain;
+
+#include <asm/ptrace.h>
+#include <asm/types.h>
+#include <asm/domain.h>
+
+typedef unsigned long mm_segment_t;
+
+struct cpu_context_save {
+	__u32	r4;
+	__u32	r5;
+	__u32	r6;
+	__u32	r7;
+	__u32	r8;
+	__u32	r9;
+	__u32	sl;
+	__u32	fp;
+	__u32	sp;
+	__u32	pc;
+	__u32	extra[2];		/* Xscale 'acc' register, etc */
+};
+
+/*
+ * low level task data that entry.S needs immediate access to.
+ * __switch_to() assumes cpu_context follows immediately after cpu_domain.
+ */
+struct thread_info {
+	unsigned long		flags;		/* low level flags */
+	int			preempt_count;	/* 0 => preemptable, <0 => bug */
+	mm_segment_t		addr_limit;	/* address limit */
+	struct task_struct	*task;		/* main task structure */
+	struct exec_domain	*exec_domain;	/* execution domain */
+	__u32			cpu;		/* cpu */
+	__u32			cpu_domain;	/* cpu domain */
+	struct cpu_context_save	cpu_context;	/* cpu context */
+	__u8			used_cp[16];	/* thread used copro */
+	unsigned long		tp_value;
+	struct crunch_state	crunchstate;
+	union fp_state		fpstate __attribute__((aligned(8)));
+	union vfp_state		vfpstate;
+	struct restart_block	restart_block;
+};
+
+#define INIT_THREAD_INFO(tsk)						\
+{									\
+	.task		= &tsk,						\
+	.exec_domain	= &default_exec_domain,				\
+	.flags		= 0,						\
+	.preempt_count	= 1,						\
+	.addr_limit	= KERNEL_DS,					\
+	.cpu_domain	= domain_val(DOMAIN_USER, DOMAIN_MANAGER) |	\
+			  domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) |	\
+			  domain_val(DOMAIN_IO, DOMAIN_CLIENT),		\
+	.restart_block	= {						\
+		.fn	= do_no_restart_syscall,			\
+	},								\
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+/*
+ * how to get the thread information struct from C
+ */
+static inline struct thread_info *current_thread_info(void) __attribute_const__;
+
+static inline struct thread_info *current_thread_info(void)
+{
+	register unsigned long sp asm ("sp");
+	return (struct thread_info *)(sp & ~(THREAD_SIZE - 1));
+}
+
+/* thread information allocation */
+#ifdef CONFIG_DEBUG_STACK_USAGE
+#define alloc_thread_info(tsk) \
+	((struct thread_info *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, \
+		THREAD_SIZE_ORDER))
+#else
+#define alloc_thread_info(tsk) \
+	((struct thread_info *)__get_free_pages(GFP_KERNEL, THREAD_SIZE_ORDER))
+#endif
+
+#define free_thread_info(info) \
+	free_pages((unsigned long)info, THREAD_SIZE_ORDER);
+
+#define thread_saved_pc(tsk)	\
+	((unsigned long)(pc_pointer(task_thread_info(tsk)->cpu_context.pc)))
+#define thread_saved_fp(tsk)	\
+	((unsigned long)(task_thread_info(tsk)->cpu_context.fp))
+
+extern void crunch_task_disable(struct thread_info *);
+extern void crunch_task_copy(struct thread_info *, void *);
+extern void crunch_task_restore(struct thread_info *, void *);
+extern void crunch_task_release(struct thread_info *);
+
+extern void iwmmxt_task_disable(struct thread_info *);
+extern void iwmmxt_task_copy(struct thread_info *, void *);
+extern void iwmmxt_task_restore(struct thread_info *, void *);
+extern void iwmmxt_task_release(struct thread_info *);
+extern void iwmmxt_task_switch(struct thread_info *);
+
+#endif
+
+/*
+ * We use bit 30 of the preempt_count to indicate that kernel
+ * preemption is occurring.  See include/asm-arm/hardirq.h.
+ */
+#define PREEMPT_ACTIVE	0x40000000
+
+/*
+ * thread information flags:
+ *  TIF_SYSCALL_TRACE	- syscall trace active
+ *  TIF_NOTIFY_RESUME	- resumption notification requested
+ *  TIF_SIGPENDING	- signal pending
+ *  TIF_NEED_RESCHED	- rescheduling necessary
+ *  TIF_USEDFPU		- FPU was used by this task this quantum (SMP)
+ *  TIF_POLLING_NRFLAG	- true if poll_idle() is polling TIF_NEED_RESCHED
+ */
+#define TIF_NOTIFY_RESUME	0
+#define TIF_SIGPENDING		1
+#define TIF_NEED_RESCHED	2
+#define TIF_SYSCALL_TRACE	8
+#define TIF_POLLING_NRFLAG	16
+#define TIF_USING_IWMMXT	17
+#define TIF_MEMDIE		18
+#define TIF_FREEZE		19
+
+#define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
+#define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
+#define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
+#define _TIF_POLLING_NRFLAG	(1 << TIF_POLLING_NRFLAG)
+#define _TIF_USING_IWMMXT	(1 << TIF_USING_IWMMXT)
+#define _TIF_FREEZE		(1 << TIF_FREEZE)
+
+/*
+ * Change these and you break ASM code in entry-common.S
+ */
+#define _TIF_WORK_MASK		0x000000ff
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_ARM_THREAD_INFO_H */
Index: build_tree/linux/include/asm/thread_notify.h
diff -u /dev/null build_tree/linux/include/asm/thread_notify.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/thread_notify.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,48 @@
+/*
+ *  linux/include/asm-arm/thread_notify.h
+ *
+ *  Copyright (C) 2006 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ASMARM_THREAD_NOTIFY_H
+#define ASMARM_THREAD_NOTIFY_H
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+#include <linux/notifier.h>
+#include <asm/thread_info.h>
+
+static inline int thread_register_notifier(struct notifier_block *n)
+{
+	extern struct atomic_notifier_head thread_notify_head;
+	return atomic_notifier_chain_register(&thread_notify_head, n);
+}
+
+static inline void thread_unregister_notifier(struct notifier_block *n)
+{
+	extern struct atomic_notifier_head thread_notify_head;
+	atomic_notifier_chain_unregister(&thread_notify_head, n);
+}
+
+static inline void thread_notify(unsigned long rc, struct thread_info *thread)
+{
+	extern struct atomic_notifier_head thread_notify_head;
+	atomic_notifier_call_chain(&thread_notify_head, rc, thread);
+}
+
+#endif
+
+/*
+ * These are the reason codes for the thread notifier.
+ */
+#define THREAD_NOTIFY_FLUSH	0
+#define THREAD_NOTIFY_RELEASE	1
+#define THREAD_NOTIFY_SWITCH	2
+
+#endif
+#endif
Index: build_tree/linux/include/asm/timex.h
diff -u /dev/null build_tree/linux/include/asm/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/timex.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,24 @@
+/*
+ *  linux/include/asm-arm/timex.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Architecture Specific TIME specifications
+ */
+#ifndef _ASMARM_TIMEX_H
+#define _ASMARM_TIMEX_H
+
+#include <asm/arch/timex.h>
+
+typedef unsigned long cycles_t;
+
+static inline cycles_t get_cycles (void)
+{
+	return 0;
+}
+
+#endif
Index: build_tree/linux/include/asm/tlb.h
diff -u /dev/null build_tree/linux/include/asm/tlb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/tlb.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,94 @@
+/*
+ *  linux/include/asm-arm/tlb.h
+ *
+ *  Copyright (C) 2002 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Experimentation shows that on a StrongARM, it appears to be faster
+ *  to use the "invalidate whole tlb" rather than "invalidate single
+ *  tlb" for this.
+ *
+ *  This appears true for both the process fork+exit case, as well as
+ *  the munmap-large-area case.
+ */
+#ifndef __ASMARM_TLB_H
+#define __ASMARM_TLB_H
+
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+
+#ifndef CONFIG_MMU
+
+#include <linux/pagemap.h>
+#include <asm-generic/tlb.h>
+
+#else /* !CONFIG_MMU */
+
+#include <asm/pgalloc.h>
+
+/*
+ * TLB handling.  This allows us to remove pages from the page
+ * tables, and efficiently handle the TLB issues.
+ */
+struct mmu_gather {
+	struct mm_struct	*mm;
+	unsigned int		fullmm;
+};
+
+DECLARE_PER_CPU(struct mmu_gather, mmu_gathers);
+
+static inline struct mmu_gather *
+tlb_gather_mmu(struct mm_struct *mm, unsigned int full_mm_flush)
+{
+	struct mmu_gather *tlb = &get_cpu_var(mmu_gathers);
+
+	tlb->mm = mm;
+	tlb->fullmm = full_mm_flush;
+
+	return tlb;
+}
+
+static inline void
+tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long end)
+{
+	if (tlb->fullmm)
+		flush_tlb_mm(tlb->mm);
+
+	/* keep the page table cache within bounds */
+	check_pgt_cache();
+
+	put_cpu_var(mmu_gathers);
+}
+
+#define tlb_remove_tlb_entry(tlb,ptep,address)	do { } while (0)
+
+/*
+ * In the case of tlb vma handling, we can optimise these away in the
+ * case where we're doing a full MM flush.  When we're doing a munmap,
+ * the vmas are adjusted to only cover the region to be torn down.
+ */
+static inline void
+tlb_start_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
+{
+	if (!tlb->fullmm)
+		flush_cache_range(vma, vma->vm_start, vma->vm_end);
+}
+
+static inline void
+tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
+{
+	if (!tlb->fullmm)
+		flush_tlb_range(vma, vma->vm_start, vma->vm_end);
+}
+
+#define tlb_remove_page(tlb,page)	free_page_and_swap_cache(page)
+#define pte_free_tlb(tlb,ptep)		pte_free(ptep)
+#define pmd_free_tlb(tlb,pmdp)		pmd_free(pmdp)
+
+#define tlb_migrate_finish(mm)		do { } while (0)
+
+#endif /* CONFIG_MMU */
+#endif
Index: build_tree/linux/include/asm/tlbflush.h
diff -u /dev/null build_tree/linux/include/asm/tlbflush.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/tlbflush.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,460 @@
+/*
+ *  linux/include/asm-arm/tlbflush.h
+ *
+ *  Copyright (C) 1999-2003 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_TLBFLUSH_H
+#define _ASMARM_TLBFLUSH_H
+
+
+#ifndef CONFIG_MMU
+
+#define tlb_flush(tlb)	((void) tlb)
+
+#else /* CONFIG_MMU */
+
+#include <asm/glue.h>
+
+#define TLB_V3_PAGE	(1 << 0)
+#define TLB_V4_U_PAGE	(1 << 1)
+#define TLB_V4_D_PAGE	(1 << 2)
+#define TLB_V4_I_PAGE	(1 << 3)
+#define TLB_V6_U_PAGE	(1 << 4)
+#define TLB_V6_D_PAGE	(1 << 5)
+#define TLB_V6_I_PAGE	(1 << 6)
+
+#define TLB_V3_FULL	(1 << 8)
+#define TLB_V4_U_FULL	(1 << 9)
+#define TLB_V4_D_FULL	(1 << 10)
+#define TLB_V4_I_FULL	(1 << 11)
+#define TLB_V6_U_FULL	(1 << 12)
+#define TLB_V6_D_FULL	(1 << 13)
+#define TLB_V6_I_FULL	(1 << 14)
+
+#define TLB_V6_U_ASID	(1 << 16)
+#define TLB_V6_D_ASID	(1 << 17)
+#define TLB_V6_I_ASID	(1 << 18)
+
+#define TLB_DCLEAN	(1 << 30)
+#define TLB_WB		(1 << 31)
+
+/*
+ *	MMU TLB Model
+ *	=============
+ *
+ *	We have the following to choose from:
+ *	  v3    - ARMv3
+ *	  v4    - ARMv4 without write buffer
+ *	  v4wb  - ARMv4 with write buffer without I TLB flush entry instruction
+ *	  v4wbi - ARMv4 with write buffer with I TLB flush entry instruction
+ *	  v6wbi - ARMv6 with write buffer with I TLB flush entry instruction
+ */
+#undef _TLB
+#undef MULTI_TLB
+
+#define v3_tlb_flags	(TLB_V3_FULL | TLB_V3_PAGE)
+
+#ifdef CONFIG_CPU_TLB_V3
+# define v3_possible_flags	v3_tlb_flags
+# define v3_always_flags	v3_tlb_flags
+# ifdef _TLB
+#  define MULTI_TLB 1
+# else
+#  define _TLB v3
+# endif
+#else
+# define v3_possible_flags	0
+# define v3_always_flags	(-1UL)
+#endif
+
+#define v4_tlb_flags	(TLB_V4_U_FULL | TLB_V4_U_PAGE)
+
+#ifdef CONFIG_CPU_TLB_V4WT
+# define v4_possible_flags	v4_tlb_flags
+# define v4_always_flags	v4_tlb_flags
+# ifdef _TLB
+#  define MULTI_TLB 1
+# else
+#  define _TLB v4
+# endif
+#else
+# define v4_possible_flags	0
+# define v4_always_flags	(-1UL)
+#endif
+
+#define v4wbi_tlb_flags	(TLB_WB | TLB_DCLEAN | \
+			 TLB_V4_I_FULL | TLB_V4_D_FULL | \
+			 TLB_V4_I_PAGE | TLB_V4_D_PAGE)
+
+#ifdef CONFIG_CPU_TLB_V4WBI
+# define v4wbi_possible_flags	v4wbi_tlb_flags
+# define v4wbi_always_flags	v4wbi_tlb_flags
+# ifdef _TLB
+#  define MULTI_TLB 1
+# else
+#  define _TLB v4wbi
+# endif
+#else
+# define v4wbi_possible_flags	0
+# define v4wbi_always_flags	(-1UL)
+#endif
+
+#define v4wb_tlb_flags	(TLB_WB | TLB_DCLEAN | \
+			 TLB_V4_I_FULL | TLB_V4_D_FULL | \
+			 TLB_V4_D_PAGE)
+
+#ifdef CONFIG_CPU_TLB_V4WB
+# define v4wb_possible_flags	v4wb_tlb_flags
+# define v4wb_always_flags	v4wb_tlb_flags
+# ifdef _TLB
+#  define MULTI_TLB 1
+# else
+#  define _TLB v4wb
+# endif
+#else
+# define v4wb_possible_flags	0
+# define v4wb_always_flags	(-1UL)
+#endif
+
+#define v6wbi_tlb_flags (TLB_WB | TLB_DCLEAN | \
+			 TLB_V6_I_FULL | TLB_V6_D_FULL | \
+			 TLB_V6_I_PAGE | TLB_V6_D_PAGE | \
+			 TLB_V6_I_ASID | TLB_V6_D_ASID)
+
+#ifdef CONFIG_CPU_TLB_V6
+# define v6wbi_possible_flags	v6wbi_tlb_flags
+# define v6wbi_always_flags	v6wbi_tlb_flags
+# ifdef _TLB
+#  define MULTI_TLB 1
+# else
+#  define _TLB v6wbi
+# endif
+#else
+# define v6wbi_possible_flags	0
+# define v6wbi_always_flags	(-1UL)
+#endif
+
+#ifndef _TLB
+#error Unknown TLB model
+#endif
+
+#ifndef __ASSEMBLY__
+
+struct cpu_tlb_fns {
+	void (*flush_user_range)(unsigned long, unsigned long, struct vm_area_struct *);
+	void (*flush_kern_range)(unsigned long, unsigned long);
+	unsigned long tlb_flags;
+};
+
+/*
+ * Select the calling method
+ */
+#ifdef MULTI_TLB
+
+#define __cpu_flush_user_tlb_range	cpu_tlb.flush_user_range
+#define __cpu_flush_kern_tlb_range	cpu_tlb.flush_kern_range
+
+#else
+
+#define __cpu_flush_user_tlb_range	__glue(_TLB,_flush_user_tlb_range)
+#define __cpu_flush_kern_tlb_range	__glue(_TLB,_flush_kern_tlb_range)
+
+extern void __cpu_flush_user_tlb_range(unsigned long, unsigned long, struct vm_area_struct *);
+extern void __cpu_flush_kern_tlb_range(unsigned long, unsigned long);
+
+#endif
+
+extern struct cpu_tlb_fns cpu_tlb;
+
+#define __cpu_tlb_flags			cpu_tlb.tlb_flags
+
+/*
+ *	TLB Management
+ *	==============
+ *
+ *	The arch/arm/mm/tlb-*.S files implement these methods.
+ *
+ *	The TLB specific code is expected to perform whatever tests it
+ *	needs to determine if it should invalidate the TLB for each
+ *	call.  Start addresses are inclusive and end addresses are
+ *	exclusive; it is safe to round these addresses down.
+ *
+ *	flush_tlb_all()
+ *
+ *		Invalidate the entire TLB.
+ *
+ *	flush_tlb_mm(mm)
+ *
+ *		Invalidate all TLB entries in a particular address
+ *		space.
+ *		- mm	- mm_struct describing address space
+ *
+ *	flush_tlb_range(mm,start,end)
+ *
+ *		Invalidate a range of TLB entries in the specified
+ *		address space.
+ *		- mm	- mm_struct describing address space
+ *		- start - start address (may not be aligned)
+ *		- end	- end address (exclusive, may not be aligned)
+ *
+ *	flush_tlb_page(vaddr,vma)
+ *
+ *		Invalidate the specified page in the specified address range.
+ *		- vaddr - virtual address (may not be aligned)
+ *		- vma	- vma_struct describing address range
+ *
+ *	flush_kern_tlb_page(kaddr)
+ *
+ *		Invalidate the TLB entry for the specified page.  The address
+ *		will be in the kernels virtual memory space.  Current uses
+ *		only require the D-TLB to be invalidated.
+ *		- kaddr - Kernel virtual memory address
+ */
+
+/*
+ * We optimise the code below by:
+ *  - building a set of TLB flags that might be set in __cpu_tlb_flags
+ *  - building a set of TLB flags that will always be set in __cpu_tlb_flags
+ *  - if we're going to need __cpu_tlb_flags, access it once and only once
+ *
+ * This allows us to build optimal assembly for the single-CPU type case,
+ * and as close to optimal given the compiler constrants for multi-CPU
+ * case.  We could do better for the multi-CPU case if the compiler
+ * implemented the "%?" method, but this has been discontinued due to too
+ * many people getting it wrong.
+ */
+#define possible_tlb_flags	(v3_possible_flags | \
+				 v4_possible_flags | \
+				 v4wbi_possible_flags | \
+				 v4wb_possible_flags | \
+				 v6wbi_possible_flags)
+
+#define always_tlb_flags	(v3_always_flags & \
+				 v4_always_flags & \
+				 v4wbi_always_flags & \
+				 v4wb_always_flags & \
+				 v6wbi_always_flags)
+
+#define tlb_flag(f)	((always_tlb_flags & (f)) || (__tlb_flag & possible_tlb_flags & (f)))
+
+static inline void local_flush_tlb_all(void)
+{
+	const int zero = 0;
+	const unsigned int __tlb_flag = __cpu_tlb_flags;
+
+	if (tlb_flag(TLB_WB))
+		dsb();
+
+	if (tlb_flag(TLB_V3_FULL))
+		asm("mcr p15, 0, %0, c6, c0, 0" : : "r" (zero) : "cc");
+	if (tlb_flag(TLB_V4_U_FULL | TLB_V6_U_FULL))
+		asm("mcr p15, 0, %0, c8, c7, 0" : : "r" (zero) : "cc");
+	if (tlb_flag(TLB_V4_D_FULL | TLB_V6_D_FULL))
+		asm("mcr p15, 0, %0, c8, c6, 0" : : "r" (zero) : "cc");
+	if (tlb_flag(TLB_V4_I_FULL | TLB_V6_I_FULL))
+		asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
+
+	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
+		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
+		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+		/* flush the branch target cache */
+		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		dsb();
+		isb();
+	}
+}
+
+static inline void local_flush_tlb_mm(struct mm_struct *mm)
+{
+	const int zero = 0;
+	const int asid = ASID(mm);
+	const unsigned int __tlb_flag = __cpu_tlb_flags;
+
+	if (tlb_flag(TLB_WB))
+		dsb();
+
+	if (cpu_isset(smp_processor_id(), mm->cpu_vm_mask)) {
+		if (tlb_flag(TLB_V3_FULL))
+			asm("mcr p15, 0, %0, c6, c0, 0" : : "r" (zero) : "cc");
+		if (tlb_flag(TLB_V4_U_FULL))
+			asm("mcr p15, 0, %0, c8, c7, 0" : : "r" (zero) : "cc");
+		if (tlb_flag(TLB_V4_D_FULL))
+			asm("mcr p15, 0, %0, c8, c6, 0" : : "r" (zero) : "cc");
+		if (tlb_flag(TLB_V4_I_FULL))
+			asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
+	}
+
+	if (tlb_flag(TLB_V6_U_ASID))
+		asm("mcr p15, 0, %0, c8, c7, 2" : : "r" (asid) : "cc");
+	if (tlb_flag(TLB_V6_D_ASID))
+		asm("mcr p15, 0, %0, c8, c6, 2" : : "r" (asid) : "cc");
+	if (tlb_flag(TLB_V6_I_ASID))
+		asm("mcr p15, 0, %0, c8, c5, 2" : : "r" (asid) : "cc");
+
+	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
+		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
+		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+		/* flush the branch target cache */
+		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		dsb();
+	}
+}
+
+static inline void
+local_flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)
+{
+	const int zero = 0;
+	const unsigned int __tlb_flag = __cpu_tlb_flags;
+
+	uaddr = (uaddr & PAGE_MASK) | ASID(vma->vm_mm);
+
+	if (tlb_flag(TLB_WB))
+		dsb();
+
+	if (cpu_isset(smp_processor_id(), vma->vm_mm->cpu_vm_mask)) {
+		if (tlb_flag(TLB_V3_PAGE))
+			asm("mcr p15, 0, %0, c6, c0, 0" : : "r" (uaddr) : "cc");
+		if (tlb_flag(TLB_V4_U_PAGE))
+			asm("mcr p15, 0, %0, c8, c7, 1" : : "r" (uaddr) : "cc");
+		if (tlb_flag(TLB_V4_D_PAGE))
+			asm("mcr p15, 0, %0, c8, c6, 1" : : "r" (uaddr) : "cc");
+		if (tlb_flag(TLB_V4_I_PAGE))
+			asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (uaddr) : "cc");
+		if (!tlb_flag(TLB_V4_I_PAGE) && tlb_flag(TLB_V4_I_FULL))
+			asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
+	}
+
+	if (tlb_flag(TLB_V6_U_PAGE))
+		asm("mcr p15, 0, %0, c8, c7, 1" : : "r" (uaddr) : "cc");
+	if (tlb_flag(TLB_V6_D_PAGE))
+		asm("mcr p15, 0, %0, c8, c6, 1" : : "r" (uaddr) : "cc");
+	if (tlb_flag(TLB_V6_I_PAGE))
+		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (uaddr) : "cc");
+
+	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
+		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
+		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+		/* flush the branch target cache */
+		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		dsb();
+	}
+}
+
+static inline void local_flush_tlb_kernel_page(unsigned long kaddr)
+{
+	const int zero = 0;
+	const unsigned int __tlb_flag = __cpu_tlb_flags;
+
+	kaddr &= PAGE_MASK;
+
+	if (tlb_flag(TLB_WB))
+		dsb();
+
+	if (tlb_flag(TLB_V3_PAGE))
+		asm("mcr p15, 0, %0, c6, c0, 0" : : "r" (kaddr) : "cc");
+	if (tlb_flag(TLB_V4_U_PAGE))
+		asm("mcr p15, 0, %0, c8, c7, 1" : : "r" (kaddr) : "cc");
+	if (tlb_flag(TLB_V4_D_PAGE))
+		asm("mcr p15, 0, %0, c8, c6, 1" : : "r" (kaddr) : "cc");
+	if (tlb_flag(TLB_V4_I_PAGE))
+		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (kaddr) : "cc");
+	if (!tlb_flag(TLB_V4_I_PAGE) && tlb_flag(TLB_V4_I_FULL))
+		asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
+
+	if (tlb_flag(TLB_V6_U_PAGE))
+		asm("mcr p15, 0, %0, c8, c7, 1" : : "r" (kaddr) : "cc");
+	if (tlb_flag(TLB_V6_D_PAGE))
+		asm("mcr p15, 0, %0, c8, c6, 1" : : "r" (kaddr) : "cc");
+	if (tlb_flag(TLB_V6_I_PAGE))
+		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (kaddr) : "cc");
+
+	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
+		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
+		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+		/* flush the branch target cache */
+		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
+		dsb();
+		isb();
+	}
+}
+
+/*
+ *	flush_pmd_entry
+ *
+ *	Flush a PMD entry (word aligned, or double-word aligned) to
+ *	RAM if the TLB for the CPU we are running on requires this.
+ *	This is typically used when we are creating PMD entries.
+ *
+ *	clean_pmd_entry
+ *
+ *	Clean (but don't drain the write buffer) if the CPU requires
+ *	these operations.  This is typically used when we are removing
+ *	PMD entries.
+ */
+static inline void flush_pmd_entry(pmd_t *pmd)
+{
+	const unsigned int __tlb_flag = __cpu_tlb_flags;
+
+	if (tlb_flag(TLB_DCLEAN))
+		asm("mcr	p15, 0, %0, c7, c10, 1	@ flush_pmd"
+			: : "r" (pmd) : "cc");
+	if (tlb_flag(TLB_WB))
+		dsb();
+}
+
+static inline void clean_pmd_entry(pmd_t *pmd)
+{
+	const unsigned int __tlb_flag = __cpu_tlb_flags;
+
+	if (tlb_flag(TLB_DCLEAN))
+		asm("mcr	p15, 0, %0, c7, c10, 1	@ flush_pmd"
+			: : "r" (pmd) : "cc");
+}
+
+#undef tlb_flag
+#undef always_tlb_flags
+#undef possible_tlb_flags
+
+/*
+ * Convert calls to our calling convention.
+ */
+#define local_flush_tlb_range(vma,start,end)	__cpu_flush_user_tlb_range(start,end,vma)
+#define local_flush_tlb_kernel_range(s,e)	__cpu_flush_kern_tlb_range(s,e)
+
+#ifndef CONFIG_SMP
+#define flush_tlb_all		local_flush_tlb_all
+#define flush_tlb_mm		local_flush_tlb_mm
+#define flush_tlb_page		local_flush_tlb_page
+#define flush_tlb_kernel_page	local_flush_tlb_kernel_page
+#define flush_tlb_range		local_flush_tlb_range
+#define flush_tlb_kernel_range	local_flush_tlb_kernel_range
+#else
+extern void flush_tlb_all(void);
+extern void flush_tlb_mm(struct mm_struct *mm);
+extern void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr);
+extern void flush_tlb_kernel_page(unsigned long kaddr);
+extern void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end);
+extern void flush_tlb_kernel_range(unsigned long start, unsigned long end);
+#endif
+
+/*
+ * if PG_dcache_dirty is set for the page, we need to ensure that any
+ * cache entries for the kernels virtual memory range are written
+ * back to the page.
+ */
+extern void update_mmu_cache(struct vm_area_struct *vma, unsigned long addr, pte_t pte);
+
+/*
+ * ARM processors do not cache TLB tables in RAM.
+ */
+#define flush_tlb_pgtables(mm,start,end)	do { } while (0)
+
+#endif
+
+#endif /* CONFIG_MMU */
+
+#endif
Index: build_tree/linux/include/asm/topology.h
diff -u /dev/null build_tree/linux/include/asm/topology.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/topology.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,6 @@
+#ifndef _ASM_ARM_TOPOLOGY_H
+#define _ASM_ARM_TOPOLOGY_H
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_ARM_TOPOLOGY_H */
Index: build_tree/linux/include/asm/traps.h
diff -u /dev/null build_tree/linux/include/asm/traps.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/traps.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,18 @@
+#ifndef _ASMARM_TRAP_H
+#define _ASMARM_TRAP_H
+
+#include <linux/list.h>
+
+struct undef_hook {
+	struct list_head node;
+	u32 instr_mask;
+	u32 instr_val;
+	u32 cpsr_mask;
+	u32 cpsr_val;
+	int (*fn)(struct pt_regs *regs, unsigned int instr);
+};
+
+void register_undef_hook(struct undef_hook *hook);
+void unregister_undef_hook(struct undef_hook *hook);
+
+#endif
Index: build_tree/linux/include/asm/types.h
diff -u /dev/null build_tree/linux/include/asm/types.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/types.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,60 @@
+#ifndef __ASM_ARM_TYPES_H
+#define __ASM_ARM_TYPES_H
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+/* Dma addresses are 32-bits wide.  */
+
+typedef u32 dma_addr_t;
+typedef u32 dma64_addr_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif
+
Index: build_tree/linux/include/asm/uaccess.h
diff -u /dev/null build_tree/linux/include/asm/uaccess.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/uaccess.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,444 @@
+/*
+ *  linux/include/asm-arm/uaccess.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASMARM_UACCESS_H
+#define _ASMARM_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/sched.h>
+#include <asm/errno.h>
+#include <asm/memory.h>
+#include <asm/domain.h>
+#include <asm/system.h>
+
+#define VERIFY_READ 0
+#define VERIFY_WRITE 1
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+extern int fixup_exception(struct pt_regs *regs);
+
+/*
+ * These two are intentionally not defined anywhere - if the kernel
+ * code generates any references to them, that's a bug.
+ */
+extern int __get_user_bad(void);
+extern int __put_user_bad(void);
+
+/*
+ * Note that this is actually 0x1,0000,0000
+ */
+#define KERNEL_DS	0x00000000
+#define get_ds()	(KERNEL_DS)
+
+#ifdef CONFIG_MMU
+
+#define USER_DS		TASK_SIZE
+#define get_fs()	(current_thread_info()->addr_limit)
+
+static inline void set_fs(mm_segment_t fs)
+{
+	current_thread_info()->addr_limit = fs;
+	modify_domain(DOMAIN_KERNEL, fs ? DOMAIN_CLIENT : DOMAIN_MANAGER);
+}
+
+#define segment_eq(a,b)	((a) == (b))
+
+#define __addr_ok(addr) ({ \
+	unsigned long flag; \
+	__asm__("cmp %2, %0; movlo %0, #0" \
+		: "=&r" (flag) \
+		: "0" (current_thread_info()->addr_limit), "r" (addr) \
+		: "cc"); \
+	(flag == 0); })
+
+/* We use 33-bit arithmetic here... */
+#define __range_ok(addr,size) ({ \
+	unsigned long flag, roksum; \
+	__chk_user_ptr(addr);	\
+	__asm__("adds %1, %2, %3; sbcccs %1, %1, %0; movcc %0, #0" \
+		: "=&r" (flag), "=&r" (roksum) \
+		: "r" (addr), "Ir" (size), "0" (current_thread_info()->addr_limit) \
+		: "cc"); \
+	flag; })
+
+/*
+ * Single-value transfer routines.  They automatically use the right
+ * size if we just have the right pointer type.  Note that the functions
+ * which read from user space (*get_*) need to take care not to leak
+ * kernel data even if the calling code is buggy and fails to check
+ * the return value.  This means zeroing out the destination variable
+ * or buffer on error.  Normally this is done out of line by the
+ * fixup code, but there are a few places where it intrudes on the
+ * main code path.  When we only write to user space, there is no
+ * problem.
+ */
+extern int __get_user_1(void *);
+extern int __get_user_2(void *);
+extern int __get_user_4(void *);
+
+#define __get_user_x(__r2,__p,__e,__s,__i...)				\
+	   __asm__ __volatile__ (					\
+		__asmeq("%0", "r0") __asmeq("%1", "r2")			\
+		"bl	__get_user_" #__s				\
+		: "=&r" (__e), "=r" (__r2)				\
+		: "0" (__p)						\
+		: __i, "cc")
+
+#define get_user(x,p)							\
+	({								\
+		register const typeof(*(p)) __user *__p asm("r0") = (p);\
+		register unsigned long __r2 asm("r2");			\
+		register int __e asm("r0");				\
+		switch (sizeof(*(__p))) {				\
+		case 1:							\
+			__get_user_x(__r2, __p, __e, 1, "lr");		\
+	       		break;						\
+		case 2:							\
+			__get_user_x(__r2, __p, __e, 2, "r3", "lr");	\
+			break;						\
+		case 4:							\
+	       		__get_user_x(__r2, __p, __e, 4, "lr");		\
+			break;						\
+		default: __e = __get_user_bad(); break;			\
+		}							\
+		x = (typeof(*(p))) __r2;				\
+		__e;							\
+	})
+
+extern int __put_user_1(void *, unsigned int);
+extern int __put_user_2(void *, unsigned int);
+extern int __put_user_4(void *, unsigned int);
+extern int __put_user_8(void *, unsigned long long);
+
+#define __put_user_x(__r2,__p,__e,__s)					\
+	   __asm__ __volatile__ (					\
+		__asmeq("%0", "r0") __asmeq("%2", "r2")			\
+		"bl	__put_user_" #__s				\
+		: "=&r" (__e)						\
+		: "0" (__p), "r" (__r2)					\
+		: "ip", "lr", "cc")
+
+#define put_user(x,p)							\
+	({								\
+		register const typeof(*(p)) __r2 asm("r2") = (x);	\
+		register const typeof(*(p)) __user *__p asm("r0") = (p);\
+		register int __e asm("r0");				\
+		switch (sizeof(*(__p))) {				\
+		case 1:							\
+			__put_user_x(__r2, __p, __e, 1);		\
+			break;						\
+		case 2:							\
+			__put_user_x(__r2, __p, __e, 2);		\
+			break;						\
+		case 4:							\
+			__put_user_x(__r2, __p, __e, 4);		\
+			break;						\
+		case 8:							\
+			__put_user_x(__r2, __p, __e, 8);		\
+			break;						\
+		default: __e = __put_user_bad(); break;			\
+		}							\
+		__e;							\
+	})
+
+#else /* CONFIG_MMU */
+
+/*
+ * uClinux has only one addr space, so has simplified address limits.
+ */
+#define USER_DS			KERNEL_DS
+
+#define segment_eq(a,b)		(1)
+#define __addr_ok(addr)		(1)
+#define __range_ok(addr,size)	(0)
+#define get_fs()		(KERNEL_DS)
+
+static inline void set_fs(mm_segment_t fs)
+{
+}
+
+#define get_user(x,p)	__get_user(x,p)
+#define put_user(x,p)	__put_user(x,p)
+
+#endif /* CONFIG_MMU */
+
+#define access_ok(type,addr,size)	(__range_ok(addr,size) == 0)
+
+/*
+ * The "__xxx" versions of the user access functions do not verify the
+ * address space - it must have been done previously with a separate
+ * "access_ok()" call.
+ *
+ * The "xxx_error" versions set the third argument to EFAULT if an
+ * error occurs, and leave it unchanged on success.  Note that these
+ * versions are void (ie, don't return a value as such).
+ */
+#define __get_user(x,ptr)						\
+({									\
+	long __gu_err = 0;						\
+	__get_user_err((x),(ptr),__gu_err);				\
+	__gu_err;							\
+})
+
+#define __get_user_error(x,ptr,err)					\
+({									\
+	__get_user_err((x),(ptr),err);					\
+	(void) 0;							\
+})
+
+#define __get_user_err(x,ptr,err)					\
+do {									\
+	unsigned long __gu_addr = (unsigned long)(ptr);			\
+	unsigned long __gu_val;						\
+	__chk_user_ptr(ptr);						\
+	switch (sizeof(*(ptr))) {					\
+	case 1:	__get_user_asm_byte(__gu_val,__gu_addr,err);	break;	\
+	case 2:	__get_user_asm_half(__gu_val,__gu_addr,err);	break;	\
+	case 4:	__get_user_asm_word(__gu_val,__gu_addr,err);	break;	\
+	default: (__gu_val) = __get_user_bad();				\
+	}								\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+} while (0)
+
+#define __get_user_asm_byte(x,addr,err)				\
+	__asm__ __volatile__(					\
+	"1:	ldrbt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	mov	%1, #0\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err), "=&r" (x)					\
+	: "r" (addr), "i" (-EFAULT)				\
+	: "cc")
+
+#ifndef __ARMEB__
+#define __get_user_asm_half(x,__gu_addr,err)			\
+({								\
+	unsigned long __b1, __b2;				\
+	__get_user_asm_byte(__b1, __gu_addr, err);		\
+	__get_user_asm_byte(__b2, __gu_addr + 1, err);		\
+	(x) = __b1 | (__b2 << 8);				\
+})
+#else
+#define __get_user_asm_half(x,__gu_addr,err)			\
+({								\
+	unsigned long __b1, __b2;				\
+	__get_user_asm_byte(__b1, __gu_addr, err);		\
+	__get_user_asm_byte(__b2, __gu_addr + 1, err);		\
+	(x) = (__b1 << 8) | __b2;				\
+})
+#endif
+
+#define __get_user_asm_word(x,addr,err)				\
+	__asm__ __volatile__(					\
+	"1:	ldrt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	mov	%1, #0\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err), "=&r" (x)					\
+	: "r" (addr), "i" (-EFAULT)				\
+	: "cc")
+
+#define __put_user(x,ptr)						\
+({									\
+	long __pu_err = 0;						\
+	__put_user_err((x),(ptr),__pu_err);				\
+	__pu_err;							\
+})
+
+#define __put_user_error(x,ptr,err)					\
+({									\
+	__put_user_err((x),(ptr),err);					\
+	(void) 0;							\
+})
+
+#define __put_user_err(x,ptr,err)					\
+do {									\
+	unsigned long __pu_addr = (unsigned long)(ptr);			\
+	__typeof__(*(ptr)) __pu_val = (x);				\
+	__chk_user_ptr(ptr);						\
+	switch (sizeof(*(ptr))) {					\
+	case 1: __put_user_asm_byte(__pu_val,__pu_addr,err);	break;	\
+	case 2: __put_user_asm_half(__pu_val,__pu_addr,err);	break;	\
+	case 4: __put_user_asm_word(__pu_val,__pu_addr,err);	break;	\
+	case 8:	__put_user_asm_dword(__pu_val,__pu_addr,err);	break;	\
+	default: __put_user_bad();					\
+	}								\
+} while (0)
+
+#define __put_user_asm_byte(x,__pu_addr,err)			\
+	__asm__ __volatile__(					\
+	"1:	strbt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err)						\
+	: "r" (x), "r" (__pu_addr), "i" (-EFAULT)		\
+	: "cc")
+
+#ifndef __ARMEB__
+#define __put_user_asm_half(x,__pu_addr,err)			\
+({								\
+	unsigned long __temp = (unsigned long)(x);		\
+	__put_user_asm_byte(__temp, __pu_addr, err);		\
+	__put_user_asm_byte(__temp >> 8, __pu_addr + 1, err);	\
+})
+#else
+#define __put_user_asm_half(x,__pu_addr,err)			\
+({								\
+	unsigned long __temp = (unsigned long)(x);		\
+	__put_user_asm_byte(__temp >> 8, __pu_addr, err);	\
+	__put_user_asm_byte(__temp, __pu_addr + 1, err);	\
+})
+#endif
+
+#define __put_user_asm_word(x,__pu_addr,err)			\
+	__asm__ __volatile__(					\
+	"1:	strt	%1,[%2],#0\n"				\
+	"2:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"3:	mov	%0, %3\n"				\
+	"	b	2b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 3b\n"				\
+	"	.previous"					\
+	: "+r" (err)						\
+	: "r" (x), "r" (__pu_addr), "i" (-EFAULT)		\
+	: "cc")
+
+#ifndef __ARMEB__
+#define	__reg_oper0	"%R2"
+#define	__reg_oper1	"%Q2"
+#else
+#define	__reg_oper0	"%Q2"
+#define	__reg_oper1	"%R2"
+#endif
+
+#define __put_user_asm_dword(x,__pu_addr,err)			\
+	__asm__ __volatile__(					\
+	"1:	strt	" __reg_oper1 ", [%1], #4\n"		\
+	"2:	strt	" __reg_oper0 ", [%1], #0\n"		\
+	"3:\n"							\
+	"	.section .fixup,\"ax\"\n"			\
+	"	.align	2\n"					\
+	"4:	mov	%0, %3\n"				\
+	"	b	3b\n"					\
+	"	.previous\n"					\
+	"	.section __ex_table,\"a\"\n"			\
+	"	.align	3\n"					\
+	"	.long	1b, 4b\n"				\
+	"	.long	2b, 4b\n"				\
+	"	.previous"					\
+	: "+r" (err), "+r" (__pu_addr)				\
+	: "r" (x), "i" (-EFAULT)				\
+	: "cc")
+
+
+#ifdef CONFIG_MMU
+extern unsigned long __must_check __copy_from_user(void *to, const void __user *from, unsigned long n);
+extern unsigned long __must_check __copy_to_user(void __user *to, const void *from, unsigned long n);
+extern unsigned long __must_check __clear_user(void __user *addr, unsigned long n);
+#else
+#define __copy_from_user(to,from,n)	(memcpy(to, (void __force *)from, n), 0)
+#define __copy_to_user(to,from,n)	(memcpy((void __force *)to, from, n), 0)
+#define __clear_user(addr,n)		(memset((void __force *)addr, 0, n), 0)
+#endif
+
+extern unsigned long __must_check __strncpy_from_user(char *to, const char __user *from, unsigned long count);
+extern unsigned long __must_check __strnlen_user(const char __user *s, long n);
+
+static inline unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	if (access_ok(VERIFY_READ, from, n))
+		n = __copy_from_user(to, from, n);
+	else /* security hole - plug it */
+		memzero(to, n);
+	return n;
+}
+
+static inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __copy_to_user(to, from, n);
+	return n;
+}
+
+#define __copy_to_user_inatomic __copy_to_user
+#define __copy_from_user_inatomic __copy_from_user
+
+static inline unsigned long __must_check clear_user(void __user *to, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __clear_user(to, n);
+	return n;
+}
+
+static inline long __must_check strncpy_from_user(char *dst, const char __user *src, long count)
+{
+	long res = -EFAULT;
+	if (access_ok(VERIFY_READ, src, 1))
+		res = __strncpy_from_user(dst, src, count);
+	return res;
+}
+
+#define strlen_user(s)	strnlen_user(s, ~0UL >> 1)
+
+static inline long __must_check strnlen_user(const char __user *s, long n)
+{
+	unsigned long res = 0;
+
+	if (__addr_ok(s))
+		res = __strnlen_user(s, n);
+
+	return res;
+}
+
+#endif /* _ASMARM_UACCESS_H */
Index: build_tree/linux/include/asm/ucontext.h
diff -u /dev/null build_tree/linux/include/asm/ucontext.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/ucontext.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,103 @@
+#ifndef _ASMARM_UCONTEXT_H
+#define _ASMARM_UCONTEXT_H
+
+#include <asm/fpstate.h>
+
+/*
+ * struct sigcontext only has room for the basic registers, but struct
+ * ucontext now has room for all registers which need to be saved and
+ * restored.  Coprocessor registers are stored in uc_regspace.  Each
+ * coprocessor's saved state should start with a documented 32-bit magic
+ * number, followed by a 32-bit word giving the coproccesor's saved size.
+ * uc_regspace may be expanded if necessary, although this takes some
+ * coordination with glibc.
+ */
+
+struct ucontext {
+	unsigned long	  uc_flags;
+	struct ucontext  *uc_link;
+	stack_t		  uc_stack;
+	struct sigcontext uc_mcontext;
+	sigset_t	  uc_sigmask;
+	/* Allow for uc_sigmask growth.  Glibc uses a 1024-bit sigset_t.  */
+	int		  __unused[32 - (sizeof (sigset_t) / sizeof (int))];
+	/* Last for extensibility.  Eight byte aligned because some
+	   coprocessors require eight byte alignment.  */
+ 	unsigned long	  uc_regspace[128] __attribute__((__aligned__(8)));
+};
+
+#ifdef __KERNEL__
+
+/*
+ * Coprocessor save state.  The magic values and specific
+ * coprocessor's layouts are part of the userspace ABI.  Each one of
+ * these should be a multiple of eight bytes and aligned to eight
+ * bytes, to prevent unpredictable padding in the signal frame.
+ */
+
+#ifdef CONFIG_CRUNCH
+#define CRUNCH_MAGIC		0x5065cf03
+#define CRUNCH_STORAGE_SIZE	(CRUNCH_SIZE + 8)
+
+struct crunch_sigframe {
+	unsigned long	magic;
+	unsigned long	size;
+	struct crunch_state	storage;
+} __attribute__((__aligned__(8)));
+#endif
+
+#ifdef CONFIG_IWMMXT
+/* iwmmxt_area is 0x98 bytes long, preceeded by 8 bytes of signature */
+#define IWMMXT_MAGIC		0x12ef842a
+#define IWMMXT_STORAGE_SIZE	(IWMMXT_SIZE + 8)
+
+struct iwmmxt_sigframe {
+	unsigned long	magic;
+	unsigned long	size;
+	struct iwmmxt_struct storage;
+} __attribute__((__aligned__(8)));
+#endif /* CONFIG_IWMMXT */
+
+#ifdef CONFIG_VFP
+#if __LINUX_ARM_ARCH__ < 6
+/* For ARM pre-v6, we use fstmiax and fldmiax.  This adds one extra
+ * word after the registers, and a word of padding at the end for
+ * alignment.  */
+#define VFP_MAGIC		0x56465001
+#define VFP_STORAGE_SIZE	152
+#else
+#define VFP_MAGIC		0x56465002
+#define VFP_STORAGE_SIZE	144
+#endif
+
+struct vfp_sigframe
+{
+	unsigned long		magic;
+	unsigned long		size;
+	union vfp_state		storage;
+};
+#endif /* CONFIG_VFP */
+
+/*
+ * Auxiliary signal frame.  This saves stuff like FP state.
+ * The layout of this structure is not part of the user ABI,
+ * because the config options aren't.  uc_regspace is really
+ * one of these.
+ */
+struct aux_sigframe {
+#ifdef CONFIG_CRUNCH
+	struct crunch_sigframe	crunch;
+#endif
+#ifdef CONFIG_IWMMXT
+	struct iwmmxt_sigframe	iwmmxt;
+#endif
+#if 0 && defined CONFIG_VFP /* Not yet saved.  */
+	struct vfp_sigframe	vfp;
+#endif
+	/* Something that isn't a valid magic number for any coprocessor.  */
+	unsigned long		end_magic;
+} __attribute__((__aligned__(8)));
+
+#endif
+
+#endif /* !_ASMARM_UCONTEXT_H */
Index: build_tree/linux/include/asm/unaligned.h
diff -u /dev/null build_tree/linux/include/asm/unaligned.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/unaligned.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,179 @@
+#ifndef __ASM_ARM_UNALIGNED_H
+#define __ASM_ARM_UNALIGNED_H
+
+#include <asm/types.h>
+
+extern int __bug_unaligned_x(const void *ptr);
+
+/*
+ * What is the most efficient way of loading/storing an unaligned value?
+ *
+ * That is the subject of this file.  Efficiency here is defined as
+ * minimum code size with minimum register usage for the common cases.
+ * It is currently not believed that long longs are common, so we
+ * trade efficiency for the chars, shorts and longs against the long
+ * longs.
+ *
+ * Current stats with gcc 2.7.2.2 for these functions:
+ *
+ *	ptrsize	get:	code	regs	put:	code	regs
+ *	1		1	1		1	2
+ *	2		3	2		3	2
+ *	4		7	3		7	3
+ *	8		20	6		16	6
+ *
+ * gcc 2.95.1 seems to code differently:
+ *
+ *	ptrsize	get:	code	regs	put:	code	regs
+ *	1		1	1		1	2
+ *	2		3	2		3	2
+ *	4		7	4		7	4
+ *	8		19	8		15	6
+ *
+ * which may or may not be more efficient (depending upon whether
+ * you can afford the extra registers).  Hopefully the gcc 2.95
+ * is inteligent enough to decide if it is better to use the
+ * extra register, but evidence so far seems to suggest otherwise.
+ *
+ * Unfortunately, gcc is not able to optimise the high word
+ * out of long long >> 32, or the low word from long long << 32
+ */
+
+#define __get_unaligned_2_le(__p)					\
+	(__p[0] | __p[1] << 8)
+
+#define __get_unaligned_2_be(__p)					\
+	(__p[0] << 8 | __p[1])
+
+#define __get_unaligned_4_le(__p)					\
+	(__p[0] | __p[1] << 8 | __p[2] << 16 | __p[3] << 24)
+
+#define __get_unaligned_4_be(__p)					\
+	(__p[0] << 24 | __p[1] << 16 | __p[2] << 8 | __p[3])
+
+#define __get_unaligned_8_le(__p)					\
+	((unsigned long long)__get_unaligned_4_le((__p+4)) << 32 |	\
+		__get_unaligned_4_le(__p))
+
+#define __get_unaligned_8_be(__p)					\
+	((unsigned long long)__get_unaligned_4_be(__p) << 32 |		\
+		__get_unaligned_4_be((__p+4)))
+
+#define __get_unaligned_le(ptr)						\
+	({								\
+		const __u8 *__p = (const __u8 *)(ptr);			\
+		__builtin_choose_expr(sizeof(*(ptr)) == 1, *__p,	\
+		  __builtin_choose_expr(sizeof(*(ptr)) == 2, __get_unaligned_2_le(__p),	\
+		  __builtin_choose_expr(sizeof(*(ptr)) == 4, __get_unaligned_4_le(__p),	\
+		  __builtin_choose_expr(sizeof(*(ptr)) == 8, __get_unaligned_8_le(__p),	\
+		    (void)__bug_unaligned_x(__p)))));			\
+	})
+
+#define __get_unaligned_be(ptr)						\
+	({								\
+		const __u8 *__p = (const __u8 *)(ptr);			\
+		__builtin_choose_expr(sizeof(*(ptr)) == 1, *__p,	\
+		  __builtin_choose_expr(sizeof(*(ptr)) == 2, __get_unaligned_2_be(__p),	\
+		  __builtin_choose_expr(sizeof(*(ptr)) == 4, __get_unaligned_4_be(__p),	\
+		  __builtin_choose_expr(sizeof(*(ptr)) == 8, __get_unaligned_8_be(__p),	\
+		    (void)__bug_unaligned_x(__p)))));			\
+	})
+
+
+static inline void __put_unaligned_2_le(__u32 __v, register __u8 *__p)
+{
+	*__p++ = __v;
+	*__p++ = __v >> 8;
+}
+
+static inline void __put_unaligned_2_be(__u32 __v, register __u8 *__p)
+{
+	*__p++ = __v >> 8;
+	*__p++ = __v;
+}
+
+static inline void __put_unaligned_4_le(__u32 __v, register __u8 *__p)
+{
+	__put_unaligned_2_le(__v >> 16, __p + 2);
+	__put_unaligned_2_le(__v, __p);
+}
+
+static inline void __put_unaligned_4_be(__u32 __v, register __u8 *__p)
+{
+	__put_unaligned_2_be(__v >> 16, __p);
+	__put_unaligned_2_be(__v, __p + 2);
+}
+
+static inline void __put_unaligned_8_le(const unsigned long long __v, register __u8 *__p)
+{
+	/*
+	 * tradeoff: 8 bytes of stack for all unaligned puts (2
+	 * instructions), or an extra register in the long long
+	 * case - go for the extra register.
+	 */
+	__put_unaligned_4_le(__v >> 32, __p+4);
+	__put_unaligned_4_le(__v, __p);
+}
+
+static inline void __put_unaligned_8_be(const unsigned long long __v, register __u8 *__p)
+{
+	/*
+	 * tradeoff: 8 bytes of stack for all unaligned puts (2
+	 * instructions), or an extra register in the long long
+	 * case - go for the extra register.
+	 */
+	__put_unaligned_4_be(__v >> 32, __p);
+	__put_unaligned_4_be(__v, __p+4);
+}
+
+/*
+ * Try to store an unaligned value as efficiently as possible.
+ */
+#define __put_unaligned_le(val,ptr)					\
+	({							\
+		switch (sizeof(*(ptr))) {			\
+		case 1:						\
+			*(ptr) = (val);				\
+			break;					\
+		case 2: __put_unaligned_2_le((val),(__u8 *)(ptr));	\
+			break;					\
+		case 4:	__put_unaligned_4_le((val),(__u8 *)(ptr));	\
+			break;					\
+		case 8:	__put_unaligned_8_le((val),(__u8 *)(ptr)); \
+			break;					\
+		default: __bug_unaligned_x(ptr);		\
+			break;					\
+		}						\
+		(void) 0;					\
+	})
+
+#define __put_unaligned_be(val,ptr)					\
+	({							\
+		switch (sizeof(*(ptr))) {			\
+		case 1:						\
+			*(ptr) = (val);				\
+			break;					\
+		case 2: __put_unaligned_2_be((val),(__u8 *)(ptr));	\
+			break;					\
+		case 4:	__put_unaligned_4_be((val),(__u8 *)(ptr));	\
+			break;					\
+		case 8:	__put_unaligned_8_be((val),(__u8 *)(ptr)); \
+			break;					\
+		default: __bug_unaligned_x(ptr);		\
+			break;					\
+		}						\
+		(void) 0;					\
+	})
+
+/*
+ * Select endianness
+ */
+#ifndef __ARMEB__
+#define get_unaligned	__get_unaligned_le
+#define put_unaligned	__put_unaligned_le
+#else
+#define get_unaligned	__get_unaligned_be
+#define put_unaligned	__put_unaligned_be
+#endif
+
+#endif
Index: build_tree/linux/include/asm/unistd.h
diff -u /dev/null build_tree/linux/include/asm/unistd.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/unistd.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,437 @@
+/*
+ *  linux/include/asm-arm/unistd.h
+ *
+ *  Copyright (C) 2001-2005 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Please forward _all_ changes to this file to rmk@arm.linux.org.uk,
+ * no matter what the change is.  Thanks!
+ */
+#ifndef __ASM_ARM_UNISTD_H
+#define __ASM_ARM_UNISTD_H
+
+#define __NR_OABI_SYSCALL_BASE	0x900000
+
+#if defined(__thumb__) || defined(__ARM_EABI__)
+#define __NR_SYSCALL_BASE	0
+#else
+#define __NR_SYSCALL_BASE	__NR_OABI_SYSCALL_BASE
+#endif
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_restart_syscall		(__NR_SYSCALL_BASE+  0)
+#define __NR_exit			(__NR_SYSCALL_BASE+  1)
+#define __NR_fork			(__NR_SYSCALL_BASE+  2)
+#define __NR_read			(__NR_SYSCALL_BASE+  3)
+#define __NR_write			(__NR_SYSCALL_BASE+  4)
+#define __NR_open			(__NR_SYSCALL_BASE+  5)
+#define __NR_close			(__NR_SYSCALL_BASE+  6)
+					/* 7 was sys_waitpid */
+#define __NR_creat			(__NR_SYSCALL_BASE+  8)
+#define __NR_link			(__NR_SYSCALL_BASE+  9)
+#define __NR_unlink			(__NR_SYSCALL_BASE+ 10)
+#define __NR_execve			(__NR_SYSCALL_BASE+ 11)
+#define __NR_chdir			(__NR_SYSCALL_BASE+ 12)
+#define __NR_time			(__NR_SYSCALL_BASE+ 13)
+#define __NR_mknod			(__NR_SYSCALL_BASE+ 14)
+#define __NR_chmod			(__NR_SYSCALL_BASE+ 15)
+#define __NR_lchown			(__NR_SYSCALL_BASE+ 16)
+					/* 17 was sys_break */
+					/* 18 was sys_stat */
+#define __NR_lseek			(__NR_SYSCALL_BASE+ 19)
+#define __NR_getpid			(__NR_SYSCALL_BASE+ 20)
+#define __NR_mount			(__NR_SYSCALL_BASE+ 21)
+#define __NR_umount			(__NR_SYSCALL_BASE+ 22)
+#define __NR_setuid			(__NR_SYSCALL_BASE+ 23)
+#define __NR_getuid			(__NR_SYSCALL_BASE+ 24)
+#define __NR_stime			(__NR_SYSCALL_BASE+ 25)
+#define __NR_ptrace			(__NR_SYSCALL_BASE+ 26)
+#define __NR_alarm			(__NR_SYSCALL_BASE+ 27)
+					/* 28 was sys_fstat */
+#define __NR_pause			(__NR_SYSCALL_BASE+ 29)
+#define __NR_utime			(__NR_SYSCALL_BASE+ 30)
+					/* 31 was sys_stty */
+					/* 32 was sys_gtty */
+#define __NR_access			(__NR_SYSCALL_BASE+ 33)
+#define __NR_nice			(__NR_SYSCALL_BASE+ 34)
+					/* 35 was sys_ftime */
+#define __NR_sync			(__NR_SYSCALL_BASE+ 36)
+#define __NR_kill			(__NR_SYSCALL_BASE+ 37)
+#define __NR_rename			(__NR_SYSCALL_BASE+ 38)
+#define __NR_mkdir			(__NR_SYSCALL_BASE+ 39)
+#define __NR_rmdir			(__NR_SYSCALL_BASE+ 40)
+#define __NR_dup			(__NR_SYSCALL_BASE+ 41)
+#define __NR_pipe			(__NR_SYSCALL_BASE+ 42)
+#define __NR_times			(__NR_SYSCALL_BASE+ 43)
+					/* 44 was sys_prof */
+#define __NR_brk			(__NR_SYSCALL_BASE+ 45)
+#define __NR_setgid			(__NR_SYSCALL_BASE+ 46)
+#define __NR_getgid			(__NR_SYSCALL_BASE+ 47)
+					/* 48 was sys_signal */
+#define __NR_geteuid			(__NR_SYSCALL_BASE+ 49)
+#define __NR_getegid			(__NR_SYSCALL_BASE+ 50)
+#define __NR_acct			(__NR_SYSCALL_BASE+ 51)
+#define __NR_umount2			(__NR_SYSCALL_BASE+ 52)
+					/* 53 was sys_lock */
+#define __NR_ioctl			(__NR_SYSCALL_BASE+ 54)
+#define __NR_fcntl			(__NR_SYSCALL_BASE+ 55)
+					/* 56 was sys_mpx */
+#define __NR_setpgid			(__NR_SYSCALL_BASE+ 57)
+					/* 58 was sys_ulimit */
+					/* 59 was sys_olduname */
+#define __NR_umask			(__NR_SYSCALL_BASE+ 60)
+#define __NR_chroot			(__NR_SYSCALL_BASE+ 61)
+#define __NR_ustat			(__NR_SYSCALL_BASE+ 62)
+#define __NR_dup2			(__NR_SYSCALL_BASE+ 63)
+#define __NR_getppid			(__NR_SYSCALL_BASE+ 64)
+#define __NR_getpgrp			(__NR_SYSCALL_BASE+ 65)
+#define __NR_setsid			(__NR_SYSCALL_BASE+ 66)
+#define __NR_sigaction			(__NR_SYSCALL_BASE+ 67)
+					/* 68 was sys_sgetmask */
+					/* 69 was sys_ssetmask */
+#define __NR_setreuid			(__NR_SYSCALL_BASE+ 70)
+#define __NR_setregid			(__NR_SYSCALL_BASE+ 71)
+#define __NR_sigsuspend			(__NR_SYSCALL_BASE+ 72)
+#define __NR_sigpending			(__NR_SYSCALL_BASE+ 73)
+#define __NR_sethostname		(__NR_SYSCALL_BASE+ 74)
+#define __NR_setrlimit			(__NR_SYSCALL_BASE+ 75)
+#define __NR_getrlimit			(__NR_SYSCALL_BASE+ 76)	/* Back compat 2GB limited rlimit */
+#define __NR_getrusage			(__NR_SYSCALL_BASE+ 77)
+#define __NR_gettimeofday		(__NR_SYSCALL_BASE+ 78)
+#define __NR_settimeofday		(__NR_SYSCALL_BASE+ 79)
+#define __NR_getgroups			(__NR_SYSCALL_BASE+ 80)
+#define __NR_setgroups			(__NR_SYSCALL_BASE+ 81)
+#define __NR_select			(__NR_SYSCALL_BASE+ 82)
+#define __NR_symlink			(__NR_SYSCALL_BASE+ 83)
+					/* 84 was sys_lstat */
+#define __NR_readlink			(__NR_SYSCALL_BASE+ 85)
+#define __NR_uselib			(__NR_SYSCALL_BASE+ 86)
+#define __NR_swapon			(__NR_SYSCALL_BASE+ 87)
+#define __NR_reboot			(__NR_SYSCALL_BASE+ 88)
+#define __NR_readdir			(__NR_SYSCALL_BASE+ 89)
+#define __NR_mmap			(__NR_SYSCALL_BASE+ 90)
+#define __NR_munmap			(__NR_SYSCALL_BASE+ 91)
+#define __NR_truncate			(__NR_SYSCALL_BASE+ 92)
+#define __NR_ftruncate			(__NR_SYSCALL_BASE+ 93)
+#define __NR_fchmod			(__NR_SYSCALL_BASE+ 94)
+#define __NR_fchown			(__NR_SYSCALL_BASE+ 95)
+#define __NR_getpriority		(__NR_SYSCALL_BASE+ 96)
+#define __NR_setpriority		(__NR_SYSCALL_BASE+ 97)
+					/* 98 was sys_profil */
+#define __NR_statfs			(__NR_SYSCALL_BASE+ 99)
+#define __NR_fstatfs			(__NR_SYSCALL_BASE+100)
+					/* 101 was sys_ioperm */
+#define __NR_socketcall			(__NR_SYSCALL_BASE+102)
+#define __NR_syslog			(__NR_SYSCALL_BASE+103)
+#define __NR_setitimer			(__NR_SYSCALL_BASE+104)
+#define __NR_getitimer			(__NR_SYSCALL_BASE+105)
+#define __NR_stat			(__NR_SYSCALL_BASE+106)
+#define __NR_lstat			(__NR_SYSCALL_BASE+107)
+#define __NR_fstat			(__NR_SYSCALL_BASE+108)
+					/* 109 was sys_uname */
+					/* 110 was sys_iopl */
+#define __NR_vhangup			(__NR_SYSCALL_BASE+111)
+					/* 112 was sys_idle */
+#define __NR_syscall			(__NR_SYSCALL_BASE+113) /* syscall to call a syscall! */
+#define __NR_wait4			(__NR_SYSCALL_BASE+114)
+#define __NR_swapoff			(__NR_SYSCALL_BASE+115)
+#define __NR_sysinfo			(__NR_SYSCALL_BASE+116)
+#define __NR_ipc			(__NR_SYSCALL_BASE+117)
+#define __NR_fsync			(__NR_SYSCALL_BASE+118)
+#define __NR_sigreturn			(__NR_SYSCALL_BASE+119)
+#define __NR_clone			(__NR_SYSCALL_BASE+120)
+#define __NR_setdomainname		(__NR_SYSCALL_BASE+121)
+#define __NR_uname			(__NR_SYSCALL_BASE+122)
+					/* 123 was sys_modify_ldt */
+#define __NR_adjtimex			(__NR_SYSCALL_BASE+124)
+#define __NR_mprotect			(__NR_SYSCALL_BASE+125)
+#define __NR_sigprocmask		(__NR_SYSCALL_BASE+126)
+					/* 127 was sys_create_module */
+#define __NR_init_module		(__NR_SYSCALL_BASE+128)
+#define __NR_delete_module		(__NR_SYSCALL_BASE+129)
+					/* 130 was sys_get_kernel_syms */
+#define __NR_quotactl			(__NR_SYSCALL_BASE+131)
+#define __NR_getpgid			(__NR_SYSCALL_BASE+132)
+#define __NR_fchdir			(__NR_SYSCALL_BASE+133)
+#define __NR_bdflush			(__NR_SYSCALL_BASE+134)
+#define __NR_sysfs			(__NR_SYSCALL_BASE+135)
+#define __NR_personality		(__NR_SYSCALL_BASE+136)
+					/* 137 was sys_afs_syscall */
+#define __NR_setfsuid			(__NR_SYSCALL_BASE+138)
+#define __NR_setfsgid			(__NR_SYSCALL_BASE+139)
+#define __NR__llseek			(__NR_SYSCALL_BASE+140)
+#define __NR_getdents			(__NR_SYSCALL_BASE+141)
+#define __NR__newselect			(__NR_SYSCALL_BASE+142)
+#define __NR_flock			(__NR_SYSCALL_BASE+143)
+#define __NR_msync			(__NR_SYSCALL_BASE+144)
+#define __NR_readv			(__NR_SYSCALL_BASE+145)
+#define __NR_writev			(__NR_SYSCALL_BASE+146)
+#define __NR_getsid			(__NR_SYSCALL_BASE+147)
+#define __NR_fdatasync			(__NR_SYSCALL_BASE+148)
+#define __NR__sysctl			(__NR_SYSCALL_BASE+149)
+#define __NR_mlock			(__NR_SYSCALL_BASE+150)
+#define __NR_munlock			(__NR_SYSCALL_BASE+151)
+#define __NR_mlockall			(__NR_SYSCALL_BASE+152)
+#define __NR_munlockall			(__NR_SYSCALL_BASE+153)
+#define __NR_sched_setparam		(__NR_SYSCALL_BASE+154)
+#define __NR_sched_getparam		(__NR_SYSCALL_BASE+155)
+#define __NR_sched_setscheduler		(__NR_SYSCALL_BASE+156)
+#define __NR_sched_getscheduler		(__NR_SYSCALL_BASE+157)
+#define __NR_sched_yield		(__NR_SYSCALL_BASE+158)
+#define __NR_sched_get_priority_max	(__NR_SYSCALL_BASE+159)
+#define __NR_sched_get_priority_min	(__NR_SYSCALL_BASE+160)
+#define __NR_sched_rr_get_interval	(__NR_SYSCALL_BASE+161)
+#define __NR_nanosleep			(__NR_SYSCALL_BASE+162)
+#define __NR_mremap			(__NR_SYSCALL_BASE+163)
+#define __NR_setresuid			(__NR_SYSCALL_BASE+164)
+#define __NR_getresuid			(__NR_SYSCALL_BASE+165)
+					/* 166 was sys_vm86 */
+					/* 167 was sys_query_module */
+#define __NR_poll			(__NR_SYSCALL_BASE+168)
+#define __NR_nfsservctl			(__NR_SYSCALL_BASE+169)
+#define __NR_setresgid			(__NR_SYSCALL_BASE+170)
+#define __NR_getresgid			(__NR_SYSCALL_BASE+171)
+#define __NR_prctl			(__NR_SYSCALL_BASE+172)
+#define __NR_rt_sigreturn		(__NR_SYSCALL_BASE+173)
+#define __NR_rt_sigaction		(__NR_SYSCALL_BASE+174)
+#define __NR_rt_sigprocmask		(__NR_SYSCALL_BASE+175)
+#define __NR_rt_sigpending		(__NR_SYSCALL_BASE+176)
+#define __NR_rt_sigtimedwait		(__NR_SYSCALL_BASE+177)
+#define __NR_rt_sigqueueinfo		(__NR_SYSCALL_BASE+178)
+#define __NR_rt_sigsuspend		(__NR_SYSCALL_BASE+179)
+#define __NR_pread64			(__NR_SYSCALL_BASE+180)
+#define __NR_pwrite64			(__NR_SYSCALL_BASE+181)
+#define __NR_chown			(__NR_SYSCALL_BASE+182)
+#define __NR_getcwd			(__NR_SYSCALL_BASE+183)
+#define __NR_capget			(__NR_SYSCALL_BASE+184)
+#define __NR_capset			(__NR_SYSCALL_BASE+185)
+#define __NR_sigaltstack		(__NR_SYSCALL_BASE+186)
+#define __NR_sendfile			(__NR_SYSCALL_BASE+187)
+					/* 188 reserved */
+					/* 189 reserved */
+#define __NR_vfork			(__NR_SYSCALL_BASE+190)
+#define __NR_ugetrlimit			(__NR_SYSCALL_BASE+191)	/* SuS compliant getrlimit */
+#define __NR_mmap2			(__NR_SYSCALL_BASE+192)
+#define __NR_truncate64			(__NR_SYSCALL_BASE+193)
+#define __NR_ftruncate64		(__NR_SYSCALL_BASE+194)
+#define __NR_stat64			(__NR_SYSCALL_BASE+195)
+#define __NR_lstat64			(__NR_SYSCALL_BASE+196)
+#define __NR_fstat64			(__NR_SYSCALL_BASE+197)
+#define __NR_lchown32			(__NR_SYSCALL_BASE+198)
+#define __NR_getuid32			(__NR_SYSCALL_BASE+199)
+#define __NR_getgid32			(__NR_SYSCALL_BASE+200)
+#define __NR_geteuid32			(__NR_SYSCALL_BASE+201)
+#define __NR_getegid32			(__NR_SYSCALL_BASE+202)
+#define __NR_setreuid32			(__NR_SYSCALL_BASE+203)
+#define __NR_setregid32			(__NR_SYSCALL_BASE+204)
+#define __NR_getgroups32		(__NR_SYSCALL_BASE+205)
+#define __NR_setgroups32		(__NR_SYSCALL_BASE+206)
+#define __NR_fchown32			(__NR_SYSCALL_BASE+207)
+#define __NR_setresuid32		(__NR_SYSCALL_BASE+208)
+#define __NR_getresuid32		(__NR_SYSCALL_BASE+209)
+#define __NR_setresgid32		(__NR_SYSCALL_BASE+210)
+#define __NR_getresgid32		(__NR_SYSCALL_BASE+211)
+#define __NR_chown32			(__NR_SYSCALL_BASE+212)
+#define __NR_setuid32			(__NR_SYSCALL_BASE+213)
+#define __NR_setgid32			(__NR_SYSCALL_BASE+214)
+#define __NR_setfsuid32			(__NR_SYSCALL_BASE+215)
+#define __NR_setfsgid32			(__NR_SYSCALL_BASE+216)
+#define __NR_getdents64			(__NR_SYSCALL_BASE+217)
+#define __NR_pivot_root			(__NR_SYSCALL_BASE+218)
+#define __NR_mincore			(__NR_SYSCALL_BASE+219)
+#define __NR_madvise			(__NR_SYSCALL_BASE+220)
+#define __NR_fcntl64			(__NR_SYSCALL_BASE+221)
+					/* 222 for tux */
+					/* 223 is unused */
+#define __NR_gettid			(__NR_SYSCALL_BASE+224)
+#define __NR_readahead			(__NR_SYSCALL_BASE+225)
+#define __NR_setxattr			(__NR_SYSCALL_BASE+226)
+#define __NR_lsetxattr			(__NR_SYSCALL_BASE+227)
+#define __NR_fsetxattr			(__NR_SYSCALL_BASE+228)
+#define __NR_getxattr			(__NR_SYSCALL_BASE+229)
+#define __NR_lgetxattr			(__NR_SYSCALL_BASE+230)
+#define __NR_fgetxattr			(__NR_SYSCALL_BASE+231)
+#define __NR_listxattr			(__NR_SYSCALL_BASE+232)
+#define __NR_llistxattr			(__NR_SYSCALL_BASE+233)
+#define __NR_flistxattr			(__NR_SYSCALL_BASE+234)
+#define __NR_removexattr		(__NR_SYSCALL_BASE+235)
+#define __NR_lremovexattr		(__NR_SYSCALL_BASE+236)
+#define __NR_fremovexattr		(__NR_SYSCALL_BASE+237)
+#define __NR_tkill			(__NR_SYSCALL_BASE+238)
+#define __NR_sendfile64			(__NR_SYSCALL_BASE+239)
+#define __NR_futex			(__NR_SYSCALL_BASE+240)
+#define __NR_sched_setaffinity		(__NR_SYSCALL_BASE+241)
+#define __NR_sched_getaffinity		(__NR_SYSCALL_BASE+242)
+#define __NR_io_setup			(__NR_SYSCALL_BASE+243)
+#define __NR_io_destroy			(__NR_SYSCALL_BASE+244)
+#define __NR_io_getevents		(__NR_SYSCALL_BASE+245)
+#define __NR_io_submit			(__NR_SYSCALL_BASE+246)
+#define __NR_io_cancel			(__NR_SYSCALL_BASE+247)
+#define __NR_exit_group			(__NR_SYSCALL_BASE+248)
+#define __NR_lookup_dcookie		(__NR_SYSCALL_BASE+249)
+#define __NR_epoll_create		(__NR_SYSCALL_BASE+250)
+#define __NR_epoll_ctl			(__NR_SYSCALL_BASE+251)
+#define __NR_epoll_wait			(__NR_SYSCALL_BASE+252)
+#define __NR_remap_file_pages		(__NR_SYSCALL_BASE+253)
+					/* 254 for set_thread_area */
+					/* 255 for get_thread_area */
+#define __NR_set_tid_address		(__NR_SYSCALL_BASE+256)
+#define __NR_timer_create		(__NR_SYSCALL_BASE+257)
+#define __NR_timer_settime		(__NR_SYSCALL_BASE+258)
+#define __NR_timer_gettime		(__NR_SYSCALL_BASE+259)
+#define __NR_timer_getoverrun		(__NR_SYSCALL_BASE+260)
+#define __NR_timer_delete		(__NR_SYSCALL_BASE+261)
+#define __NR_clock_settime		(__NR_SYSCALL_BASE+262)
+#define __NR_clock_gettime		(__NR_SYSCALL_BASE+263)
+#define __NR_clock_getres		(__NR_SYSCALL_BASE+264)
+#define __NR_clock_nanosleep		(__NR_SYSCALL_BASE+265)
+#define __NR_statfs64			(__NR_SYSCALL_BASE+266)
+#define __NR_fstatfs64			(__NR_SYSCALL_BASE+267)
+#define __NR_tgkill			(__NR_SYSCALL_BASE+268)
+#define __NR_utimes			(__NR_SYSCALL_BASE+269)
+#define __NR_arm_fadvise64_64		(__NR_SYSCALL_BASE+270)
+#define __NR_pciconfig_iobase		(__NR_SYSCALL_BASE+271)
+#define __NR_pciconfig_read		(__NR_SYSCALL_BASE+272)
+#define __NR_pciconfig_write		(__NR_SYSCALL_BASE+273)
+#define __NR_mq_open			(__NR_SYSCALL_BASE+274)
+#define __NR_mq_unlink			(__NR_SYSCALL_BASE+275)
+#define __NR_mq_timedsend		(__NR_SYSCALL_BASE+276)
+#define __NR_mq_timedreceive		(__NR_SYSCALL_BASE+277)
+#define __NR_mq_notify			(__NR_SYSCALL_BASE+278)
+#define __NR_mq_getsetattr		(__NR_SYSCALL_BASE+279)
+#define __NR_waitid			(__NR_SYSCALL_BASE+280)
+#define __NR_socket			(__NR_SYSCALL_BASE+281)
+#define __NR_bind			(__NR_SYSCALL_BASE+282)
+#define __NR_connect			(__NR_SYSCALL_BASE+283)
+#define __NR_listen			(__NR_SYSCALL_BASE+284)
+#define __NR_accept			(__NR_SYSCALL_BASE+285)
+#define __NR_getsockname		(__NR_SYSCALL_BASE+286)
+#define __NR_getpeername		(__NR_SYSCALL_BASE+287)
+#define __NR_socketpair			(__NR_SYSCALL_BASE+288)
+#define __NR_send			(__NR_SYSCALL_BASE+289)
+#define __NR_sendto			(__NR_SYSCALL_BASE+290)
+#define __NR_recv			(__NR_SYSCALL_BASE+291)
+#define __NR_recvfrom			(__NR_SYSCALL_BASE+292)
+#define __NR_shutdown			(__NR_SYSCALL_BASE+293)
+#define __NR_setsockopt			(__NR_SYSCALL_BASE+294)
+#define __NR_getsockopt			(__NR_SYSCALL_BASE+295)
+#define __NR_sendmsg			(__NR_SYSCALL_BASE+296)
+#define __NR_recvmsg			(__NR_SYSCALL_BASE+297)
+#define __NR_semop			(__NR_SYSCALL_BASE+298)
+#define __NR_semget			(__NR_SYSCALL_BASE+299)
+#define __NR_semctl			(__NR_SYSCALL_BASE+300)
+#define __NR_msgsnd			(__NR_SYSCALL_BASE+301)
+#define __NR_msgrcv			(__NR_SYSCALL_BASE+302)
+#define __NR_msgget			(__NR_SYSCALL_BASE+303)
+#define __NR_msgctl			(__NR_SYSCALL_BASE+304)
+#define __NR_shmat			(__NR_SYSCALL_BASE+305)
+#define __NR_shmdt			(__NR_SYSCALL_BASE+306)
+#define __NR_shmget			(__NR_SYSCALL_BASE+307)
+#define __NR_shmctl			(__NR_SYSCALL_BASE+308)
+#define __NR_add_key			(__NR_SYSCALL_BASE+309)
+#define __NR_request_key		(__NR_SYSCALL_BASE+310)
+#define __NR_keyctl			(__NR_SYSCALL_BASE+311)
+#define __NR_semtimedop			(__NR_SYSCALL_BASE+312)
+#define __NR_vserver			(__NR_SYSCALL_BASE+313)
+#define __NR_ioprio_set			(__NR_SYSCALL_BASE+314)
+#define __NR_ioprio_get			(__NR_SYSCALL_BASE+315)
+#define __NR_inotify_init		(__NR_SYSCALL_BASE+316)
+#define __NR_inotify_add_watch		(__NR_SYSCALL_BASE+317)
+#define __NR_inotify_rm_watch		(__NR_SYSCALL_BASE+318)
+#define __NR_mbind			(__NR_SYSCALL_BASE+319)
+#define __NR_get_mempolicy		(__NR_SYSCALL_BASE+320)
+#define __NR_set_mempolicy		(__NR_SYSCALL_BASE+321)
+#define __NR_openat			(__NR_SYSCALL_BASE+322)
+#define __NR_mkdirat			(__NR_SYSCALL_BASE+323)
+#define __NR_mknodat			(__NR_SYSCALL_BASE+324)
+#define __NR_fchownat			(__NR_SYSCALL_BASE+325)
+#define __NR_futimesat			(__NR_SYSCALL_BASE+326)
+#define __NR_fstatat64			(__NR_SYSCALL_BASE+327)
+#define __NR_unlinkat			(__NR_SYSCALL_BASE+328)
+#define __NR_renameat			(__NR_SYSCALL_BASE+329)
+#define __NR_linkat			(__NR_SYSCALL_BASE+330)
+#define __NR_symlinkat			(__NR_SYSCALL_BASE+331)
+#define __NR_readlinkat			(__NR_SYSCALL_BASE+332)
+#define __NR_fchmodat			(__NR_SYSCALL_BASE+333)
+#define __NR_faccessat			(__NR_SYSCALL_BASE+334)
+					/* 335 for pselect6 */
+					/* 336 for ppoll */
+#define __NR_unshare			(__NR_SYSCALL_BASE+337)
+#define __NR_set_robust_list		(__NR_SYSCALL_BASE+338)
+#define __NR_get_robust_list		(__NR_SYSCALL_BASE+339)
+#define __NR_splice			(__NR_SYSCALL_BASE+340)
+#define __NR_arm_sync_file_range	(__NR_SYSCALL_BASE+341)
+#define __NR_tee			(__NR_SYSCALL_BASE+342)
+#define __NR_vmsplice			(__NR_SYSCALL_BASE+343)
+#define __NR_move_pages			(__NR_SYSCALL_BASE+344)
+#define __NR_getcpu			(__NR_SYSCALL_BASE+345)
+					/* 346 for epoll_pwait */
+#define __NR_kexec_load			(__NR_SYSCALL_BASE+347)
+
+/*
+ * The following SWIs are ARM private.
+ */
+#define __ARM_NR_BASE			(__NR_SYSCALL_BASE+0x0f0000)
+#define __ARM_NR_breakpoint		(__ARM_NR_BASE+1)
+#define __ARM_NR_cacheflush		(__ARM_NR_BASE+2)
+#define __ARM_NR_usr26			(__ARM_NR_BASE+3)
+#define __ARM_NR_usr32			(__ARM_NR_BASE+4)
+#define __ARM_NR_set_tls		(__ARM_NR_BASE+5)
+
+/*
+ * The following syscalls are obsolete and no longer available for EABI.
+ */
+#if defined(__ARM_EABI__) && !defined(__KERNEL__)
+#undef __NR_time
+#undef __NR_umount
+#undef __NR_stime
+#undef __NR_alarm
+#undef __NR_utime
+#undef __NR_getrlimit
+#undef __NR_select
+#undef __NR_readdir
+#undef __NR_mmap
+#undef __NR_socketcall
+#undef __NR_syscall
+#undef __NR_ipc
+#endif
+
+#ifdef __KERNEL__
+
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+
+#if !defined(CONFIG_AEABI) || defined(CONFIG_OABI_COMPAT)
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_SYS_SOCKETCALL
+#endif
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_ARM_UNISTD_H */
Index: build_tree/linux/include/asm/user.h
diff -u /dev/null build_tree/linux/include/asm/user.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/user.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,84 @@
+#ifndef _ARM_USER_H
+#define _ARM_USER_H
+
+#include <asm/page.h>
+#include <asm/ptrace.h>
+/* Core file format: The core file is written in such a way that gdb
+   can understand it and provide useful information to the user (under
+   linux we use the 'trad-core' bfd).  There are quite a number of
+   obstacles to being able to view the contents of the floating point
+   registers, and until these are solved you will not be able to view the
+   contents of them.  Actually, you can read in the core file and look at
+   the contents of the user struct to find out what the floating point
+   registers contain.
+   The actual file contents are as follows:
+   UPAGE: 1 page consisting of a user struct that tells gdb what is present
+   in the file.  Directly after this is a copy of the task_struct, which
+   is currently not used by gdb, but it may come in useful at some point.
+   All of the registers are stored as part of the upage.  The upage should
+   always be only one page.
+   DATA: The data area is stored.  We use current->end_text to
+   current->brk to pick up all of the user variables, plus any memory
+   that may have been malloced.  No attempt is made to determine if a page
+   is demand-zero or if a page is totally unused, we just cover the entire
+   range.  All of the addresses are rounded in such a way that an integral
+   number of pages is written.
+   STACK: We need the stack information in order to get a meaningful
+   backtrace.  We need to write the data from (esp) to
+   current->start_stack, so we round each of these off in order to be able
+   to write an integer number of pages.
+   The minimum core file size is 3 pages, or 12288 bytes.
+*/
+
+struct user_fp {
+	struct fp_reg {
+		unsigned int sign1:1;
+		unsigned int unused:15;
+		unsigned int sign2:1;
+		unsigned int exponent:14;
+		unsigned int j:1;
+		unsigned int mantissa1:31;
+		unsigned int mantissa0:32;
+	} fpregs[8];
+	unsigned int fpsr:32;
+	unsigned int fpcr:32;
+	unsigned char ftype[8];
+	unsigned int init_flag;
+};
+
+/* When the kernel dumps core, it starts by dumping the user struct -
+   this will be used by gdb to figure out where the data and stack segments
+   are within the file, and what virtual addresses to use. */
+struct user{
+/* We start with the registers, to mimic the way that "memory" is returned
+   from the ptrace(3,...) function.  */
+  struct pt_regs regs;		/* Where the registers are actually stored */
+/* ptrace does not yet supply these.  Someday.... */
+  int u_fpvalid;		/* True if math co-processor being used. */
+                                /* for this mess. Not yet used. */
+/* The rest of this junk is to help gdb figure out what goes where */
+  unsigned long int u_tsize;	/* Text segment size (pages). */
+  unsigned long int u_dsize;	/* Data segment size (pages). */
+  unsigned long int u_ssize;	/* Stack segment size (pages). */
+  unsigned long start_code;     /* Starting virtual address of text. */
+  unsigned long start_stack;	/* Starting virtual address of stack area.
+				   This is actually the bottom of the stack,
+				   the top of the stack is always found in the
+				   esp register.  */
+  long int signal;     		/* Signal that caused the core dump. */
+  int reserved;			/* No longer used */
+  struct pt_regs * u_ar0;	/* Used by gdb to help find the values for */
+				/* the registers. */
+  unsigned long magic;		/* To uniquely identify a core file */
+  char u_comm[32];		/* User command that was responsible */
+  int u_debugreg[8];
+  struct user_fp u_fp;		/* FP state */
+  struct user_fp_struct * u_fp0;/* Used by gdb to help find the values for */
+  				/* the FP registers. */
+};
+#define NBPG PAGE_SIZE
+#define UPAGES 1
+#define HOST_TEXT_START_ADDR (u.start_code)
+#define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
+
+#endif /* _ARM_USER_H */
Index: build_tree/linux/include/asm/vfp.h
diff -u /dev/null build_tree/linux/include/asm/vfp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/vfp.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,78 @@
+/*
+ * linux/include/asm-arm/vfp.h
+ *
+ * VFP register definitions.
+ * First, the standard VFP set.
+ */
+
+#define FPSID			cr0
+#define FPSCR			cr1
+#define FPEXC			cr8
+
+/* FPSID bits */
+#define FPSID_IMPLEMENTER_BIT	(24)
+#define FPSID_IMPLEMENTER_MASK	(0xff << FPSID_IMPLEMENTER_BIT)
+#define FPSID_SOFTWARE		(1<<23)
+#define FPSID_FORMAT_BIT	(21)
+#define FPSID_FORMAT_MASK	(0x3  << FPSID_FORMAT_BIT)
+#define FPSID_NODOUBLE		(1<<20)
+#define FPSID_ARCH_BIT		(16)
+#define FPSID_ARCH_MASK		(0xF  << FPSID_ARCH_BIT)
+#define FPSID_PART_BIT		(8)
+#define FPSID_PART_MASK		(0xFF << FPSID_PART_BIT)
+#define FPSID_VARIANT_BIT	(4)
+#define FPSID_VARIANT_MASK	(0xF  << FPSID_VARIANT_BIT)
+#define FPSID_REV_BIT		(0)
+#define FPSID_REV_MASK		(0xF  << FPSID_REV_BIT)
+
+/* FPEXC bits */
+#define FPEXC_EXCEPTION		(1<<31)
+#define FPEXC_ENABLE		(1<<30)
+
+/* FPSCR bits */
+#define FPSCR_DEFAULT_NAN	(1<<25)
+#define FPSCR_FLUSHTOZERO	(1<<24)
+#define FPSCR_ROUND_NEAREST	(0<<22)
+#define FPSCR_ROUND_PLUSINF	(1<<22)
+#define FPSCR_ROUND_MINUSINF	(2<<22)
+#define FPSCR_ROUND_TOZERO	(3<<22)
+#define FPSCR_RMODE_BIT		(22)
+#define FPSCR_RMODE_MASK	(3 << FPSCR_RMODE_BIT)
+#define FPSCR_STRIDE_BIT	(20)
+#define FPSCR_STRIDE_MASK	(3 << FPSCR_STRIDE_BIT)
+#define FPSCR_LENGTH_BIT	(16)
+#define FPSCR_LENGTH_MASK	(7 << FPSCR_LENGTH_BIT)
+#define FPSCR_IOE		(1<<8)
+#define FPSCR_DZE		(1<<9)
+#define FPSCR_OFE		(1<<10)
+#define FPSCR_UFE		(1<<11)
+#define FPSCR_IXE		(1<<12)
+#define FPSCR_IDE		(1<<15)
+#define FPSCR_IOC		(1<<0)
+#define FPSCR_DZC		(1<<1)
+#define FPSCR_OFC		(1<<2)
+#define FPSCR_UFC		(1<<3)
+#define FPSCR_IXC		(1<<4)
+#define FPSCR_IDC		(1<<7)
+
+/*
+ * VFP9-S specific.
+ */
+#define FPINST			cr9
+#define FPINST2			cr10
+
+/* FPEXC bits */
+#define FPEXC_FPV2		(1<<28)
+#define FPEXC_LENGTH_BIT	(8)
+#define FPEXC_LENGTH_MASK	(7 << FPEXC_LENGTH_BIT)
+#define FPEXC_INV		(1 << 7)
+#define FPEXC_UFC		(1 << 3)
+#define FPEXC_OFC		(1 << 2)
+#define FPEXC_IOC		(1 << 0)
+
+/* Bit patterns for decoding the packaged operation descriptors */
+#define VFPOPDESC_LENGTH_BIT	(9)
+#define VFPOPDESC_LENGTH_MASK	(0x07 << VFPOPDESC_LENGTH_BIT)
+#define VFPOPDESC_UNUSED_BIT	(24)
+#define VFPOPDESC_UNUSED_MASK	(0xFF << VFPOPDESC_UNUSED_BIT)
+#define VFPOPDESC_OPDESC_MASK	(~(VFPOPDESC_LENGTH_MASK | VFPOPDESC_UNUSED_MASK))
Index: build_tree/linux/include/asm/vfpmacros.h
diff -u /dev/null build_tree/linux/include/asm/vfpmacros.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/vfpmacros.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,33 @@
+/*
+ * linux/include/asm-arm/vfpmacros.h
+ *
+ * Assembler-only file containing VFP macros and register definitions.
+ */
+#include "vfp.h"
+
+@ Macros to allow building with old toolkits (with no VFP support)
+	.macro	VFPFMRX, rd, sysreg, cond
+	MRC\cond	p10, 7, \rd, \sysreg, cr0, 0	@ FMRX	\rd, \sysreg
+	.endm
+
+	.macro	VFPFMXR, sysreg, rd, cond
+	MCR\cond	p10, 7, \rd, \sysreg, cr0, 0	@ FMXR	\sysreg, \rd
+	.endm
+
+	@ read all the working registers back into the VFP
+	.macro	VFPFLDMIA, base
+#if __LINUX_ARM_ARCH__ < 6
+	LDC	p11, cr0, [\base],#33*4		    @ FLDMIAX \base!, {d0-d15}
+#else
+	LDC	p11, cr0, [\base],#32*4		    @ FLDMIAD \base!, {d0-d15}
+#endif
+	.endm
+
+	@ write all the working registers out of the VFP
+	.macro	VFPFSTMIA, base
+#if __LINUX_ARM_ARCH__ < 6
+	STC	p11, cr0, [\base],#33*4		    @ FSTMIAX \base!, {d0-d15}
+#else
+	STC	p11, cr0, [\base],#32*4		    @ FSTMIAD \base!, {d0-d15}
+#endif
+	.endm
Index: build_tree/linux/include/asm/vga.h
diff -u /dev/null build_tree/linux/include/asm/vga.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/vga.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,12 @@
+#ifndef ASMARM_VGA_H
+#define ASMARM_VGA_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#define VGA_MAP_MEM(x,s)	(PCIMEM_BASE + (x))
+
+#define vga_readb(x)	(*((volatile unsigned char *)x))
+#define vga_writeb(x,y)	(*((volatile unsigned char *)y) = (x))
+
+#endif
Index: build_tree/linux/include/asm/xor.h
diff -u /dev/null build_tree/linux/include/asm/xor.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/xor.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,141 @@
+/*
+ *  linux/include/asm-arm/xor.h
+ *
+ *  Copyright (C) 2001 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm-generic/xor.h>
+
+#define __XOR(a1, a2) a1 ^= a2
+
+#define GET_BLOCK_2(dst) \
+	__asm__("ldmia	%0, {%1, %2}" \
+		: "=r" (dst), "=r" (a1), "=r" (a2) \
+		: "0" (dst))
+
+#define GET_BLOCK_4(dst) \
+	__asm__("ldmia	%0, {%1, %2, %3, %4}" \
+		: "=r" (dst), "=r" (a1), "=r" (a2), "=r" (a3), "=r" (a4) \
+		: "0" (dst))
+
+#define XOR_BLOCK_2(src) \
+	__asm__("ldmia	%0!, {%1, %2}" \
+		: "=r" (src), "=r" (b1), "=r" (b2) \
+		: "0" (src)); \
+	__XOR(a1, b1); __XOR(a2, b2);
+
+#define XOR_BLOCK_4(src) \
+	__asm__("ldmia	%0!, {%1, %2, %3, %4}" \
+		: "=r" (src), "=r" (b1), "=r" (b2), "=r" (b3), "=r" (b4) \
+		: "0" (src)); \
+	__XOR(a1, b1); __XOR(a2, b2); __XOR(a3, b3); __XOR(a4, b4)
+
+#define PUT_BLOCK_2(dst) \
+	__asm__ __volatile__("stmia	%0!, {%2, %3}" \
+		: "=r" (dst) \
+		: "0" (dst), "r" (a1), "r" (a2))
+
+#define PUT_BLOCK_4(dst) \
+	__asm__ __volatile__("stmia	%0!, {%2, %3, %4, %5}" \
+		: "=r" (dst) \
+		: "0" (dst), "r" (a1), "r" (a2), "r" (a3), "r" (a4))
+
+static void
+xor_arm4regs_2(unsigned long bytes, unsigned long *p1, unsigned long *p2)
+{
+	unsigned int lines = bytes / sizeof(unsigned long) / 4;
+	register unsigned int a1 __asm__("r4");
+	register unsigned int a2 __asm__("r5");
+	register unsigned int a3 __asm__("r6");
+	register unsigned int a4 __asm__("r7");
+	register unsigned int b1 __asm__("r8");
+	register unsigned int b2 __asm__("r9");
+	register unsigned int b3 __asm__("ip");
+	register unsigned int b4 __asm__("lr");
+
+	do {
+		GET_BLOCK_4(p1);
+		XOR_BLOCK_4(p2);
+		PUT_BLOCK_4(p1);
+	} while (--lines);
+}
+
+static void
+xor_arm4regs_3(unsigned long bytes, unsigned long *p1, unsigned long *p2,
+		unsigned long *p3)
+{
+	unsigned int lines = bytes / sizeof(unsigned long) / 4;
+	register unsigned int a1 __asm__("r4");
+	register unsigned int a2 __asm__("r5");
+	register unsigned int a3 __asm__("r6");
+	register unsigned int a4 __asm__("r7");
+	register unsigned int b1 __asm__("r8");
+	register unsigned int b2 __asm__("r9");
+	register unsigned int b3 __asm__("ip");
+	register unsigned int b4 __asm__("lr");
+
+	do {
+		GET_BLOCK_4(p1);
+		XOR_BLOCK_4(p2);
+		XOR_BLOCK_4(p3);
+		PUT_BLOCK_4(p1);
+	} while (--lines);
+}
+
+static void
+xor_arm4regs_4(unsigned long bytes, unsigned long *p1, unsigned long *p2,
+		unsigned long *p3, unsigned long *p4)
+{
+	unsigned int lines = bytes / sizeof(unsigned long) / 2;
+	register unsigned int a1 __asm__("r8");
+	register unsigned int a2 __asm__("r9");
+	register unsigned int b1 __asm__("ip");
+	register unsigned int b2 __asm__("lr");
+
+	do {
+		GET_BLOCK_2(p1);
+		XOR_BLOCK_2(p2);
+		XOR_BLOCK_2(p3);
+		XOR_BLOCK_2(p4);
+		PUT_BLOCK_2(p1);
+	} while (--lines);
+}
+
+static void
+xor_arm4regs_5(unsigned long bytes, unsigned long *p1, unsigned long *p2,
+		unsigned long *p3, unsigned long *p4, unsigned long *p5)
+{
+	unsigned int lines = bytes / sizeof(unsigned long) / 2;
+	register unsigned int a1 __asm__("r8");
+	register unsigned int a2 __asm__("r9");
+	register unsigned int b1 __asm__("ip");
+	register unsigned int b2 __asm__("lr");
+
+	do {
+		GET_BLOCK_2(p1);
+		XOR_BLOCK_2(p2);
+		XOR_BLOCK_2(p3);
+		XOR_BLOCK_2(p4);
+		XOR_BLOCK_2(p5);
+		PUT_BLOCK_2(p1);
+	} while (--lines);
+}
+
+static struct xor_block_template xor_block_arm4regs = {
+	.name	= "arm4regs",
+	.do_2	= xor_arm4regs_2,
+	.do_3	= xor_arm4regs_3,
+	.do_4	= xor_arm4regs_4,
+	.do_5	= xor_arm4regs_5,
+};
+
+#undef XOR_TRY_TEMPLATES
+#define XOR_TRY_TEMPLATES			\
+	do {					\
+		xor_speed(&xor_block_arm4regs);	\
+		xor_speed(&xor_block_8regs);	\
+		xor_speed(&xor_block_32regs);	\
+	} while (0)
Index: build_tree/linux/include/asm/arch/akita.h
diff -u /dev/null build_tree/linux/include/asm/arch/akita.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/akita.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * Hardware specific definitions for SL-C1000 (Akita)
+ *
+ * Copyright (c) 2005 Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/* Akita IO Expander GPIOs */
+
+#define AKITA_IOEXP_RESERVED_7      (1 << 7)
+#define AKITA_IOEXP_IR_ON           (1 << 6)
+#define AKITA_IOEXP_AKIN_PULLUP     (1 << 5)
+#define AKITA_IOEXP_BACKLIGHT_CONT  (1 << 4)
+#define AKITA_IOEXP_BACKLIGHT_ON    (1 << 3)
+#define AKITA_IOEXP_MIC_BIAS        (1 << 2)
+#define AKITA_IOEXP_RESERVED_1      (1 << 1)
+#define AKITA_IOEXP_RESERVED_0      (1 << 0)
+
+/* Direction Bitfield  0=output  1=input */
+#define AKITA_IOEXP_IO_DIR	0
+/* Default Values */
+#define AKITA_IOEXP_IO_OUT	(AKITA_IOEXP_IR_ON | AKITA_IOEXP_AKIN_PULLUP)
+
+extern struct platform_device akitaioexp_device;
+
+void akita_set_ioexp(struct device *dev, unsigned char bitmask);
+void akita_reset_ioexp(struct device *dev, unsigned char bitmask);
+
Index: build_tree/linux/include/asm/arch/audio.h
diff -u /dev/null build_tree/linux/include/asm/arch/audio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/audio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+#ifndef __ASM_ARCH_AUDIO_H__
+#define __ASM_ARCH_AUDIO_H__
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+
+typedef struct {
+	int (*startup)(struct snd_pcm_substream *, void *);
+	void (*shutdown)(struct snd_pcm_substream *, void *);
+	void (*suspend)(void *);
+	void (*resume)(void *);
+	void *priv;
+} pxa2xx_audio_ops_t;
+
+#endif
Index: build_tree/linux/include/asm/arch/bitfield.h
diff -u /dev/null build_tree/linux/include/asm/arch/bitfield.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/bitfield.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,113 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+                	(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+                	((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
Index: build_tree/linux/include/asm/arch/corgi.h
diff -u /dev/null build_tree/linux/include/asm/arch/corgi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/corgi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,110 @@
+/*
+ * Hardware specific definitions for SL-C7xx series of PDAs
+ *
+ * Copyright (c) 2004-2005 Richard Purdie
+ *
+ * Based on Sharp's 2.4 kernel patches
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ASM_ARCH_CORGI_H
+#define __ASM_ARCH_CORGI_H  1
+
+
+/*
+ * Corgi (Non Standard) GPIO Definitions
+ */
+#define CORGI_GPIO_KEY_INT			(0)	/* Keyboard Interrupt */
+#define CORGI_GPIO_AC_IN			(1) /* Charger Detection */
+#define CORGI_GPIO_WAKEUP			(3) /* System wakeup notification? */
+#define CORGI_GPIO_AK_INT			(4)	/* Headphone Jack Control Interrupt */
+#define CORGI_GPIO_TP_INT			(5)	/* Touch Panel Interrupt */
+#define CORGI_GPIO_nSD_WP			(7) /* SD Write Protect? */
+#define CORGI_GPIO_nSD_DETECT		(9) /* MMC/SD Card Detect */
+#define CORGI_GPIO_nSD_INT			(10) /* SD Interrupt for SDIO? */
+#define CORGI_GPIO_MAIN_BAT_LOW		(11) /* Main Battery Low Notification */
+#define CORGI_GPIO_BAT_COVER		(11) /* Battery Cover Detect */
+#define CORGI_GPIO_LED_ORANGE		(13) /* Orange LED Control */
+#define CORGI_GPIO_CF_CD			(14) /* Compact Flash Card Detect */
+#define CORGI_GPIO_CHRG_FULL		(16) /* Charging Complete Notification */
+#define CORGI_GPIO_CF_IRQ			(17) /* Compact Flash Interrupt */
+#define CORGI_GPIO_LCDCON_CS		(19) /* LCD Control Chip Select */
+#define CORGI_GPIO_MAX1111_CS		(20) /* MAX1111 Chip Select */
+#define CORGI_GPIO_ADC_TEMP_ON		(21) /* Select battery voltage or temperature */
+#define CORGI_GPIO_IR_ON			(22) /* Enable IR Transciever */
+#define CORGI_GPIO_ADS7846_CS		(24) /* ADS7846 Chip Select */
+#define CORGI_GPIO_SD_PWR			(33) /* MMC/SD Power */
+#define CORGI_GPIO_CHRG_ON			(38) /* Enable battery Charging */
+#define CORGI_GPIO_DISCHARGE_ON		(42) /* Enable battery Discharge */
+#define CORGI_GPIO_CHRG_UKN			(43) /* Unknown Charging (Bypass Control?) */
+#define CORGI_GPIO_HSYNC			(44) /* LCD HSync Pulse */
+#define CORGI_GPIO_USB_PULLUP		(45) /* USB show presence to host */
+
+
+/*
+ * Corgi Keyboard Definitions
+ */
+#define CORGI_KEY_STROBE_NUM		(12)
+#define CORGI_KEY_SENSE_NUM			(8)
+#define CORGI_GPIO_ALL_STROBE_BIT	(0x00003ffc)
+#define CORGI_GPIO_HIGH_SENSE_BIT	(0xfc000000)
+#define CORGI_GPIO_HIGH_SENSE_RSHIFT	(26)
+#define CORGI_GPIO_LOW_SENSE_BIT	(0x00000003)
+#define CORGI_GPIO_LOW_SENSE_LSHIFT	(6)
+#define CORGI_GPIO_STROBE_BIT(a)	GPIO_bit(66+(a))
+#define CORGI_GPIO_SENSE_BIT(a)		GPIO_bit(58+(a))
+#define CORGI_GAFR_ALL_STROBE_BIT	(0x0ffffff0)
+#define CORGI_GAFR_HIGH_SENSE_BIT	(0xfff00000)
+#define CORGI_GAFR_LOW_SENSE_BIT	(0x0000000f)
+#define CORGI_GPIO_KEY_SENSE(a)		(58+(a))
+#define CORGI_GPIO_KEY_STROBE(a)	(66+(a))
+
+
+/*
+ * Corgi Interrupts
+ */
+#define CORGI_IRQ_GPIO_KEY_INT		IRQ_GPIO(0)
+#define CORGI_IRQ_GPIO_AC_IN		IRQ_GPIO(1)
+#define CORGI_IRQ_GPIO_WAKEUP		IRQ_GPIO(3)
+#define CORGI_IRQ_GPIO_AK_INT		IRQ_GPIO(4)
+#define CORGI_IRQ_GPIO_TP_INT		IRQ_GPIO(5)
+#define CORGI_IRQ_GPIO_nSD_DETECT	IRQ_GPIO(9)
+#define CORGI_IRQ_GPIO_nSD_INT		IRQ_GPIO(10)
+#define CORGI_IRQ_GPIO_MAIN_BAT_LOW	IRQ_GPIO(11)
+#define CORGI_IRQ_GPIO_CF_CD		IRQ_GPIO(14)
+#define CORGI_IRQ_GPIO_CHRG_FULL	IRQ_GPIO(16)	/* Battery fully charged */
+#define CORGI_IRQ_GPIO_CF_IRQ		IRQ_GPIO(17)
+#define CORGI_IRQ_GPIO_KEY_SENSE(a)	IRQ_GPIO(58+(a))	/* Keyboard Sense lines */
+
+
+/*
+ * Corgi SCOOP GPIOs and Config
+ */
+#define CORGI_SCP_LED_GREEN		SCOOP_GPCR_PA11
+#define CORGI_SCP_SWA			SCOOP_GPCR_PA12  /* Hinge Switch A */
+#define CORGI_SCP_SWB			SCOOP_GPCR_PA13  /* Hinge Switch B */
+#define CORGI_SCP_MUTE_L		SCOOP_GPCR_PA14
+#define CORGI_SCP_MUTE_R		SCOOP_GPCR_PA15
+#define CORGI_SCP_AKIN_PULLUP	SCOOP_GPCR_PA16
+#define CORGI_SCP_APM_ON		SCOOP_GPCR_PA17
+#define CORGI_SCP_BACKLIGHT_CONT	SCOOP_GPCR_PA18
+#define CORGI_SCP_MIC_BIAS		SCOOP_GPCR_PA19
+
+#define CORGI_SCOOP_IO_DIR	( CORGI_SCP_LED_GREEN | CORGI_SCP_MUTE_L | CORGI_SCP_MUTE_R | \
+			CORGI_SCP_AKIN_PULLUP | CORGI_SCP_APM_ON | CORGI_SCP_BACKLIGHT_CONT | \
+			CORGI_SCP_MIC_BIAS )
+#define CORGI_SCOOP_IO_OUT	( CORGI_SCP_MUTE_L | CORGI_SCP_MUTE_R )
+
+
+/*
+ * Shared data structures
+ */
+extern struct platform_device corgiscoop_device;
+extern struct platform_device corgissp_device;
+extern struct platform_device corgifb_device;
+
+#endif /* __ASM_ARCH_CORGI_H  */
+
Index: build_tree/linux/include/asm/arch/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,25 @@
+/* linux/include/asm-arm/arch-pxa/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include "hardware.h"
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x40000000		@ physical
+		movne	\rx, #io_p2v(0x40000000)	@ virtual
+		orr	\rx, \rx, #0x00100000
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,64 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/dma.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/*
+ * Descriptor structure for PXA's DMA engine
+ * Note: this structure must always be aligned to a 16-byte boundary.
+ */
+
+typedef struct pxa_dma_desc {
+	volatile u32 ddadr;	/* Points to the next descriptor + flags */
+	volatile u32 dsadr;	/* DSADR value for the current transfer */
+	volatile u32 dtadr;	/* DTADR value for the current transfer */
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+} pxa_dma_desc;
+
+typedef enum {
+	DMA_PRIO_HIGH = 0,
+	DMA_PRIO_MEDIUM = 1,
+	DMA_PRIO_LOW = 2
+} pxa_dma_prio;
+
+#if defined(CONFIG_PXA27x)
+
+#define PXA_DMA_CHANNELS	32
+
+#define pxa_for_each_dma_prio(ch, prio)					\
+for (									\
+	ch = prio * 4;							\
+	ch != (4 << prio) + 16;						\
+	ch = (ch + 1 == (4 << prio)) ? (prio * 4 + 16) : (ch + 1)	\
+)
+
+#elif defined(CONFIG_PXA25x)
+
+#define PXA_DMA_CHANNELS	16
+
+#define pxa_for_each_dma_prio(ch, prio)					\
+	for (ch = prio * 4; ch != (4 << prio); ch++)
+
+#endif
+
+/*
+ * DMA registration
+ */
+
+int pxa_request_dma (char *name,
+			 pxa_dma_prio prio,
+			 void (*irq_handler)(int, void *),
+			 void *data);
+
+void pxa_free_dma (int dma_ch);
+
+#endif /* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-pxa/entry-macro.S
+ *
+ * Low-level IRQ helper macros for PXA-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/arch/irqs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+#ifdef CONFIG_PXA27x
+		mrc	p6, 0, \irqstat, c0, c0, 0		@ ICIP
+		mrc	p6, 0, \irqnr, c1, c0, 0		@ ICMR
+#else
+		mov	\base, #io_p2v(0x40000000)	@ IIR Ctl = 0x40d00000
+		add	\base, \base, #0x00d00000
+		ldr	\irqstat, [\base, #0]		@ ICIP
+		ldr	\irqnr, [\base, #4]		@ ICMR
+#endif
+		ands	\irqnr, \irqstat, \irqnr
+		beq	1001f
+		rsb	\irqstat, \irqnr, #0
+		and	\irqstat, \irqstat, \irqnr
+		clz	\irqnr, \irqstat
+		rsb	\irqnr, \irqnr, #(31 - PXA_IRQ_SKIP)
+1001:
+		.endm
Index: build_tree/linux/include/asm/arch/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,80 @@
+/*
+ * linux/include/asm-arm/arch-pxa/gpio.h
+ *
+ * PXA GPIO wrappers for arch-neutral GPIO calls
+ *
+ * Written by Philipp Zabel <philipp.zabel@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __ASM_ARCH_PXA_GPIO_H
+#define __ASM_ARCH_PXA_GPIO_H
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+	return;
+}
+
+static inline int gpio_direction_input(unsigned gpio)
+{
+	return pxa_gpio_mode(gpio | GPIO_IN);
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	return pxa_gpio_mode(gpio | GPIO_OUT | (value ? 0 : GPIO_DFLT_LOW));
+}
+
+static inline int __gpio_get_value(unsigned gpio)
+{
+	return GPLR(gpio) & GPIO_bit(gpio);
+}
+
+#define gpio_get_value(gpio)			\
+	(__builtin_constant_p(gpio) ?		\
+	 __gpio_get_value(gpio) :		\
+	 pxa_gpio_get_value(gpio))
+
+static inline void __gpio_set_value(unsigned gpio, int value)
+{
+	if (value)
+		GPSR(gpio) = GPIO_bit(gpio);
+	else
+		GPCR(gpio) = GPIO_bit(gpio);
+}
+
+#define gpio_set_value(gpio,value)		\
+	(__builtin_constant_p(gpio) ?		\
+	 __gpio_set_value(gpio, value) :	\
+	 pxa_gpio_set_value(gpio, value))
+
+#include <asm-generic/gpio.h>			/* cansleep wrappers */
+
+#define gpio_to_irq(gpio)	IRQ_GPIO(gpio)
+#define irq_to_gpio(irq)	IRQ_TO_GPIO(irq)
+
+
+#endif
Index: build_tree/linux/include/asm/arch/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,93 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/hardware.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/*
+ * We requires absolute addresses.
+ */
+#define PCIO_BASE		0
+
+/*
+ * Workarounds for at least 2 errata so far require this.
+ * The mapping is set in mach-pxa/generic.c.
+ */
+#define UNCACHED_PHYS_0		0xff000000
+#define UNCACHED_ADDR		UNCACHED_PHYS_0
+
+/*
+ * Intel PXA2xx internal register mapping:
+ *
+ * 0x40000000 - 0x41ffffff <--> 0xf2000000 - 0xf3ffffff
+ * 0x44000000 - 0x45ffffff <--> 0xf4000000 - 0xf5ffffff
+ * 0x48000000 - 0x49ffffff <--> 0xf6000000 - 0xf7ffffff
+ * 0x4c000000 - 0x4dffffff <--> 0xf8000000 - 0xf9ffffff
+ * 0x50000000 - 0x51ffffff <--> 0xfa000000 - 0xfbffffff
+ * 0x54000000 - 0x55ffffff <--> 0xfc000000 - 0xfdffffff
+ * 0x58000000 - 0x59ffffff <--> 0xfe000000 - 0xffffffff
+ *
+ * Note that not all PXA2xx chips implement all those addresses, and the
+ * kernel only maps the minimum needed range of this mapping.
+ */
+#define io_p2v(x) (0xf2000000 + ((x) & 0x01ffffff) + (((x) & 0x1c000000) >> 1))
+#define io_v2p(x) (0x3c000000 + ((x) & 0x01ffffff) + (((x) & 0x0e000000) << 1))
+
+#ifndef __ASSEMBLY__
+
+# define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+
+/* With indexed regs we don't want to feed the index through io_p2v()
+   especially if it is a variable, otherwise horrible code will result. */
+# define __REG2(x,y)	\
+	(*(volatile u32 *)((u32)&__REG(x) + (y)))
+
+# define __PREG(x)	(io_v2p((u32)&(x)))
+
+#else
+
+# define __REG(x)	io_p2v(x)
+# define __PREG(x)	io_v2p(x)
+
+#endif
+
+#ifndef __ASSEMBLY__
+
+/*
+ * Handy routine to set GPIO alternate functions
+ */
+extern int pxa_gpio_mode( int gpio_mode );
+
+/*
+ * Return GPIO level, nonzero means high, zero is low
+ */
+extern int pxa_gpio_get_value(unsigned gpio);
+
+/*
+ * Set output GPIO level
+ */
+extern void pxa_gpio_set_value(unsigned gpio, int value);
+
+/*
+ * Routine to enable or disable CKEN
+ */
+extern void pxa_set_cken(int clock, int enable);
+
+/*
+ * return current memory and LCD clock frequency in units of 10kHz
+ */
+extern unsigned int get_memclk_frequency_10khz(void);
+extern unsigned int get_lcdclk_frequency_10khz(void);
+
+#endif
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch/i2c.h
diff -u /dev/null build_tree/linux/include/asm/arch/i2c.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/i2c.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,70 @@
+/*
+ *  i2c_pxa.h
+ *
+ *  Copyright (C) 2002 Intrinsyc Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+#ifndef _I2C_PXA_H_
+#define _I2C_PXA_H_
+
+#if 0
+#define DEF_TIMEOUT             3
+#else
+/* need a longer timeout if we're dealing with the fact we may well be
+ * looking at a multi-master environment
+*/
+#define DEF_TIMEOUT             32
+#endif
+
+#define BUS_ERROR               (-EREMOTEIO)
+#define XFER_NAKED              (-ECONNREFUSED)
+#define I2C_RETRY               (-2000) /* an error has occurred retry transmit */
+
+/* ICR initialize bit values
+*
+*  15. FM       0 (100 Khz operation)
+*  14. UR       0 (No unit reset)
+*  13. SADIE    0 (Disables the unit from interrupting on slave addresses
+*                                       matching its slave address)
+*  12. ALDIE    0 (Disables the unit from interrupt when it loses arbitration
+*                                       in master mode)
+*  11. SSDIE    0 (Disables interrupts from a slave stop detected, in slave mode)
+*  10. BEIE     1 (Enable interrupts from detected bus errors, no ACK sent)
+*  9.  IRFIE    1 (Enable interrupts from full buffer received)
+*  8.  ITEIE    1 (Enables the I2C unit to interrupt when transmit buffer empty)
+*  7.  GCD      1 (Disables i2c unit response to general call messages as a slave)
+*  6.  IUE      0 (Disable unit until we change settings)
+*  5.  SCLE     1 (Enables the i2c clock output for master mode (drives SCL)
+*  4.  MA       0 (Only send stop with the ICR stop bit)
+*  3.  TB       0 (We are not transmitting a byte initially)
+*  2.  ACKNAK   0 (Send an ACK after the unit receives a byte)
+*  1.  STOP     0 (Do not send a STOP)
+*  0.  START    0 (Do not send a START)
+*
+*/
+#define I2C_ICR_INIT	(ICR_BEIE | ICR_IRFIE | ICR_ITEIE | ICR_GCD | ICR_SCLE)
+
+/* I2C status register init values
+ *
+ * 10. BED      1 (Clear bus error detected)
+ * 9.  SAD      1 (Clear slave address detected)
+ * 7.  IRF      1 (Clear IDBR Receive Full)
+ * 6.  ITE      1 (Clear IDBR Transmit Empty)
+ * 5.  ALD      1 (Clear Arbitration Loss Detected)
+ * 4.  SSD      1 (Clear Slave Stop Detected)
+ */
+#define I2C_ISR_INIT	0x7FF  /* status register init */
+
+struct i2c_slave_client;
+
+struct i2c_pxa_platform_data {
+	unsigned int		slave_addr;
+	struct i2c_slave_client	*slave;
+};
+
+extern void pxa_set_i2c_info(struct i2c_pxa_platform_data *info);
+#endif
Index: build_tree/linux/include/asm/arch/idp.h
diff -u /dev/null build_tree/linux/include/asm/arch/idp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/idp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,199 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/idp.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) 2001 Cliff Brake, Accelent Systems Inc.
+ *
+ * 2001-09-13: Cliff Brake <cbrake@accelent.com>
+ *             Initial code
+ *
+ * 2005-02-15: Cliff Brake <cliff.brake@gmail.com>
+ *             <http://www.vibren.com> <http://bec-systems.com>
+ *             Changes for 2.6 kernel.
+ */
+
+
+/*
+ * Note: this file must be safe to include in assembly files
+ *
+ * Support for the Vibren PXA255 IDP requires rev04 or later
+ * IDP hardware.
+ */
+
+
+#define IDP_FLASH_PHYS		(PXA_CS0_PHYS)
+#define IDP_ALT_FLASH_PHYS	(PXA_CS1_PHYS)
+#define IDP_MEDIAQ_PHYS		(PXA_CS3_PHYS)
+#define IDP_IDE_PHYS		(PXA_CS5_PHYS + 0x03000000)
+#define IDP_ETH_PHYS		(PXA_CS5_PHYS + 0x03400000)
+#define IDP_COREVOLT_PHYS	(PXA_CS5_PHYS + 0x03800000)
+#define IDP_CPLD_PHYS		(PXA_CS5_PHYS + 0x03C00000)
+
+
+/*
+ * virtual memory map
+ */
+
+#define IDP_COREVOLT_VIRT	(0xf0000000)
+#define IDP_COREVOLT_SIZE	(1*1024*1024)
+
+#define IDP_CPLD_VIRT		(IDP_COREVOLT_VIRT + IDP_COREVOLT_SIZE)
+#define IDP_CPLD_SIZE		(1*1024*1024)
+
+#if (IDP_CPLD_VIRT + IDP_CPLD_SIZE) > 0xfc000000
+#error Your custom IO space is getting a bit large !!
+#endif
+
+#define CPLD_P2V(x)		((x) - IDP_CPLD_PHYS + IDP_CPLD_VIRT)
+#define CPLD_V2P(x)		((x) - IDP_CPLD_VIRT + IDP_CPLD_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __CPLD_REG(x)		(*((volatile unsigned long *)CPLD_P2V(x)))
+#else
+#  define __CPLD_REG(x)		CPLD_P2V(x)
+#endif
+
+/* board level registers in the CPLD: (offsets from CPLD_VIRT) */
+
+#define _IDP_CPLD_REV			(IDP_CPLD_PHYS + 0x00)
+#define _IDP_CPLD_PERIPH_PWR		(IDP_CPLD_PHYS + 0x04)
+#define _IDP_CPLD_LED_CONTROL		(IDP_CPLD_PHYS + 0x08)
+#define _IDP_CPLD_KB_COL_HIGH		(IDP_CPLD_PHYS + 0x0C)
+#define _IDP_CPLD_KB_COL_LOW		(IDP_CPLD_PHYS + 0x10)
+#define _IDP_CPLD_PCCARD_EN		(IDP_CPLD_PHYS + 0x14)
+#define _IDP_CPLD_GPIOH_DIR		(IDP_CPLD_PHYS + 0x18)
+#define _IDP_CPLD_GPIOH_VALUE		(IDP_CPLD_PHYS + 0x1C)
+#define _IDP_CPLD_GPIOL_DIR		(IDP_CPLD_PHYS + 0x20)
+#define _IDP_CPLD_GPIOL_VALUE		(IDP_CPLD_PHYS + 0x24)
+#define _IDP_CPLD_PCCARD_PWR		(IDP_CPLD_PHYS + 0x28)
+#define _IDP_CPLD_MISC_CTRL		(IDP_CPLD_PHYS + 0x2C)
+#define _IDP_CPLD_LCD			(IDP_CPLD_PHYS + 0x30)
+#define _IDP_CPLD_FLASH_WE		(IDP_CPLD_PHYS + 0x34)
+
+#define _IDP_CPLD_KB_ROW		(IDP_CPLD_PHYS + 0x50)
+#define _IDP_CPLD_PCCARD0_STATUS	(IDP_CPLD_PHYS + 0x54)
+#define _IDP_CPLD_PCCARD1_STATUS	(IDP_CPLD_PHYS + 0x58)
+#define _IDP_CPLD_MISC_STATUS		(IDP_CPLD_PHYS + 0x5C)
+
+/* FPGA register virtual addresses */
+
+#define IDP_CPLD_REV			__CPLD_REG(_IDP_CPLD_REV)
+#define IDP_CPLD_PERIPH_PWR		__CPLD_REG(_IDP_CPLD_PERIPH_PWR)
+#define IDP_CPLD_LED_CONTROL		__CPLD_REG(_IDP_CPLD_LED_CONTROL)
+#define IDP_CPLD_KB_COL_HIGH		__CPLD_REG(_IDP_CPLD_KB_COL_HIGH)
+#define IDP_CPLD_KB_COL_LOW		__CPLD_REG(_IDP_CPLD_KB_COL_LOW)
+#define IDP_CPLD_PCCARD_EN		__CPLD_REG(_IDP_CPLD_PCCARD_EN)
+#define IDP_CPLD_GPIOH_DIR		__CPLD_REG(_IDP_CPLD_GPIOH_DIR)
+#define IDP_CPLD_GPIOH_VALUE		__CPLD_REG(_IDP_CPLD_GPIOH_VALUE)
+#define IDP_CPLD_GPIOL_DIR		__CPLD_REG(_IDP_CPLD_GPIOL_DIR)
+#define IDP_CPLD_GPIOL_VALUE		__CPLD_REG(_IDP_CPLD_GPIOL_VALUE)
+#define IDP_CPLD_PCCARD_PWR		__CPLD_REG(_IDP_CPLD_PCCARD_PWR)
+#define IDP_CPLD_MISC_CTRL		__CPLD_REG(_IDP_CPLD_MISC_CTRL)
+#define IDP_CPLD_LCD			__CPLD_REG(_IDP_CPLD_LCD)
+#define IDP_CPLD_FLASH_WE		__CPLD_REG(_IDP_CPLD_FLASH_WE)
+
+#define IDP_CPLD_KB_ROW		        __CPLD_REG(_IDP_CPLD_KB_ROW)
+#define IDP_CPLD_PCCARD0_STATUS	        __CPLD_REG(_IDP_CPLD_PCCARD0_STATUS)
+#define IDP_CPLD_PCCARD1_STATUS	        __CPLD_REG(_IDP_CPLD_PCCARD1_STATUS)
+#define IDP_CPLD_MISC_STATUS		__CPLD_REG(_IDP_CPLD_MISC_STATUS)
+
+
+/*
+ * Bit masks for various registers
+ */
+
+// IDP_CPLD_PCCARD_PWR
+#define PCC0_PWR0	(1 << 0)
+#define PCC0_PWR1	(1 << 1)
+#define PCC0_PWR2	(1 << 2)
+#define PCC0_PWR3	(1 << 3)
+#define PCC1_PWR0	(1 << 4)
+#define PCC1_PWR1	(1 << 5)
+#define PCC1_PWR2	(1 << 6)
+#define PCC1_PWR3	(1 << 7)
+
+// IDP_CPLD_PCCARD_EN
+#define PCC0_RESET	(1 << 6)
+#define PCC1_RESET	(1 << 7)
+#define PCC0_ENABLE	(1 << 0)
+#define PCC1_ENABLE	(1 << 1)
+
+// IDP_CPLD_PCCARDx_STATUS
+#define _PCC_WRPROT	(1 << 7) // 7-4 read as low true
+#define _PCC_RESET	(1 << 6)
+#define _PCC_IRQ	(1 << 5)
+#define _PCC_INPACK	(1 << 4)
+#define PCC_BVD2	(1 << 3)
+#define PCC_BVD1	(1 << 2)
+#define PCC_VS2		(1 << 1)
+#define PCC_VS1		(1 << 0)
+
+#define PCC_DETECT(x)	(GPLR(7 + (x)) & GPIO_bit(7 + (x)))
+
+/* A listing of interrupts used by external hardware devices */
+
+#define TOUCH_PANEL_IRQ			IRQ_GPIO(5)
+#define IDE_IRQ				IRQ_GPIO(21)
+
+#define TOUCH_PANEL_IRQ_EDGE		IRQT_FALLING
+
+#define ETHERNET_IRQ			IRQ_GPIO(4)
+#define ETHERNET_IRQ_EDGE		IRQT_RISING
+
+#define IDE_IRQ_EDGE			IRQT_RISING
+
+#define PCMCIA_S0_CD_VALID		IRQ_GPIO(7)
+#define PCMCIA_S0_CD_VALID_EDGE		IRQT_BOTHEDGE
+
+#define PCMCIA_S1_CD_VALID		IRQ_GPIO(8)
+#define PCMCIA_S1_CD_VALID_EDGE		IRQT_BOTHEDGE
+
+#define PCMCIA_S0_RDYINT		IRQ_GPIO(19)
+#define PCMCIA_S1_RDYINT		IRQ_GPIO(22)
+
+
+/*
+ * Macros for LED Driver
+ */
+
+/* leds 0 = ON */
+#define IDP_HB_LED	(1<<5)
+#define IDP_BUSY_LED	(1<<6)
+
+#define IDP_LEDS_MASK	(IDP_HB_LED | IDP_BUSY_LED)
+
+/*
+ * macros for MTD driver
+ */
+
+#define FLASH_WRITE_PROTECT_DISABLE()	((IDP_CPLD_FLASH_WE) &= ~(0x1))
+#define FLASH_WRITE_PROTECT_ENABLE()	((IDP_CPLD_FLASH_WE) |= (0x1))
+
+/*
+ * macros for matrix keyboard driver
+ */
+
+#define KEYBD_MATRIX_NUMBER_INPUTS	7
+#define KEYBD_MATRIX_NUMBER_OUTPUTS	14
+
+#define KEYBD_MATRIX_INVERT_OUTPUT_LOGIC	FALSE
+#define KEYBD_MATRIX_INVERT_INPUT_LOGIC		FALSE
+
+#define KEYBD_MATRIX_SETTLING_TIME_US			100
+#define KEYBD_MATRIX_KEYSTATE_DEBOUNCE_CONSTANT		2
+
+#define KEYBD_MATRIX_SET_OUTPUTS(outputs) \
+{\
+	IDP_CPLD_KB_COL_LOW = outputs;\
+	IDP_CPLD_KB_COL_HIGH = outputs >> 7;\
+}
+
+#define KEYBD_MATRIX_GET_INPUTS(inputs) \
+{\
+	inputs = (IDP_CPLD_KB_ROW & 0x7f);\
+}
+
+
Index: build_tree/linux/include/asm/arch/io.h
diff -u /dev/null build_tree/linux/include/asm/arch/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * linux/include/asm-arm/arch-pxa/io.h
+ *
+ * Copied from asm/arch/sa1100/io.h
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch/irda.h
diff -u /dev/null build_tree/linux/include/asm/arch/irda.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/irda.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,17 @@
+#ifndef ASMARM_ARCH_IRDA_H
+#define ASMARM_ARCH_IRDA_H
+
+/* board specific transceiver capabilities */
+
+#define IR_OFF		1
+#define IR_SIRMODE	2
+#define IR_FIRMODE	4
+
+struct pxaficp_platform_data {
+	int transceiver_cap;
+	void (*transceiver_mode)(struct device *dev, int mode);
+};
+
+extern void pxa_set_ficp_info(struct pxaficp_platform_data *info);
+
+#endif
Index: build_tree/linux/include/asm/arch/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,224 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/irqs.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifdef CONFIG_PXA27x
+#define PXA_IRQ_SKIP	0
+#else
+#define PXA_IRQ_SKIP	7
+#endif
+
+#define PXA_IRQ(x)	((x) - PXA_IRQ_SKIP)
+
+#define IRQ_SSP3	PXA_IRQ(0)	/* SSP3 service request */
+#define IRQ_MSL		PXA_IRQ(1)	/* MSL Interface interrupt */
+#define IRQ_USBH2	PXA_IRQ(2)	/* USB Host interrupt 1 (OHCI) */
+#define IRQ_USBH1	PXA_IRQ(3)	/* USB Host interrupt 2 (non-OHCI) */
+#define IRQ_KEYPAD	PXA_IRQ(4)	/* Key pad controller */
+#define IRQ_MEMSTK	PXA_IRQ(5)	/* Memory Stick interrupt */
+#define IRQ_PWRI2C	PXA_IRQ(6)	/* Power I2C interrupt */
+#define IRQ_HWUART	PXA_IRQ(7)	/* HWUART Transmit/Receive/Error (PXA26x) */
+#define IRQ_OST_4_11	PXA_IRQ(7)	/* OS timer 4-11 matches (PXA27x) */
+#define	IRQ_GPIO0	PXA_IRQ(8)	/* GPIO0 Edge Detect */
+#define	IRQ_GPIO1	PXA_IRQ(9)	/* GPIO1 Edge Detect */
+#define	IRQ_GPIO_2_x	PXA_IRQ(10)	/* GPIO[2-x] Edge Detect */
+#define	IRQ_USB		PXA_IRQ(11)	/* USB Service */
+#define	IRQ_PMU		PXA_IRQ(12)	/* Performance Monitoring Unit */
+#define	IRQ_I2S		PXA_IRQ(13)	/* I2S Interrupt */
+#define	IRQ_AC97	PXA_IRQ(14)	/* AC97 Interrupt */
+#define IRQ_ASSP	PXA_IRQ(15)	/* Audio SSP Service Request (PXA25x) */
+#define IRQ_USIM	PXA_IRQ(15)     /* Smart Card interface interrupt (PXA27x) */
+#define IRQ_NSSP	PXA_IRQ(16)	/* Network SSP Service Request (PXA25x) */
+#define IRQ_SSP2	PXA_IRQ(16)	/* SSP2 interrupt (PXA27x) */
+#define	IRQ_LCD		PXA_IRQ(17)	/* LCD Controller Service Request */
+#define	IRQ_I2C		PXA_IRQ(18)	/* I2C Service Request */
+#define	IRQ_ICP		PXA_IRQ(19)	/* ICP Transmit/Receive/Error */
+#define	IRQ_STUART	PXA_IRQ(20)	/* STUART Transmit/Receive/Error */
+#define	IRQ_BTUART	PXA_IRQ(21)	/* BTUART Transmit/Receive/Error */
+#define	IRQ_FFUART	PXA_IRQ(22)	/* FFUART Transmit/Receive/Error*/
+#define	IRQ_MMC		PXA_IRQ(23)	/* MMC Status/Error Detection */
+#define	IRQ_SSP		PXA_IRQ(24)	/* SSP Service Request */
+#define	IRQ_DMA 	PXA_IRQ(25)	/* DMA Channel Service Request */
+#define	IRQ_OST0 	PXA_IRQ(26)	/* OS Timer match 0 */
+#define	IRQ_OST1 	PXA_IRQ(27)	/* OS Timer match 1 */
+#define	IRQ_OST2 	PXA_IRQ(28)	/* OS Timer match 2 */
+#define	IRQ_OST3 	PXA_IRQ(29)	/* OS Timer match 3 */
+#define	IRQ_RTC1Hz	PXA_IRQ(30)	/* RTC HZ Clock Tick */
+#define	IRQ_RTCAlrm	PXA_IRQ(31)	/* RTC Alarm */
+
+#ifdef CONFIG_PXA27x
+#define IRQ_TPM		PXA_IRQ(32)	/* TPM interrupt */
+#define IRQ_CAMERA	PXA_IRQ(33)	/* Camera Interface */
+
+#define PXA_INTERNAL_IRQS 34
+#else
+#define PXA_INTERNAL_IRQS 32
+#endif
+
+#define GPIO_2_x_TO_IRQ(x)	\
+			PXA_IRQ((x) - 2 + PXA_INTERNAL_IRQS)
+#define IRQ_GPIO(x)	(((x) < 2) ? (IRQ_GPIO0 + (x)) : GPIO_2_x_TO_IRQ(x))
+
+#define IRQ_TO_GPIO_2_x(i)	\
+			((i) - IRQ_GPIO(2) + 2)
+#define IRQ_TO_GPIO(i)	(((i) < IRQ_GPIO(2)) ? ((i) - IRQ_GPIO0) : IRQ_TO_GPIO_2_x(i))
+
+#if defined(CONFIG_PXA25x)
+#define PXA_LAST_GPIO	84
+#elif defined(CONFIG_PXA27x)
+#define PXA_LAST_GPIO	127
+#endif
+
+/*
+ * The next 16 interrupts are for board specific purposes.  Since
+ * the kernel can only run on one machine at a time, we can re-use
+ * these.  If you need more, increase IRQ_BOARD_END, but keep it
+ * within sensible limits.
+ */
+#define IRQ_BOARD_START		(IRQ_GPIO(PXA_LAST_GPIO) + 1)
+#define IRQ_BOARD_END		(IRQ_BOARD_START + 16)
+
+#define IRQ_SA1111_START	(IRQ_BOARD_END)
+#define IRQ_GPAIN0		(IRQ_BOARD_END + 0)
+#define IRQ_GPAIN1		(IRQ_BOARD_END + 1)
+#define IRQ_GPAIN2		(IRQ_BOARD_END + 2)
+#define IRQ_GPAIN3		(IRQ_BOARD_END + 3)
+#define IRQ_GPBIN0		(IRQ_BOARD_END + 4)
+#define IRQ_GPBIN1		(IRQ_BOARD_END + 5)
+#define IRQ_GPBIN2		(IRQ_BOARD_END + 6)
+#define IRQ_GPBIN3		(IRQ_BOARD_END + 7)
+#define IRQ_GPBIN4		(IRQ_BOARD_END + 8)
+#define IRQ_GPBIN5		(IRQ_BOARD_END + 9)
+#define IRQ_GPCIN0		(IRQ_BOARD_END + 10)
+#define IRQ_GPCIN1		(IRQ_BOARD_END + 11)
+#define IRQ_GPCIN2		(IRQ_BOARD_END + 12)
+#define IRQ_GPCIN3		(IRQ_BOARD_END + 13)
+#define IRQ_GPCIN4		(IRQ_BOARD_END + 14)
+#define IRQ_GPCIN5		(IRQ_BOARD_END + 15)
+#define IRQ_GPCIN6		(IRQ_BOARD_END + 16)
+#define IRQ_GPCIN7		(IRQ_BOARD_END + 17)
+#define IRQ_MSTXINT		(IRQ_BOARD_END + 18)
+#define IRQ_MSRXINT		(IRQ_BOARD_END + 19)
+#define IRQ_MSSTOPERRINT	(IRQ_BOARD_END + 20)
+#define IRQ_TPTXINT		(IRQ_BOARD_END + 21)
+#define IRQ_TPRXINT		(IRQ_BOARD_END + 22)
+#define IRQ_TPSTOPERRINT	(IRQ_BOARD_END + 23)
+#define SSPXMTINT		(IRQ_BOARD_END + 24)
+#define SSPRCVINT		(IRQ_BOARD_END + 25)
+#define SSPROR			(IRQ_BOARD_END + 26)
+#define AUDXMTDMADONEA		(IRQ_BOARD_END + 32)
+#define AUDRCVDMADONEA		(IRQ_BOARD_END + 33)
+#define AUDXMTDMADONEB		(IRQ_BOARD_END + 34)
+#define AUDRCVDMADONEB		(IRQ_BOARD_END + 35)
+#define AUDTFSR			(IRQ_BOARD_END + 36)
+#define AUDRFSR			(IRQ_BOARD_END + 37)
+#define AUDTUR			(IRQ_BOARD_END + 38)
+#define AUDROR			(IRQ_BOARD_END + 39)
+#define AUDDTS			(IRQ_BOARD_END + 40)
+#define AUDRDD			(IRQ_BOARD_END + 41)
+#define AUDSTO			(IRQ_BOARD_END + 42)
+#define IRQ_USBPWR		(IRQ_BOARD_END + 43)
+#define IRQ_HCIM		(IRQ_BOARD_END + 44)
+#define IRQ_HCIBUFFACC		(IRQ_BOARD_END + 45)
+#define IRQ_HCIRMTWKP		(IRQ_BOARD_END + 46)
+#define IRQ_NHCIMFCIR		(IRQ_BOARD_END + 47)
+#define IRQ_USB_PORT_RESUME	(IRQ_BOARD_END + 48)
+#define IRQ_S0_READY_NINT	(IRQ_BOARD_END + 49)
+#define IRQ_S1_READY_NINT	(IRQ_BOARD_END + 50)
+#define IRQ_S0_CD_VALID		(IRQ_BOARD_END + 51)
+#define IRQ_S1_CD_VALID		(IRQ_BOARD_END + 52)
+#define IRQ_S0_BVD1_STSCHG	(IRQ_BOARD_END + 53)
+#define IRQ_S1_BVD1_STSCHG	(IRQ_BOARD_END + 54)
+
+#define IRQ_LOCOMO_START	(IRQ_BOARD_END)
+#define IRQ_LOCOMO_KEY		(IRQ_BOARD_END + 0)
+#define IRQ_LOCOMO_GPIO0	(IRQ_BOARD_END + 1)
+#define IRQ_LOCOMO_GPIO1	(IRQ_BOARD_END + 2)
+#define IRQ_LOCOMO_GPIO2	(IRQ_BOARD_END + 3)
+#define IRQ_LOCOMO_GPIO3	(IRQ_BOARD_END + 4)
+#define IRQ_LOCOMO_GPIO4	(IRQ_BOARD_END + 5)
+#define IRQ_LOCOMO_GPIO5	(IRQ_BOARD_END + 6)
+#define IRQ_LOCOMO_GPIO6	(IRQ_BOARD_END + 7)
+#define IRQ_LOCOMO_GPIO7	(IRQ_BOARD_END + 8)
+#define IRQ_LOCOMO_GPIO8	(IRQ_BOARD_END + 9)
+#define IRQ_LOCOMO_GPIO9	(IRQ_BOARD_END + 10)
+#define IRQ_LOCOMO_GPIO10	(IRQ_BOARD_END + 11)
+#define IRQ_LOCOMO_GPIO11	(IRQ_BOARD_END + 12)
+#define IRQ_LOCOMO_GPIO12	(IRQ_BOARD_END + 13)
+#define IRQ_LOCOMO_GPIO13	(IRQ_BOARD_END + 14)
+#define IRQ_LOCOMO_GPIO14	(IRQ_BOARD_END + 15)
+#define IRQ_LOCOMO_GPIO15	(IRQ_BOARD_END + 16)
+#define IRQ_LOCOMO_LT		(IRQ_BOARD_END + 17)
+#define IRQ_LOCOMO_SPI_RFR	(IRQ_BOARD_END + 18)
+#define IRQ_LOCOMO_SPI_RFW	(IRQ_BOARD_END + 19)
+#define IRQ_LOCOMO_SPI_OVRN	(IRQ_BOARD_END + 20)
+#define IRQ_LOCOMO_SPI_TEND	(IRQ_BOARD_END + 21)
+
+/*
+ * Figure out the MAX IRQ number.
+ *
+ * If we have an SA1111, the max IRQ is S1_BVD1_STSCHG+1.
+ * If we have an LoCoMo, the max IRQ is IRQ_LOCOMO_SPI_TEND+1
+ * Otherwise, we have the standard IRQs only.
+ */
+#ifdef CONFIG_SA1111
+#define NR_IRQS			(IRQ_S1_BVD1_STSCHG + 1)
+#elif defined(CONFIG_SHARP_LOCOMO)
+#define NR_IRQS			(IRQ_LOCOMO_SPI_TEND + 1)
+#elif defined(CONFIG_ARCH_LUBBOCK) || \
+      defined(CONFIG_MACH_LOGICPD_PXA270) || \
+      defined(CONFIG_MACH_MAINSTONE)
+#define NR_IRQS			(IRQ_BOARD_END)
+#else
+#define NR_IRQS			(IRQ_BOARD_START)
+#endif
+
+/*
+ * Board specific IRQs.  Define them here.
+ * Do not surround them with ifdefs.
+ */
+#define LUBBOCK_IRQ(x)		(IRQ_BOARD_START + (x))
+#define LUBBOCK_SD_IRQ		LUBBOCK_IRQ(0)
+#define LUBBOCK_SA1111_IRQ	LUBBOCK_IRQ(1)
+#define LUBBOCK_USB_IRQ		LUBBOCK_IRQ(2)  /* usb connect */
+#define LUBBOCK_ETH_IRQ		LUBBOCK_IRQ(3)
+#define LUBBOCK_UCB1400_IRQ	LUBBOCK_IRQ(4)
+#define LUBBOCK_BB_IRQ		LUBBOCK_IRQ(5)
+#define LUBBOCK_USB_DISC_IRQ	LUBBOCK_IRQ(6)  /* usb disconnect */
+#define LUBBOCK_LAST_IRQ	LUBBOCK_IRQ(6)
+
+#define LPD270_IRQ(x)		(IRQ_BOARD_START + (x))
+#define LPD270_USBC_IRQ		LPD270_IRQ(2)
+#define LPD270_ETHERNET_IRQ	LPD270_IRQ(3)
+#define LPD270_AC97_IRQ		LPD270_IRQ(4)
+
+#define MAINSTONE_IRQ(x)	(IRQ_BOARD_START + (x))
+#define MAINSTONE_MMC_IRQ	MAINSTONE_IRQ(0)
+#define MAINSTONE_USIM_IRQ	MAINSTONE_IRQ(1)
+#define MAINSTONE_USBC_IRQ	MAINSTONE_IRQ(2)
+#define MAINSTONE_ETHERNET_IRQ	MAINSTONE_IRQ(3)
+#define MAINSTONE_AC97_IRQ	MAINSTONE_IRQ(4)
+#define MAINSTONE_PEN_IRQ	MAINSTONE_IRQ(5)
+#define MAINSTONE_MSINS_IRQ	MAINSTONE_IRQ(6)
+#define MAINSTONE_EXBRD_IRQ	MAINSTONE_IRQ(7)
+#define MAINSTONE_S0_CD_IRQ	MAINSTONE_IRQ(9)
+#define MAINSTONE_S0_STSCHG_IRQ	MAINSTONE_IRQ(10)
+#define MAINSTONE_S0_IRQ	MAINSTONE_IRQ(11)
+#define MAINSTONE_S1_CD_IRQ	MAINSTONE_IRQ(13)
+#define MAINSTONE_S1_STSCHG_IRQ	MAINSTONE_IRQ(14)
+#define MAINSTONE_S1_IRQ	MAINSTONE_IRQ(15)
+
+/* LoCoMo Interrupts (CONFIG_SHARP_LOCOMO) */
+#define IRQ_LOCOMO_KEY_BASE	(IRQ_BOARD_START + 0)
+#define IRQ_LOCOMO_GPIO_BASE	(IRQ_BOARD_START + 1)
+#define IRQ_LOCOMO_LT_BASE	(IRQ_BOARD_START + 2)
+#define IRQ_LOCOMO_SPI_BASE	(IRQ_BOARD_START + 3)
Index: build_tree/linux/include/asm/arch/lpd270.h
diff -u /dev/null build_tree/linux/include/asm/arch/lpd270.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/lpd270.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-pxa/lpd270.h
+ *
+ * Author:	Lennert Buytenhek
+ * Created:	Feb 10, 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_LPD270_H
+#define __ASM_ARCH_LPD270_H
+
+#define LPD270_CPLD_PHYS	PXA_CS2_PHYS
+#define LPD270_CPLD_VIRT	0xf0000000
+#define LPD270_CPLD_SIZE	0x00100000
+
+#define LPD270_ETH_PHYS		(PXA_CS2_PHYS + 0x01000000)
+
+/* CPLD registers  */
+#define LPD270_CPLD_REG(x)	((unsigned long)(LPD270_CPLD_VIRT + (x)))
+#define LPD270_CONTROL		LPD270_CPLD_REG(0x00)
+#define LPD270_PERIPHERAL0	LPD270_CPLD_REG(0x04)
+#define LPD270_PERIPHERAL1	LPD270_CPLD_REG(0x08)
+#define LPD270_CPLD_REVISION	LPD270_CPLD_REG(0x14)
+#define LPD270_EEPROM_SPI_ITF	LPD270_CPLD_REG(0x20)
+#define LPD270_MODE_PINS	LPD270_CPLD_REG(0x24)
+#define LPD270_EGPIO		LPD270_CPLD_REG(0x30)
+#define LPD270_INT_MASK		LPD270_CPLD_REG(0x40)
+#define LPD270_INT_STATUS	LPD270_CPLD_REG(0x50)
+
+#define LPD270_INT_AC97		(1 << 4)  /* AC'97 CODEC IRQ */
+#define LPD270_INT_ETHERNET	(1 << 3)  /* Ethernet controller IRQ */
+#define LPD270_INT_USBC		(1 << 2)  /* USB client cable detection IRQ */
+
+
+#endif
Index: build_tree/linux/include/asm/arch/lubbock.h
diff -u /dev/null build_tree/linux/include/asm/arch/lubbock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/lubbock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/lubbock.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define LUBBOCK_ETH_PHYS	PXA_CS3_PHYS
+
+#define LUBBOCK_FPGA_PHYS	PXA_CS2_PHYS
+#define LUBBOCK_FPGA_VIRT	(0xf0000000)
+#define LUB_P2V(x)		((x) - LUBBOCK_FPGA_PHYS + LUBBOCK_FPGA_VIRT)
+#define LUB_V2P(x)		((x) - LUBBOCK_FPGA_VIRT + LUBBOCK_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __LUB_REG(x)		(*((volatile unsigned long *)LUB_P2V(x)))
+#else
+#  define __LUB_REG(x)		LUB_P2V(x)
+#endif
+
+/* FPGA register virtual addresses */
+#define LUB_WHOAMI		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x000)
+#define LUB_HEXLED		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x010)
+#define LUB_DISC_BLNK_LED	__LUB_REG(LUBBOCK_FPGA_PHYS + 0x040)
+#define LUB_CONF_SWITCHES	__LUB_REG(LUBBOCK_FPGA_PHYS + 0x050)
+#define LUB_USER_SWITCHES	__LUB_REG(LUBBOCK_FPGA_PHYS + 0x060)
+#define LUB_MISC_WR		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x080)
+#define LUB_MISC_RD		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x090)
+#define LUB_IRQ_MASK_EN		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x0c0)
+#define LUB_IRQ_SET_CLR		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x0d0)
+#define LUB_GP			__LUB_REG(LUBBOCK_FPGA_PHYS + 0x100)
+
+#ifndef __ASSEMBLY__
+extern void lubbock_set_misc_wr(unsigned int mask, unsigned int set);
+#endif
Index: build_tree/linux/include/asm/arch/mainstone.h
diff -u /dev/null build_tree/linux/include/asm/arch/mainstone.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/mainstone.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,120 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/mainstone.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Nov 14, 2002
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef ASM_ARCH_MAINSTONE_H
+#define ASM_ARCH_MAINSTONE_H
+
+#define MST_ETH_PHYS		PXA_CS4_PHYS
+
+#define MST_FPGA_PHYS		PXA_CS2_PHYS
+#define MST_FPGA_VIRT		(0xf0000000)
+#define MST_P2V(x)		((x) - MST_FPGA_PHYS + MST_FPGA_VIRT)
+#define MST_V2P(x)		((x) - MST_FPGA_VIRT + MST_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+# define __MST_REG(x)		(*((volatile unsigned long *)MST_P2V(x)))
+#else
+# define __MST_REG(x)		MST_P2V(x)
+#endif
+
+/* board level registers in the FPGA */
+
+#define MST_LEDDAT1		__MST_REG(0x08000010)
+#define MST_LEDDAT2		__MST_REG(0x08000014)
+#define MST_LEDCTRL		__MST_REG(0x08000040)
+#define MST_GPSWR		__MST_REG(0x08000060)
+#define MST_MSCWR1		__MST_REG(0x08000080)
+#define MST_MSCWR2		__MST_REG(0x08000084)
+#define MST_MSCWR3		__MST_REG(0x08000088)
+#define MST_MSCRD		__MST_REG(0x08000090)
+#define MST_INTMSKENA		__MST_REG(0x080000c0)
+#define MST_INTSETCLR		__MST_REG(0x080000d0)
+#define MST_PCMCIA0		__MST_REG(0x080000e0)
+#define MST_PCMCIA1		__MST_REG(0x080000e4)
+
+#define MST_MSCWR1_CAMERA_ON	(1 << 15)  /* Camera interface power control */
+#define MST_MSCWR1_CAMERA_SEL	(1 << 14)  /* Camera interface mux control */
+#define MST_MSCWR1_LCD_CTL	(1 << 13)  /* General-purpose LCD control */
+#define MST_MSCWR1_MS_ON	(1 << 12)  /* Memory Stick power control */
+#define MST_MSCWR1_MMC_ON	(1 << 11)  /* MultiMediaCard* power control */
+#define MST_MSCWR1_MS_SEL	(1 << 10)  /* SD/MS multiplexer control */
+#define MST_MSCWR1_BB_SEL	(1 << 9)   /* PCMCIA/Baseband multiplexer */
+#define MST_MSCWR1_BT_ON	(1 << 8)   /* Bluetooth UART transceiver */
+#define MST_MSCWR1_BTDTR	(1 << 7)   /* Bluetooth UART DTR */
+
+#define MST_MSCWR1_IRDA_MASK	(3 << 5)   /* IrDA transceiver mode */
+#define MST_MSCWR1_IRDA_FULL	(0 << 5)   /* full distance power */
+#define MST_MSCWR1_IRDA_OFF	(1 << 5)   /* shutdown */
+#define MST_MSCWR1_IRDA_MED	(2 << 5)   /* 2/3 distance power */
+#define MST_MSCWR1_IRDA_LOW	(3 << 5)   /* 1/3 distance power */
+
+#define MST_MSCWR1_IRDA_FIR	(1 << 4)   /* IrDA transceiver SIR/FIR */
+#define MST_MSCWR1_GREENLED	(1 << 3)   /* LED D1 control */
+#define MST_MSCWR1_PDC_CTL	(1 << 2)   /* reserved */
+#define MST_MSCWR1_MTR_ON	(1 << 1)   /* Silent alert motor */
+#define MST_MSCWR1_SYSRESET	(1 << 0)   /* System reset */
+
+#define MST_MSCWR2_USB_OTG_RST	(1 << 6)   /* USB On The Go reset */
+#define MST_MSCWR2_USB_OTG_SEL	(1 << 5)   /* USB On The Go control */
+#define MST_MSCWR2_nUSBC_SC	(1 << 4)   /* USB client soft connect control */
+#define MST_MSCWR2_I2S_SPKROFF	(1 << 3)   /* I2S CODEC amplifier control */
+#define MST_MSCWR2_AC97_SPKROFF	(1 << 2)   /* AC97 CODEC amplifier control */
+#define MST_MSCWR2_RADIO_PWR	(1 << 1)   /* Radio module power control */
+#define MST_MSCWR2_RADIO_WAKE	(1 << 0)   /* Radio module wake-up signal */
+
+#define MST_MSCWR3_GPIO_RESET_EN	(1 << 2) /* Enable GPIO Reset */
+#define MST_MSCWR3_GPIO_RESET		(1 << 1) /* Initiate a GPIO Reset */
+#define MST_MSCWR3_COMMS_SW_RESET	(1 << 0) /* Communications Processor Reset Control */
+
+#define MST_MSCRD_nPENIRQ	(1 << 9)   /* ADI7873* nPENIRQ signal */
+#define MST_MSCRD_nMEMSTK_CD	(1 << 8)   /* Memory Stick detection signal */
+#define MST_MSCRD_nMMC_CD	(1 << 7)   /* SD/MMC card detection signal */
+#define MST_MSCRD_nUSIM_CD	(1 << 6)   /* USIM card detection signal */
+#define MST_MSCRD_USB_CBL	(1 << 5)   /* USB client cable status */
+#define MST_MSCRD_TS_BUSY	(1 << 4)   /* ADI7873 busy */
+#define MST_MSCRD_BTDSR		(1 << 3)   /* Bluetooth UART DSR */
+#define MST_MSCRD_BTRI		(1 << 2)   /* Bluetooth UART Ring Indicator */
+#define MST_MSCRD_BTDCD		(1 << 1)   /* Bluetooth UART DCD */
+#define MST_MSCRD_nMMC_WP	(1 << 0)   /* SD/MMC write-protect status */
+
+#define MST_INT_S1_IRQ		(1 << 15)  /* PCMCIA socket 1 IRQ */
+#define MST_INT_S1_STSCHG	(1 << 14)  /* PCMCIA socket 1 status changed */
+#define MST_INT_S1_CD		(1 << 13)  /* PCMCIA socket 1 card detection */
+#define MST_INT_S0_IRQ		(1 << 11)  /* PCMCIA socket 0 IRQ */
+#define MST_INT_S0_STSCHG	(1 << 10)  /* PCMCIA socket 0 status changed */
+#define MST_INT_S0_CD		(1 << 9)   /* PCMCIA socket 0 card detection */
+#define MST_INT_nEXBRD_INT	(1 << 7)   /* Expansion board IRQ */
+#define MST_INT_MSINS		(1 << 6)   /* Memory Stick* detection */
+#define MST_INT_PENIRQ		(1 << 5)   /* ADI7873* touch-screen IRQ */
+#define MST_INT_AC97		(1 << 4)   /* AC'97 CODEC IRQ */
+#define MST_INT_ETHERNET	(1 << 3)   /* Ethernet controller IRQ */
+#define MST_INT_USBC		(1 << 2)   /* USB client cable detection IRQ */
+#define MST_INT_USIM		(1 << 1)   /* USIM card detection IRQ */
+#define MST_INT_MMC		(1 << 0)   /* MMC/SD card detection IRQ */
+
+#define MST_PCMCIA_nIRQ		(1 << 10)  /* IRQ / ready signal */
+#define MST_PCMCIA_nSPKR_BVD2	(1 << 9)   /* VDD sense / digital speaker */
+#define MST_PCMCIA_nSTSCHG_BVD1	(1 << 8)   /* VDD sense / card status changed */
+#define MST_PCMCIA_nVS2		(1 << 7)   /* VSS voltage sense */
+#define MST_PCMCIA_nVS1		(1 << 6)   /* VSS voltage sense */
+#define MST_PCMCIA_nCD		(1 << 5)   /* Card detection signal */
+#define MST_PCMCIA_RESET	(1 << 4)   /* Card reset signal */
+#define MST_PCMCIA_PWR_MASK	(0x000f)   /* MAX1602 power-supply controls */
+
+#define MST_PCMCIA_PWR_VPP_0    0x0	   /* voltage VPP = 0V */
+#define MST_PCMCIA_PWR_VPP_120  0x2 	   /* voltage VPP = 12V*/
+#define MST_PCMCIA_PWR_VPP_VCC  0x1	   /* voltage VPP = VCC */
+#define MST_PCMCIA_PWR_VCC_0    0x0	   /* voltage VCC = 0V */
+#define MST_PCMCIA_PWR_VCC_33   0x8	   /* voltage VCC = 3.3V */
+#define MST_PCMCIA_PWR_VCC_50   0x4	   /* voltage VCC = 5.0V */
+
+#endif
Index: build_tree/linux/include/asm/arch/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/memory.h
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0xa0000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+/*
+ * The nodes are matched with the physical SDRAM banks as follows:
+ *
+ * 	node 0:  0xa0000000-0xa3ffffff	-->  0xc0000000-0xc3ffffff
+ * 	node 1:  0xa4000000-0xa7ffffff	-->  0xc4000000-0xc7ffffff
+ * 	node 2:  0xa8000000-0xabffffff	-->  0xc8000000-0xcbffffff
+ * 	node 3:  0xac000000-0xafffffff	-->  0xcc000000-0xcfffffff
+ *
+ * This needs a node mem size of 26 bits.
+ */
+#define NODE_MEM_SIZE_BITS	26
+
+#endif
Index: build_tree/linux/include/asm/arch/mmc.h
diff -u /dev/null build_tree/linux/include/asm/arch/mmc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/mmc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+#ifndef ASMARM_ARCH_MMC_H
+#define ASMARM_ARCH_MMC_H
+
+#include <linux/mmc/protocol.h>
+#include <linux/interrupt.h>
+
+struct device;
+struct mmc_host;
+
+struct pxamci_platform_data {
+	unsigned int ocr_mask;			/* available voltages */
+	unsigned long detect_delay;		/* delay in jiffies before detecting cards after interrupt */
+	int (*init)(struct device *, irq_handler_t , void *);
+	int (*get_ro)(struct device *);
+	void (*setpower)(struct device *, unsigned int);
+	void (*exit)(struct device *, void *);
+};
+
+extern void pxa_set_mci_info(struct pxamci_platform_data *info);
+
+#endif
Index: build_tree/linux/include/asm/arch/mtd-xip.h
diff -u /dev/null build_tree/linux/include/asm/arch/mtd-xip.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/mtd-xip.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * MTD primitives for XIP support. Architecture specific functions
+ *
+ * Do not include this file directly. It's included from linux/mtd/xip.h
+ * 
+ * Author:	Nicolas Pitre
+ * Created:	Nov 2, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * $Id: xip.h,v 1.2 2004/12/01 15:49:10 nico Exp $
+ */
+
+#ifndef __ARCH_PXA_MTD_XIP_H__
+#define __ARCH_PXA_MTD_XIP_H__
+
+#include <asm/arch/pxa-regs.h>
+
+#define xip_irqpending()	(ICIP & ICMR)
+
+/* we sample OSCR and convert desired delta to usec (1/4 ~= 1000000/3686400) */
+#define xip_currtime()		(OSCR)
+#define xip_elapsed_since(x)	(signed)((OSCR - (x)) / 4)
+
+/*
+ * xip_cpu_idle() is used when waiting for a delay equal or larger than
+ * the system timer tick period.  This should put the CPU into idle mode
+ * to save power and to be woken up only when some interrupts are pending.
+ * As above, this should not rely upon standard kernel code.
+ */
+
+#define xip_cpu_idle()  asm volatile ("mcr p14, 0, %0, c7, c0, 0" :: "r" (1))
+
+#endif /* __ARCH_PXA_MTD_XIP_H__ */
Index: build_tree/linux/include/asm/arch/ohci.h
diff -u /dev/null build_tree/linux/include/asm/arch/ohci.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/ohci.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+#ifndef ASMARM_ARCH_OHCI_H
+#define ASMARM_ARCH_OHCI_H
+
+struct device;
+
+struct pxaohci_platform_data {
+	int (*init)(struct device *);
+	void (*exit)(struct device *);
+
+	int port_mode;
+#define PMM_NPS_MODE           1
+#define PMM_GLOBAL_MODE        2
+#define PMM_PERPORT_MODE       3
+
+	int power_budget;
+};
+
+extern void pxa_set_ohci_info(struct pxaohci_platform_data *info);
+
+#endif
Index: build_tree/linux/include/asm/arch/pm.h
diff -u /dev/null build_tree/linux/include/asm/arch/pm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/pm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2005 Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+extern int pxa_pm_prepare(suspend_state_t state);
+extern int pxa_pm_enter(suspend_state_t state);
+extern int pxa_pm_finish(suspend_state_t state);
Index: build_tree/linux/include/asm/arch/poodle.h
diff -u /dev/null build_tree/linux/include/asm/arch/poodle.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/poodle.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,75 @@
+/*
+ * linux/include/asm-arm/arch-pxa/poodle.h
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Based on:
+ *   linux/include/asm-arm/arch-sa1100/collie.h
+ *
+ * ChangeLog:
+ *   04-06-2001 Lineo Japan, Inc.
+ *   04-16-2001 SHARP Corporation
+ *   Update to 2.6 John Lenz
+ */
+#ifndef __ASM_ARCH_POODLE_H
+#define __ASM_ARCH_POODLE_H  1
+
+/*
+ * GPIOs
+ */
+/* PXA GPIOs */
+#define POODLE_GPIO_ON_KEY		(0)
+#define POODLE_GPIO_AC_IN		(1)
+#define POODLE_GPIO_CO			16
+#define POODLE_GPIO_TP_INT		(5)
+#define POODLE_GPIO_WAKEUP		(11)	/* change battery */
+#define POODLE_GPIO_GA_INT		(10)
+#define POODLE_GPIO_IR_ON		(22)
+#define POODLE_GPIO_HP_IN		(4)
+#define POODLE_GPIO_CF_IRQ		(17)
+#define POODLE_GPIO_CF_CD		(14)
+#define POODLE_GPIO_CF_STSCHG		(14)
+#define POODLE_GPIO_SD_PWR		(33)
+#define POODLE_GPIO_SD_PWR1		(3)
+#define POODLE_GPIO_nSD_CLK		(6)
+#define POODLE_GPIO_nSD_WP		(7)
+#define POODLE_GPIO_nSD_INT		(8)
+#define POODLE_GPIO_nSD_DETECT		(9)
+#define POODLE_GPIO_MAIN_BAT_LOW	(13)
+#define POODLE_GPIO_BAT_COVER		(13)
+#define POODLE_GPIO_USB_PULLUP		(20)
+#define POODLE_GPIO_ADC_TEMP_ON		(21)
+#define POODLE_GPIO_BYPASS_ON		(36)
+#define POODLE_GPIO_CHRG_ON		(38)
+#define POODLE_GPIO_CHRG_FULL		(16)
+#define POODLE_GPIO_DISCHARGE_ON        (42) /* Enable battery discharge */
+
+/* PXA GPIOs */
+#define POODLE_IRQ_GPIO_ON_KEY		IRQ_GPIO(0)
+#define POODLE_IRQ_GPIO_AC_IN		IRQ_GPIO(1)
+#define POODLE_IRQ_GPIO_HP_IN		IRQ_GPIO(4)
+#define POODLE_IRQ_GPIO_CO		IRQ_GPIO(16)
+#define POODLE_IRQ_GPIO_TP_INT		IRQ_GPIO(5)
+#define POODLE_IRQ_GPIO_WAKEUP		IRQ_GPIO(11)
+#define POODLE_IRQ_GPIO_GA_INT		IRQ_GPIO(10)
+#define POODLE_IRQ_GPIO_CF_IRQ		IRQ_GPIO(17)
+#define POODLE_IRQ_GPIO_CF_CD		IRQ_GPIO(14)
+#define POODLE_IRQ_GPIO_nSD_INT		IRQ_GPIO(8)
+#define POODLE_IRQ_GPIO_nSD_DETECT	IRQ_GPIO(9)
+#define POODLE_IRQ_GPIO_MAIN_BAT_LOW	IRQ_GPIO(13)
+
+/* SCOOP GPIOs */
+#define POODLE_SCOOP_CHARGE_ON	SCOOP_GPCR_PA11
+#define POODLE_SCOOP_CP401	SCOOP_GPCR_PA13
+#define POODLE_SCOOP_VPEN	SCOOP_GPCR_PA18
+#define POODLE_SCOOP_L_PCLK	SCOOP_GPCR_PA20
+#define POODLE_SCOOP_L_LCLK	SCOOP_GPCR_PA21
+#define POODLE_SCOOP_HS_OUT	SCOOP_GPCR_PA22
+
+#define POODLE_SCOOP_IO_DIR	( POODLE_SCOOP_VPEN | POODLE_SCOOP_HS_OUT )
+#define POODLE_SCOOP_IO_OUT	( 0 )
+
+extern struct platform_device poodle_locomo_device;
+
+#endif /* __ASM_ARCH_POODLE_H  */
Index: build_tree/linux/include/asm/arch/pxa-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch/pxa-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/pxa-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,2369 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/pxa-regs.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __PXA_REGS_H
+#define __PXA_REGS_H
+
+
+/*
+ * PXA Chip selects
+ */
+
+#define PXA_CS0_PHYS	0x00000000
+#define PXA_CS1_PHYS	0x04000000
+#define PXA_CS2_PHYS	0x08000000
+#define PXA_CS3_PHYS	0x0C000000
+#define PXA_CS4_PHYS	0x10000000
+#define PXA_CS5_PHYS	0x14000000
+
+
+/*
+ * Personal Computer Memory Card International Association (PCMCIA) sockets
+ */
+
+#define PCMCIAPrtSp	0x04000000	/* PCMCIA Partition Space [byte]   */
+#define PCMCIASp	(4*PCMCIAPrtSp)	/* PCMCIA Space [byte]             */
+#define PCMCIAIOSp	PCMCIAPrtSp	/* PCMCIA I/O Space [byte]         */
+#define PCMCIAAttrSp	PCMCIAPrtSp	/* PCMCIA Attribute Space [byte]   */
+#define PCMCIAMemSp	PCMCIAPrtSp	/* PCMCIA Memory Space [byte]      */
+
+#define PCMCIA0Sp	PCMCIASp	/* PCMCIA 0 Space [byte]           */
+#define PCMCIA0IOSp	PCMCIAIOSp	/* PCMCIA 0 I/O Space [byte]       */
+#define PCMCIA0AttrSp	PCMCIAAttrSp	/* PCMCIA 0 Attribute Space [byte] */
+#define PCMCIA0MemSp	PCMCIAMemSp	/* PCMCIA 0 Memory Space [byte]    */
+
+#define PCMCIA1Sp	PCMCIASp	/* PCMCIA 1 Space [byte]           */
+#define PCMCIA1IOSp	PCMCIAIOSp	/* PCMCIA 1 I/O Space [byte]       */
+#define PCMCIA1AttrSp	PCMCIAAttrSp	/* PCMCIA 1 Attribute Space [byte] */
+#define PCMCIA1MemSp	PCMCIAMemSp	/* PCMCIA 1 Memory Space [byte]    */
+
+#define _PCMCIA(Nb)	        	/* PCMCIA [0..1]                   */ \
+                	(0x20000000 + (Nb)*PCMCIASp)
+#define _PCMCIAIO(Nb)	_PCMCIA (Nb)	/* PCMCIA I/O [0..1]               */
+#define _PCMCIAAttr(Nb)	        	/* PCMCIA Attribute [0..1]         */ \
+                	(_PCMCIA (Nb) + 2*PCMCIAPrtSp)
+#define _PCMCIAMem(Nb)	        	/* PCMCIA Memory [0..1]            */ \
+                	(_PCMCIA (Nb) + 3*PCMCIAPrtSp)
+
+#define _PCMCIA0	_PCMCIA (0)	/* PCMCIA 0                        */
+#define _PCMCIA0IO	_PCMCIAIO (0)	/* PCMCIA 0 I/O                    */
+#define _PCMCIA0Attr	_PCMCIAAttr (0)	/* PCMCIA 0 Attribute              */
+#define _PCMCIA0Mem	_PCMCIAMem (0)	/* PCMCIA 0 Memory                 */
+
+#define _PCMCIA1	_PCMCIA (1)	/* PCMCIA 1                        */
+#define _PCMCIA1IO	_PCMCIAIO (1)	/* PCMCIA 1 I/O                    */
+#define _PCMCIA1Attr	_PCMCIAAttr (1)	/* PCMCIA 1 Attribute              */
+#define _PCMCIA1Mem	_PCMCIAMem (1)	/* PCMCIA 1 Memory                 */
+
+
+
+/*
+ * DMA Controller
+ */
+
+#define DCSR0		__REG(0x40000000)  /* DMA Control / Status Register for Channel 0 */
+#define DCSR1		__REG(0x40000004)  /* DMA Control / Status Register for Channel 1 */
+#define DCSR2		__REG(0x40000008)  /* DMA Control / Status Register for Channel 2 */
+#define DCSR3		__REG(0x4000000c)  /* DMA Control / Status Register for Channel 3 */
+#define DCSR4		__REG(0x40000010)  /* DMA Control / Status Register for Channel 4 */
+#define DCSR5		__REG(0x40000014)  /* DMA Control / Status Register for Channel 5 */
+#define DCSR6		__REG(0x40000018)  /* DMA Control / Status Register for Channel 6 */
+#define DCSR7		__REG(0x4000001c)  /* DMA Control / Status Register for Channel 7 */
+#define DCSR8		__REG(0x40000020)  /* DMA Control / Status Register for Channel 8 */
+#define DCSR9		__REG(0x40000024)  /* DMA Control / Status Register for Channel 9 */
+#define DCSR10		__REG(0x40000028)  /* DMA Control / Status Register for Channel 10 */
+#define DCSR11		__REG(0x4000002c)  /* DMA Control / Status Register for Channel 11 */
+#define DCSR12		__REG(0x40000030)  /* DMA Control / Status Register for Channel 12 */
+#define DCSR13		__REG(0x40000034)  /* DMA Control / Status Register for Channel 13 */
+#define DCSR14		__REG(0x40000038)  /* DMA Control / Status Register for Channel 14 */
+#define DCSR15		__REG(0x4000003c)  /* DMA Control / Status Register for Channel 15 */
+
+#define DCSR(x)		__REG2(0x40000000, (x) << 2)
+
+#define DCSR_RUN	(1 << 31)	/* Run Bit (read / write) */
+#define DCSR_NODESC	(1 << 30)	/* No-Descriptor Fetch (read / write) */
+#define DCSR_STOPIRQEN	(1 << 29)	/* Stop Interrupt Enable (read / write) */
+#ifdef CONFIG_PXA27x
+#define DCSR_EORIRQEN	(1 << 28)       /* End of Receive Interrupt Enable (R/W) */
+#define DCSR_EORJMPEN	(1 << 27)       /* Jump to next descriptor on EOR */
+#define DCSR_EORSTOPEN	(1 << 26)       /* STOP on an EOR */
+#define DCSR_SETCMPST	(1 << 25)       /* Set Descriptor Compare Status */
+#define DCSR_CLRCMPST	(1 << 24)       /* Clear Descriptor Compare Status */
+#define DCSR_CMPST	(1 << 10)       /* The Descriptor Compare Status */
+#define DCSR_EORINTR	(1 << 9)        /* The end of Receive */
+#endif
+#define DCSR_REQPEND	(1 << 8)	/* Request Pending (read-only) */
+#define DCSR_STOPSTATE	(1 << 3)	/* Stop State (read-only) */
+#define DCSR_ENDINTR	(1 << 2)	/* End Interrupt (read / write) */
+#define DCSR_STARTINTR	(1 << 1)	/* Start Interrupt (read / write) */
+#define DCSR_BUSERR	(1 << 0)	/* Bus Error Interrupt (read / write) */
+
+#define DALGN		__REG(0x400000a0)  /* DMA Alignment Register */
+#define DINT		__REG(0x400000f0)  /* DMA Interrupt Register */
+
+#define DRCMR(n)	__REG2(0x40000100, (n)<<2)
+#define DRCMR0		__REG(0x40000100)  /* Request to Channel Map Register for DREQ 0 */
+#define DRCMR1		__REG(0x40000104)  /* Request to Channel Map Register for DREQ 1 */
+#define DRCMR2		__REG(0x40000108)  /* Request to Channel Map Register for I2S receive Request */
+#define DRCMR3		__REG(0x4000010c)  /* Request to Channel Map Register for I2S transmit Request */
+#define DRCMR4		__REG(0x40000110)  /* Request to Channel Map Register for BTUART receive Request */
+#define DRCMR5		__REG(0x40000114)  /* Request to Channel Map Register for BTUART transmit Request. */
+#define DRCMR6		__REG(0x40000118)  /* Request to Channel Map Register for FFUART receive Request */
+#define DRCMR7		__REG(0x4000011c)  /* Request to Channel Map Register for FFUART transmit Request */
+#define DRCMR8		__REG(0x40000120)  /* Request to Channel Map Register for AC97 microphone Request */
+#define DRCMR9		__REG(0x40000124)  /* Request to Channel Map Register for AC97 modem receive Request */
+#define DRCMR10		__REG(0x40000128)  /* Request to Channel Map Register for AC97 modem transmit Request */
+#define DRCMR11		__REG(0x4000012c)  /* Request to Channel Map Register for AC97 audio receive Request */
+#define DRCMR12		__REG(0x40000130)  /* Request to Channel Map Register for AC97 audio transmit Request */
+#define DRCMR13		__REG(0x40000134)  /* Request to Channel Map Register for SSP receive Request */
+#define DRCMR14		__REG(0x40000138)  /* Request to Channel Map Register for SSP transmit Request */
+#define DRCMR15		__REG(0x4000013c)  /* Request to Channel Map Register for SSP2 receive Request */
+#define DRCMR16		__REG(0x40000140)  /* Request to Channel Map Register for SSP2 transmit Request */
+#define DRCMR17		__REG(0x40000144)  /* Request to Channel Map Register for ICP receive Request */
+#define DRCMR18		__REG(0x40000148)  /* Request to Channel Map Register for ICP transmit Request */
+#define DRCMR19		__REG(0x4000014c)  /* Request to Channel Map Register for STUART receive Request */
+#define DRCMR20		__REG(0x40000150)  /* Request to Channel Map Register for STUART transmit Request */
+#define DRCMR21		__REG(0x40000154)  /* Request to Channel Map Register for MMC receive Request */
+#define DRCMR22		__REG(0x40000158)  /* Request to Channel Map Register for MMC transmit Request */
+#define DRCMR23		__REG(0x4000015c)  /* Reserved */
+#define DRCMR24		__REG(0x40000160)  /* Reserved */
+#define DRCMR25		__REG(0x40000164)  /* Request to Channel Map Register for USB endpoint 1 Request */
+#define DRCMR26		__REG(0x40000168)  /* Request to Channel Map Register for USB endpoint 2 Request */
+#define DRCMR27		__REG(0x4000016C)  /* Request to Channel Map Register for USB endpoint 3 Request */
+#define DRCMR28		__REG(0x40000170)  /* Request to Channel Map Register for USB endpoint 4 Request */
+#define DRCMR29		__REG(0x40000174)  /* Reserved */
+#define DRCMR30		__REG(0x40000178)  /* Request to Channel Map Register for USB endpoint 6 Request */
+#define DRCMR31		__REG(0x4000017C)  /* Request to Channel Map Register for USB endpoint 7 Request */
+#define DRCMR32		__REG(0x40000180)  /* Request to Channel Map Register for USB endpoint 8 Request */
+#define DRCMR33		__REG(0x40000184)  /* Request to Channel Map Register for USB endpoint 9 Request */
+#define DRCMR34		__REG(0x40000188)  /* Reserved */
+#define DRCMR35		__REG(0x4000018C)  /* Request to Channel Map Register for USB endpoint 11 Request */
+#define DRCMR36		__REG(0x40000190)  /* Request to Channel Map Register for USB endpoint 12 Request */
+#define DRCMR37		__REG(0x40000194)  /* Request to Channel Map Register for USB endpoint 13 Request */
+#define DRCMR38		__REG(0x40000198)  /* Request to Channel Map Register for USB endpoint 14 Request */
+#define DRCMR39		__REG(0x4000019C)  /* Reserved */
+#define DRCMR66		__REG(0x40001108)  /* Request to Channel Map Register for SSP3 receive Request */
+#define DRCMR67		__REG(0x4000110C)  /* Request to Channel Map Register for SSP3 transmit Request */
+#define DRCMR68		__REG(0x40001110)  /* Request to Channel Map Register for Camera FIFO 0 Request */
+#define DRCMR69		__REG(0x40001114)  /* Request to Channel Map Register for Camera FIFO 1 Request */
+#define DRCMR70		__REG(0x40001118)  /* Request to Channel Map Register for Camera FIFO 2 Request */
+
+#define DRCMRRXSADR	DRCMR2
+#define DRCMRTXSADR	DRCMR3
+#define DRCMRRXBTRBR	DRCMR4
+#define DRCMRTXBTTHR	DRCMR5
+#define DRCMRRXFFRBR	DRCMR6
+#define DRCMRTXFFTHR	DRCMR7
+#define DRCMRRXMCDR	DRCMR8
+#define DRCMRRXMODR	DRCMR9
+#define DRCMRTXMODR	DRCMR10
+#define DRCMRRXPCDR	DRCMR11
+#define DRCMRTXPCDR	DRCMR12
+#define DRCMRRXSSDR	DRCMR13
+#define DRCMRTXSSDR	DRCMR14
+#define DRCMRRXSS2DR   DRCMR15
+#define DRCMRTXSS2DR   DRCMR16
+#define DRCMRRXICDR	DRCMR17
+#define DRCMRTXICDR	DRCMR18
+#define DRCMRRXSTRBR	DRCMR19
+#define DRCMRTXSTTHR	DRCMR20
+#define DRCMRRXMMC	DRCMR21
+#define DRCMRTXMMC	DRCMR22
+#define DRCMRRXSS3DR   DRCMR66
+#define DRCMRTXSS3DR   DRCMR67
+#define DRCMRUDC(x)	DRCMR((x) + 24)
+
+#define DRCMR_MAPVLD	(1 << 7)	/* Map Valid (read / write) */
+#define DRCMR_CHLNUM	0x1f		/* mask for Channel Number (read / write) */
+
+#define DDADR0		__REG(0x40000200)  /* DMA Descriptor Address Register Channel 0 */
+#define DSADR0		__REG(0x40000204)  /* DMA Source Address Register Channel 0 */
+#define DTADR0		__REG(0x40000208)  /* DMA Target Address Register Channel 0 */
+#define DCMD0		__REG(0x4000020c)  /* DMA Command Address Register Channel 0 */
+#define DDADR1		__REG(0x40000210)  /* DMA Descriptor Address Register Channel 1 */
+#define DSADR1		__REG(0x40000214)  /* DMA Source Address Register Channel 1 */
+#define DTADR1		__REG(0x40000218)  /* DMA Target Address Register Channel 1 */
+#define DCMD1		__REG(0x4000021c)  /* DMA Command Address Register Channel 1 */
+#define DDADR2		__REG(0x40000220)  /* DMA Descriptor Address Register Channel 2 */
+#define DSADR2		__REG(0x40000224)  /* DMA Source Address Register Channel 2 */
+#define DTADR2		__REG(0x40000228)  /* DMA Target Address Register Channel 2 */
+#define DCMD2		__REG(0x4000022c)  /* DMA Command Address Register Channel 2 */
+#define DDADR3		__REG(0x40000230)  /* DMA Descriptor Address Register Channel 3 */
+#define DSADR3		__REG(0x40000234)  /* DMA Source Address Register Channel 3 */
+#define DTADR3		__REG(0x40000238)  /* DMA Target Address Register Channel 3 */
+#define DCMD3		__REG(0x4000023c)  /* DMA Command Address Register Channel 3 */
+#define DDADR4		__REG(0x40000240)  /* DMA Descriptor Address Register Channel 4 */
+#define DSADR4		__REG(0x40000244)  /* DMA Source Address Register Channel 4 */
+#define DTADR4		__REG(0x40000248)  /* DMA Target Address Register Channel 4 */
+#define DCMD4		__REG(0x4000024c)  /* DMA Command Address Register Channel 4 */
+#define DDADR5		__REG(0x40000250)  /* DMA Descriptor Address Register Channel 5 */
+#define DSADR5		__REG(0x40000254)  /* DMA Source Address Register Channel 5 */
+#define DTADR5		__REG(0x40000258)  /* DMA Target Address Register Channel 5 */
+#define DCMD5		__REG(0x4000025c)  /* DMA Command Address Register Channel 5 */
+#define DDADR6		__REG(0x40000260)  /* DMA Descriptor Address Register Channel 6 */
+#define DSADR6		__REG(0x40000264)  /* DMA Source Address Register Channel 6 */
+#define DTADR6		__REG(0x40000268)  /* DMA Target Address Register Channel 6 */
+#define DCMD6		__REG(0x4000026c)  /* DMA Command Address Register Channel 6 */
+#define DDADR7		__REG(0x40000270)  /* DMA Descriptor Address Register Channel 7 */
+#define DSADR7		__REG(0x40000274)  /* DMA Source Address Register Channel 7 */
+#define DTADR7		__REG(0x40000278)  /* DMA Target Address Register Channel 7 */
+#define DCMD7		__REG(0x4000027c)  /* DMA Command Address Register Channel 7 */
+#define DDADR8		__REG(0x40000280)  /* DMA Descriptor Address Register Channel 8 */
+#define DSADR8		__REG(0x40000284)  /* DMA Source Address Register Channel 8 */
+#define DTADR8		__REG(0x40000288)  /* DMA Target Address Register Channel 8 */
+#define DCMD8		__REG(0x4000028c)  /* DMA Command Address Register Channel 8 */
+#define DDADR9		__REG(0x40000290)  /* DMA Descriptor Address Register Channel 9 */
+#define DSADR9		__REG(0x40000294)  /* DMA Source Address Register Channel 9 */
+#define DTADR9		__REG(0x40000298)  /* DMA Target Address Register Channel 9 */
+#define DCMD9		__REG(0x4000029c)  /* DMA Command Address Register Channel 9 */
+#define DDADR10		__REG(0x400002a0)  /* DMA Descriptor Address Register Channel 10 */
+#define DSADR10		__REG(0x400002a4)  /* DMA Source Address Register Channel 10 */
+#define DTADR10		__REG(0x400002a8)  /* DMA Target Address Register Channel 10 */
+#define DCMD10		__REG(0x400002ac)  /* DMA Command Address Register Channel 10 */
+#define DDADR11		__REG(0x400002b0)  /* DMA Descriptor Address Register Channel 11 */
+#define DSADR11		__REG(0x400002b4)  /* DMA Source Address Register Channel 11 */
+#define DTADR11		__REG(0x400002b8)  /* DMA Target Address Register Channel 11 */
+#define DCMD11		__REG(0x400002bc)  /* DMA Command Address Register Channel 11 */
+#define DDADR12		__REG(0x400002c0)  /* DMA Descriptor Address Register Channel 12 */
+#define DSADR12		__REG(0x400002c4)  /* DMA Source Address Register Channel 12 */
+#define DTADR12		__REG(0x400002c8)  /* DMA Target Address Register Channel 12 */
+#define DCMD12		__REG(0x400002cc)  /* DMA Command Address Register Channel 12 */
+#define DDADR13		__REG(0x400002d0)  /* DMA Descriptor Address Register Channel 13 */
+#define DSADR13		__REG(0x400002d4)  /* DMA Source Address Register Channel 13 */
+#define DTADR13		__REG(0x400002d8)  /* DMA Target Address Register Channel 13 */
+#define DCMD13		__REG(0x400002dc)  /* DMA Command Address Register Channel 13 */
+#define DDADR14		__REG(0x400002e0)  /* DMA Descriptor Address Register Channel 14 */
+#define DSADR14		__REG(0x400002e4)  /* DMA Source Address Register Channel 14 */
+#define DTADR14		__REG(0x400002e8)  /* DMA Target Address Register Channel 14 */
+#define DCMD14		__REG(0x400002ec)  /* DMA Command Address Register Channel 14 */
+#define DDADR15		__REG(0x400002f0)  /* DMA Descriptor Address Register Channel 15 */
+#define DSADR15		__REG(0x400002f4)  /* DMA Source Address Register Channel 15 */
+#define DTADR15		__REG(0x400002f8)  /* DMA Target Address Register Channel 15 */
+#define DCMD15		__REG(0x400002fc)  /* DMA Command Address Register Channel 15 */
+
+#define DDADR(x)	__REG2(0x40000200, (x) << 4)
+#define DSADR(x)	__REG2(0x40000204, (x) << 4)
+#define DTADR(x)	__REG2(0x40000208, (x) << 4)
+#define DCMD(x)		__REG2(0x4000020c, (x) << 4)
+
+#define DDADR_DESCADDR	0xfffffff0	/* Address of next descriptor (mask) */
+#define DDADR_STOP	(1 << 0)	/* Stop (read / write) */
+
+#define DCMD_INCSRCADDR	(1 << 31)	/* Source Address Increment Setting. */
+#define DCMD_INCTRGADDR	(1 << 30)	/* Target Address Increment Setting. */
+#define DCMD_FLOWSRC	(1 << 29)	/* Flow Control by the source. */
+#define DCMD_FLOWTRG	(1 << 28)	/* Flow Control by the target. */
+#define DCMD_STARTIRQEN	(1 << 22)	/* Start Interrupt Enable */
+#define DCMD_ENDIRQEN	(1 << 21)	/* End Interrupt Enable */
+#define DCMD_ENDIAN	(1 << 18)	/* Device Endian-ness. */
+#define DCMD_BURST8	(1 << 16)	/* 8 byte burst */
+#define DCMD_BURST16	(2 << 16)	/* 16 byte burst */
+#define DCMD_BURST32	(3 << 16)	/* 32 byte burst */
+#define DCMD_WIDTH1	(1 << 14)	/* 1 byte width */
+#define DCMD_WIDTH2	(2 << 14)	/* 2 byte width (HalfWord) */
+#define DCMD_WIDTH4	(3 << 14)	/* 4 byte width (Word) */
+#define DCMD_LENGTH	0x01fff		/* length mask (max = 8K - 1) */
+
+
+/*
+ * UARTs
+ */
+
+/* Full Function UART (FFUART) */
+#define FFUART		FFRBR
+#define FFRBR		__REG(0x40100000)  /* Receive Buffer Register (read only) */
+#define FFTHR		__REG(0x40100000)  /* Transmit Holding Register (write only) */
+#define FFIER		__REG(0x40100004)  /* Interrupt Enable Register (read/write) */
+#define FFIIR		__REG(0x40100008)  /* Interrupt ID Register (read only) */
+#define FFFCR		__REG(0x40100008)  /* FIFO Control Register (write only) */
+#define FFLCR		__REG(0x4010000C)  /* Line Control Register (read/write) */
+#define FFMCR		__REG(0x40100010)  /* Modem Control Register (read/write) */
+#define FFLSR		__REG(0x40100014)  /* Line Status Register (read only) */
+#define FFMSR		__REG(0x40100018)  /* Modem Status Register (read only) */
+#define FFSPR		__REG(0x4010001C)  /* Scratch Pad Register (read/write) */
+#define FFISR		__REG(0x40100020)  /* Infrared Selection Register (read/write) */
+#define FFDLL		__REG(0x40100000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define FFDLH		__REG(0x40100004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Bluetooth UART (BTUART) */
+#define BTUART		BTRBR
+#define BTRBR		__REG(0x40200000)  /* Receive Buffer Register (read only) */
+#define BTTHR		__REG(0x40200000)  /* Transmit Holding Register (write only) */
+#define BTIER		__REG(0x40200004)  /* Interrupt Enable Register (read/write) */
+#define BTIIR		__REG(0x40200008)  /* Interrupt ID Register (read only) */
+#define BTFCR		__REG(0x40200008)  /* FIFO Control Register (write only) */
+#define BTLCR		__REG(0x4020000C)  /* Line Control Register (read/write) */
+#define BTMCR		__REG(0x40200010)  /* Modem Control Register (read/write) */
+#define BTLSR		__REG(0x40200014)  /* Line Status Register (read only) */
+#define BTMSR		__REG(0x40200018)  /* Modem Status Register (read only) */
+#define BTSPR		__REG(0x4020001C)  /* Scratch Pad Register (read/write) */
+#define BTISR		__REG(0x40200020)  /* Infrared Selection Register (read/write) */
+#define BTDLL		__REG(0x40200000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define BTDLH		__REG(0x40200004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Standard UART (STUART) */
+#define STUART		STRBR
+#define STRBR		__REG(0x40700000)  /* Receive Buffer Register (read only) */
+#define STTHR		__REG(0x40700000)  /* Transmit Holding Register (write only) */
+#define STIER		__REG(0x40700004)  /* Interrupt Enable Register (read/write) */
+#define STIIR		__REG(0x40700008)  /* Interrupt ID Register (read only) */
+#define STFCR		__REG(0x40700008)  /* FIFO Control Register (write only) */
+#define STLCR		__REG(0x4070000C)  /* Line Control Register (read/write) */
+#define STMCR		__REG(0x40700010)  /* Modem Control Register (read/write) */
+#define STLSR		__REG(0x40700014)  /* Line Status Register (read only) */
+#define STMSR		__REG(0x40700018)  /* Reserved */
+#define STSPR		__REG(0x4070001C)  /* Scratch Pad Register (read/write) */
+#define STISR		__REG(0x40700020)  /* Infrared Selection Register (read/write) */
+#define STDLL		__REG(0x40700000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define STDLH		__REG(0x40700004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Hardware UART (HWUART) */
+#define HWUART		HWRBR
+#define HWRBR		__REG(0x41600000)  /* Receive Buffer Register (read only) */
+#define HWTHR		__REG(0x41600000)  /* Transmit Holding Register (write only) */
+#define HWIER		__REG(0x41600004)  /* Interrupt Enable Register (read/write) */
+#define HWIIR		__REG(0x41600008)  /* Interrupt ID Register (read only) */
+#define HWFCR		__REG(0x41600008)  /* FIFO Control Register (write only) */
+#define HWLCR		__REG(0x4160000C)  /* Line Control Register (read/write) */
+#define HWMCR		__REG(0x41600010)  /* Modem Control Register (read/write) */
+#define HWLSR		__REG(0x41600014)  /* Line Status Register (read only) */
+#define HWMSR		__REG(0x41600018)  /* Modem Status Register (read only) */
+#define HWSPR		__REG(0x4160001C)  /* Scratch Pad Register (read/write) */
+#define HWISR		__REG(0x41600020)  /* Infrared Selection Register (read/write) */
+#define HWFOR		__REG(0x41600024)  /* Receive FIFO Occupancy Register (read only) */
+#define HWABR		__REG(0x41600028)  /* Auto-Baud Control Register (read/write) */
+#define HWACR		__REG(0x4160002C)  /* Auto-Baud Count Register (read only) */
+#define HWDLL		__REG(0x41600000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define HWDLH		__REG(0x41600004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+#define IER_DMAE	(1 << 7)	/* DMA Requests Enable */
+#define IER_UUE		(1 << 6)	/* UART Unit Enable */
+#define IER_NRZE	(1 << 5)	/* NRZ coding Enable */
+#define IER_RTIOE	(1 << 4)	/* Receiver Time Out Interrupt Enable */
+#define IER_MIE		(1 << 3)	/* Modem Interrupt Enable */
+#define IER_RLSE	(1 << 2)	/* Receiver Line Status Interrupt Enable */
+#define IER_TIE		(1 << 1)	/* Transmit Data request Interrupt Enable */
+#define IER_RAVIE	(1 << 0)	/* Receiver Data Available Interrupt Enable */
+
+#define IIR_FIFOES1	(1 << 7)	/* FIFO Mode Enable Status */
+#define IIR_FIFOES0	(1 << 6)	/* FIFO Mode Enable Status */
+#define IIR_TOD		(1 << 3)	/* Time Out Detected */
+#define IIR_IID2	(1 << 2)	/* Interrupt Source Encoded */
+#define IIR_IID1	(1 << 1)	/* Interrupt Source Encoded */
+#define IIR_IP		(1 << 0)	/* Interrupt Pending (active low) */
+
+#define FCR_ITL2	(1 << 7)	/* Interrupt Trigger Level */
+#define FCR_ITL1	(1 << 6)	/* Interrupt Trigger Level */
+#define FCR_RESETTF	(1 << 2)	/* Reset Transmitter FIFO */
+#define FCR_RESETRF	(1 << 1)	/* Reset Receiver FIFO */
+#define FCR_TRFIFOE	(1 << 0)	/* Transmit and Receive FIFO Enable */
+#define FCR_ITL_1	(0)
+#define FCR_ITL_8	(FCR_ITL1)
+#define FCR_ITL_16	(FCR_ITL2)
+#define FCR_ITL_32	(FCR_ITL2|FCR_ITL1)
+
+#define LCR_DLAB	(1 << 7)	/* Divisor Latch Access Bit */
+#define LCR_SB		(1 << 6)	/* Set Break */
+#define LCR_STKYP	(1 << 5)	/* Sticky Parity */
+#define LCR_EPS		(1 << 4)	/* Even Parity Select */
+#define LCR_PEN		(1 << 3)	/* Parity Enable */
+#define LCR_STB		(1 << 2)	/* Stop Bit */
+#define LCR_WLS1	(1 << 1)	/* Word Length Select */
+#define LCR_WLS0	(1 << 0)	/* Word Length Select */
+
+#define LSR_FIFOE	(1 << 7)	/* FIFO Error Status */
+#define LSR_TEMT	(1 << 6)	/* Transmitter Empty */
+#define LSR_TDRQ	(1 << 5)	/* Transmit Data Request */
+#define LSR_BI		(1 << 4)	/* Break Interrupt */
+#define LSR_FE		(1 << 3)	/* Framing Error */
+#define LSR_PE		(1 << 2)	/* Parity Error */
+#define LSR_OE		(1 << 1)	/* Overrun Error */
+#define LSR_DR		(1 << 0)	/* Data Ready */
+
+#define MCR_LOOP	(1 << 4)
+#define MCR_OUT2	(1 << 3)	/* force MSR_DCD in loopback mode */
+#define MCR_OUT1	(1 << 2)	/* force MSR_RI in loopback mode */
+#define MCR_RTS		(1 << 1)	/* Request to Send */
+#define MCR_DTR		(1 << 0)	/* Data Terminal Ready */
+
+#define MSR_DCD		(1 << 7)	/* Data Carrier Detect */
+#define MSR_RI		(1 << 6)	/* Ring Indicator */
+#define MSR_DSR		(1 << 5)	/* Data Set Ready */
+#define MSR_CTS		(1 << 4)	/* Clear To Send */
+#define MSR_DDCD	(1 << 3)	/* Delta Data Carrier Detect */
+#define MSR_TERI	(1 << 2)	/* Trailing Edge Ring Indicator */
+#define MSR_DDSR	(1 << 1)	/* Delta Data Set Ready */
+#define MSR_DCTS	(1 << 0)	/* Delta Clear To Send */
+
+/*
+ * IrSR (Infrared Selection Register)
+ */
+#define STISR_RXPL      (1 << 4)        /* Receive Data Polarity */
+#define STISR_TXPL      (1 << 3)        /* Transmit Data Polarity */
+#define STISR_XMODE     (1 << 2)        /* Transmit Pulse Width Select */
+#define STISR_RCVEIR    (1 << 1)        /* Receiver SIR Enable */
+#define STISR_XMITIR    (1 << 0)        /* Transmitter SIR Enable */
+
+
+/*
+ * I2C registers
+ */
+
+#define IBMR		__REG(0x40301680)  /* I2C Bus Monitor Register - IBMR */
+#define IDBR		__REG(0x40301688)  /* I2C Data Buffer Register - IDBR */
+#define ICR		__REG(0x40301690)  /* I2C Control Register - ICR */
+#define ISR		__REG(0x40301698)  /* I2C Status Register - ISR */
+#define ISAR		__REG(0x403016A0)  /* I2C Slave Address Register - ISAR */
+
+#define PWRIBMR    __REG(0x40f00180)  /* Power I2C Bus Monitor Register-IBMR */
+#define PWRIDBR    __REG(0x40f00188)  /* Power I2C Data Buffer Register-IDBR */
+#define PWRICR __REG(0x40f00190)  /* Power I2C Control Register - ICR */
+#define PWRISR __REG(0x40f00198)  /* Power I2C Status Register - ISR */
+#define PWRISAR    __REG(0x40f001A0)  /*Power I2C Slave Address Register-ISAR */
+
+#define ICR_START	(1 << 0)	   /* start bit */
+#define ICR_STOP	(1 << 1)	   /* stop bit */
+#define ICR_ACKNAK	(1 << 2)	   /* send ACK(0) or NAK(1) */
+#define ICR_TB		(1 << 3)	   /* transfer byte bit */
+#define ICR_MA		(1 << 4)	   /* master abort */
+#define ICR_SCLE	(1 << 5)	   /* master clock enable */
+#define ICR_IUE		(1 << 6)	   /* unit enable */
+#define ICR_GCD		(1 << 7)	   /* general call disable */
+#define ICR_ITEIE	(1 << 8)	   /* enable tx interrupts */
+#define ICR_IRFIE	(1 << 9)	   /* enable rx interrupts */
+#define ICR_BEIE	(1 << 10)	   /* enable bus error ints */
+#define ICR_SSDIE	(1 << 11)	   /* slave STOP detected int enable */
+#define ICR_ALDIE	(1 << 12)	   /* enable arbitration interrupt */
+#define ICR_SADIE	(1 << 13)	   /* slave address detected int enable */
+#define ICR_UR		(1 << 14)	   /* unit reset */
+
+#define ISR_RWM		(1 << 0)	   /* read/write mode */
+#define ISR_ACKNAK	(1 << 1)	   /* ack/nak status */
+#define ISR_UB		(1 << 2)	   /* unit busy */
+#define ISR_IBB		(1 << 3)	   /* bus busy */
+#define ISR_SSD		(1 << 4)	   /* slave stop detected */
+#define ISR_ALD		(1 << 5)	   /* arbitration loss detected */
+#define ISR_ITE		(1 << 6)	   /* tx buffer empty */
+#define ISR_IRF		(1 << 7)	   /* rx buffer full */
+#define ISR_GCAD	(1 << 8)	   /* general call address detected */
+#define ISR_SAD		(1 << 9)	   /* slave address detected */
+#define ISR_BED		(1 << 10)	   /* bus error no ACK/NAK */
+
+
+/*
+ * Serial Audio Controller
+ */
+
+#define SACR0		__REG(0x40400000)  /* Global Control Register */
+#define SACR1		__REG(0x40400004)  /* Serial Audio I 2 S/MSB-Justified Control Register */
+#define SASR0		__REG(0x4040000C)  /* Serial Audio I 2 S/MSB-Justified Interface and FIFO Status Register */
+#define SAIMR		__REG(0x40400014)  /* Serial Audio Interrupt Mask Register */
+#define SAICR		__REG(0x40400018)  /* Serial Audio Interrupt Clear Register */
+#define SADIV		__REG(0x40400060)  /* Audio Clock Divider Register. */
+#define SADR		__REG(0x40400080)  /* Serial Audio Data Register (TX and RX FIFO access Register). */
+
+#define SACR0_RFTH(x)	((x) << 12)	/* Rx FIFO Interrupt or DMA Trigger Threshold */
+#define SACR0_TFTH(x)	((x) << 8)	/* Tx FIFO Interrupt or DMA Trigger Threshold */
+#define SACR0_STRF	(1 << 5)	/* FIFO Select for EFWR Special Function */
+#define SACR0_EFWR	(1 << 4)	/* Enable EFWR Function  */
+#define SACR0_RST	(1 << 3)	/* FIFO, i2s Register Reset */
+#define SACR0_BCKD	(1 << 2) 	/* Bit Clock Direction */
+#define SACR0_ENB	(1 << 0)	/* Enable I2S Link */
+#define SACR1_ENLBF	(1 << 5)	/* Enable Loopback */
+#define SACR1_DRPL	(1 << 4) 	/* Disable Replaying Function */
+#define SACR1_DREC	(1 << 3)	/* Disable Recording Function */
+#define SACR1_AMSL	(1 << 0)	/* Specify Alternate Mode */
+
+#define SASR0_I2SOFF	(1 << 7)	/* Controller Status */
+#define SASR0_ROR	(1 << 6)	/* Rx FIFO Overrun */
+#define SASR0_TUR	(1 << 5)	/* Tx FIFO Underrun */
+#define SASR0_RFS	(1 << 4)	/* Rx FIFO Service Request */
+#define SASR0_TFS	(1 << 3)	/* Tx FIFO Service Request */
+#define SASR0_BSY	(1 << 2)	/* I2S Busy */
+#define SASR0_RNE	(1 << 1)	/* Rx FIFO Not Empty */
+#define SASR0_TNF	(1 << 0) 	/* Tx FIFO Not Empty */
+
+#define SAICR_ROR	(1 << 6)	/* Clear Rx FIFO Overrun Interrupt */
+#define SAICR_TUR	(1 << 5)	/* Clear Tx FIFO Underrun Interrupt */
+
+#define SAIMR_ROR	(1 << 6)	/* Enable Rx FIFO Overrun Condition Interrupt */
+#define SAIMR_TUR	(1 << 5)	/* Enable Tx FIFO Underrun Condition Interrupt */
+#define SAIMR_RFS	(1 << 4)	/* Enable Rx FIFO Service Interrupt */
+#define SAIMR_TFS	(1 << 3)	/* Enable Tx FIFO Service Interrupt */
+
+/*
+ * AC97 Controller registers
+ */
+
+#define POCR		__REG(0x40500000)  /* PCM Out Control Register */
+#define POCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+#define POCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define PICR		__REG(0x40500004)  /* PCM In Control Register */
+#define PICR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+#define PICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define MCCR		__REG(0x40500008)  /* Mic In Control Register */
+#define MCCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+#define MCCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define GCR		__REG(0x4050000C)  /* Global Control Register */
+#define GCR_nDMAEN	(1 << 24)	/* non DMA Enable */
+#define GCR_CDONE_IE	(1 << 19)	/* Command Done Interrupt Enable */
+#define GCR_SDONE_IE	(1 << 18)	/* Status Done Interrupt Enable */
+#define GCR_SECRDY_IEN	(1 << 9)	/* Secondary Ready Interrupt Enable */
+#define GCR_PRIRDY_IEN	(1 << 8)	/* Primary Ready Interrupt Enable */
+#define GCR_SECRES_IEN	(1 << 5)	/* Secondary Resume Interrupt Enable */
+#define GCR_PRIRES_IEN	(1 << 4)	/* Primary Resume Interrupt Enable */
+#define GCR_ACLINK_OFF	(1 << 3)	/* AC-link Shut Off */
+#define GCR_WARM_RST	(1 << 2)	/* AC97 Warm Reset */
+#define GCR_COLD_RST	(1 << 1)	/* AC'97 Cold Reset (0 = active) */
+#define GCR_GIE		(1 << 0)	/* Codec GPI Interrupt Enable */
+
+#define POSR		__REG(0x40500010)  /* PCM Out Status Register */
+#define POSR_FIFOE	(1 << 4)	/* FIFO error */
+#define POSR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define PISR		__REG(0x40500014)  /* PCM In Status Register */
+#define PISR_FIFOE	(1 << 4)	/* FIFO error */
+#define PISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
+#define PISR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define MCSR		__REG(0x40500018)  /* Mic In Status Register */
+#define MCSR_FIFOE	(1 << 4)	/* FIFO error */
+#define MCSR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
+#define MCSR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define GSR		__REG(0x4050001C)  /* Global Status Register */
+#define GSR_CDONE	(1 << 19)	/* Command Done */
+#define GSR_SDONE	(1 << 18)	/* Status Done */
+#define GSR_RDCS	(1 << 15)	/* Read Completion Status */
+#define GSR_BIT3SLT12	(1 << 14)	/* Bit 3 of slot 12 */
+#define GSR_BIT2SLT12	(1 << 13)	/* Bit 2 of slot 12 */
+#define GSR_BIT1SLT12	(1 << 12)	/* Bit 1 of slot 12 */
+#define GSR_SECRES	(1 << 11)	/* Secondary Resume Interrupt */
+#define GSR_PRIRES	(1 << 10)	/* Primary Resume Interrupt */
+#define GSR_SCR		(1 << 9)	/* Secondary Codec Ready */
+#define GSR_PCR		(1 << 8)	/*  Primary Codec Ready */
+#define GSR_MCINT	(1 << 7)	/* Mic In Interrupt */
+#define GSR_POINT	(1 << 6)	/* PCM Out Interrupt */
+#define GSR_PIINT	(1 << 5)	/* PCM In Interrupt */
+#define GSR_ACOFFD	(1 << 3)	/* AC-link Shut Off Done */
+#define GSR_MOINT	(1 << 2)	/* Modem Out Interrupt */
+#define GSR_MIINT	(1 << 1)	/* Modem In Interrupt */
+#define GSR_GSCI	(1 << 0)	/* Codec GPI Status Change Interrupt */
+
+#define CAR		__REG(0x40500020)  /* CODEC Access Register */
+#define CAR_CAIP	(1 << 0)	/* Codec Access In Progress */
+
+#define PCDR		__REG(0x40500040)  /* PCM FIFO Data Register */
+#define MCDR		__REG(0x40500060)  /* Mic-in FIFO Data Register */
+
+#define MOCR		__REG(0x40500100)  /* Modem Out Control Register */
+#define MOCR_FEIE	(1 << 3)	/* FIFO Error */
+#define MOCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define MICR		__REG(0x40500108)  /* Modem In Control Register */
+#define MICR_FEIE	(1 << 3)	/* FIFO Error */
+#define MICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define MOSR		__REG(0x40500110)  /* Modem Out Status Register */
+#define MOSR_FIFOE	(1 << 4)	/* FIFO error */
+#define MOSR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define MISR		__REG(0x40500118)  /* Modem In Status Register */
+#define MISR_FIFOE	(1 << 4)	/* FIFO error */
+#define MISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
+#define MISR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define MODR		__REG(0x40500140)  /* Modem FIFO Data Register */
+
+#define PAC_REG_BASE	__REG(0x40500200)  /* Primary Audio Codec */
+#define SAC_REG_BASE	__REG(0x40500300)  /* Secondary Audio Codec */
+#define PMC_REG_BASE	__REG(0x40500400)  /* Primary Modem Codec */
+#define SMC_REG_BASE	__REG(0x40500500)  /* Secondary Modem Codec */
+
+
+/*
+ * USB Device Controller
+ * PXA25x and PXA27x USB device controller registers are different.
+ */
+#if defined(CONFIG_PXA25x)
+
+#define UDC_RES1	__REG(0x40600004)  /* UDC Undocumented - Reserved1 */
+#define UDC_RES2	__REG(0x40600008)  /* UDC Undocumented - Reserved2 */
+#define UDC_RES3	__REG(0x4060000C)  /* UDC Undocumented - Reserved3 */
+
+#define UDCCR		__REG(0x40600000)  /* UDC Control Register */
+#define UDCCR_UDE	(1 << 0)	/* UDC enable */
+#define UDCCR_UDA	(1 << 1)	/* UDC active */
+#define UDCCR_RSM	(1 << 2)	/* Device resume */
+#define UDCCR_RESIR	(1 << 3)	/* Resume interrupt request */
+#define UDCCR_SUSIR	(1 << 4)	/* Suspend interrupt request */
+#define UDCCR_SRM	(1 << 5)	/* Suspend/resume interrupt mask */
+#define UDCCR_RSTIR	(1 << 6)	/* Reset interrupt request */
+#define UDCCR_REM	(1 << 7)	/* Reset interrupt mask */
+
+#define UDCCS0		__REG(0x40600010)  /* UDC Endpoint 0 Control/Status Register */
+#define UDCCS0_OPR	(1 << 0)	/* OUT packet ready */
+#define UDCCS0_IPR	(1 << 1)	/* IN packet ready */
+#define UDCCS0_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS0_DRWF	(1 << 3)	/* Device remote wakeup feature */
+#define UDCCS0_SST	(1 << 4)	/* Sent stall */
+#define UDCCS0_FST	(1 << 5)	/* Force stall */
+#define UDCCS0_RNE	(1 << 6)	/* Receive FIFO no empty */
+#define UDCCS0_SA	(1 << 7)	/* Setup active */
+
+/* Bulk IN - Endpoint 1,6,11 */
+#define UDCCS1		__REG(0x40600014)  /* UDC Endpoint 1 (IN) Control/Status Register */
+#define UDCCS6		__REG(0x40600028)  /* UDC Endpoint 6 (IN) Control/Status Register */
+#define UDCCS11		__REG(0x4060003C)  /* UDC Endpoint 11 (IN) Control/Status Register */
+
+#define UDCCS_BI_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_BI_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_BI_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_BI_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_BI_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BI_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BI_TSP	(1 << 7)	/* Transmit short packet */
+
+/* Bulk OUT - Endpoint 2,7,12 */
+#define UDCCS2		__REG(0x40600018)  /* UDC Endpoint 2 (OUT) Control/Status Register */
+#define UDCCS7		__REG(0x4060002C)  /* UDC Endpoint 7 (OUT) Control/Status Register */
+#define UDCCS12		__REG(0x40600040)  /* UDC Endpoint 12 (OUT) Control/Status Register */
+
+#define UDCCS_BO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_BO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_BO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_BO_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BO_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_BO_RSP	(1 << 7)	/* Receive short packet */
+
+/* Isochronous IN - Endpoint 3,8,13 */
+#define UDCCS3		__REG(0x4060001C)  /* UDC Endpoint 3 (IN) Control/Status Register */
+#define UDCCS8		__REG(0x40600030)  /* UDC Endpoint 8 (IN) Control/Status Register */
+#define UDCCS13		__REG(0x40600044)  /* UDC Endpoint 13 (IN) Control/Status Register */
+
+#define UDCCS_II_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_II_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_II_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_II_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_II_TSP	(1 << 7)	/* Transmit short packet */
+
+/* Isochronous OUT - Endpoint 4,9,14 */
+#define UDCCS4		__REG(0x40600020)  /* UDC Endpoint 4 (OUT) Control/Status Register */
+#define UDCCS9		__REG(0x40600034)  /* UDC Endpoint 9 (OUT) Control/Status Register */
+#define UDCCS14		__REG(0x40600048)  /* UDC Endpoint 14 (OUT) Control/Status Register */
+
+#define UDCCS_IO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_IO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_IO_ROF	(1 << 2)	/* Receive overflow */
+#define UDCCS_IO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_IO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_IO_RSP	(1 << 7)	/* Receive short packet */
+
+/* Interrupt IN - Endpoint 5,10,15 */
+#define UDCCS5		__REG(0x40600024)  /* UDC Endpoint 5 (Interrupt) Control/Status Register */
+#define UDCCS10		__REG(0x40600038)  /* UDC Endpoint 10 (Interrupt) Control/Status Register */
+#define UDCCS15		__REG(0x4060004C)  /* UDC Endpoint 15 (Interrupt) Control/Status Register */
+
+#define UDCCS_INT_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_INT_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_INT_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_INT_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_INT_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_INT_FST	(1 << 5)	/* Force stall */
+#define UDCCS_INT_TSP	(1 << 7)	/* Transmit short packet */
+
+#define UFNRH		__REG(0x40600060)  /* UDC Frame Number Register High */
+#define UFNRL		__REG(0x40600064)  /* UDC Frame Number Register Low */
+#define UBCR2		__REG(0x40600068)  /* UDC Byte Count Reg 2 */
+#define UBCR4		__REG(0x4060006c)  /* UDC Byte Count Reg 4 */
+#define UBCR7		__REG(0x40600070)  /* UDC Byte Count Reg 7 */
+#define UBCR9		__REG(0x40600074)  /* UDC Byte Count Reg 9 */
+#define UBCR12		__REG(0x40600078)  /* UDC Byte Count Reg 12 */
+#define UBCR14		__REG(0x4060007c)  /* UDC Byte Count Reg 14 */
+#define UDDR0		__REG(0x40600080)  /* UDC Endpoint 0 Data Register */
+#define UDDR1		__REG(0x40600100)  /* UDC Endpoint 1 Data Register */
+#define UDDR2		__REG(0x40600180)  /* UDC Endpoint 2 Data Register */
+#define UDDR3		__REG(0x40600200)  /* UDC Endpoint 3 Data Register */
+#define UDDR4		__REG(0x40600400)  /* UDC Endpoint 4 Data Register */
+#define UDDR5		__REG(0x406000A0)  /* UDC Endpoint 5 Data Register */
+#define UDDR6		__REG(0x40600600)  /* UDC Endpoint 6 Data Register */
+#define UDDR7		__REG(0x40600680)  /* UDC Endpoint 7 Data Register */
+#define UDDR8		__REG(0x40600700)  /* UDC Endpoint 8 Data Register */
+#define UDDR9		__REG(0x40600900)  /* UDC Endpoint 9 Data Register */
+#define UDDR10		__REG(0x406000C0)  /* UDC Endpoint 10 Data Register */
+#define UDDR11		__REG(0x40600B00)  /* UDC Endpoint 11 Data Register */
+#define UDDR12		__REG(0x40600B80)  /* UDC Endpoint 12 Data Register */
+#define UDDR13		__REG(0x40600C00)  /* UDC Endpoint 13 Data Register */
+#define UDDR14		__REG(0x40600E00)  /* UDC Endpoint 14 Data Register */
+#define UDDR15		__REG(0x406000E0)  /* UDC Endpoint 15 Data Register */
+
+#define UICR0		__REG(0x40600050)  /* UDC Interrupt Control Register 0 */
+
+#define UICR0_IM0	(1 << 0)	/* Interrupt mask ep 0 */
+#define UICR0_IM1	(1 << 1)	/* Interrupt mask ep 1 */
+#define UICR0_IM2	(1 << 2)	/* Interrupt mask ep 2 */
+#define UICR0_IM3	(1 << 3)	/* Interrupt mask ep 3 */
+#define UICR0_IM4	(1 << 4)	/* Interrupt mask ep 4 */
+#define UICR0_IM5	(1 << 5)	/* Interrupt mask ep 5 */
+#define UICR0_IM6	(1 << 6)	/* Interrupt mask ep 6 */
+#define UICR0_IM7	(1 << 7)	/* Interrupt mask ep 7 */
+
+#define UICR1		__REG(0x40600054)  /* UDC Interrupt Control Register 1 */
+
+#define UICR1_IM8	(1 << 0)	/* Interrupt mask ep 8 */
+#define UICR1_IM9	(1 << 1)	/* Interrupt mask ep 9 */
+#define UICR1_IM10	(1 << 2)	/* Interrupt mask ep 10 */
+#define UICR1_IM11	(1 << 3)	/* Interrupt mask ep 11 */
+#define UICR1_IM12	(1 << 4)	/* Interrupt mask ep 12 */
+#define UICR1_IM13	(1 << 5)	/* Interrupt mask ep 13 */
+#define UICR1_IM14	(1 << 6)	/* Interrupt mask ep 14 */
+#define UICR1_IM15	(1 << 7)	/* Interrupt mask ep 15 */
+
+#define USIR0		__REG(0x40600058)  /* UDC Status Interrupt Register 0 */
+
+#define USIR0_IR0	(1 << 0)	/* Interrup request ep 0 */
+#define USIR0_IR1	(1 << 1)	/* Interrup request ep 1 */
+#define USIR0_IR2	(1 << 2)	/* Interrup request ep 2 */
+#define USIR0_IR3	(1 << 3)	/* Interrup request ep 3 */
+#define USIR0_IR4	(1 << 4)	/* Interrup request ep 4 */
+#define USIR0_IR5	(1 << 5)	/* Interrup request ep 5 */
+#define USIR0_IR6	(1 << 6)	/* Interrup request ep 6 */
+#define USIR0_IR7	(1 << 7)	/* Interrup request ep 7 */
+
+#define USIR1		__REG(0x4060005C)  /* UDC Status Interrupt Register 1 */
+
+#define USIR1_IR8	(1 << 0)	/* Interrup request ep 8 */
+#define USIR1_IR9	(1 << 1)	/* Interrup request ep 9 */
+#define USIR1_IR10	(1 << 2)	/* Interrup request ep 10 */
+#define USIR1_IR11	(1 << 3)	/* Interrup request ep 11 */
+#define USIR1_IR12	(1 << 4)	/* Interrup request ep 12 */
+#define USIR1_IR13	(1 << 5)	/* Interrup request ep 13 */
+#define USIR1_IR14	(1 << 6)	/* Interrup request ep 14 */
+#define USIR1_IR15	(1 << 7)	/* Interrup request ep 15 */
+
+#elif defined(CONFIG_PXA27x)
+
+#define UDCCR           __REG(0x40600000) /* UDC Control Register */
+#define UDCCR_OEN	(1 << 31)	/* On-the-Go Enable */
+#define UDCCR_AALTHNP	(1 << 30)	/* A-device Alternate Host Negotiation
+					   Protocol Port Support */
+#define UDCCR_AHNP	(1 << 29)	/* A-device Host Negotiation Protocol
+					   Support */
+#define UDCCR_BHNP	(1 << 28)	/* B-device Host Negotiation Protocol
+					   Enable */
+#define UDCCR_DWRE	(1 << 16)	/* Device Remote Wake-up Enable */
+#define UDCCR_ACN	(0x03 << 11)	/* Active UDC configuration Number */
+#define UDCCR_ACN_S	11
+#define UDCCR_AIN	(0x07 << 8)	/* Active UDC interface Number */
+#define UDCCR_AIN_S	8
+#define UDCCR_AAISN	(0x07 << 5)	/* Active UDC Alternate Interface
+					   Setting Number */
+#define UDCCR_AAISN_S	5
+#define UDCCR_SMAC	(1 << 4)	/* Switch Endpoint Memory to Active
+					   Configuration */
+#define UDCCR_EMCE	(1 << 3)	/* Endpoint Memory Configuration
+					   Error */
+#define UDCCR_UDR	(1 << 2)	/* UDC Resume */
+#define UDCCR_UDA	(1 << 1)	/* UDC Active */
+#define UDCCR_UDE	(1 << 0)	/* UDC Enable */
+
+#define UDCICR0         __REG(0x40600004) /* UDC Interrupt Control Register0 */
+#define UDCICR1         __REG(0x40600008) /* UDC Interrupt Control Register1 */
+#define UDCICR_FIFOERR	(1 << 1)	/* FIFO Error interrupt for EP */
+#define UDCICR_PKTCOMPL (1 << 0)	/* Packet Complete interrupt for EP */
+
+#define UDC_INT_FIFOERROR  (0x2)
+#define UDC_INT_PACKETCMP  (0x1)
+
+#define UDCICR_INT(n,intr) (((intr) & 0x03) << (((n) & 0x0F) * 2))
+#define UDCICR1_IECC	(1 << 31)	/* IntEn - Configuration Change */
+#define UDCICR1_IESOF	(1 << 30)	/* IntEn - Start of Frame */
+#define UDCICR1_IERU	(1 << 29)	/* IntEn - Resume */
+#define UDCICR1_IESU	(1 << 28)	/* IntEn - Suspend */
+#define UDCICR1_IERS	(1 << 27)	/* IntEn - Reset */
+
+#define UDCISR0         __REG(0x4060000C) /* UDC Interrupt Status Register 0 */
+#define UDCISR1         __REG(0x40600010) /* UDC Interrupt Status Register 1 */
+#define UDCISR_INT(n,intr) (((intr) & 0x03) << (((n) & 0x0F) * 2))
+#define UDCISR1_IRCC	(1 << 31)	/* IntReq - Configuration Change */
+#define UDCISR1_IRSOF	(1 << 30)	/* IntReq - Start of Frame */
+#define UDCISR1_IRRU	(1 << 29)	/* IntReq - Resume */
+#define UDCISR1_IRSU	(1 << 28)	/* IntReq - Suspend */
+#define UDCISR1_IRRS	(1 << 27)	/* IntReq - Reset */
+
+#define UDCFNR          __REG(0x40600014) /* UDC Frame Number Register */
+#define UDCOTGICR	__REG(0x40600018) /* UDC On-The-Go interrupt control */
+#define UDCOTGICR_IESF	(1 << 24)	/* OTG SET_FEATURE command recvd */
+#define UDCOTGICR_IEXR	(1 << 17)	/* Extra Transciever Interrupt
+					   Rising Edge Interrupt Enable */
+#define UDCOTGICR_IEXF	(1 << 16)	/* Extra Transciever Interrupt
+					   Falling Edge Interrupt Enable */
+#define UDCOTGICR_IEVV40R (1 << 9)	/* OTG Vbus Valid 4.0V Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEVV40F (1 << 8)	/* OTG Vbus Valid 4.0V Falling Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEVV44R (1 << 7)	/* OTG Vbus Valid 4.4V Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEVV44F (1 << 6)	/* OTG Vbus Valid 4.4V Falling Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IESVR	(1 << 5)	/* OTG Session Valid Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IESVF	(1 << 4)	/* OTG Session Valid Falling Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IESDR	(1 << 3)	/* OTG A-Device SRP Detect Rising
+					   Edge Interrupt Enable */
+#define UDCOTGICR_IESDF	(1 << 2)	/* OTG A-Device SRP Detect Falling
+					   Edge Interrupt Enable */
+#define UDCOTGICR_IEIDR	(1 << 1)	/* OTG ID Change Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEIDF	(1 << 0)	/* OTG ID Change Falling Edge
+					   Interrupt Enable */
+
+#define UP2OCR		  __REG(0x40600020)  /* USB Port 2 Output Control register */
+
+#define UP2OCR_CPVEN	(1 << 0)	/* Charge Pump Vbus Enable */
+#define UP2OCR_CPVPE	(1 << 1)	/* Charge Pump Vbus Pulse Enable */
+#define UP2OCR_DPPDE	(1 << 2)	/* Host Port 2 Transceiver D+ Pull Down Enable */
+#define UP2OCR_DMPDE	(1 << 3)	/* Host Port 2 Transceiver D- Pull Down Enable */
+#define UP2OCR_DPPUE	(1 << 4)	/* Host Port 2 Transceiver D+ Pull Up Enable */
+#define UP2OCR_DMPUE	(1 << 5)	/* Host Port 2 Transceiver D- Pull Up Enable */
+#define UP2OCR_DPPUBE	(1 << 6)	/* Host Port 2 Transceiver D+ Pull Up Bypass Enable */
+#define UP2OCR_DMPUBE	(1 << 7)	/* Host Port 2 Transceiver D- Pull Up Bypass Enable */
+#define UP2OCR_EXSP		(1 << 8)	/* External Transceiver Speed Control */
+#define UP2OCR_EXSUS	(1 << 9)	/* External Transceiver Speed Enable */
+#define UP2OCR_IDON		(1 << 10)	/* OTG ID Read Enable */
+#define UP2OCR_HXS		(1 << 16)	/* Host Port 2 Transceiver Output Select */
+#define UP2OCR_HXOE		(1 << 17)	/* Host Port 2 Transceiver Output Enable */
+#define UP2OCR_SEOS		(1 << 24)	/* Single-Ended Output Select */
+
+#define UDCCSN(x)	__REG2(0x40600100, (x) << 2)
+#define UDCCSR0         __REG(0x40600100) /* UDC Control/Status register - Endpoint 0 */
+#define UDCCSR0_SA	(1 << 7)	/* Setup Active */
+#define UDCCSR0_RNE	(1 << 6)	/* Receive FIFO Not Empty */
+#define UDCCSR0_FST	(1 << 5)	/* Force Stall */
+#define UDCCSR0_SST	(1 << 4)	/* Sent Stall */
+#define UDCCSR0_DME	(1 << 3)	/* DMA Enable */
+#define UDCCSR0_FTF	(1 << 2)	/* Flush Transmit FIFO */
+#define UDCCSR0_IPR	(1 << 1)	/* IN Packet Ready */
+#define UDCCSR0_OPC	(1 << 0)	/* OUT Packet Complete */
+
+#define UDCCSRA         __REG(0x40600104) /* UDC Control/Status register - Endpoint A */
+#define UDCCSRB         __REG(0x40600108) /* UDC Control/Status register - Endpoint B */
+#define UDCCSRC         __REG(0x4060010C) /* UDC Control/Status register - Endpoint C */
+#define UDCCSRD         __REG(0x40600110) /* UDC Control/Status register - Endpoint D */
+#define UDCCSRE         __REG(0x40600114) /* UDC Control/Status register - Endpoint E */
+#define UDCCSRF         __REG(0x40600118) /* UDC Control/Status register - Endpoint F */
+#define UDCCSRG         __REG(0x4060011C) /* UDC Control/Status register - Endpoint G */
+#define UDCCSRH         __REG(0x40600120) /* UDC Control/Status register - Endpoint H */
+#define UDCCSRI         __REG(0x40600124) /* UDC Control/Status register - Endpoint I */
+#define UDCCSRJ         __REG(0x40600128) /* UDC Control/Status register - Endpoint J */
+#define UDCCSRK         __REG(0x4060012C) /* UDC Control/Status register - Endpoint K */
+#define UDCCSRL         __REG(0x40600130) /* UDC Control/Status register - Endpoint L */
+#define UDCCSRM         __REG(0x40600134) /* UDC Control/Status register - Endpoint M */
+#define UDCCSRN         __REG(0x40600138) /* UDC Control/Status register - Endpoint N */
+#define UDCCSRP         __REG(0x4060013C) /* UDC Control/Status register - Endpoint P */
+#define UDCCSRQ         __REG(0x40600140) /* UDC Control/Status register - Endpoint Q */
+#define UDCCSRR         __REG(0x40600144) /* UDC Control/Status register - Endpoint R */
+#define UDCCSRS         __REG(0x40600148) /* UDC Control/Status register - Endpoint S */
+#define UDCCSRT         __REG(0x4060014C) /* UDC Control/Status register - Endpoint T */
+#define UDCCSRU         __REG(0x40600150) /* UDC Control/Status register - Endpoint U */
+#define UDCCSRV         __REG(0x40600154) /* UDC Control/Status register - Endpoint V */
+#define UDCCSRW         __REG(0x40600158) /* UDC Control/Status register - Endpoint W */
+#define UDCCSRX         __REG(0x4060015C) /* UDC Control/Status register - Endpoint X */
+
+#define UDCCSR_DPE	(1 << 9)	/* Data Packet Error */
+#define UDCCSR_FEF	(1 << 8)	/* Flush Endpoint FIFO */
+#define UDCCSR_SP	(1 << 7)	/* Short Packet Control/Status */
+#define UDCCSR_BNE	(1 << 6)	/* Buffer Not Empty (IN endpoints) */
+#define UDCCSR_BNF	(1 << 6)	/* Buffer Not Full (OUT endpoints) */
+#define UDCCSR_FST	(1 << 5)	/* Force STALL */
+#define UDCCSR_SST	(1 << 4)	/* Sent STALL */
+#define UDCCSR_DME	(1 << 3)	/* DMA Enable */
+#define UDCCSR_TRN	(1 << 2)	/* Tx/Rx NAK */
+#define UDCCSR_PC	(1 << 1)	/* Packet Complete */
+#define UDCCSR_FS	(1 << 0)	/* FIFO needs service */
+
+#define UDCBCN(x)	__REG2(0x40600200, (x)<<2)
+#define UDCBCR0         __REG(0x40600200) /* Byte Count Register - EP0 */
+#define UDCBCRA         __REG(0x40600204) /* Byte Count Register - EPA */
+#define UDCBCRB         __REG(0x40600208) /* Byte Count Register - EPB */
+#define UDCBCRC         __REG(0x4060020C) /* Byte Count Register - EPC */
+#define UDCBCRD         __REG(0x40600210) /* Byte Count Register - EPD */
+#define UDCBCRE         __REG(0x40600214) /* Byte Count Register - EPE */
+#define UDCBCRF         __REG(0x40600218) /* Byte Count Register - EPF */
+#define UDCBCRG         __REG(0x4060021C) /* Byte Count Register - EPG */
+#define UDCBCRH         __REG(0x40600220) /* Byte Count Register - EPH */
+#define UDCBCRI         __REG(0x40600224) /* Byte Count Register - EPI */
+#define UDCBCRJ         __REG(0x40600228) /* Byte Count Register - EPJ */
+#define UDCBCRK         __REG(0x4060022C) /* Byte Count Register - EPK */
+#define UDCBCRL         __REG(0x40600230) /* Byte Count Register - EPL */
+#define UDCBCRM         __REG(0x40600234) /* Byte Count Register - EPM */
+#define UDCBCRN         __REG(0x40600238) /* Byte Count Register - EPN */
+#define UDCBCRP         __REG(0x4060023C) /* Byte Count Register - EPP */
+#define UDCBCRQ         __REG(0x40600240) /* Byte Count Register - EPQ */
+#define UDCBCRR         __REG(0x40600244) /* Byte Count Register - EPR */
+#define UDCBCRS         __REG(0x40600248) /* Byte Count Register - EPS */
+#define UDCBCRT         __REG(0x4060024C) /* Byte Count Register - EPT */
+#define UDCBCRU         __REG(0x40600250) /* Byte Count Register - EPU */
+#define UDCBCRV         __REG(0x40600254) /* Byte Count Register - EPV */
+#define UDCBCRW         __REG(0x40600258) /* Byte Count Register - EPW */
+#define UDCBCRX         __REG(0x4060025C) /* Byte Count Register - EPX */
+
+#define UDCDN(x)	__REG2(0x40600300, (x)<<2)
+#define PHYS_UDCDN(x)	(0x40600300 + ((x)<<2))
+#define PUDCDN(x)	(volatile u32 *)(io_p2v(PHYS_UDCDN((x))))
+#define UDCDR0          __REG(0x40600300) /* Data Register - EP0 */
+#define UDCDRA          __REG(0x40600304) /* Data Register - EPA */
+#define UDCDRB          __REG(0x40600308) /* Data Register - EPB */
+#define UDCDRC          __REG(0x4060030C) /* Data Register - EPC */
+#define UDCDRD          __REG(0x40600310) /* Data Register - EPD */
+#define UDCDRE          __REG(0x40600314) /* Data Register - EPE */
+#define UDCDRF          __REG(0x40600318) /* Data Register - EPF */
+#define UDCDRG          __REG(0x4060031C) /* Data Register - EPG */
+#define UDCDRH          __REG(0x40600320) /* Data Register - EPH */
+#define UDCDRI          __REG(0x40600324) /* Data Register - EPI */
+#define UDCDRJ          __REG(0x40600328) /* Data Register - EPJ */
+#define UDCDRK          __REG(0x4060032C) /* Data Register - EPK */
+#define UDCDRL          __REG(0x40600330) /* Data Register - EPL */
+#define UDCDRM          __REG(0x40600334) /* Data Register - EPM */
+#define UDCDRN          __REG(0x40600338) /* Data Register - EPN */
+#define UDCDRP          __REG(0x4060033C) /* Data Register - EPP */
+#define UDCDRQ          __REG(0x40600340) /* Data Register - EPQ */
+#define UDCDRR          __REG(0x40600344) /* Data Register - EPR */
+#define UDCDRS          __REG(0x40600348) /* Data Register - EPS */
+#define UDCDRT          __REG(0x4060034C) /* Data Register - EPT */
+#define UDCDRU          __REG(0x40600350) /* Data Register - EPU */
+#define UDCDRV          __REG(0x40600354) /* Data Register - EPV */
+#define UDCDRW          __REG(0x40600358) /* Data Register - EPW */
+#define UDCDRX          __REG(0x4060035C) /* Data Register - EPX */
+
+#define UDCCN(x)       __REG2(0x40600400, (x)<<2)
+#define UDCCRA          __REG(0x40600404) /* Configuration register EPA */
+#define UDCCRB          __REG(0x40600408) /* Configuration register EPB */
+#define UDCCRC          __REG(0x4060040C) /* Configuration register EPC */
+#define UDCCRD          __REG(0x40600410) /* Configuration register EPD */
+#define UDCCRE          __REG(0x40600414) /* Configuration register EPE */
+#define UDCCRF          __REG(0x40600418) /* Configuration register EPF */
+#define UDCCRG          __REG(0x4060041C) /* Configuration register EPG */
+#define UDCCRH          __REG(0x40600420) /* Configuration register EPH */
+#define UDCCRI          __REG(0x40600424) /* Configuration register EPI */
+#define UDCCRJ          __REG(0x40600428) /* Configuration register EPJ */
+#define UDCCRK          __REG(0x4060042C) /* Configuration register EPK */
+#define UDCCRL          __REG(0x40600430) /* Configuration register EPL */
+#define UDCCRM          __REG(0x40600434) /* Configuration register EPM */
+#define UDCCRN          __REG(0x40600438) /* Configuration register EPN */
+#define UDCCRP          __REG(0x4060043C) /* Configuration register EPP */
+#define UDCCRQ          __REG(0x40600440) /* Configuration register EPQ */
+#define UDCCRR          __REG(0x40600444) /* Configuration register EPR */
+#define UDCCRS          __REG(0x40600448) /* Configuration register EPS */
+#define UDCCRT          __REG(0x4060044C) /* Configuration register EPT */
+#define UDCCRU          __REG(0x40600450) /* Configuration register EPU */
+#define UDCCRV          __REG(0x40600454) /* Configuration register EPV */
+#define UDCCRW          __REG(0x40600458) /* Configuration register EPW */
+#define UDCCRX          __REG(0x4060045C) /* Configuration register EPX */
+
+#define UDCCONR_CN	(0x03 << 25)	/* Configuration Number */
+#define UDCCONR_CN_S	(25)
+#define UDCCONR_IN	(0x07 << 22)	/* Interface Number */
+#define UDCCONR_IN_S	(22)
+#define UDCCONR_AISN	(0x07 << 19)	/* Alternate Interface Number */
+#define UDCCONR_AISN_S	(19)
+#define UDCCONR_EN	(0x0f << 15)	/* Endpoint Number */
+#define UDCCONR_EN_S	(15)
+#define UDCCONR_ET	(0x03 << 13)	/* Endpoint Type: */
+#define UDCCONR_ET_S	(13)
+#define UDCCONR_ET_INT	(0x03 << 13)	/*   Interrupt */
+#define UDCCONR_ET_BULK	(0x02 << 13)	/*   Bulk */
+#define UDCCONR_ET_ISO	(0x01 << 13)	/*   Isochronous */
+#define UDCCONR_ET_NU	(0x00 << 13)	/*   Not used */
+#define UDCCONR_ED	(1 << 12)	/* Endpoint Direction */
+#define UDCCONR_MPS	(0x3ff << 2)	/* Maximum Packet Size */
+#define UDCCONR_MPS_S	(2)
+#define UDCCONR_DE	(1 << 1)	/* Double Buffering Enable */
+#define UDCCONR_EE	(1 << 0)	/* Endpoint Enable */
+
+
+#define UDC_INT_FIFOERROR  (0x2)
+#define UDC_INT_PACKETCMP  (0x1)
+
+#define UDC_FNR_MASK     (0x7ff)
+
+#define UDCCSR_WR_MASK   (UDCCSR_DME|UDCCSR_FST)
+#define UDC_BCR_MASK    (0x3ff)
+#endif
+
+/*
+ * Fast Infrared Communication Port
+ */
+
+#define FICP		__REG(0x40800000)  /* Start of FICP area */
+#define ICCR0		__REG(0x40800000)  /* ICP Control Register 0 */
+#define ICCR1		__REG(0x40800004)  /* ICP Control Register 1 */
+#define ICCR2		__REG(0x40800008)  /* ICP Control Register 2 */
+#define ICDR		__REG(0x4080000c)  /* ICP Data Register */
+#define ICSR0		__REG(0x40800014)  /* ICP Status Register 0 */
+#define ICSR1		__REG(0x40800018)  /* ICP Status Register 1 */
+
+#define ICCR0_AME	(1 << 7)	/* Adress match enable */
+#define ICCR0_TIE	(1 << 6)	/* Transmit FIFO interrupt enable */
+#define ICCR0_RIE	(1 << 5)	/* Recieve FIFO interrupt enable */
+#define ICCR0_RXE	(1 << 4)	/* Receive enable */
+#define ICCR0_TXE	(1 << 3)	/* Transmit enable */
+#define ICCR0_TUS	(1 << 2)	/* Transmit FIFO underrun select */
+#define ICCR0_LBM	(1 << 1)	/* Loopback mode */
+#define ICCR0_ITR	(1 << 0)	/* IrDA transmission */
+
+#define ICCR2_RXP       (1 << 3)	/* Receive Pin Polarity select */
+#define ICCR2_TXP       (1 << 2)	/* Transmit Pin Polarity select */
+#define ICCR2_TRIG	(3 << 0)	/* Receive FIFO Trigger threshold */
+#define ICCR2_TRIG_8    (0 << 0)	/* 	>= 8 bytes */
+#define ICCR2_TRIG_16   (1 << 0)	/*	>= 16 bytes */
+#define ICCR2_TRIG_32   (2 << 0)	/*	>= 32 bytes */
+
+#ifdef CONFIG_PXA27x
+#define ICSR0_EOC	(1 << 6)	/* DMA End of Descriptor Chain */
+#endif
+#define ICSR0_FRE	(1 << 5)	/* Framing error */
+#define ICSR0_RFS	(1 << 4)	/* Receive FIFO service request */
+#define ICSR0_TFS	(1 << 3)	/* Transnit FIFO service request */
+#define ICSR0_RAB	(1 << 2)	/* Receiver abort */
+#define ICSR0_TUR	(1 << 1)	/* Trunsmit FIFO underun */
+#define ICSR0_EIF	(1 << 0)	/* End/Error in FIFO */
+
+#define ICSR1_ROR	(1 << 6)	/* Receiver FIFO underrun  */
+#define ICSR1_CRE	(1 << 5)	/* CRC error */
+#define ICSR1_EOF	(1 << 4)	/* End of frame */
+#define ICSR1_TNF	(1 << 3)	/* Transmit FIFO not full */
+#define ICSR1_RNE	(1 << 2)	/* Receive FIFO not empty */
+#define ICSR1_TBY	(1 << 1)	/* Tramsmiter busy flag */
+#define ICSR1_RSY	(1 << 0)	/* Recevier synchronized flag */
+
+
+/*
+ * Real Time Clock
+ */
+
+#define RCNR		__REG(0x40900000)  /* RTC Count Register */
+#define RTAR		__REG(0x40900004)  /* RTC Alarm Register */
+#define RTSR		__REG(0x40900008)  /* RTC Status Register */
+#define RTTR		__REG(0x4090000C)  /* RTC Timer Trim Register */
+#define PIAR		__REG(0x40900038)  /* Periodic Interrupt Alarm Register */
+
+#define RTSR_PICE	(1 << 15)	/* Periodic interrupt count enable */
+#define RTSR_PIALE	(1 << 14)	/* Periodic interrupt Alarm enable */
+#define RTSR_HZE	(1 << 3)	/* HZ interrupt enable */
+#define RTSR_ALE	(1 << 2)	/* RTC alarm interrupt enable */
+#define RTSR_HZ		(1 << 1)	/* HZ rising-edge detected */
+#define RTSR_AL		(1 << 0)	/* RTC alarm detected */
+
+
+/*
+ * OS Timer & Match Registers
+ */
+
+#define OSMR0		__REG(0x40A00000)  /* */
+#define OSMR1		__REG(0x40A00004)  /* */
+#define OSMR2		__REG(0x40A00008)  /* */
+#define OSMR3		__REG(0x40A0000C)  /* */
+#define OSMR4		__REG(0x40A00080)  /* */
+#define OSCR		__REG(0x40A00010)  /* OS Timer Counter Register */
+#define OSCR4		__REG(0x40A00040)  /* OS Timer Counter Register */
+#define OMCR4		__REG(0x40A000C0)  /* */
+#define OSSR		__REG(0x40A00014)  /* OS Timer Status Register */
+#define OWER		__REG(0x40A00018)  /* OS Timer Watchdog Enable Register */
+#define OIER		__REG(0x40A0001C)  /* OS Timer Interrupt Enable Register */
+
+#define OSSR_M3		(1 << 3)	/* Match status channel 3 */
+#define OSSR_M2		(1 << 2)	/* Match status channel 2 */
+#define OSSR_M1		(1 << 1)	/* Match status channel 1 */
+#define OSSR_M0		(1 << 0)	/* Match status channel 0 */
+
+#define OWER_WME	(1 << 0)	/* Watchdog Match Enable */
+
+#define OIER_E3		(1 << 3)	/* Interrupt enable channel 3 */
+#define OIER_E2		(1 << 2)	/* Interrupt enable channel 2 */
+#define OIER_E1		(1 << 1)	/* Interrupt enable channel 1 */
+#define OIER_E0		(1 << 0)	/* Interrupt enable channel 0 */
+
+
+/*
+ * Pulse Width Modulator
+ */
+
+#define PWM_CTRL0	__REG(0x40B00000)  /* PWM 0 Control Register */
+#define PWM_PWDUTY0	__REG(0x40B00004)  /* PWM 0 Duty Cycle Register */
+#define PWM_PERVAL0	__REG(0x40B00008)  /* PWM 0 Period Control Register */
+
+#define PWM_CTRL1	__REG(0x40C00000)  /* PWM 1Control Register */
+#define PWM_PWDUTY1	__REG(0x40C00004)  /* PWM 1 Duty Cycle Register */
+#define PWM_PERVAL1	__REG(0x40C00008)  /* PWM 1 Period Control Register */
+
+/* AERONIX added for Zipit2*/
+#define PWM_CTRL2       __REG(0x40B00010)
+#define PWM_PWDUTY2     __REG(0x40B00014)
+#define PWM_PERVAL2     __REG(0x40B00018)
+
+/*
+ * Interrupt Controller
+ */
+
+#define ICIP		__REG(0x40D00000)  /* Interrupt Controller IRQ Pending Register */
+#define ICMR		__REG(0x40D00004)  /* Interrupt Controller Mask Register */
+#define ICLR		__REG(0x40D00008)  /* Interrupt Controller Level Register */
+#define ICFP		__REG(0x40D0000C)  /* Interrupt Controller FIQ Pending Register */
+#define ICPR		__REG(0x40D00010)  /* Interrupt Controller Pending Register */
+#define ICCR		__REG(0x40D00014)  /* Interrupt Controller Control Register */
+
+
+/*
+ * General Purpose I/O
+ */
+
+#define GPLR0		__REG(0x40E00000)  /* GPIO Pin-Level Register GPIO<31:0> */
+#define GPLR1		__REG(0x40E00004)  /* GPIO Pin-Level Register GPIO<63:32> */
+#define GPLR2		__REG(0x40E00008)  /* GPIO Pin-Level Register GPIO<80:64> */
+
+#define GPDR0		__REG(0x40E0000C)  /* GPIO Pin Direction Register GPIO<31:0> */
+#define GPDR1		__REG(0x40E00010)  /* GPIO Pin Direction Register GPIO<63:32> */
+#define GPDR2		__REG(0x40E00014)  /* GPIO Pin Direction Register GPIO<80:64> */
+
+#define GPSR0		__REG(0x40E00018)  /* GPIO Pin Output Set Register GPIO<31:0> */
+#define GPSR1		__REG(0x40E0001C)  /* GPIO Pin Output Set Register GPIO<63:32> */
+#define GPSR2		__REG(0x40E00020)  /* GPIO Pin Output Set Register GPIO<80:64> */
+
+#define GPCR0		__REG(0x40E00024)  /* GPIO Pin Output Clear Register GPIO<31:0> */
+#define GPCR1		__REG(0x40E00028)  /* GPIO Pin Output Clear Register GPIO <63:32> */
+#define GPCR2		__REG(0x40E0002C)  /* GPIO Pin Output Clear Register GPIO <80:64> */
+
+#define GRER0		__REG(0x40E00030)  /* GPIO Rising-Edge Detect Register GPIO<31:0> */
+#define GRER1		__REG(0x40E00034)  /* GPIO Rising-Edge Detect Register GPIO<63:32> */
+#define GRER2		__REG(0x40E00038)  /* GPIO Rising-Edge Detect Register GPIO<80:64> */
+
+#define GFER0		__REG(0x40E0003C)  /* GPIO Falling-Edge Detect Register GPIO<31:0> */
+#define GFER1		__REG(0x40E00040)  /* GPIO Falling-Edge Detect Register GPIO<63:32> */
+#define GFER2		__REG(0x40E00044)  /* GPIO Falling-Edge Detect Register GPIO<80:64> */
+
+#define GEDR0		__REG(0x40E00048)  /* GPIO Edge Detect Status Register GPIO<31:0> */
+#define GEDR1		__REG(0x40E0004C)  /* GPIO Edge Detect Status Register GPIO<63:32> */
+#define GEDR2		__REG(0x40E00050)  /* GPIO Edge Detect Status Register GPIO<80:64> */
+
+#define GAFR0_L		__REG(0x40E00054)  /* GPIO Alternate Function Select Register GPIO<15:0> */
+#define GAFR0_U		__REG(0x40E00058)  /* GPIO Alternate Function Select Register GPIO<31:16> */
+#define GAFR1_L		__REG(0x40E0005C)  /* GPIO Alternate Function Select Register GPIO<47:32> */
+#define GAFR1_U		__REG(0x40E00060)  /* GPIO Alternate Function Select Register GPIO<63:48> */
+#define GAFR2_L		__REG(0x40E00064)  /* GPIO Alternate Function Select Register GPIO<79:64> */
+#define GAFR2_U		__REG(0x40E00068)  /* GPIO Alternate Function Select Register GPIO<95-80> */
+#define GAFR3_L		__REG(0x40E0006C)  /* GPIO Alternate Function Select Register GPIO<111:96> */
+#define GAFR3_U		__REG(0x40E00070)  /* GPIO Alternate Function Select Register GPIO<127:112> */
+
+#define GPLR3		__REG(0x40E00100)  /* GPIO Pin-Level Register GPIO<127:96> */
+#define GPDR3		__REG(0x40E0010C)  /* GPIO Pin Direction Register GPIO<127:96> */
+#define GPSR3		__REG(0x40E00118)  /* GPIO Pin Output Set Register GPIO<127:96> */
+#define GPCR3		__REG(0x40E00124)  /* GPIO Pin Output Clear Register GPIO<127:96> */
+#define GRER3		__REG(0x40E00130)  /* GPIO Rising-Edge Detect Register GPIO<127:96> */
+#define GFER3		__REG(0x40E0013C)  /* GPIO Falling-Edge Detect Register GPIO<127:96> */
+#define GEDR3		__REG(0x40E00148)  /* GPIO Edge Detect Status Register GPIO<127:96> */
+
+/* More handy macros.  The argument is a literal GPIO number. */
+
+#define GPIO_bit(x)	(1 << ((x) & 0x1f))
+
+#ifdef CONFIG_PXA27x
+
+/* Interrupt Controller */
+
+#define ICIP2		__REG(0x40D0009C)  /* Interrupt Controller IRQ Pending Register 2 */
+#define ICMR2		__REG(0x40D000A0)  /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40D000A4)  /* Interrupt Controller Level Register 2 */
+#define ICFP2		__REG(0x40D000A8)  /* Interrupt Controller FIQ Pending Register 2 */
+#define ICPR2		__REG(0x40D000AC)  /* Interrupt Controller Pending Register 2 */
+
+#define _GPLR(x)	__REG2(0x40E00000, ((x) & 0x60) >> 3)
+#define _GPDR(x)	__REG2(0x40E0000C, ((x) & 0x60) >> 3)
+#define _GPSR(x)	__REG2(0x40E00018, ((x) & 0x60) >> 3)
+#define _GPCR(x)	__REG2(0x40E00024, ((x) & 0x60) >> 3)
+#define _GRER(x)	__REG2(0x40E00030, ((x) & 0x60) >> 3)
+#define _GFER(x)	__REG2(0x40E0003C, ((x) & 0x60) >> 3)
+#define _GEDR(x)	__REG2(0x40E00048, ((x) & 0x60) >> 3)
+#define _GAFR(x)	__REG2(0x40E00054, ((x) & 0x70) >> 2)
+
+#define GPLR(x) 	(*((((x) & 0x7f) < 96) ? &_GPLR(x) : &GPLR3))
+#define GPDR(x)		(*((((x) & 0x7f) < 96) ? &_GPDR(x) : &GPDR3))
+#define GPSR(x)		(*((((x) & 0x7f) < 96) ? &_GPSR(x) : &GPSR3))
+#define GPCR(x)		(*((((x) & 0x7f) < 96) ? &_GPCR(x) : &GPCR3))
+#define GRER(x)		(*((((x) & 0x7f) < 96) ? &_GRER(x) : &GRER3))
+#define GFER(x)		(*((((x) & 0x7f) < 96) ? &_GFER(x) : &GFER3))
+#define GEDR(x)		(*((((x) & 0x7f) < 96) ? &_GEDR(x) : &GEDR3))
+#define GAFR(x)		(*((((x) & 0x7f) < 96) ? &_GAFR(x) : \
+			 ((((x) & 0x7f) < 112) ? &GAFR3_L : &GAFR3_U)))
+#else
+
+#define GPLR(x)		__REG2(0x40E00000, ((x) & 0x60) >> 3)
+#define GPDR(x)		__REG2(0x40E0000C, ((x) & 0x60) >> 3)
+#define GPSR(x)		__REG2(0x40E00018, ((x) & 0x60) >> 3)
+#define GPCR(x)		__REG2(0x40E00024, ((x) & 0x60) >> 3)
+#define GRER(x)		__REG2(0x40E00030, ((x) & 0x60) >> 3)
+#define GFER(x)		__REG2(0x40E0003C, ((x) & 0x60) >> 3)
+#define GEDR(x)		__REG2(0x40E00048, ((x) & 0x60) >> 3)
+#define GAFR(x)		__REG2(0x40E00054, ((x) & 0x70) >> 2)
+
+#endif
+
+
+/* GPIO alternate function assignments */
+
+#define GPIO1_RST		1	/* reset */
+#define GPIO6_MMCCLK		6	/* MMC Clock */
+#define GPIO7_48MHz		7	/* 48 MHz clock output */
+#define GPIO8_MMCCS0		8	/* MMC Chip Select 0 */
+#define GPIO9_MMCCS1		9	/* MMC Chip Select 1 */
+#define GPIO10_RTCCLK		10	/* real time clock (1 Hz) */
+#define GPIO11_3_6MHz		11	/* 3.6 MHz oscillator out */
+#define GPIO12_32KHz		12	/* 32 kHz out */
+#define GPIO13_MBGNT		13	/* memory controller grant */
+#define GPIO14_MBREQ		14	/* alternate bus master request */
+#define GPIO15_nCS_1		15	/* chip select 1 */
+#define GPIO16_PWM0		16	/* PWM0 output */
+#define GPIO17_PWM1		17	/* PWM1 output */
+#define GPIO18_RDY		18	/* Ext. Bus Ready */
+#define GPIO19_DREQ1		19	/* External DMA Request */
+#define GPIO20_DREQ0		20	/* External DMA Request */
+#define GPIO23_SCLK		23	/* SSP clock */
+#define GPIO24_SFRM		24	/* SSP Frame */
+#define GPIO25_STXD		25	/* SSP transmit */
+#define GPIO26_SRXD		26	/* SSP receive */
+#define GPIO27_SEXTCLK		27	/* SSP ext_clk */
+#define GPIO28_BITCLK		28	/* AC97/I2S bit_clk */
+#define GPIO29_SDATA_IN		29	/* AC97 Sdata_in0 / I2S Sdata_in */
+#define GPIO30_SDATA_OUT	30	/* AC97/I2S Sdata_out */
+#define GPIO31_SYNC		31	/* AC97/I2S sync */
+#define GPIO32_SDATA_IN1	32	/* AC97 Sdata_in1 */
+#define GPIO32_SYSCLK		32	/* I2S System Clock */
+#define GPIO32_MMCCLK		32	/* MMC Clock (PXA270) */
+#define GPIO33_nCS_5		33	/* chip select 5 */
+#define GPIO34_FFRXD		34	/* FFUART receive */
+#define GPIO34_MMCCS0		34	/* MMC Chip Select 0 */
+#define GPIO35_FFCTS		35	/* FFUART Clear to send */
+#define GPIO36_FFDCD		36	/* FFUART Data carrier detect */
+#define GPIO37_FFDSR		37	/* FFUART data set ready */
+#define GPIO38_FFRI		38	/* FFUART Ring Indicator */
+#define GPIO39_MMCCS1		39	/* MMC Chip Select 1 */
+#define GPIO39_FFTXD		39	/* FFUART transmit data */
+#define GPIO40_FFDTR		40	/* FFUART data terminal Ready */
+#define GPIO41_FFRTS		41	/* FFUART request to send */
+#define GPIO42_BTRXD		42	/* BTUART receive data */
+#define GPIO42_HWRXD		42	/* HWUART receive data */
+#define GPIO43_BTTXD		43	/* BTUART transmit data */
+#define GPIO43_HWTXD		43	/* HWUART transmit data */
+#define GPIO44_BTCTS		44	/* BTUART clear to send */
+#define GPIO44_HWCTS		44	/* HWUART clear to send */
+#define GPIO45_BTRTS		45	/* BTUART request to send */
+#define GPIO45_HWRTS		45	/* HWUART request to send */
+#define GPIO45_AC97_SYSCLK	45	/* AC97 System Clock */
+#define GPIO46_ICPRXD		46	/* ICP receive data */
+#define GPIO46_STRXD		46	/* STD_UART receive data */
+#define GPIO47_ICPTXD		47	/* ICP transmit data */
+#define GPIO47_STTXD		47	/* STD_UART transmit data */
+#define GPIO48_nPOE		48	/* Output Enable for Card Space */
+#define GPIO49_nPWE		49	/* Write Enable for Card Space */
+#define GPIO50_nPIOR		50	/* I/O Read for Card Space */
+#define GPIO51_nPIOW		51	/* I/O Write for Card Space */
+#define GPIO52_nPCE_1		52	/* Card Enable for Card Space */
+#define GPIO53_nPCE_2		53	/* Card Enable for Card Space */
+#define GPIO53_MMCCLK		53	/* MMC Clock */
+#define GPIO54_MMCCLK		54	/* MMC Clock */
+#define GPIO54_pSKTSEL		54	/* Socket Select for Card Space */
+#define GPIO54_nPCE_2		54	/* Card Enable for Card Space (PXA27x) */
+#define GPIO55_nPREG		55	/* Card Address bit 26 */
+#define GPIO56_nPWAIT		56	/* Wait signal for Card Space */
+#define GPIO57_nIOIS16		57	/* Bus Width select for I/O Card Space */
+#define GPIO58_LDD_0		58	/* LCD data pin 0 */
+#define GPIO59_LDD_1		59	/* LCD data pin 1 */
+#define GPIO60_LDD_2		60	/* LCD data pin 2 */
+#define GPIO61_LDD_3		61	/* LCD data pin 3 */
+#define GPIO62_LDD_4		62	/* LCD data pin 4 */
+#define GPIO63_LDD_5		63	/* LCD data pin 5 */
+#define GPIO64_LDD_6		64	/* LCD data pin 6 */
+#define GPIO65_LDD_7		65	/* LCD data pin 7 */
+#define GPIO66_LDD_8		66	/* LCD data pin 8 */
+#define GPIO66_MBREQ		66	/* alternate bus master req */
+#define GPIO67_LDD_9		67	/* LCD data pin 9 */
+#define GPIO67_MMCCS0		67	/* MMC Chip Select 0 */
+#define GPIO68_LDD_10		68	/* LCD data pin 10 */
+#define GPIO68_MMCCS1		68	/* MMC Chip Select 1 */
+#define GPIO69_LDD_11		69	/* LCD data pin 11 */
+#define GPIO69_MMCCLK		69	/* MMC_CLK */
+#define GPIO70_LDD_12		70	/* LCD data pin 12 */
+#define GPIO70_RTCCLK		70	/* Real Time clock (1 Hz) */
+#define GPIO71_LDD_13		71	/* LCD data pin 13 */
+#define GPIO71_3_6MHz		71	/* 3.6 MHz Oscillator clock */
+#define GPIO72_LDD_14		72	/* LCD data pin 14 */
+#define GPIO72_32kHz		72	/* 32 kHz clock */
+#define GPIO73_LDD_15		73	/* LCD data pin 15 */
+#define GPIO73_MBGNT		73	/* Memory controller grant */
+#define GPIO74_LCD_FCLK		74	/* LCD Frame clock */
+#define GPIO75_LCD_LCLK		75	/* LCD line clock */
+#define GPIO76_LCD_PCLK		76	/* LCD Pixel clock */
+#define GPIO77_LCD_ACBIAS	77	/* LCD AC Bias */
+#define GPIO78_nCS_2		78	/* chip select 2 */
+#define GPIO79_nCS_3		79	/* chip select 3 */
+#define GPIO80_nCS_4		80	/* chip select 4 */
+#define GPIO81_NSCLK		81	/* NSSP clock */
+#define GPIO82_NSFRM		82	/* NSSP Frame */
+#define GPIO83_NSTXD		83	/* NSSP transmit */
+#define GPIO84_NSRXD		84	/* NSSP receive */
+#define GPIO85_nPCE_1		85	/* Card Enable for Card Space (PXA27x) */
+#define GPIO92_MMCDAT0		92	/* MMC DAT0 (PXA27x) */
+#define GPIO102_nPCE_1		102	/* PCMCIA (PXA27x) */
+#define GPIO109_MMCDAT1		109	/* MMC DAT1 (PXA27x) */
+#define GPIO110_MMCDAT2		110	/* MMC DAT2 (PXA27x) */
+#define GPIO110_MMCCS0		110	/* MMC Chip Select 0 (PXA27x) */
+#define GPIO111_MMCDAT3		111	/* MMC DAT3 (PXA27x) */
+#define GPIO111_MMCCS1		111	/* MMC Chip Select 1 (PXA27x) */
+#define GPIO112_MMCCMD		112	/* MMC CMD (PXA27x) */
+#define GPIO113_I2S_SYSCLK	113	/* I2S System Clock (PXA27x) */
+#define GPIO113_AC97_RESET_N	113	/* AC97 NRESET on (PXA27x) */
+
+/* GPIO alternate function mode & direction */
+
+#define GPIO_IN			0x000
+#define GPIO_OUT		0x080
+#define GPIO_ALT_FN_1_IN	0x100
+#define GPIO_ALT_FN_1_OUT	0x180
+#define GPIO_ALT_FN_2_IN	0x200
+#define GPIO_ALT_FN_2_OUT	0x280
+#define GPIO_ALT_FN_3_IN	0x300
+#define GPIO_ALT_FN_3_OUT	0x380
+#define GPIO_MD_MASK_NR		0x07f
+#define GPIO_MD_MASK_DIR	0x080
+#define GPIO_MD_MASK_FN		0x300
+#define GPIO_DFLT_LOW		0x400
+#define GPIO_DFLT_HIGH		0x800
+
+#define GPIO1_RTS_MD		( 1 | GPIO_ALT_FN_1_IN)
+#define GPIO6_MMCCLK_MD		( 6 | GPIO_ALT_FN_1_OUT)
+#define GPIO7_48MHz_MD		( 7 | GPIO_ALT_FN_1_OUT)
+#define GPIO8_MMCCS0_MD		( 8 | GPIO_ALT_FN_1_OUT)
+#define GPIO9_MMCCS1_MD		( 9 | GPIO_ALT_FN_1_OUT)
+#define GPIO10_RTCCLK_MD	(10 | GPIO_ALT_FN_1_OUT)
+#define GPIO11_3_6MHz_MD	(11 | GPIO_ALT_FN_1_OUT)
+#define GPIO12_32KHz_MD		(12 | GPIO_ALT_FN_1_OUT)
+#define GPIO13_MBGNT_MD		(13 | GPIO_ALT_FN_2_OUT)
+#define GPIO14_MBREQ_MD		(14 | GPIO_ALT_FN_1_IN)
+#define GPIO15_nCS_1_MD		(15 | GPIO_ALT_FN_2_OUT)
+#define GPIO16_PWM0_MD		(16 | GPIO_ALT_FN_2_OUT)
+#define GPIO17_PWM1_MD		(17 | GPIO_ALT_FN_2_OUT)
+#define GPIO18_RDY_MD		(18 | GPIO_ALT_FN_1_IN)
+#define GPIO19_DREQ1_MD		(19 | GPIO_ALT_FN_1_IN)
+#define GPIO20_DREQ0_MD		(20 | GPIO_ALT_FN_1_IN)
+#define GPIO23_SCLK_MD		(23 | GPIO_ALT_FN_2_OUT)
+#define GPIO24_SFRM_MD		(24 | GPIO_ALT_FN_2_OUT)
+#define GPIO25_STXD_MD		(25 | GPIO_ALT_FN_2_OUT)
+#define GPIO26_SRXD_MD		(26 | GPIO_ALT_FN_1_IN)
+#define GPIO27_SEXTCLK_MD	(27 | GPIO_ALT_FN_1_IN)
+#define GPIO28_BITCLK_AC97_MD	(28 | GPIO_ALT_FN_1_IN)
+#define GPIO28_BITCLK_IN_I2S_MD	(28 | GPIO_ALT_FN_2_IN)
+#define GPIO28_BITCLK_OUT_I2S_MD	(28 | GPIO_ALT_FN_1_OUT)
+#define GPIO29_SDATA_IN_AC97_MD	(29 | GPIO_ALT_FN_1_IN)
+#define GPIO29_SDATA_IN_I2S_MD	(29 | GPIO_ALT_FN_2_IN)
+#define GPIO30_SDATA_OUT_AC97_MD	(30 | GPIO_ALT_FN_2_OUT)
+#define GPIO30_SDATA_OUT_I2S_MD	(30 | GPIO_ALT_FN_1_OUT)
+#define GPIO31_SYNC_I2S_MD	(31 | GPIO_ALT_FN_1_OUT)
+#define GPIO31_SYNC_AC97_MD	(31 | GPIO_ALT_FN_2_OUT)
+#define GPIO32_SDATA_IN1_AC97_MD	(32 | GPIO_ALT_FN_1_IN)
+#define GPIO32_SYSCLK_I2S_MD	(32 | GPIO_ALT_FN_1_OUT)
+#define GPIO32_MMCCLK_MD		( 32 | GPIO_ALT_FN_2_OUT)
+#define GPIO33_nCS_5_MD		(33 | GPIO_ALT_FN_2_OUT)
+#define GPIO34_FFRXD_MD		(34 | GPIO_ALT_FN_1_IN)
+#define GPIO34_MMCCS0_MD	(34 | GPIO_ALT_FN_2_OUT)
+#define GPIO35_FFCTS_MD		(35 | GPIO_ALT_FN_1_IN)
+#define GPIO36_FFDCD_MD		(36 | GPIO_ALT_FN_1_IN)
+#define GPIO37_FFDSR_MD		(37 | GPIO_ALT_FN_1_IN)
+#define GPIO38_FFRI_MD		(38 | GPIO_ALT_FN_1_IN)
+#define GPIO39_MMCCS1_MD	(39 | GPIO_ALT_FN_1_OUT)
+#define GPIO39_FFTXD_MD		(39 | GPIO_ALT_FN_2_OUT)
+#define GPIO40_FFDTR_MD		(40 | GPIO_ALT_FN_2_OUT)
+#define GPIO41_FFRTS_MD		(41 | GPIO_ALT_FN_2_OUT)
+#define GPIO42_BTRXD_MD		(42 | GPIO_ALT_FN_1_IN)
+#define GPIO42_HWRXD_MD		(42 | GPIO_ALT_FN_3_IN)
+#define GPIO43_BTTXD_MD		(43 | GPIO_ALT_FN_2_OUT)
+#define GPIO43_HWTXD_MD		(43 | GPIO_ALT_FN_3_OUT)
+#define GPIO44_BTCTS_MD		(44 | GPIO_ALT_FN_1_IN)
+#define GPIO44_HWCTS_MD		(44 | GPIO_ALT_FN_3_IN)
+#define GPIO45_BTRTS_MD		(45 | GPIO_ALT_FN_2_OUT)
+#define GPIO45_HWRTS_MD		(45 | GPIO_ALT_FN_3_OUT)
+#define GPIO45_SYSCLK_AC97_MD		(45 | GPIO_ALT_FN_1_OUT)
+#define GPIO46_ICPRXD_MD	(46 | GPIO_ALT_FN_1_IN)
+#define GPIO46_STRXD_MD		(46 | GPIO_ALT_FN_2_IN)
+#define GPIO47_ICPTXD_MD	(47 | GPIO_ALT_FN_2_OUT)
+#define GPIO47_STTXD_MD		(47 | GPIO_ALT_FN_1_OUT)
+#define GPIO48_nPOE_MD		(48 | GPIO_ALT_FN_2_OUT)
+#define GPIO48_HWTXD_MD         (48 | GPIO_ALT_FN_1_OUT)
+#define GPIO48_nPOE_MD          (48 | GPIO_ALT_FN_2_OUT)
+#define GPIO49_HWRXD_MD		(49 | GPIO_ALT_FN_1_IN)
+#define GPIO49_nPWE_MD		(49 | GPIO_ALT_FN_2_OUT)
+#define GPIO50_nPIOR_MD		(50 | GPIO_ALT_FN_2_OUT)
+#define GPIO50_HWCTS_MD         (50 | GPIO_ALT_FN_1_IN)
+#define GPIO51_HWRTS_MD         (51 | GPIO_ALT_FN_1_OUT)
+#define GPIO51_nPIOW_MD		(51 | GPIO_ALT_FN_2_OUT)
+#define GPIO52_nPCE_1_MD	(52 | GPIO_ALT_FN_2_OUT)
+#define GPIO53_nPCE_2_MD	(53 | GPIO_ALT_FN_2_OUT)
+#define GPIO53_MMCCLK_MD	(53 | GPIO_ALT_FN_1_OUT)
+#define GPIO54_MMCCLK_MD	(54 | GPIO_ALT_FN_1_OUT)
+#define GPIO54_nPCE_2_MD	(54 | GPIO_ALT_FN_2_OUT)
+#define GPIO54_pSKTSEL_MD	(54 | GPIO_ALT_FN_2_OUT)
+#define GPIO55_nPREG_MD		(55 | GPIO_ALT_FN_2_OUT)
+#define GPIO56_nPWAIT_MD	(56 | GPIO_ALT_FN_1_IN)
+#define GPIO57_nIOIS16_MD	(57 | GPIO_ALT_FN_1_IN)
+#define GPIO58_LDD_0_MD		(58 | GPIO_ALT_FN_2_OUT)
+#define GPIO59_LDD_1_MD		(59 | GPIO_ALT_FN_2_OUT)
+#define GPIO60_LDD_2_MD		(60 | GPIO_ALT_FN_2_OUT)
+#define GPIO61_LDD_3_MD		(61 | GPIO_ALT_FN_2_OUT)
+#define GPIO62_LDD_4_MD		(62 | GPIO_ALT_FN_2_OUT)
+#define GPIO63_LDD_5_MD		(63 | GPIO_ALT_FN_2_OUT)
+#define GPIO64_LDD_6_MD		(64 | GPIO_ALT_FN_2_OUT)
+#define GPIO65_LDD_7_MD		(65 | GPIO_ALT_FN_2_OUT)
+#define GPIO66_LDD_8_MD		(66 | GPIO_ALT_FN_2_OUT)
+#define GPIO66_MBREQ_MD		(66 | GPIO_ALT_FN_1_IN)
+#define GPIO67_LDD_9_MD		(67 | GPIO_ALT_FN_2_OUT)
+#define GPIO67_MMCCS0_MD	(67 | GPIO_ALT_FN_1_OUT)
+#define GPIO68_LDD_10_MD	(68 | GPIO_ALT_FN_2_OUT)
+#define GPIO68_MMCCS1_MD	(68 | GPIO_ALT_FN_1_OUT)
+#define GPIO69_LDD_11_MD	(69 | GPIO_ALT_FN_2_OUT)
+#define GPIO69_MMCCLK_MD	(69 | GPIO_ALT_FN_1_OUT)
+#define GPIO70_LDD_12_MD	(70 | GPIO_ALT_FN_2_OUT)
+#define GPIO70_RTCCLK_MD	(70 | GPIO_ALT_FN_1_OUT)
+#define GPIO71_LDD_13_MD	(71 | GPIO_ALT_FN_2_OUT)
+#define GPIO71_3_6MHz_MD	(71 | GPIO_ALT_FN_1_OUT)
+#define GPIO72_LDD_14_MD	(72 | GPIO_ALT_FN_2_OUT)
+#define GPIO72_32kHz_MD		(72 | GPIO_ALT_FN_1_OUT)
+#define GPIO73_LDD_15_MD	(73 | GPIO_ALT_FN_2_OUT)
+#define GPIO73_MBGNT_MD		(73 | GPIO_ALT_FN_1_OUT)
+#define GPIO74_LCD_FCLK_MD	(74 | GPIO_ALT_FN_2_OUT)
+#define GPIO75_LCD_LCLK_MD	(75 | GPIO_ALT_FN_2_OUT)
+#define GPIO76_LCD_PCLK_MD	(76 | GPIO_ALT_FN_2_OUT)
+#define GPIO77_LCD_ACBIAS_MD	(77 | GPIO_ALT_FN_2_OUT)
+#define GPIO78_nCS_2_MD		(78 | GPIO_ALT_FN_2_OUT)
+#define GPIO79_nCS_3_MD		(79 | GPIO_ALT_FN_2_OUT)
+#define GPIO79_pSKTSEL_MD	(79 | GPIO_ALT_FN_1_OUT)
+#define GPIO80_nCS_4_MD		(80 | GPIO_ALT_FN_2_OUT)
+#define GPIO81_NSSP_CLK_OUT 	(81 | GPIO_ALT_FN_1_OUT)
+#define GPIO81_NSSP_CLK_IN  	(81 | GPIO_ALT_FN_1_IN)
+#define GPIO82_NSSP_FRM_OUT 	(82 | GPIO_ALT_FN_1_OUT)
+#define GPIO82_NSSP_FRM_IN  	(82 | GPIO_ALT_FN_1_IN)
+#define GPIO83_NSSP_TX      	(83 | GPIO_ALT_FN_1_OUT)
+#define GPIO83_NSSP_RX      	(83 | GPIO_ALT_FN_2_IN)
+#define GPIO84_NSSP_TX      	(84 | GPIO_ALT_FN_1_OUT)
+#define GPIO84_NSSP_RX      	(84 | GPIO_ALT_FN_2_IN)
+#define GPIO85_nPCE_1_MD	(85 | GPIO_ALT_FN_1_OUT)
+#define GPIO92_MMCDAT0_MD	(92 | GPIO_ALT_FN_1_OUT)
+#define GPIO102_nPCE_1_MD	(102 | GPIO_ALT_FN_1_OUT)
+#define GPIO104_pSKTSEL_MD	(104 | GPIO_ALT_FN_1_OUT)
+#define GPIO109_MMCDAT1_MD	(109 | GPIO_ALT_FN_1_OUT)
+#define GPIO110_MMCDAT2_MD	(110 | GPIO_ALT_FN_1_OUT)
+#define GPIO110_MMCCS0_MD	(110 | GPIO_ALT_FN_1_OUT)
+#define GPIO111_MMCDAT3_MD	(111 | GPIO_ALT_FN_1_OUT)
+#define GPIO110_MMCCS1_MD	(111 | GPIO_ALT_FN_1_OUT)
+#define GPIO112_MMCCMD_MD	(112 | GPIO_ALT_FN_1_OUT)
+#define GPIO113_I2S_SYSCLK_MD	(113 | GPIO_ALT_FN_1_OUT)
+#define GPIO113_AC97_RESET_N_MD	(113 | GPIO_ALT_FN_2_OUT)
+#define GPIO117_I2CSCL_MD	(117 | GPIO_ALT_FN_1_IN)
+#define GPIO118_I2CSDA_MD	(118 | GPIO_ALT_FN_1_IN)
+
+/*
+ * Power Manager
+ */
+
+#define PMCR		__REG(0x40F00000)  /* Power Manager Control Register */
+#define PSSR		__REG(0x40F00004)  /* Power Manager Sleep Status Register */
+#define PSPR		__REG(0x40F00008)  /* Power Manager Scratch Pad Register */
+#define PWER		__REG(0x40F0000C)  /* Power Manager Wake-up Enable Register */
+#define PRER		__REG(0x40F00010)  /* Power Manager GPIO Rising-Edge Detect Enable Register */
+#define PFER		__REG(0x40F00014)  /* Power Manager GPIO Falling-Edge Detect Enable Register */
+#define PEDR		__REG(0x40F00018)  /* Power Manager GPIO Edge Detect Status Register */
+#define PCFR		__REG(0x40F0001C)  /* Power Manager General Configuration Register */
+#define PGSR0		__REG(0x40F00020)  /* Power Manager GPIO Sleep State Register for GP[31-0] */
+#define PGSR1		__REG(0x40F00024)  /* Power Manager GPIO Sleep State Register for GP[63-32] */
+#define PGSR2		__REG(0x40F00028)  /* Power Manager GPIO Sleep State Register for GP[84-64] */
+#define PGSR3		__REG(0x40F0002C)  /* Power Manager GPIO Sleep State Register for GP[118-96] */
+#define RCSR		__REG(0x40F00030)  /* Reset Controller Status Register */
+
+#define PSLR		__REG(0x40F00034)	/* Power Manager Sleep Config Register */
+#define PSTR		__REG(0x40F00038)	/*Power Manager Standby Config Register */
+#define PSNR		__REG(0x40F0003C)	/*Power Manager Sense Config Register */
+#define PVCR		__REG(0x40F00040)	/*Power Manager VoltageControl Register */
+#define PKWR		__REG(0x40F00050)	/* Power Manager KB Wake-up Enable Reg */
+#define PKSR		__REG(0x40F00054)	/* Power Manager KB Level-Detect Register */
+#define PCMD(x)	__REG2(0x40F00080, (x)<<2)
+#define PCMD0	__REG(0x40F00080 + 0 * 4)
+#define PCMD1	__REG(0x40F00080 + 1 * 4)
+#define PCMD2	__REG(0x40F00080 + 2 * 4)
+#define PCMD3	__REG(0x40F00080 + 3 * 4)
+#define PCMD4	__REG(0x40F00080 + 4 * 4)
+#define PCMD5	__REG(0x40F00080 + 5 * 4)
+#define PCMD6	__REG(0x40F00080 + 6 * 4)
+#define PCMD7	__REG(0x40F00080 + 7 * 4)
+#define PCMD8	__REG(0x40F00080 + 8 * 4)
+#define PCMD9	__REG(0x40F00080 + 9 * 4)
+#define PCMD10	__REG(0x40F00080 + 10 * 4)
+#define PCMD11	__REG(0x40F00080 + 11 * 4)
+#define PCMD12	__REG(0x40F00080 + 12 * 4)
+#define PCMD13	__REG(0x40F00080 + 13 * 4)
+#define PCMD14	__REG(0x40F00080 + 14 * 4)
+#define PCMD15	__REG(0x40F00080 + 15 * 4)
+#define PCMD16	__REG(0x40F00080 + 16 * 4)
+#define PCMD17	__REG(0x40F00080 + 17 * 4)
+#define PCMD18	__REG(0x40F00080 + 18 * 4)
+#define PCMD19	__REG(0x40F00080 + 19 * 4)
+#define PCMD20	__REG(0x40F00080 + 20 * 4)
+#define PCMD21	__REG(0x40F00080 + 21 * 4)
+#define PCMD22	__REG(0x40F00080 + 22 * 4)
+#define PCMD23	__REG(0x40F00080 + 23 * 4)
+#define PCMD24	__REG(0x40F00080 + 24 * 4)
+#define PCMD25	__REG(0x40F00080 + 25 * 4)
+#define PCMD26	__REG(0x40F00080 + 26 * 4)
+#define PCMD27	__REG(0x40F00080 + 27 * 4)
+#define PCMD28	__REG(0x40F00080 + 28 * 4)
+#define PCMD29	__REG(0x40F00080 + 29 * 4)
+#define PCMD30	__REG(0x40F00080 + 30 * 4)
+#define PCMD31	__REG(0x40F00080 + 31 * 4)
+
+#define PCMD_MBC	(1<<12)
+#define PCMD_DCE	(1<<11)
+#define PCMD_LC	(1<<10)
+/* FIXME:  PCMD_SQC need be checked.   */
+#define PCMD_SQC	(3<<8)	/* currently only bit 8 is changeable,
+				   bit 9 should be 0 all day. */
+#define PVCR_VCSA	(0x1<<14)
+#define PVCR_CommandDelay (0xf80)
+#define PCFR_PI2C_EN	(0x1 << 6)
+
+#define PSSR_OTGPH	(1 << 6)	/* OTG Peripheral control Hold */
+#define PSSR_RDH	(1 << 5)	/* Read Disable Hold */
+#define PSSR_PH		(1 << 4)	/* Peripheral Control Hold */
+#define PSSR_STS	(1 << 3)	/* Standby Mode Status */
+#define PSSR_VFS	(1 << 2)	/* VDD Fault Status */
+#define PSSR_BFS	(1 << 1)	/* Battery Fault Status */
+#define PSSR_SSS	(1 << 0)	/* Software Sleep Status */
+
+#define PSLR_SL_ROD	(1 << 20)	/* Sleep-Mode/Depp-Sleep Mode nRESET_OUT Disable */
+
+#define PCFR_RO		(1 << 15)	/* RDH Override */
+#define PCFR_PO		(1 << 14)	/* PH Override */
+#define PCFR_GPROD	(1 << 12)	/* GPIO nRESET_OUT Disable */
+#define PCFR_L1_EN	(1 << 11)	/* Sleep Mode L1 converter Enable */
+#define PCFR_FVC	(1 << 10)	/* Frequency/Voltage Change */
+#define PCFR_DC_EN	(1 << 7)	/* Sleep/deep-sleep DC-DC Converter Enable */
+#define PCFR_PI2CEN	(1 << 6)	/* Enable PI2C controller */
+#define PCFR_GPR_EN	(1 << 4)	/* nRESET_GPIO Pin Enable */
+#define PCFR_DS		(1 << 3)	/* Deep Sleep Mode */
+#define PCFR_FS		(1 << 2)	/* Float Static Chip Selects */
+#define PCFR_FP		(1 << 1)	/* Float PCMCIA controls */
+#define PCFR_OPDE	(1 << 0)	/* 3.6864 MHz oscillator power-down enable */
+
+#define RCSR_GPR	(1 << 3)	/* GPIO Reset */
+#define RCSR_SMR	(1 << 2)	/* Sleep Mode */
+#define RCSR_WDR	(1 << 1)	/* Watchdog Reset */
+#define RCSR_HWR	(1 << 0)	/* Hardware Reset */
+
+#define PWER_GPIO(Nb)	(1 << Nb)	/* GPIO [0..15] wake-up enable     */
+#define PWER_GPIO0	PWER_GPIO (0)	/* GPIO  [0] wake-up enable        */
+#define PWER_GPIO1	PWER_GPIO (1)	/* GPIO  [1] wake-up enable        */
+#define PWER_GPIO2	PWER_GPIO (2)	/* GPIO  [2] wake-up enable        */
+#define PWER_GPIO3	PWER_GPIO (3)	/* GPIO  [3] wake-up enable        */
+#define PWER_GPIO4	PWER_GPIO (4)	/* GPIO  [4] wake-up enable        */
+#define PWER_GPIO5	PWER_GPIO (5)	/* GPIO  [5] wake-up enable        */
+#define PWER_GPIO6	PWER_GPIO (6)	/* GPIO  [6] wake-up enable        */
+#define PWER_GPIO7	PWER_GPIO (7)	/* GPIO  [7] wake-up enable        */
+#define PWER_GPIO8	PWER_GPIO (8)	/* GPIO  [8] wake-up enable        */
+#define PWER_GPIO9	PWER_GPIO (9)	/* GPIO  [9] wake-up enable        */
+#define PWER_GPIO10	PWER_GPIO (10)	/* GPIO [10] wake-up enable        */
+#define PWER_GPIO11	PWER_GPIO (11)	/* GPIO [11] wake-up enable        */
+#define PWER_GPIO12	PWER_GPIO (12)	/* GPIO [12] wake-up enable        */
+#define PWER_GPIO13	PWER_GPIO (13)	/* GPIO [13] wake-up enable        */
+#define PWER_GPIO14	PWER_GPIO (14)	/* GPIO [14] wake-up enable        */
+#define PWER_GPIO15	PWER_GPIO (15)	/* GPIO [15] wake-up enable        */
+#define PWER_RTC	0x80000000	/* RTC alarm wake-up enable        */
+
+
+/*
+ * SSP Serial Port Registers
+ * PXA250, PXA255, PXA26x and PXA27x SSP controllers are all slightly different.
+ * PXA255, PXA26x and PXA27x have extra ports, registers and bits.
+ */
+
+ /* Common PXA2xx bits first */
+#define SSCR0_DSS	(0x0000000f)	/* Data Size Select (mask) */
+#define SSCR0_DataSize(x)  ((x) - 1)	/* Data Size Select [4..16] */
+#define SSCR0_FRF	(0x00000030)	/* FRame Format (mask) */
+#define SSCR0_Motorola	(0x0 << 4)	/* Motorola's Serial Peripheral Interface (SPI) */
+#define SSCR0_TI	(0x1 << 4)	/* Texas Instruments' Synchronous Serial Protocol (SSP) */
+#define SSCR0_National	(0x2 << 4)	/* National Microwire */
+#define SSCR0_ECS	(1 << 6)	/* External clock select */
+#define SSCR0_SSE	(1 << 7)	/* Synchronous Serial Port Enable */
+#if defined(CONFIG_PXA25x)
+#define SSCR0_SCR	(0x0000ff00)	/* Serial Clock Rate (mask) */
+#define SSCR0_SerClkDiv(x) ((((x) - 2)/2) << 8) /* Divisor [2..512] */
+#elif defined(CONFIG_PXA27x)
+#define SSCR0_SCR	(0x000fff00)	/* Serial Clock Rate (mask) */
+#define SSCR0_SerClkDiv(x) (((x) - 1) << 8) /* Divisor [1..4096] */
+#define SSCR0_EDSS	(1 << 20)	/* Extended data size select */
+#define SSCR0_NCS	(1 << 21)	/* Network clock select */
+#define SSCR0_RIM	(1 << 22)	/* Receive FIFO overrrun interrupt mask */
+#define SSCR0_TUM	(1 << 23)	/* Transmit FIFO underrun interrupt mask */
+#define SSCR0_FRDC	(0x07000000)	/* Frame rate divider control (mask) */
+#define SSCR0_SlotsPerFrm(x) (((x) - 1) << 24)	/* Time slots per frame [1..8] */
+#define SSCR0_ADC	(1 << 30)	/* Audio clock select */
+#define SSCR0_MOD	(1 << 31)	/* Mode (normal or network) */
+#endif
+
+#define SSCR1_RIE	(1 << 0)	/* Receive FIFO Interrupt Enable */
+#define SSCR1_TIE	(1 << 1)	/* Transmit FIFO Interrupt Enable */
+#define SSCR1_LBM	(1 << 2)	/* Loop-Back Mode */
+#define SSCR1_SPO	(1 << 3)	/* Motorola SPI SSPSCLK polarity setting */
+#define SSCR1_SPH	(1 << 4)	/* Motorola SPI SSPSCLK phase setting */
+#define SSCR1_MWDS	(1 << 5)	/* Microwire Transmit Data Size */
+#define SSCR1_TFT	(0x000003c0)	/* Transmit FIFO Threshold (mask) */
+#define SSCR1_TxTresh(x) (((x) - 1) << 6) /* level [1..16] */
+#define SSCR1_RFT	(0x00003c00)	/* Receive FIFO Threshold (mask) */
+#define SSCR1_RxTresh(x) (((x) - 1) << 10) /* level [1..16] */
+
+#define SSSR_TNF	(1 << 2)	/* Transmit FIFO Not Full */
+#define SSSR_RNE	(1 << 3)	/* Receive FIFO Not Empty */
+#define SSSR_BSY	(1 << 4)	/* SSP Busy */
+#define SSSR_TFS	(1 << 5)	/* Transmit FIFO Service Request */
+#define SSSR_RFS	(1 << 6)	/* Receive FIFO Service Request */
+#define SSSR_ROR	(1 << 7)	/* Receive FIFO Overrun */
+
+#define SSCR0_TIM		(1 << 23)	/* Transmit FIFO Under Run Interrupt Mask */
+#define SSCR0_RIM		(1 << 22)	/* Receive FIFO Over Run interrupt Mask */
+#define SSCR0_NCS		(1 << 21)	/* Network Clock Select */
+#define SSCR0_EDSS		(1 << 20)	/* Extended Data Size Select */
+
+/* extra bits in PXA255, PXA26x and PXA27x SSP ports */
+#define SSCR0_TISSP		(1 << 4)	/* TI Sync Serial Protocol */
+#define SSCR0_PSP		(3 << 4)	/* PSP - Programmable Serial Protocol */
+#define SSCR1_TTELP		(1 << 31)	/* TXD Tristate Enable Last Phase */
+#define SSCR1_TTE		(1 << 30)	/* TXD Tristate Enable */
+#define SSCR1_EBCEI		(1 << 29)	/* Enable Bit Count Error interrupt */
+#define SSCR1_SCFR		(1 << 28)	/* Slave Clock free Running */
+#define SSCR1_ECRA		(1 << 27)	/* Enable Clock Request A */
+#define SSCR1_ECRB		(1 << 26)	/* Enable Clock request B */
+#define SSCR1_SCLKDIR	(1 << 25)	/* Serial Bit Rate Clock Direction */
+#define SSCR1_SFRMDIR	(1 << 24)	/* Frame Direction */
+#define SSCR1_RWOT		(1 << 23)	/* Receive Without Transmit */
+#define SSCR1_TRAIL		(1 << 22)	/* Trailing Byte */
+#define SSCR1_TSRE		(1 << 21)	/* Transmit Service Request Enable */
+#define SSCR1_RSRE		(1 << 20)	/* Receive Service Request Enable */
+#define SSCR1_TINTE		(1 << 19)	/* Receiver Time-out Interrupt enable */
+#define SSCR1_PINTE		(1 << 18)	/* Peripheral Trailing Byte Interupt Enable */
+#define SSCR1_STRF		(1 << 15)	/* Select FIFO or EFWR */
+#define SSCR1_EFWR		(1 << 14)	/* Enable FIFO Write/Read */
+
+#define SSSR_BCE		(1 << 23)	/* Bit Count Error */
+#define SSSR_CSS		(1 << 22)	/* Clock Synchronisation Status */
+#define SSSR_TUR		(1 << 21)	/* Transmit FIFO Under Run */
+#define SSSR_EOC		(1 << 20)	/* End Of Chain */
+#define SSSR_TINT		(1 << 19)	/* Receiver Time-out Interrupt */
+#define SSSR_PINT		(1 << 18)	/* Peripheral Trailing Byte Interrupt */
+
+#define SSPSP_FSRT		(1 << 25)	/* Frame Sync Relative Timing */
+#define SSPSP_DMYSTOP(x)	((x) << 23)	/* Dummy Stop */
+#define SSPSP_SFRMWDTH(x)	((x) << 16)	/* Serial Frame Width */
+#define SSPSP_SFRMDLY(x)	((x) << 9)	/* Serial Frame Delay */
+#define SSPSP_DMYSTRT(x)	((x) << 7)	/* Dummy Start */
+#define SSPSP_STRTDLY(x)	((x) << 4)	/* Start Delay */
+#define SSPSP_ETDS			(1 << 3)	/* End of Transfer data State */
+#define SSPSP_SFRMP			(1 << 2)	/* Serial Frame Polarity */
+#define SSPSP_SCMODE(x)		((x) << 0)	/* Serial Bit Rate Clock Mode */
+
+#define SSACD_SCDB		(1 << 3)	/* SSPSYSCLK Divider Bypass */
+#define SSACD_ACPS(x)		((x) << 4)	/* Audio clock PLL select */
+#define SSACD_ACDS(x)		((x) << 0)	/* Audio clock divider select */
+
+#define SSCR0_P1	__REG(0x41000000)  /* SSP Port 1 Control Register 0 */
+#define SSCR1_P1	__REG(0x41000004)  /* SSP Port 1 Control Register 1 */
+#define SSSR_P1		__REG(0x41000008)  /* SSP Port 1 Status Register */
+#define SSITR_P1	__REG(0x4100000C)  /* SSP Port 1 Interrupt Test Register */
+#define SSDR_P1		__REG(0x41000010)  /* (Write / Read) SSP Port 1 Data Write Register/SSP Data Read Register */
+
+/* Support existing PXA25x drivers */
+#define SSCR0		SSCR0_P1  /* SSP Control Register 0 */
+#define SSCR1		SSCR1_P1  /* SSP Control Register 1 */
+#define SSSR		SSSR_P1	  /* SSP Status Register */
+#define SSITR		SSITR_P1  /* SSP Interrupt Test Register */
+#define SSDR		SSDR_P1	  /* (Write / Read) SSP Data Write Register/SSP Data Read Register */
+
+/* PXA27x ports */
+#if defined (CONFIG_PXA27x)
+#define SSTO_P1		__REG(0x41000028)  /* SSP Port 1 Time Out Register */
+#define SSPSP_P1	__REG(0x4100002C)  /* SSP Port 1 Programmable Serial Protocol */
+#define SSTSA_P1	__REG(0x41000030)  /* SSP Port 1 Tx Timeslot Active */
+#define SSRSA_P1	__REG(0x41000034)  /* SSP Port 1 Rx Timeslot Active */
+#define SSTSS_P1	__REG(0x41000038)  /* SSP Port 1 Timeslot Status */
+#define SSACD_P1	__REG(0x4100003C)  /* SSP Port 1 Audio Clock Divider */
+#define SSCR0_P2	__REG(0x41700000)  /* SSP Port 2 Control Register 0 */
+#define SSCR1_P2	__REG(0x41700004)  /* SSP Port 2 Control Register 1 */
+#define SSSR_P2		__REG(0x41700008)  /* SSP Port 2 Status Register */
+#define SSITR_P2	__REG(0x4170000C)  /* SSP Port 2 Interrupt Test Register */
+#define SSDR_P2		__REG(0x41700010)  /* (Write / Read) SSP Port 2 Data Write Register/SSP Data Read Register */
+#define SSTO_P2		__REG(0x41700028)  /* SSP Port 2 Time Out Register */
+#define SSPSP_P2	__REG(0x4170002C)  /* SSP Port 2 Programmable Serial Protocol */
+#define SSTSA_P2	__REG(0x41700030)  /* SSP Port 2 Tx Timeslot Active */
+#define SSRSA_P2	__REG(0x41700034)  /* SSP Port 2 Rx Timeslot Active */
+#define SSTSS_P2	__REG(0x41700038)  /* SSP Port 2 Timeslot Status */
+#define SSACD_P2	__REG(0x4170003C)  /* SSP Port 2 Audio Clock Divider */
+#define SSCR0_P3	__REG(0x41900000)  /* SSP Port 3 Control Register 0 */
+#define SSCR1_P3	__REG(0x41900004)  /* SSP Port 3 Control Register 1 */
+#define SSSR_P3		__REG(0x41900008)  /* SSP Port 3 Status Register */
+#define SSITR_P3	__REG(0x4190000C)  /* SSP Port 3 Interrupt Test Register */
+#define SSDR_P3		__REG(0x41900010)  /* (Write / Read) SSP Port 3 Data Write Register/SSP Data Read Register */
+#define SSTO_P3		__REG(0x41900028)  /* SSP Port 3 Time Out Register */
+#define SSPSP_P3	__REG(0x4190002C)  /* SSP Port 3 Programmable Serial Protocol */
+#define SSTSA_P3	__REG(0x41900030)  /* SSP Port 3 Tx Timeslot Active */
+#define SSRSA_P3	__REG(0x41900034)  /* SSP Port 3 Rx Timeslot Active */
+#define SSTSS_P3	__REG(0x41900038)  /* SSP Port 3 Timeslot Status */
+#define SSACD_P3	__REG(0x4190003C)  /* SSP Port 3 Audio Clock Divider */
+#else /* PXA255 (only port 2) and PXA26x ports*/
+#define SSTO_P1		__REG(0x41000028)  /* SSP Port 1 Time Out Register */
+#define SSPSP_P1	__REG(0x4100002C)  /* SSP Port 1 Programmable Serial Protocol */
+#define SSCR0_P2	__REG(0x41400000)  /* SSP Port 2 Control Register 0 */
+#define SSCR1_P2	__REG(0x41400004)  /* SSP Port 2 Control Register 1 */
+#define SSSR_P2		__REG(0x41400008)  /* SSP Port 2 Status Register */
+#define SSITR_P2	__REG(0x4140000C)  /* SSP Port 2 Interrupt Test Register */
+#define SSDR_P2		__REG(0x41400010)  /* (Write / Read) SSP Port 2 Data Write Register/SSP Data Read Register */
+#define SSTO_P2		__REG(0x41400028)  /* SSP Port 2 Time Out Register */
+#define SSPSP_P2	__REG(0x4140002C)  /* SSP Port 2 Programmable Serial Protocol */
+#define SSCR0_P3	__REG(0x41500000)  /* SSP Port 3 Control Register 0 */
+#define SSCR1_P3	__REG(0x41500004)  /* SSP Port 3 Control Register 1 */
+#define SSSR_P3		__REG(0x41500008)  /* SSP Port 3 Status Register */
+#define SSITR_P3	__REG(0x4150000C)  /* SSP Port 3 Interrupt Test Register */
+#define SSDR_P3		__REG(0x41500010)  /* (Write / Read) SSP Port 3 Data Write Register/SSP Data Read Register */
+#define SSTO_P3		__REG(0x41500028)  /* SSP Port 3 Time Out Register */
+#define SSPSP_P3	__REG(0x4150002C)  /* SSP Port 3 Programmable Serial Protocol */
+#endif
+
+#define SSCR0_P(x) (*(((x) == 1) ? &SSCR0_P1 : ((x) == 2) ? &SSCR0_P2 : ((x) == 3) ? &SSCR0_P3 : NULL))
+#define SSCR1_P(x) (*(((x) == 1) ? &SSCR1_P1 : ((x) == 2) ? &SSCR1_P2 : ((x) == 3) ? &SSCR1_P3 : NULL))
+#define SSSR_P(x) (*(((x) == 1) ? &SSSR_P1 : ((x) == 2) ? &SSSR_P2 : ((x) == 3) ? &SSSR_P3 : NULL))
+#define SSITR_P(x) (*(((x) == 1) ? &SSITR_P1 : ((x) == 2) ? &SSITR_P2 : ((x) == 3) ? &SSITR_P3 : NULL))
+#define SSDR_P(x) (*(((x) == 1) ? &SSDR_P1 : ((x) == 2) ? &SSDR_P2 : ((x) == 3) ? &SSDR_P3 : NULL))
+#define SSTO_P(x) (*(((x) == 1) ? &SSTO_P1 : ((x) == 2) ? &SSTO_P2 : ((x) == 3) ? &SSTO_P3 : NULL))
+#define SSPSP_P(x) (*(((x) == 1) ? &SSPSP_P1 : ((x) == 2) ? &SSPSP_P2 : ((x) == 3) ? &SSPSP_P3 : NULL))
+#define SSTSA_P(x) (*(((x) == 1) ? &SSTSA_P1 : ((x) == 2) ? &SSTSA_P2 : ((x) == 3) ? &SSTSA_P3 : NULL))
+#define SSRSA_P(x) (*(((x) == 1) ? &SSRSA_P1 : ((x) == 2) ? &SSRSA_P2 : ((x) == 3) ? &SSRSA_P3 : NULL))
+#define SSTSS_P(x) (*(((x) == 1) ? &SSTSS_P1 : ((x) == 2) ? &SSTSS_P2 : ((x) == 3) ? &SSTSS_P3 : NULL))
+#define SSACD_P(x) (*(((x) == 1) ? &SSACD_P1 : ((x) == 2) ? &SSACD_P2 : ((x) == 3) ? &SSACD_P3 : NULL))
+
+/*
+ * MultiMediaCard (MMC) controller
+ */
+
+#define MMC_STRPCL	__REG(0x41100000)  /* Control to start and stop MMC clock */
+#define MMC_STAT	__REG(0x41100004)  /* MMC Status Register (read only) */
+#define MMC_CLKRT	__REG(0x41100008)  /* MMC clock rate */
+#define MMC_SPI		__REG(0x4110000c)  /* SPI mode control bits */
+#define MMC_CMDAT	__REG(0x41100010)  /* Command/response/data sequence control */
+#define MMC_RESTO	__REG(0x41100014)  /* Expected response time out */
+#define MMC_RDTO	__REG(0x41100018)  /* Expected data read time out */
+#define MMC_BLKLEN	__REG(0x4110001c)  /* Block length of data transaction */
+#define MMC_NOB		__REG(0x41100020)  /* Number of blocks, for block mode */
+#define MMC_PRTBUF	__REG(0x41100024)  /* Partial MMC_TXFIFO FIFO written */
+#define MMC_I_MASK	__REG(0x41100028)  /* Interrupt Mask */
+#define MMC_I_REG	__REG(0x4110002c)  /* Interrupt Register (read only) */
+#define MMC_CMD		__REG(0x41100030)  /* Index of current command */
+#define MMC_ARGH	__REG(0x41100034)  /* MSW part of the current command argument */
+#define MMC_ARGL	__REG(0x41100038)  /* LSW part of the current command argument */
+#define MMC_RES		__REG(0x4110003c)  /* Response FIFO (read only) */
+#define MMC_RXFIFO	__REG(0x41100040)  /* Receive FIFO (read only) */
+#define MMC_TXFIFO	__REG(0x41100044)  /* Transmit FIFO (write only) */
+
+
+/*
+ * Core Clock
+ */
+
+#define CCCR		__REG(0x41300000)  /* Core Clock Configuration Register */
+#define CKEN		__REG(0x41300004)  /* Clock Enable Register */
+#define OSCC		__REG(0x41300008)  /* Oscillator Configuration Register */
+#define CCSR		__REG(0x4130000C)  /* Core Clock Status Register */
+
+#define CCCR_N_MASK	0x0380		/* Run Mode Frequency to Turbo Mode Frequency Multiplier */
+#define CCCR_M_MASK	0x0060		/* Memory Frequency to Run Mode Frequency Multiplier */
+#define CCCR_L_MASK	0x001f		/* Crystal Frequency to Memory Frequency Multiplier */
+
+#define CKEN24_CAMERA	(1 << 24)	/* Camera Interface Clock Enable */
+#define CKEN23_SSP1	(1 << 23)	/* SSP1 Unit Clock Enable */
+#define CKEN22_MEMC	(1 << 22)	/* Memory Controller Clock Enable */
+#define CKEN21_MEMSTK	(1 << 21)	/* Memory Stick Host Controller */
+#define CKEN20_IM	(1 << 20)	/* Internal Memory Clock Enable */
+#define CKEN19_KEYPAD	(1 << 19)	/* Keypad Interface Clock Enable */
+#define CKEN18_USIM	(1 << 18)	/* USIM Unit Clock Enable */
+#define CKEN17_MSL	(1 << 17)	/* MSL Unit Clock Enable */
+#define CKEN16_LCD	(1 << 16)	/* LCD Unit Clock Enable */
+#define CKEN15_PWRI2C	(1 << 15)	/* PWR I2C Unit Clock Enable */
+#define CKEN14_I2C	(1 << 14)	/* I2C Unit Clock Enable */
+#define CKEN13_FICP	(1 << 13)	/* FICP Unit Clock Enable */
+#define CKEN12_MMC	(1 << 12)	/* MMC Unit Clock Enable */
+#define CKEN11_USB	(1 << 11)	/* USB Unit Clock Enable */
+#define CKEN10_ASSP	(1 << 10)	/* ASSP (SSP3) Clock Enable */
+#define CKEN10_USBHOST	(1 << 10)	/* USB Host Unit Clock Enable */
+#define CKEN9_OSTIMER	(1 << 9)	/* OS Timer Unit Clock Enable */
+#define CKEN9_NSSP	(1 << 9)	/* NSSP (SSP2) Clock Enable */
+#define CKEN8_I2S	(1 << 8)	/* I2S Unit Clock Enable */
+#define CKEN7_BTUART	(1 << 7)	/* BTUART Unit Clock Enable */
+#define CKEN6_FFUART	(1 << 6)	/* FFUART Unit Clock Enable */
+#define CKEN5_STUART	(1 << 5)	/* STUART Unit Clock Enable */
+#define CKEN4_HWUART	(1 << 4)	/* HWUART Unit Clock Enable */
+#define CKEN4_SSP3	(1 << 4)	/* SSP3 Unit Clock Enable */
+#define CKEN3_SSP	(1 << 3)	/* SSP Unit Clock Enable */
+#define CKEN3_SSP2	(1 << 3)	/* SSP2 Unit Clock Enable */
+#define CKEN2_AC97	(1 << 2)	/* AC97 Unit Clock Enable */
+#define CKEN1_PWM1	(1 << 1)	/* PWM1 Clock Enable */
+#define CKEN0_PWM0	(1 << 0)	/* PWM0 Clock Enable */
+
+#define OSCC_OON	(1 << 1)	/* 32.768kHz OON (write-once only bit) */
+#define OSCC_OOK	(1 << 0)	/* 32.768kHz OOK (read-only bit) */
+
+
+/*
+ * LCD
+ */
+
+#define LCCR0		__REG(0x44000000)  /* LCD Controller Control Register 0 */
+#define LCCR1		__REG(0x44000004)  /* LCD Controller Control Register 1 */
+#define LCCR2		__REG(0x44000008)  /* LCD Controller Control Register 2 */
+#define LCCR3		__REG(0x4400000C)  /* LCD Controller Control Register 3 */
+#define DFBR0		__REG(0x44000020)  /* DMA Channel 0 Frame Branch Register */
+#define DFBR1		__REG(0x44000024)  /* DMA Channel 1 Frame Branch Register */
+#define LCSR		__REG(0x44000038)  /* LCD Controller Status Register */
+#define LIIDR		__REG(0x4400003C)  /* LCD Controller Interrupt ID Register */
+#define TMEDRGBR	__REG(0x44000040)  /* TMED RGB Seed Register */
+#define TMEDCR		__REG(0x44000044)  /* TMED Control Register */
+
+#define LCCR3_1BPP (0 << 24)
+#define LCCR3_2BPP (1 << 24)
+#define LCCR3_4BPP (2 << 24)
+#define LCCR3_8BPP (3 << 24)
+#define LCCR3_16BPP (4 << 24)
+
+#define FDADR0		__REG(0x44000200)  /* DMA Channel 0 Frame Descriptor Address Register */
+#define FSADR0		__REG(0x44000204)  /* DMA Channel 0 Frame Source Address Register */
+#define FIDR0		__REG(0x44000208)  /* DMA Channel 0 Frame ID Register */
+#define LDCMD0		__REG(0x4400020C)  /* DMA Channel 0 Command Register */
+#define FDADR1		__REG(0x44000210)  /* DMA Channel 1 Frame Descriptor Address Register */
+#define FSADR1		__REG(0x44000214)  /* DMA Channel 1 Frame Source Address Register */
+#define FIDR1		__REG(0x44000218)  /* DMA Channel 1 Frame ID Register */
+#define LDCMD1		__REG(0x4400021C)  /* DMA Channel 1 Command Register */
+
+#define LCCR0_ENB	(1 << 0)	/* LCD Controller enable */
+#define LCCR0_CMS	(1 << 1)	/* Color/Monochrome Display Select */
+#define LCCR0_Color     (LCCR0_CMS*0)   /*  Color display                  */
+#define LCCR0_Mono      (LCCR0_CMS*1)   /*  Monochrome display             */
+#define LCCR0_SDS	(1 << 2)	/* Single/Dual Panel Display       */
+                                        /* Select                          */
+#define LCCR0_Sngl      (LCCR0_SDS*0)   /*  Single panel display           */
+#define LCCR0_Dual      (LCCR0_SDS*1)   /*  Dual panel display             */
+
+#define LCCR0_LDM	(1 << 3)	/* LCD Disable Done Mask */
+#define LCCR0_SFM	(1 << 4)	/* Start of frame mask */
+#define LCCR0_IUM	(1 << 5)	/* Input FIFO underrun mask */
+#define LCCR0_EFM	(1 << 6)	/* End of Frame mask */
+#define LCCR0_PAS	(1 << 7)	/* Passive/Active display Select   */
+#define LCCR0_Pas       (LCCR0_PAS*0)   /*  Passive display (STN)          */
+#define LCCR0_Act       (LCCR0_PAS*1)   /*  Active display (TFT)           */
+#define LCCR0_DPD	(1 << 9)	/* Double Pixel Data (monochrome   */
+                                        /* display mode)                   */
+#define LCCR0_4PixMono  (LCCR0_DPD*0)   /*  4-Pixel/clock Monochrome       */
+                                        /*  display                        */
+#define LCCR0_8PixMono  (LCCR0_DPD*1)   /*  8-Pixel/clock Monochrome       */
+                                        /*  display                        */
+#define LCCR0_DIS	(1 << 10)	/* LCD Disable */
+#define LCCR0_QDM	(1 << 11)	/* LCD Quick Disable mask */
+#define LCCR0_PDD	(0xff << 12)	/* Palette DMA request delay */
+#define LCCR0_PDD_S	12
+#define LCCR0_BM	(1 << 20) 	/* Branch mask */
+#define LCCR0_OUM	(1 << 21)	/* Output FIFO underrun mask */
+#define LCCR0_LCDT      (1 << 22)       /* LCD panel type */
+#define LCCR0_RDSTM     (1 << 23)       /* Read status interrupt mask */
+#define LCCR0_CMDIM     (1 << 24)       /* Command interrupt mask */
+#define LCCR0_OUC       (1 << 25)       /* Overlay Underlay control bit */
+#define LCCR0_LDDALT    (1 << 26)       /* LDD alternate mapping control */
+
+#define LCCR1_PPL       Fld (10, 0)      /* Pixels Per Line - 1 */
+#define LCCR1_DisWdth(Pixel)            /* Display Width [1..800 pix.]  */ \
+                        (((Pixel) - 1) << FShft (LCCR1_PPL))
+
+#define LCCR1_HSW       Fld (6, 10)     /* Horizontal Synchronization     */
+#define LCCR1_HorSnchWdth(Tpix)         /* Horizontal Synchronization     */ \
+                                        /* pulse Width [1..64 Tpix]       */ \
+                        (((Tpix) - 1) << FShft (LCCR1_HSW))
+
+#define LCCR1_ELW       Fld (8, 16)     /* End-of-Line pixel clock Wait    */
+                                        /* count - 1 [Tpix]                */
+#define LCCR1_EndLnDel(Tpix)            /*  End-of-Line Delay              */ \
+                                        /*  [1..256 Tpix]                  */ \
+                        (((Tpix) - 1) << FShft (LCCR1_ELW))
+
+#define LCCR1_BLW       Fld (8, 24)     /* Beginning-of-Line pixel clock   */
+                                        /* Wait count - 1 [Tpix]           */
+#define LCCR1_BegLnDel(Tpix)            /*  Beginning-of-Line Delay        */ \
+                                        /*  [1..256 Tpix]                  */ \
+                        (((Tpix) - 1) << FShft (LCCR1_BLW))
+
+
+#define LCCR2_LPP       Fld (10, 0)     /* Line Per Panel - 1              */
+#define LCCR2_DisHght(Line)             /*  Display Height [1..1024 lines] */ \
+                        (((Line) - 1) << FShft (LCCR2_LPP))
+
+#define LCCR2_VSW       Fld (6, 10)     /* Vertical Synchronization pulse  */
+                                        /* Width - 1 [Tln] (L_FCLK)        */
+#define LCCR2_VrtSnchWdth(Tln)          /*  Vertical Synchronization pulse */ \
+                                        /*  Width [1..64 Tln]              */ \
+                        (((Tln) - 1) << FShft (LCCR2_VSW))
+
+#define LCCR2_EFW       Fld (8, 16)     /* End-of-Frame line clock Wait    */
+                                        /* count [Tln]                     */
+#define LCCR2_EndFrmDel(Tln)            /*  End-of-Frame Delay             */ \
+                                        /*  [0..255 Tln]                   */ \
+                        ((Tln) << FShft (LCCR2_EFW))
+
+#define LCCR2_BFW       Fld (8, 24)     /* Beginning-of-Frame line clock   */
+                                        /* Wait count [Tln]                */
+#define LCCR2_BegFrmDel(Tln)            /*  Beginning-of-Frame Delay       */ \
+                                        /*  [0..255 Tln]                   */ \
+                        ((Tln) << FShft (LCCR2_BFW))
+
+#if 0
+#define LCCR3_PCD	(0xff)		/* Pixel clock divisor */
+#define LCCR3_ACB	(0xff << 8)	/* AC Bias pin frequency */
+#define LCCR3_ACB_S	8
+#endif
+
+#define LCCR3_API	(0xf << 16)	/* AC Bias pin trasitions per interrupt */
+#define LCCR3_API_S	16
+#define LCCR3_VSP	(1 << 20)	/* vertical sync polarity */
+#define LCCR3_HSP	(1 << 21)	/* horizontal sync polarity */
+#define LCCR3_PCP	(1 << 22)	/* Pixel Clock Polarity (L_PCLK)   */
+#define LCCR3_PixRsEdg  (LCCR3_PCP*0)   /*  Pixel clock Rising-Edge        */
+#define LCCR3_PixFlEdg  (LCCR3_PCP*1)   /*  Pixel clock Falling-Edge       */
+
+#define LCCR3_OEP       (1 << 23)       /* Output Enable Polarity (L_BIAS, */
+                                        /* active display mode)            */
+#define LCCR3_OutEnH    (LCCR3_OEP*0)   /*  Output Enable active High      */
+#define LCCR3_OutEnL    (LCCR3_OEP*1)   /*  Output Enable active Low       */
+
+#if 0
+#define LCCR3_BPP	(7 << 24)	/* bits per pixel */
+#define LCCR3_BPP_S	24
+#endif
+#define LCCR3_DPC	(1 << 27)	/* double pixel clock mode */
+
+
+#define LCCR3_PCD       Fld (8, 0)      /* Pixel Clock Divisor */
+#define LCCR3_PixClkDiv(Div)            /* Pixel Clock Divisor */ \
+                        (((Div) << FShft (LCCR3_PCD)))
+
+
+#define LCCR3_BPP       Fld (3, 24)     /* Bit Per Pixel */
+#define LCCR3_Bpp(Bpp)                  /* Bit Per Pixel */ \
+                        (((Bpp) << FShft (LCCR3_BPP)))
+
+#define LCCR3_ACB       Fld (8, 8)      /* AC Bias */
+#define LCCR3_Acb(Acb)                  /* BAC Bias */ \
+                        (((Acb) << FShft (LCCR3_ACB)))
+
+#define LCCR3_HorSnchH  (LCCR3_HSP*0)   /*  Horizontal Synchronization     */
+                                        /*  pulse active High              */
+#define LCCR3_HorSnchL  (LCCR3_HSP*1)   /*  Horizontal Synchronization     */
+
+#define LCCR3_VrtSnchH  (LCCR3_VSP*0)   /*  Vertical Synchronization pulse */
+                                        /*  active High                    */
+#define LCCR3_VrtSnchL  (LCCR3_VSP*1)   /*  Vertical Synchronization pulse */
+                                        /*  active Low                     */
+
+#define LCSR_LDD	(1 << 0)	/* LCD Disable Done */
+#define LCSR_SOF	(1 << 1)	/* Start of frame */
+#define LCSR_BER	(1 << 2)	/* Bus error */
+#define LCSR_ABC	(1 << 3)	/* AC Bias count */
+#define LCSR_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
+#define LCSR_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
+#define LCSR_OU		(1 << 6)	/* output FIFO underrun */
+#define LCSR_QD		(1 << 7)	/* quick disable */
+#define LCSR_EOF	(1 << 8)	/* end of frame */
+#define LCSR_BS		(1 << 9)	/* branch status */
+#define LCSR_SINT	(1 << 10)	/* subsequent interrupt */
+
+#define LDCMD_PAL	(1 << 26)	/* instructs DMA to load palette buffer */
+
+#define LCSR_LDD	(1 << 0)	/* LCD Disable Done */
+#define LCSR_SOF	(1 << 1)	/* Start of frame */
+#define LCSR_BER	(1 << 2)	/* Bus error */
+#define LCSR_ABC	(1 << 3)	/* AC Bias count */
+#define LCSR_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
+#define LCSR_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
+#define LCSR_OU		(1 << 6)	/* output FIFO underrun */
+#define LCSR_QD		(1 << 7)	/* quick disable */
+#define LCSR_EOF	(1 << 8)	/* end of frame */
+#define LCSR_BS		(1 << 9)	/* branch status */
+#define LCSR_SINT	(1 << 10)	/* subsequent interrupt */
+
+#define LDCMD_PAL	(1 << 26)	/* instructs DMA to load palette buffer */
+
+/*
+ * Memory controller
+ */
+
+#define MDCNFG		__REG(0x48000000)  /* SDRAM Configuration Register 0 */
+#define MDREFR		__REG(0x48000004)  /* SDRAM Refresh Control Register */
+#define MSC0		__REG(0x48000008)  /* Static Memory Control Register 0 */
+#define MSC1		__REG(0x4800000C)  /* Static Memory Control Register 1 */
+#define MSC2		__REG(0x48000010)  /* Static Memory Control Register 2 */
+#define MECR		__REG(0x48000014)  /* Expansion Memory (PCMCIA/Compact Flash) Bus Configuration */
+#define SXLCR		__REG(0x48000018)  /* LCR value to be written to SDRAM-Timing Synchronous Flash */
+#define SXCNFG		__REG(0x4800001C)  /* Synchronous Static Memory Control Register */
+#define SXMRS		__REG(0x48000024)  /* MRS value to be written to Synchronous Flash or SMROM */
+#define MCMEM0		__REG(0x48000028)  /* Card interface Common Memory Space Socket 0 Timing */
+#define MCMEM1		__REG(0x4800002C)  /* Card interface Common Memory Space Socket 1 Timing */
+#define MCATT0		__REG(0x48000030)  /* Card interface Attribute Space Socket 0 Timing Configuration */
+#define MCATT1		__REG(0x48000034)  /* Card interface Attribute Space Socket 1 Timing Configuration */
+#define MCIO0		__REG(0x48000038)  /* Card interface I/O Space Socket 0 Timing Configuration */
+#define MCIO1		__REG(0x4800003C)  /* Card interface I/O Space Socket 1 Timing Configuration */
+#define MDMRS		__REG(0x48000040)  /* MRS value to be written to SDRAM */
+#define BOOT_DEF	__REG(0x48000044)  /* Read-Only Boot-Time Register. Contains BOOT_SEL and PKG_SEL */
+
+/*
+ * More handy macros for PCMCIA
+ *
+ * Arg is socket number
+ */
+#define MCMEM(s)	__REG2(0x48000028, (s)<<2 )  /* Card interface Common Memory Space Socket s Timing */
+#define MCATT(s)	__REG2(0x48000030, (s)<<2 )  /* Card interface Attribute Space Socket s Timing Configuration */
+#define MCIO(s)		__REG2(0x48000038, (s)<<2 )  /* Card interface I/O Space Socket s Timing Configuration */
+
+/* MECR register defines */
+#define MECR_NOS	(1 << 0)	/* Number Of Sockets: 0 -> 1 sock, 1 -> 2 sock */
+#define MECR_CIT	(1 << 1)	/* Card Is There: 0 -> no card, 1 -> card inserted */
+
+#define MDREFR_K0DB4	(1 << 29)	/* SDCLK0 Divide by 4 Control/Status */
+#define MDREFR_K2FREE	(1 << 25)	/* SDRAM Free-Running Control */
+#define MDREFR_K1FREE	(1 << 24)	/* SDRAM Free-Running Control */
+#define MDREFR_K0FREE	(1 << 23)	/* SDRAM Free-Running Control */
+#define MDREFR_SLFRSH	(1 << 22)	/* SDRAM Self-Refresh Control/Status */
+#define MDREFR_APD	(1 << 20)	/* SDRAM/SSRAM Auto-Power-Down Enable */
+#define MDREFR_K2DB2	(1 << 19)	/* SDCLK2 Divide by 2 Control/Status */
+#define MDREFR_K2RUN	(1 << 18)	/* SDCLK2 Run Control/Status */
+#define MDREFR_K1DB2	(1 << 17)	/* SDCLK1 Divide by 2 Control/Status */
+#define MDREFR_K1RUN	(1 << 16)	/* SDCLK1 Run Control/Status */
+#define MDREFR_E1PIN	(1 << 15)	/* SDCKE1 Level Control/Status */
+#define MDREFR_K0DB2	(1 << 14)	/* SDCLK0 Divide by 2 Control/Status */
+#define MDREFR_K0RUN	(1 << 13)	/* SDCLK0 Run Control/Status */
+#define MDREFR_E0PIN	(1 << 12)	/* SDCKE0 Level Control/Status */
+
+
+#ifdef CONFIG_PXA27x
+
+#define ARB_CNTRL	__REG(0x48000048)  /* Arbiter Control Register */
+
+#define ARB_DMA_SLV_PARK	(1<<31)	   /* Be parked with DMA slave when idle */
+#define ARB_CI_PARK		(1<<30)	   /* Be parked with Camera Interface when idle */
+#define ARB_EX_MEM_PARK 	(1<<29)	   /* Be parked with external MEMC when idle */
+#define ARB_INT_MEM_PARK	(1<<28)	   /* Be parked with internal MEMC when idle */
+#define ARB_USB_PARK		(1<<27)	   /* Be parked with USB when idle */
+#define ARB_LCD_PARK		(1<<26)	   /* Be parked with LCD when idle */
+#define ARB_DMA_PARK		(1<<25)	   /* Be parked with DMA when idle */
+#define ARB_CORE_PARK		(1<<24)	   /* Be parked with core when idle */
+#define ARB_LOCK_FLAG		(1<<23)	   /* Only Locking masters gain access to the bus */
+
+/*
+ * Keypad
+ */
+#define KPC             __REG(0x41500000) /* Keypad Interface Control register */
+#define KPDK            __REG(0x41500008) /* Keypad Interface Direct Key register */
+#define KPREC           __REG(0x41500010) /* Keypad Interface Rotary Encoder register */
+#define KPMK            __REG(0x41500018) /* Keypad Interface Matrix Key register */
+#define KPAS            __REG(0x41500020) /* Keypad Interface Automatic Scan register */
+#define KPASMKP0        __REG(0x41500028) /* Keypad Interface Automatic Scan Multiple Key Presser register 0 */
+#define KPASMKP1        __REG(0x41500030) /* Keypad Interface Automatic Scan Multiple Key Presser register 1 */
+#define KPASMKP2        __REG(0x41500038) /* Keypad Interface Automatic Scan Multiple Key Presser register 2 */
+#define KPASMKP3        __REG(0x41500040) /* Keypad Interface Automatic Scan Multiple Key Presser register 3 */
+#define KPKDI           __REG(0x41500048) /* Keypad Interface Key Debounce Interval register */
+
+#define KPC_AS          (0x1 << 30)  /* Automatic Scan bit */
+#define KPC_ASACT       (0x1 << 29)  /* Automatic Scan on Activity */
+#define KPC_MI          (0x1 << 22)  /* Matrix interrupt bit */
+#define KPC_IMKP        (0x1 << 21)  /* Ignore Multiple Key Press */
+#define KPC_MS7         (0x1 << 20)  /* Matrix scan line 7 */
+#define KPC_MS6         (0x1 << 19)  /* Matrix scan line 6 */
+#define KPC_MS5         (0x1 << 18)  /* Matrix scan line 5 */
+#define KPC_MS4         (0x1 << 17)  /* Matrix scan line 4 */
+#define KPC_MS3         (0x1 << 16)  /* Matrix scan line 3 */
+#define KPC_MS2         (0x1 << 15)  /* Matrix scan line 2 */
+#define KPC_MS1         (0x1 << 14)  /* Matrix scan line 1 */
+#define KPC_MS0         (0x1 << 13)  /* Matrix scan line 0 */
+#define KPC_MS_ALL      (KPC_MS0 | KPC_MS1 | KPC_MS2 | KPC_MS3 | KPC_MS4 | KPC_MS5 | KPC_MS6 | KPC_MS7)
+#define KPC_ME          (0x1 << 12)  /* Matrix Keypad Enable */
+#define KPC_MIE         (0x1 << 11)  /* Matrix Interrupt Enable */
+#define KPC_DK_DEB_SEL	(0x1 <<  9)  /* Direct Keypad Debounce Select */
+#define KPC_DI          (0x1 <<  5)  /* Direct key interrupt bit */
+#define KPC_RE_ZERO_DEB (0x1 <<  4)  /* Rotary Encoder Zero Debounce */
+#define KPC_REE1        (0x1 <<  3)  /* Rotary Encoder1 Enable */
+#define KPC_REE0        (0x1 <<  2)  /* Rotary Encoder0 Enable */
+#define KPC_DE          (0x1 <<  1)  /* Direct Keypad Enable */
+#define KPC_DIE         (0x1 <<  0)  /* Direct Keypad interrupt Enable */
+
+#define KPDK_DKP        (0x1 << 31)
+#define KPDK_DK7        (0x1 <<  7)
+#define KPDK_DK6        (0x1 <<  6)
+#define KPDK_DK5        (0x1 <<  5)
+#define KPDK_DK4        (0x1 <<  4)
+#define KPDK_DK3        (0x1 <<  3)
+#define KPDK_DK2        (0x1 <<  2)
+#define KPDK_DK1        (0x1 <<  1)
+#define KPDK_DK0        (0x1 <<  0)
+
+#define KPREC_OF1       (0x1 << 31)
+#define kPREC_UF1       (0x1 << 30)
+#define KPREC_OF0       (0x1 << 15)
+#define KPREC_UF0       (0x1 << 14)
+
+#define KPMK_MKP        (0x1 << 31)
+#define KPAS_SO         (0x1 << 31)
+#define KPASMKPx_SO     (0x1 << 31)
+
+/*
+ * UHC: USB Host Controller (OHCI-like) register definitions
+ */
+#define UHC_BASE_PHYS	(0x4C000000)
+#define UHCREV		__REG(0x4C000000) /* UHC HCI Spec Revision */
+#define UHCHCON		__REG(0x4C000004) /* UHC Host Control Register */
+#define UHCCOMS		__REG(0x4C000008) /* UHC Command Status Register */
+#define UHCINTS		__REG(0x4C00000C) /* UHC Interrupt Status Register */
+#define UHCINTE		__REG(0x4C000010) /* UHC Interrupt Enable */
+#define UHCINTD		__REG(0x4C000014) /* UHC Interrupt Disable */
+#define UHCHCCA		__REG(0x4C000018) /* UHC Host Controller Comm. Area */
+#define UHCPCED		__REG(0x4C00001C) /* UHC Period Current Endpt Descr */
+#define UHCCHED		__REG(0x4C000020) /* UHC Control Head Endpt Descr */
+#define UHCCCED		__REG(0x4C000024) /* UHC Control Current Endpt Descr */
+#define UHCBHED		__REG(0x4C000028) /* UHC Bulk Head Endpt Descr */
+#define UHCBCED		__REG(0x4C00002C) /* UHC Bulk Current Endpt Descr */
+#define UHCDHEAD	__REG(0x4C000030) /* UHC Done Head */
+#define UHCFMI		__REG(0x4C000034) /* UHC Frame Interval */
+#define UHCFMR		__REG(0x4C000038) /* UHC Frame Remaining */
+#define UHCFMN		__REG(0x4C00003C) /* UHC Frame Number */
+#define UHCPERS		__REG(0x4C000040) /* UHC Periodic Start */
+#define UHCLS		__REG(0x4C000044) /* UHC Low Speed Threshold */
+
+#define UHCRHDA		__REG(0x4C000048) /* UHC Root Hub Descriptor A */
+#define UHCRHDA_NOCP	(1 << 12)	/* No over current protection */
+
+#define UHCRHDB		__REG(0x4C00004C) /* UHC Root Hub Descriptor B */
+#define UHCRHS		__REG(0x4C000050) /* UHC Root Hub Status */
+#define UHCRHPS1	__REG(0x4C000054) /* UHC Root Hub Port 1 Status */
+#define UHCRHPS2	__REG(0x4C000058) /* UHC Root Hub Port 2 Status */
+#define UHCRHPS3	__REG(0x4C00005C) /* UHC Root Hub Port 3 Status */
+
+#define UHCSTAT		__REG(0x4C000060) /* UHC Status Register */
+#define UHCSTAT_UPS3	(1 << 16)	/* USB Power Sense Port3 */
+#define UHCSTAT_SBMAI	(1 << 15)	/* System Bus Master Abort Interrupt*/
+#define UHCSTAT_SBTAI	(1 << 14)	/* System Bus Target Abort Interrupt*/
+#define UHCSTAT_UPRI	(1 << 13)	/* USB Port Resume Interrupt */
+#define UHCSTAT_UPS2	(1 << 12)	/* USB Power Sense Port 2 */
+#define UHCSTAT_UPS1	(1 << 11)	/* USB Power Sense Port 1 */
+#define UHCSTAT_HTA	(1 << 10)	/* HCI Target Abort */
+#define UHCSTAT_HBA	(1 << 8)	/* HCI Buffer Active */
+#define UHCSTAT_RWUE	(1 << 7)	/* HCI Remote Wake Up Event */
+
+#define UHCHR           __REG(0x4C000064) /* UHC Reset Register */
+#define UHCHR_SSEP3	(1 << 11)	/* Sleep Standby Enable for Port3 */
+#define UHCHR_SSEP2	(1 << 10)	/* Sleep Standby Enable for Port2 */
+#define UHCHR_SSEP1	(1 << 9)	/* Sleep Standby Enable for Port1 */
+#define UHCHR_PCPL	(1 << 7)	/* Power control polarity low */
+#define UHCHR_PSPL	(1 << 6)	/* Power sense polarity low */
+#define UHCHR_SSE	(1 << 5)	/* Sleep Standby Enable */
+#define UHCHR_UIT	(1 << 4)	/* USB Interrupt Test */
+#define UHCHR_SSDC	(1 << 3)	/* Simulation Scale Down Clock */
+#define UHCHR_CGR	(1 << 2)	/* Clock Generation Reset */
+#define UHCHR_FHR	(1 << 1)	/* Force Host Controller Reset */
+#define UHCHR_FSBIR	(1 << 0)	/* Force System Bus Iface Reset */
+
+#define UHCHIE          __REG(0x4C000068) /* UHC Interrupt Enable Register*/
+#define UHCHIE_UPS3IE	(1 << 14)	/* Power Sense Port3 IntEn */
+#define UHCHIE_UPRIE	(1 << 13)	/* Port Resume IntEn */
+#define UHCHIE_UPS2IE	(1 << 12)	/* Power Sense Port2 IntEn */
+#define UHCHIE_UPS1IE	(1 << 11)	/* Power Sense Port1 IntEn */
+#define UHCHIE_TAIE	(1 << 10)	/* HCI Interface Transfer Abort
+					   Interrupt Enable*/
+#define UHCHIE_HBAIE	(1 << 8)	/* HCI Buffer Active IntEn */
+#define UHCHIE_RWIE	(1 << 7)	/* Remote Wake-up IntEn */
+
+#define UHCHIT          __REG(0x4C00006C) /* UHC Interrupt Test register */
+
+/* Camera Interface */
+#define CICR0		__REG(0x50000000)
+#define CICR1		__REG(0x50000004)
+#define CICR2		__REG(0x50000008)
+#define CICR3		__REG(0x5000000C)
+#define CICR4		__REG(0x50000010)
+#define CISR		__REG(0x50000014)
+#define CIFR		__REG(0x50000018)
+#define CITOR		__REG(0x5000001C)
+#define CIBR0		__REG(0x50000028)
+#define CIBR1		__REG(0x50000030)
+#define CIBR2		__REG(0x50000038)
+
+#define CICR0_DMAEN	(1 << 31)	/* DMA request enable */
+#define CICR0_PAR_EN	(1 << 30)	/* Parity enable */
+#define CICR0_SL_CAP_EN	(1 << 29)	/* Capture enable for slave mode */
+#define CICR0_ENB	(1 << 28)	/* Camera interface enable */
+#define CICR0_DIS	(1 << 27)	/* Camera interface disable */
+#define CICR0_SIM	(0x7 << 24)	/* Sensor interface mode mask */
+#define CICR0_TOM	(1 << 9)	/* Time-out mask */
+#define CICR0_RDAVM	(1 << 8)	/* Receive-data-available mask */
+#define CICR0_FEM	(1 << 7)	/* FIFO-empty mask */
+#define CICR0_EOLM	(1 << 6)	/* End-of-line mask */
+#define CICR0_PERRM	(1 << 5)	/* Parity-error mask */
+#define CICR0_QDM	(1 << 4)	/* Quick-disable mask */
+#define CICR0_CDM	(1 << 3)	/* Disable-done mask */
+#define CICR0_SOFM	(1 << 2)	/* Start-of-frame mask */
+#define CICR0_EOFM	(1 << 1)	/* End-of-frame mask */
+#define CICR0_FOM	(1 << 0)	/* FIFO-overrun mask */
+
+#define CICR1_TBIT	(1 << 31)	/* Transparency bit */
+#define CICR1_RGBT_CONV	(0x3 << 30)	/* RGBT conversion mask */
+#define CICR1_PPL	(0x7ff << 15)	/* Pixels per line mask */
+#define CICR1_RGB_CONV	(0x7 << 12)	/* RGB conversion mask */
+#define CICR1_RGB_F	(1 << 11)	/* RGB format */
+#define CICR1_YCBCR_F	(1 << 10)	/* YCbCr format */
+#define CICR1_RGB_BPP	(0x7 << 7)	/* RGB bis per pixel mask */
+#define CICR1_RAW_BPP	(0x3 << 5)	/* Raw bis per pixel mask */
+#define CICR1_COLOR_SP	(0x3 << 3)	/* Color space mask */
+#define CICR1_DW	(0x7 << 0)	/* Data width mask */
+
+#define CICR2_BLW	(0xff << 24)	/* Beginning-of-line pixel clock
+					   wait count mask */
+#define CICR2_ELW	(0xff << 16)	/* End-of-line pixel clock
+					   wait count mask */
+#define CICR2_HSW	(0x3f << 10)	/* Horizontal sync pulse width mask */
+#define CICR2_BFPW	(0x3f << 3)	/* Beginning-of-frame pixel clock
+					   wait count mask */
+#define CICR2_FSW	(0x7 << 0)	/* Frame stabilization
+					   wait count mask */
+
+#define CICR3_BFW	(0xff << 24)	/* Beginning-of-frame line clock
+					   wait count mask */
+#define CICR3_EFW	(0xff << 16)	/* End-of-frame line clock
+					   wait count mask */
+#define CICR3_VSW	(0x3f << 10)	/* Vertical sync pulse width mask */
+#define CICR3_BFPW	(0x3f << 3)	/* Beginning-of-frame pixel clock
+					   wait count mask */
+#define CICR3_LPF	(0x7ff << 0)	/* Lines per frame mask */
+
+#define CICR4_MCLK_DLY	(0x3 << 24)	/* MCLK Data Capture Delay mask */
+#define CICR4_PCLK_EN	(1 << 23)	/* Pixel clock enable */
+#define CICR4_PCP	(1 << 22)	/* Pixel clock polarity */
+#define CICR4_HSP	(1 << 21)	/* Horizontal sync polarity */
+#define CICR4_VSP	(1 << 20)	/* Vertical sync polarity */
+#define CICR4_MCLK_EN	(1 << 19)	/* MCLK enable */
+#define CICR4_FR_RATE	(0x7 << 8)	/* Frame rate mask */
+#define CICR4_DIV	(0xff << 0)	/* Clock divisor mask */
+
+#define CISR_FTO	(1 << 15)	/* FIFO time-out */
+#define CISR_RDAV_2	(1 << 14)	/* Channel 2 receive data available */
+#define CISR_RDAV_1	(1 << 13)	/* Channel 1 receive data available */
+#define CISR_RDAV_0	(1 << 12)	/* Channel 0 receive data available */
+#define CISR_FEMPTY_2	(1 << 11)	/* Channel 2 FIFO empty */
+#define CISR_FEMPTY_1	(1 << 10)	/* Channel 1 FIFO empty */
+#define CISR_FEMPTY_0	(1 << 9)	/* Channel 0 FIFO empty */
+#define CISR_EOL	(1 << 8)	/* End of line */
+#define CISR_PAR_ERR	(1 << 7)	/* Parity error */
+#define CISR_CQD	(1 << 6)	/* Camera interface quick disable */
+#define CISR_CDD	(1 << 5)	/* Camera interface disable done */
+#define CISR_SOF	(1 << 4)	/* Start of frame */
+#define CISR_EOF	(1 << 3)	/* End of frame */
+#define CISR_IFO_2	(1 << 2)	/* FIFO overrun for Channel 2 */
+#define CISR_IFO_1	(1 << 1)	/* FIFO overrun for Channel 1 */
+#define CISR_IFO_0	(1 << 0)	/* FIFO overrun for Channel 0 */
+
+#define CIFR_FLVL2	(0x7f << 23)	/* FIFO 2 level mask */
+#define CIFR_FLVL1	(0x7f << 16)	/* FIFO 1 level mask */
+#define CIFR_FLVL0	(0xff << 8)	/* FIFO 0 level mask */
+#define CIFR_THL_0	(0x3 << 4)	/* Threshold Level for Channel 0 FIFO */
+#define CIFR_RESET_F	(1 << 3)	/* Reset input FIFOs */
+#define CIFR_FEN2	(1 << 2)	/* FIFO enable for channel 2 */
+#define CIFR_FEN1	(1 << 1)	/* FIFO enable for channel 1 */
+#define CIFR_FEN0	(1 << 0)	/* FIFO enable for channel 0 */
+
+#define SRAM_SIZE		0x40000 /* 4x64K  */
+
+#define SRAM_MEM_PHYS		0x5C000000
+
+#define IMPMCR		__REG(0x58000000) /* IM Power Management Control Reg */
+#define IMPMSR		__REG(0x58000008) /* IM Power Management Status Reg */
+
+#define IMPMCR_PC3		(0x3 << 22) /* Bank 3 Power Control */
+#define IMPMCR_PC3_RUN_MODE	(0x0 << 22) /*   Run mode */
+#define IMPMCR_PC3_STANDBY_MODE	(0x1 << 22) /*   Standby mode */
+#define IMPMCR_PC3_AUTO_MODE	(0x3 << 22) /*   Automatically controlled */
+
+#define IMPMCR_PC2		(0x3 << 20) /* Bank 2 Power Control */
+#define IMPMCR_PC2_RUN_MODE	(0x0 << 20) /*   Run mode */
+#define IMPMCR_PC2_STANDBY_MODE	(0x1 << 20) /*   Standby mode */
+#define IMPMCR_PC2_AUTO_MODE	(0x3 << 20) /*   Automatically controlled */
+
+#define IMPMCR_PC1		(0x3 << 18) /* Bank 1 Power Control */
+#define IMPMCR_PC1_RUN_MODE	(0x0 << 18) /*   Run mode */
+#define IMPMCR_PC1_STANDBY_MODE	(0x1 << 18) /*   Standby mode */
+#define IMPMCR_PC1_AUTO_MODE	(0x3 << 18) /*   Automatically controlled */
+
+#define IMPMCR_PC0		(0x3 << 16) /* Bank 0 Power Control */
+#define IMPMCR_PC0_RUN_MODE	(0x0 << 16) /*   Run mode */
+#define IMPMCR_PC0_STANDBY_MODE	(0x1 << 16) /*   Standby mode */
+#define IMPMCR_PC0_AUTO_MODE	(0x3 << 16) /*   Automatically controlled */
+
+#define IMPMCR_AW3		(1 << 11) /* Bank 3 Automatic Wake-up enable */
+#define IMPMCR_AW2		(1 << 10) /* Bank 2 Automatic Wake-up enable */
+#define IMPMCR_AW1		(1 << 9)  /* Bank 1 Automatic Wake-up enable */
+#define IMPMCR_AW0		(1 << 8)  /* Bank 0 Automatic Wake-up enable */
+
+#define IMPMCR_DST		(0xFF << 0) /* Delay Standby Time, ms */
+
+#define IMPMSR_PS3		(0x3 << 6) /* Bank 3 Power Status: */
+#define IMPMSR_PS3_RUN_MODE	(0x0 << 6) /*    Run mode */
+#define IMPMSR_PS3_STANDBY_MODE	(0x1 << 6) /*    Standby mode */
+
+#define IMPMSR_PS2		(0x3 << 4) /* Bank 2 Power Status: */
+#define IMPMSR_PS2_RUN_MODE	(0x0 << 4) /*    Run mode */
+#define IMPMSR_PS2_STANDBY_MODE	(0x1 << 4) /*    Standby mode */
+
+#define IMPMSR_PS1		(0x3 << 2) /* Bank 1 Power Status: */
+#define IMPMSR_PS1_RUN_MODE	(0x0 << 2) /*    Run mode */
+#define IMPMSR_PS1_STANDBY_MODE	(0x1 << 2) /*    Standby mode */
+
+#define IMPMSR_PS0		(0x3 << 0) /* Bank 0 Power Status: */
+#define IMPMSR_PS0_RUN_MODE	(0x0 << 0) /*    Run mode */
+#define IMPMSR_PS0_STANDBY_MODE	(0x1 << 0) /*    Standby mode */
+
+#endif
+
+/* PWRMODE register M field values */
+
+#define PWRMODE_IDLE		0x1
+#define PWRMODE_STANDBY		0x2
+#define PWRMODE_SLEEP		0x3
+#define PWRMODE_DEEPSLEEP	0x7
+
+#endif
Index: build_tree/linux/include/asm/arch/pxa2xx_spi.h
diff -u /dev/null build_tree/linux/include/asm/arch/pxa2xx_spi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/pxa2xx_spi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2005 Stephen Street / StreetFire Sound Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef PXA2XX_SPI_H_
+#define PXA2XX_SPI_H_
+
+#define PXA2XX_CS_ASSERT (0x01)
+#define PXA2XX_CS_DEASSERT (0x02)
+
+#if defined(CONFIG_PXA25x)
+#define CLOCK_SPEED_HZ 3686400
+#define SSP1_SerClkDiv(x) (((CLOCK_SPEED_HZ/2/(x+1))<<8)&0x0000ff00)
+#define SSP2_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#define SSP3_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#elif defined(CONFIG_PXA27x)
+#define CLOCK_SPEED_HZ 13000000
+#define SSP1_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#define SSP2_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#define SSP3_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#endif
+
+#define SSP1_VIRT ((void *)(io_p2v(__PREG(SSCR0_P(1)))))
+#define SSP2_VIRT ((void *)(io_p2v(__PREG(SSCR0_P(2)))))
+#define SSP3_VIRT ((void *)(io_p2v(__PREG(SSCR0_P(3)))))
+
+enum pxa_ssp_type {
+	SSP_UNDEFINED = 0,
+	PXA25x_SSP,  /* pxa 210, 250, 255, 26x */
+	PXA25x_NSSP, /* pxa 255, 26x (including ASSP) */
+	PXA27x_SSP,
+};
+
+/* device.platform_data for SSP controller devices */
+struct pxa2xx_spi_master {
+	enum pxa_ssp_type ssp_type;
+	u32 clock_enable;
+	u16 num_chipselect;
+	u8 enable_dma;
+};
+
+/* spi_board_info.controller_data for SPI slave devices,
+ * copied to spi_device.platform_data ... mostly for dma tuning
+ */
+struct pxa2xx_spi_chip {
+	u8 tx_threshold;
+	u8 rx_threshold;
+	u8 dma_burst_size;
+	u32 timeout;
+	u8 enable_loopback;
+	void (*cs_control)(u32 command);
+};
+
+#endif /*PXA2XX_SPI_H_*/
Index: build_tree/linux/include/asm/arch/pxafb.h
diff -u /dev/null build_tree/linux/include/asm/arch/pxafb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/pxafb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,135 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/pxafb.h
+ *
+ *  Support for the xscale frame buffer.
+ *
+ *  Author:     Jean-Frederic Clere
+ *  Created:    Sep 22, 2003
+ *  Copyright:  jfclere@sinix.net
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/fb.h>
+
+/*
+ * This structure describes the machine which we are running on.
+ * It is set in linux/arch/arm/mach-pxa/machine_name.c and used in the probe routine
+ * of linux/drivers/video/pxafb.c
+ */
+struct pxafb_mode_info {
+	u_long		pixclock;
+
+	u_short		xres;
+	u_short		yres;
+
+	u_char		bpp;
+	u_char		hsync_len;
+	u_char		left_margin;
+	u_char		right_margin;
+
+	u_char		vsync_len;
+	u_char		upper_margin;
+	u_char		lower_margin;
+	u_char		sync;
+
+	u_int		cmap_greyscale:1,
+			unused:31;
+};
+
+struct pxafb_mach_info {
+	struct pxafb_mode_info *modes;
+	unsigned int num_modes;
+
+	u_int		fixed_modes:1,
+			cmap_inverse:1,
+			cmap_static:1,
+			unused:29;
+
+	/* The following should be defined in LCCR0
+	 *      LCCR0_Act or LCCR0_Pas          Active or Passive
+	 *      LCCR0_Sngl or LCCR0_Dual        Single/Dual panel
+	 *      LCCR0_Mono or LCCR0_Color       Mono/Color
+	 *      LCCR0_4PixMono or LCCR0_8PixMono (in mono single mode)
+	 *      LCCR0_DMADel(Tcpu) (optional)   DMA request delay
+	 *
+	 * The following should not be defined in LCCR0:
+	 *      LCCR0_OUM, LCCR0_BM, LCCR0_QDM, LCCR0_DIS, LCCR0_EFM
+	 *      LCCR0_IUM, LCCR0_SFM, LCCR0_LDM, LCCR0_ENB
+	 */
+	u_int		lccr0;
+	/* The following should be defined in LCCR3
+	 *      LCCR3_OutEnH or LCCR3_OutEnL    Output enable polarity
+	 *      LCCR3_PixRsEdg or LCCR3_PixFlEdg Pixel clock edge type
+	 *      LCCR3_Acb(X)                    AB Bias pin frequency
+	 *      LCCR3_DPC (optional)            Double Pixel Clock mode (untested)
+	 *
+	 * The following should not be defined in LCCR3
+	 *      LCCR3_HSP, LCCR3_VSP, LCCR0_Pcd(x), LCCR3_Bpp
+	 */
+	u_int		lccr3;
+
+	void (*pxafb_backlight_power)(int);
+	void (*pxafb_lcd_power)(int, struct fb_var_screeninfo *);
+
+};
+void set_pxa_fb_info(struct pxafb_mach_info *hard_pxa_fb_info);
+void set_pxa_fb_parent(struct device *parent_dev);
+unsigned long pxafb_get_hsync_time(struct device *dev);
+
+
+/* PIXCLOCK --- unit 10khz*/
+/* Modified for Z2 Optrex */
+#define ZIPIT2
+
+#if 1   /*Z2 rev 2 LCD*/
+#define LCD_PIXCLOCK	688	
+/*JWK test new Z2 LCD 041607 #define LCD_PIXCLOCK		576 */
+#define LCD_BPP				16
+#define LCD_XRES			240
+#define LCD_YRES			320
+#define LCD_HORIZONTAL_SYNC_PULSE_WIDTH	4
+#define LCD_VERTICAL_SYNC_PULSE_WIDTH	4
+#define LCD_BEGIN_OF_LINE_WAIT_COUNT	4
+#define LCD_BEGIN_FRAME_WAIT_COUNT 	4
+#define LCD_END_OF_LINE_WAIT_COUNT	8
+#define LCD_END_OF_FRAME_WAIT_COUNT	8
+#define LCD_SYNC			(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT)
+#else /*Z2 rev 1 LCD*/
+#define LCD_PIXCLOCK	 		576	
+#define LCD_BPP				16
+#define LCD_XRES			240
+#define LCD_YRES			320
+#define LCD_HORIZONTAL_SYNC_PULSE_WIDTH	2
+#define LCD_VERTICAL_SYNC_PULSE_WIDTH	2
+#define LCD_BEGIN_OF_LINE_WAIT_COUNT	1
+#define LCD_BEGIN_FRAME_WAIT_COUNT 	1
+#define LCD_END_OF_LINE_WAIT_COUNT	10
+#define LCD_END_OF_FRAME_WAIT_COUNT	1
+#define LCD_SYNC			(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT)
+#endif 
+
+
+//#define LCD_LCCR0		0x1B00A78
+//#define LCD_LCCR3		0x4008000
+
+//#define LCD_LCCR0		(LCCR0_OUC | LCCR0_CMDIM | LCCR0_RDSTM | \
+                         LCCR0_OUM | LCCR0_BM | LCCR0_QDM | LCCR0_PAS | \
+                         LCCR0_EFM | LCCR0_IUM | LCCR0_SFM | LCCR0_LDM)
+
+/* Z2 -- Removed Active setting */
+/*#define LCD_LCCR0		(LCCR0_OUC | LCCR0_CMDIM | LCCR0_RDSTM | \
+                         LCCR0_OUM | LCCR0_BM | LCCR0_QDM | \
+                         LCCR0_EFM | LCCR0_IUM | LCCR0_SFM | LCCR0_LDM)
+*/
+#define LCD_LCCR0 0x05B00AF8 // per Frank W."older than IEEE"  Tinklepaugh
+
+/*#define LCD_LCCR3 	    (LCCR3_PCP | LCCR3_HSP | LCCR3_VSP )
+*/
+#if 0 /*Z2 rev 1 LCD*/
+#define LCD_LCCR3 0x04f00009
+#else  /*Z2 rev 2 LCD*/
+#define LCD_LCCR3 0x04b00006
+#endif
Index: build_tree/linux/include/asm/arch/sharpsl.h
diff -u /dev/null build_tree/linux/include/asm/arch/sharpsl.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/sharpsl.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ * SharpSL SSP Driver
+ */
+
+unsigned long corgi_ssp_ads7846_putget(unsigned long);
+unsigned long corgi_ssp_ads7846_get(void);
+void corgi_ssp_ads7846_put(unsigned long data);
+void corgi_ssp_ads7846_lock(void);
+void corgi_ssp_ads7846_unlock(void);
+void corgi_ssp_lcdtg_send (unsigned char adrs, unsigned char data);
+void corgi_ssp_blduty_set(int duty);
+int corgi_ssp_max1111_get(unsigned long data);
+
+/*
+ * SharpSL Touchscreen Driver
+ */
+
+struct corgits_machinfo {
+	unsigned long (*get_hsync_len)(void);
+	void (*put_hsync)(void);
+	void (*wait_hsync)(void);
+};
+
+
+/*
+ * SharpSL Backlight
+ */
+struct corgibl_machinfo {
+	int max_intensity;
+	int default_intensity;
+	int limit_mask;
+	void (*set_bl_intensity)(int intensity);
+};
+extern void corgibl_limit_intensity(int limit);
+
+
+/*
+ * SharpSL Battery/PM Driver
+ */
+extern void sharpsl_battery_kick(void);
Index: build_tree/linux/include/asm/arch/spitz.h
diff -u /dev/null build_tree/linux/include/asm/arch/spitz.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/spitz.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,160 @@
+/*
+ * Hardware specific definitions for SL-Cx000 series of PDAs
+ *
+ * Copyright (c) 2005 Alexander Wykes
+ * Copyright (c) 2005 Richard Purdie
+ *
+ * Based on Sharp's 2.4 kernel patches
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ASM_ARCH_SPITZ_H
+#define __ASM_ARCH_SPITZ_H  1
+#endif
+
+#include <linux/fb.h>
+
+/* Spitz/Akita GPIOs */
+
+#define SPITZ_GPIO_KEY_INT         (0) /* Key Interrupt */
+#define SPITZ_GPIO_RESET           (1)
+#define SPITZ_GPIO_nSD_DETECT      (9)
+#define SPITZ_GPIO_TP_INT          (11) /* Touch Panel interrupt */
+#define SPITZ_GPIO_AK_INT          (13) /* Remote Control */
+#define SPITZ_GPIO_ADS7846_CS      (14)
+#define SPITZ_GPIO_SYNC            (16)
+#define SPITZ_GPIO_MAX1111_CS      (20)
+#define SPITZ_GPIO_FATAL_BAT       (21)
+#define SPITZ_GPIO_HSYNC           (22)
+#define SPITZ_GPIO_nSD_CLK         (32)
+#define SPITZ_GPIO_USB_DEVICE      (35)
+#define SPITZ_GPIO_USB_HOST        (37)
+#define SPITZ_GPIO_USB_CONNECT     (41)
+#define SPITZ_GPIO_LCDCON_CS       (53)
+#define SPITZ_GPIO_nPCE            (54)
+#define SPITZ_GPIO_nSD_WP          (81)
+#define SPITZ_GPIO_ON_RESET        (89)
+#define SPITZ_GPIO_BAT_COVER       (90)
+#define SPITZ_GPIO_CF_CD           (94)
+#define SPITZ_GPIO_ON_KEY          (95)
+#define SPITZ_GPIO_SWA             (97)
+#define SPITZ_GPIO_SWB             (96)
+#define SPITZ_GPIO_CHRG_FULL       (101)
+#define SPITZ_GPIO_CO              (101)
+#define SPITZ_GPIO_CF_IRQ          (105)
+#define SPITZ_GPIO_AC_IN           (115)
+#define SPITZ_GPIO_HP_IN           (116)
+
+/* Spitz Only GPIOs */
+
+#define SPITZ_GPIO_CF2_IRQ         (106) /* CF slot1 Ready */
+#define SPITZ_GPIO_CF2_CD          (93)
+
+
+/* Spitz/Akita Keyboard Definitions */
+
+#define SPITZ_KEY_STROBE_NUM         (11)
+#define SPITZ_KEY_SENSE_NUM          (7)
+#define SPITZ_GPIO_G0_STROBE_BIT     0x0f800000
+#define SPITZ_GPIO_G1_STROBE_BIT     0x00100000
+#define SPITZ_GPIO_G2_STROBE_BIT     0x01000000
+#define SPITZ_GPIO_G3_STROBE_BIT     0x00041880
+#define SPITZ_GPIO_G0_SENSE_BIT      0x00021000
+#define SPITZ_GPIO_G1_SENSE_BIT      0x000000d4
+#define SPITZ_GPIO_G2_SENSE_BIT      0x08000000
+#define SPITZ_GPIO_G3_SENSE_BIT      0x00000000
+
+#define SPITZ_GPIO_KEY_STROBE0       88
+#define SPITZ_GPIO_KEY_STROBE1       23
+#define SPITZ_GPIO_KEY_STROBE2       24
+#define SPITZ_GPIO_KEY_STROBE3       25
+#define SPITZ_GPIO_KEY_STROBE4       26
+#define SPITZ_GPIO_KEY_STROBE5       27
+#define SPITZ_GPIO_KEY_STROBE6       52
+#define SPITZ_GPIO_KEY_STROBE7       103
+#define SPITZ_GPIO_KEY_STROBE8       107
+#define SPITZ_GPIO_KEY_STROBE9       108
+#define SPITZ_GPIO_KEY_STROBE10      114
+
+#define SPITZ_GPIO_KEY_SENSE0        12
+#define SPITZ_GPIO_KEY_SENSE1        17
+#define SPITZ_GPIO_KEY_SENSE2        91
+#define SPITZ_GPIO_KEY_SENSE3        34
+#define SPITZ_GPIO_KEY_SENSE4        36
+#define SPITZ_GPIO_KEY_SENSE5        38
+#define SPITZ_GPIO_KEY_SENSE6        39
+
+
+/* Spitz Scoop Device (No. 1) GPIOs */
+/* Suspend States in comments */
+#define SPITZ_SCP_LED_GREEN     SCOOP_GPCR_PA11  /* Keep */
+#define SPITZ_SCP_JK_B          SCOOP_GPCR_PA12  /* Keep */
+#define SPITZ_SCP_CHRG_ON       SCOOP_GPCR_PA13  /* Keep */
+#define SPITZ_SCP_MUTE_L        SCOOP_GPCR_PA14  /* Low */
+#define SPITZ_SCP_MUTE_R        SCOOP_GPCR_PA15  /* Low */
+#define SPITZ_SCP_CF_POWER      SCOOP_GPCR_PA16  /* Keep */
+#define SPITZ_SCP_LED_ORANGE    SCOOP_GPCR_PA17  /* Keep */
+#define SPITZ_SCP_JK_A          SCOOP_GPCR_PA18  /* Low */
+#define SPITZ_SCP_ADC_TEMP_ON   SCOOP_GPCR_PA19  /* Low */
+
+#define SPITZ_SCP_IO_DIR      (SPITZ_SCP_LED_GREEN | SPITZ_SCP_JK_B | SPITZ_SCP_CHRG_ON | \
+                               SPITZ_SCP_MUTE_L | SPITZ_SCP_MUTE_R | SPITZ_SCP_LED_ORANGE | \
+                               SPITZ_SCP_CF_POWER | SPITZ_SCP_JK_A | SPITZ_SCP_ADC_TEMP_ON)
+#define SPITZ_SCP_IO_OUT      (SPITZ_SCP_CHRG_ON | SPITZ_SCP_MUTE_L | SPITZ_SCP_MUTE_R)
+#define SPITZ_SCP_SUS_CLR     (SPITZ_SCP_MUTE_L | SPITZ_SCP_MUTE_R | SPITZ_SCP_JK_A | SPITZ_SCP_ADC_TEMP_ON)
+#define SPITZ_SCP_SUS_SET     0
+
+/* Spitz Scoop Device (No. 2) GPIOs */
+/* Suspend States in comments */
+#define SPITZ_SCP2_IR_ON           SCOOP_GPCR_PA11  /* High */
+#define SPITZ_SCP2_AKIN_PULLUP     SCOOP_GPCR_PA12  /* Keep */
+#define SPITZ_SCP2_RESERVED_1      SCOOP_GPCR_PA13  /* High */
+#define SPITZ_SCP2_RESERVED_2      SCOOP_GPCR_PA14  /* Low */
+#define SPITZ_SCP2_RESERVED_3      SCOOP_GPCR_PA15  /* Low */
+#define SPITZ_SCP2_RESERVED_4      SCOOP_GPCR_PA16  /* Low */
+#define SPITZ_SCP2_BACKLIGHT_CONT  SCOOP_GPCR_PA17  /* Low */
+#define SPITZ_SCP2_BACKLIGHT_ON    SCOOP_GPCR_PA18  /* Low */
+#define SPITZ_SCP2_MIC_BIAS        SCOOP_GPCR_PA19  /* Low */
+
+#define SPITZ_SCP2_IO_DIR (SPITZ_SCP2_IR_ON | SPITZ_SCP2_AKIN_PULLUP | SPITZ_SCP2_RESERVED_1 | \
+                           SPITZ_SCP2_RESERVED_2 | SPITZ_SCP2_RESERVED_3 | SPITZ_SCP2_RESERVED_4 | \
+                           SPITZ_SCP2_BACKLIGHT_CONT | SPITZ_SCP2_BACKLIGHT_ON | SPITZ_SCP2_MIC_BIAS)
+
+#define SPITZ_SCP2_IO_OUT   (SPITZ_SCP2_IR_ON | SPITZ_SCP2_AKIN_PULLUP | SPITZ_SCP2_RESERVED_1)
+#define SPITZ_SCP2_SUS_CLR  (SPITZ_SCP2_RESERVED_2 | SPITZ_SCP2_RESERVED_3 | SPITZ_SCP2_RESERVED_4 | \
+                             SPITZ_SCP2_BACKLIGHT_CONT | SPITZ_SCP2_BACKLIGHT_ON | SPITZ_SCP2_MIC_BIAS)
+#define SPITZ_SCP2_SUS_SET  (SPITZ_SCP2_IR_ON | SPITZ_SCP2_RESERVED_1)
+
+
+/* Spitz IRQ Definitions */
+
+#define SPITZ_IRQ_GPIO_KEY_INT        IRQ_GPIO(SPITZ_GPIO_KEY_INT)
+#define SPITZ_IRQ_GPIO_AC_IN          IRQ_GPIO(SPITZ_GPIO_AC_IN)
+#define SPITZ_IRQ_GPIO_AK_INT         IRQ_GPIO(SPITZ_GPIO_AK_INT)
+#define SPITZ_IRQ_GPIO_HP_IN          IRQ_GPIO(SPITZ_GPIO_HP_IN)
+#define SPITZ_IRQ_GPIO_TP_INT         IRQ_GPIO(SPITZ_GPIO_TP_INT)
+#define SPITZ_IRQ_GPIO_SYNC           IRQ_GPIO(SPITZ_GPIO_SYNC)
+#define SPITZ_IRQ_GPIO_ON_KEY         IRQ_GPIO(SPITZ_GPIO_ON_KEY)
+#define SPITZ_IRQ_GPIO_SWA            IRQ_GPIO(SPITZ_GPIO_SWA)
+#define SPITZ_IRQ_GPIO_SWB            IRQ_GPIO(SPITZ_GPIO_SWB)
+#define SPITZ_IRQ_GPIO_BAT_COVER      IRQ_GPIO(SPITZ_GPIO_BAT_COVER)
+#define SPITZ_IRQ_GPIO_FATAL_BAT      IRQ_GPIO(SPITZ_GPIO_FATAL_BAT)
+#define SPITZ_IRQ_GPIO_CO             IRQ_GPIO(SPITZ_GPIO_CO)
+#define SPITZ_IRQ_GPIO_CF_IRQ         IRQ_GPIO(SPITZ_GPIO_CF_IRQ)
+#define SPITZ_IRQ_GPIO_CF_CD          IRQ_GPIO(SPITZ_GPIO_CF_CD)
+#define SPITZ_IRQ_GPIO_CF2_IRQ        IRQ_GPIO(SPITZ_GPIO_CF2_IRQ)
+#define SPITZ_IRQ_GPIO_nSD_INT        IRQ_GPIO(SPITZ_GPIO_nSD_INT)
+#define SPITZ_IRQ_GPIO_nSD_DETECT     IRQ_GPIO(SPITZ_GPIO_nSD_DETECT)
+
+/*
+ * Shared data structures
+ */
+extern struct platform_device spitzscoop_device;
+extern struct platform_device spitzscoop2_device;
+extern struct platform_device spitzssp_device;
+extern struct sharpsl_charger_machinfo spitz_pm_machinfo;
+
+extern void spitz_lcd_power(int on, struct fb_var_screeninfo *var);
Index: build_tree/linux/include/asm/arch/ssp.h
diff -u /dev/null build_tree/linux/include/asm/arch/ssp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/ssp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,53 @@
+/*
+ *  ssp.h
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This driver supports the following PXA CPU/SSP ports:-
+ *
+ *       PXA250     SSP
+ *       PXA255     SSP, NSSP
+ *       PXA26x     SSP, NSSP, ASSP
+ *       PXA27x     SSP1, SSP2, SSP3
+ */
+
+#ifndef SSP_H
+#define SSP_H
+
+/*
+ * SSP initialisation flags
+ */
+#define SSP_NO_IRQ	0x1		/* don't register an irq handler in SSP driver */
+
+struct ssp_state {
+	u32	cr0;
+	u32 cr1;
+	u32 to;
+	u32 psp;
+};
+
+struct ssp_dev {
+	u32 port;
+	u32 mode;
+	u32 flags;
+	u32 psp_flags;
+	u32 speed;
+	int irq;
+};
+
+int ssp_write_word(struct ssp_dev *dev, u32 data);
+int ssp_read_word(struct ssp_dev *dev, u32 *data);
+int ssp_flush(struct ssp_dev *dev);
+void ssp_enable(struct ssp_dev *dev);
+void ssp_disable(struct ssp_dev *dev);
+void ssp_save_state(struct ssp_dev *dev, struct ssp_state *ssp);
+void ssp_restore_state(struct ssp_dev *dev, struct ssp_state *ssp);
+int ssp_init(struct ssp_dev *dev, u32 port, u32 init_flags);
+int ssp_config(struct ssp_dev *dev, u32 mode, u32 flags, u32 psp_flags, u32 speed);
+void ssp_exit(struct ssp_dev *dev);
+
+#endif
Index: build_tree/linux/include/asm/arch/system.h
diff -u /dev/null build_tree/linux/include/asm/arch/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-pxa/system.h
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Jun 15, 2001
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/proc-fns.h>
+#include "hardware.h"
+#include "pxa-regs.h"
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+
+static inline void arch_reset(char mode)
+{
+	if (mode == 's') {
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+	} else {
+		/* Initialize the watchdog and let it fire */
+		OWER = OWER_WME;
+		OSSR = OSSR_M3;
+		OSMR3 = OSCR + 368640;	/* ... in 100 ms */
+	}
+}
+
Index: build_tree/linux/include/asm/arch/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ * linux/include/asm-arm/arch-pxa/timex.h
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Jun 15, 2001
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#if defined(CONFIG_PXA25x)
+/* PXA250/210 timer base */
+#define CLOCK_TICK_RATE 3686400
+#elif defined(CONFIG_PXA27x)
+/* PXA27x timer base */
+#ifdef CONFIG_MACH_MAINSTONE
+#define CLOCK_TICK_RATE 3249600
+#else
+#define CLOCK_TICK_RATE 3250000
+#endif
+#endif
Index: build_tree/linux/include/asm/arch/tosa.h
diff -u /dev/null build_tree/linux/include/asm/arch/tosa.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/tosa.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,166 @@
+/*
+ * Hardware specific definitions for Sharp SL-C6000x series of PDAs
+ *
+ * Copyright (c) 2005 Dirk Opfer
+ *
+ * Based on Sharp's 2.4 kernel patches
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _ASM_ARCH_TOSA_H_
+#define _ASM_ARCH_TOSA_H_ 1
+
+/*  TOSA Chip selects  */
+#define TOSA_LCDC_PHYS		PXA_CS4_PHYS
+/* Internel Scoop */
+#define TOSA_CF_PHYS		(PXA_CS2_PHYS + 0x00800000)
+/* Jacket Scoop */
+#define TOSA_SCOOP_PHYS  	(PXA_CS5_PHYS + 0x00800000)
+
+/*
+ * SCOOP2 internal GPIOs
+ */
+#define TOSA_SCOOP_PXA_VCORE1		SCOOP_GPCR_PA11
+#define TOSA_SCOOP_TC6393_REST_IN	SCOOP_GPCR_PA12
+#define TOSA_SCOOP_IR_POWERDWN		SCOOP_GPCR_PA13
+#define TOSA_SCOOP_SD_WP		SCOOP_GPCR_PA14
+#define TOSA_SCOOP_PWR_ON		SCOOP_GPCR_PA15
+#define TOSA_SCOOP_AUD_PWR_ON		SCOOP_GPCR_PA16
+#define TOSA_SCOOP_BT_RESET		SCOOP_GPCR_PA17
+#define TOSA_SCOOP_BT_PWR_EN		SCOOP_GPCR_PA18
+#define TOSA_SCOOP_AC_IN_OL		SCOOP_GPCR_PA19
+
+/* GPIO Direction   1 : output mode / 0:input mode */
+#define TOSA_SCOOP_IO_DIR     ( TOSA_SCOOP_PXA_VCORE1 | TOSA_SCOOP_TC6393_REST_IN | \
+		TOSA_SCOOP_IR_POWERDWN | TOSA_SCOOP_PWR_ON | TOSA_SCOOP_AUD_PWR_ON |\
+		TOSA_SCOOP_BT_RESET | TOSA_SCOOP_BT_PWR_EN )
+/* GPIO out put level when init   1: Hi */
+#define TOSA_SCOOP_IO_OUT     ( TOSA_SCOOP_TC6393_REST_IN )
+
+/*
+ * SCOOP2 jacket GPIOs
+ */
+#define TOSA_SCOOP_JC_BT_LED		SCOOP_GPCR_PA11
+#define TOSA_SCOOP_JC_NOTE_LED		SCOOP_GPCR_PA12
+#define TOSA_SCOOP_JC_CHRG_ERR_LED	SCOOP_GPCR_PA13
+#define TOSA_SCOOP_JC_USB_PULLUP	SCOOP_GPCR_PA14
+#define TOSA_SCOOP_JC_TC6393_SUSPEND	SCOOP_GPCR_PA15
+#define TOSA_SCOOP_JC_TC3693_L3V_ON	SCOOP_GPCR_PA16
+#define TOSA_SCOOP_JC_WLAN_DETECT	SCOOP_GPCR_PA17
+#define TOSA_SCOOP_JC_WLAN_LED		SCOOP_GPCR_PA18
+#define TOSA_SCOOP_JC_CARD_LIMIT_SEL	SCOOP_GPCR_PA19
+
+/* GPIO Direction   1 : output mode / 0:input mode */
+#define TOSA_SCOOP_JC_IO_DIR ( TOSA_SCOOP_JC_BT_LED | TOSA_SCOOP_JC_NOTE_LED | \
+		TOSA_SCOOP_JC_CHRG_ERR_LED | TOSA_SCOOP_JC_USB_PULLUP | \
+		TOSA_SCOOP_JC_TC6393_SUSPEND | TOSA_SCOOP_JC_TC3693_L3V_ON | \
+		TOSA_SCOOP_JC_WLAN_LED | TOSA_SCOOP_JC_CARD_LIMIT_SEL )
+/* GPIO out put level when init   1: Hi */
+#define TOSA_SCOOP_JC_IO_OUT ( 0 )
+
+/*
+ * Timing Generator
+ */
+#define TG_PNLCTL 			0x00
+#define TG_TPOSCTL 			0x01
+#define TG_DUTYCTL 			0x02
+#define TG_GPOSR 			0x03
+#define TG_GPODR1 			0x04
+#define TG_GPODR2 			0x05
+#define TG_PINICTL 			0x06
+#define TG_HPOSCTL 			0x07
+
+/*
+ * LED
+ */
+#define TOSA_SCOOP_LED_BLUE   		TOSA_SCOOP_GPCR_PA11
+#define TOSA_SCOOP_LED_GREEN  		TOSA_SCOOP_GPCR_PA12
+#define TOSA_SCOOP_LED_ORANGE		TOSA_SCOOP_GPCR_PA13
+#define TOSA_SCOOP_LED_WLAN		TOSA_SCOOP_GPCR_PA18
+
+
+/*
+ * PXA GPIOs
+ */
+#define TOSA_GPIO_POWERON		(0)
+#define TOSA_GPIO_RESET			(1)
+#define TOSA_GPIO_AC_IN			(2)
+#define TOSA_GPIO_RECORD_BTN		(3)
+#define TOSA_GPIO_SYNC			(4)	/* Cradle SYNC Button */
+#define TOSA_GPIO_USB_IN		(5)
+#define TOSA_GPIO_JACKET_DETECT		(7)
+#define TOSA_GPIO_nSD_DETECT		(9)
+#define TOSA_GPIO_nSD_INT		(10)
+#define TOSA_GPIO_TC6393_CLK		(11)
+#define TOSA_GPIO_BAT1_CRG		(12)
+#define TOSA_GPIO_CF_CD			(13)
+#define TOSA_GPIO_BAT0_CRG		(14)
+#define TOSA_GPIO_TC6393_INT		(15)
+#define TOSA_GPIO_BAT0_LOW		(17)
+#define TOSA_GPIO_TC6393_RDY		(18)
+#define TOSA_GPIO_ON_RESET		(19)
+#define TOSA_GPIO_EAR_IN		(20)
+#define TOSA_GPIO_CF_IRQ		(21)	/* CF slot0 Ready */
+#define TOSA_GPIO_ON_KEY		(22)
+#define TOSA_GPIO_VGA_LINE		(27)
+#define TOSA_GPIO_TP_INT		(32)	/* Touch Panel pen down interrupt */
+#define TOSA_GPIO_JC_CF_IRQ		(36)	/* CF slot1 Ready */
+#define TOSA_GPIO_BAT_LOCKED		(38)	/* Battery locked */
+#define TOSA_GPIO_TG_SPI_SCLK		(81)
+#define TOSA_GPIO_TG_SPI_CS		(82)
+#define TOSA_GPIO_TG_SPI_MOSI		(83)
+#define TOSA_GPIO_BAT1_LOW		(84)
+
+#define TOSA_GPIO_HP_IN			GPIO_EAR_IN
+
+#define TOSA_GPIO_MAIN_BAT_LOW		GPIO_BAT0_LOW
+
+#define TOSA_KEY_STROBE_NUM		(11)
+#define TOSA_KEY_SENSE_NUM		(7)
+
+#define TOSA_GPIO_HIGH_STROBE_BIT	(0xfc000000)
+#define TOSA_GPIO_LOW_STROBE_BIT	(0x0000001f)
+#define TOSA_GPIO_ALL_SENSE_BIT		(0x00000fe0)
+#define TOSA_GPIO_ALL_SENSE_RSHIFT	(5)
+#define TOSA_GPIO_STROBE_BIT(a)		GPIO_bit(58+(a))
+#define TOSA_GPIO_SENSE_BIT(a)		GPIO_bit(69+(a))
+#define TOSA_GAFR_HIGH_STROBE_BIT	(0xfff00000)
+#define TOSA_GAFR_LOW_STROBE_BIT	(0x000003ff)
+#define TOSA_GAFR_ALL_SENSE_BIT		(0x00fffc00)
+#define TOSA_GPIO_KEY_SENSE(a) 		(69+(a))
+#define TOSA_GPIO_KEY_STROBE(a)		(58+(a))
+
+/*
+ * Interrupts
+ */
+#define TOSA_IRQ_GPIO_WAKEUP        	IRQ_GPIO(TOSA_GPIO_WAKEUP)
+#define TOSA_IRQ_GPIO_AC_IN         	IRQ_GPIO(TOSA_GPIO_AC_IN)
+#define TOSA_IRQ_GPIO_RECORD_BTN    	IRQ_GPIO(TOSA_GPIO_RECORD_BTN)
+#define TOSA_IRQ_GPIO_SYNC          	IRQ_GPIO(TOSA_GPIO_SYNC)
+#define TOSA_IRQ_GPIO_USB_IN        	IRQ_GPIO(TOSA_GPIO_USB_IN)
+#define TOSA_IRQ_GPIO_JACKET_DETECT 	IRQ_GPIO(TOSA_GPIO_JACKET_DETECT)
+#define TOSA_IRQ_GPIO_nSD_INT       	IRQ_GPIO(TOSA_GPIO_nSD_INT)
+#define TOSA_IRQ_GPIO_nSD_DETECT    	IRQ_GPIO(TOSA_GPIO_nSD_DETECT)
+#define TOSA_IRQ_GPIO_BAT1_CRG      	IRQ_GPIO(TOSA_GPIO_BAT1_CRG)
+#define TOSA_IRQ_GPIO_CF_CD         	IRQ_GPIO(TOSA_GPIO_CF_CD)
+#define TOSA_IRQ_GPIO_BAT0_CRG      	IRQ_GPIO(TOSA_GPIO_BAT0_CRG)
+#define TOSA_IRQ_GPIO_TC6393_INT    	IRQ_GPIO(TOSA_GPIO_TC6393_INT)
+#define TOSA_IRQ_GPIO_BAT0_LOW      	IRQ_GPIO(TOSA_GPIO_BAT0_LOW)
+#define TOSA_IRQ_GPIO_EAR_IN        	IRQ_GPIO(TOSA_GPIO_EAR_IN)
+#define TOSA_IRQ_GPIO_CF_IRQ        	IRQ_GPIO(TOSA_GPIO_CF_IRQ)
+#define TOSA_IRQ_GPIO_ON_KEY        	IRQ_GPIO(TOSA_GPIO_ON_KEY)
+#define TOSA_IRQ_GPIO_VGA_LINE      	IRQ_GPIO(TOSA_GPIO_VGA_LINE)
+#define TOSA_IRQ_GPIO_TP_INT        	IRQ_GPIO(TOSA_GPIO_TP_INT)
+#define TOSA_IRQ_GPIO_JC_CF_IRQ     	IRQ_GPIO(TOSA_GPIO_JC_CF_IRQ)
+#define TOSA_IRQ_GPIO_BAT_LOCKED    	IRQ_GPIO(TOSA_GPIO_BAT_LOCKED)
+#define TOSA_IRQ_GPIO_BAT1_LOW      	IRQ_GPIO(TOSA_GPIO_BAT1_LOW)
+#define TOSA_IRQ_GPIO_KEY_SENSE(a)  	IRQ_GPIO(69+(a))
+
+#define TOSA_IRQ_GPIO_MAIN_BAT_LOW 	IRQ_GPIO(TOSA_GPIO_MAIN_BAT_LOW)
+
+extern struct platform_device tosascoop_jc_device;
+extern struct platform_device tosascoop_device;
+#endif /* _ASM_ARCH_TOSA_H_ */
Index: build_tree/linux/include/asm/arch/trizeps4.h
diff -u /dev/null build_tree/linux/include/asm/arch/trizeps4.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/trizeps4.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,106 @@
+/************************************************************************
+ * Include file for TRIZEPS4 SoM and ConXS eval-board
+ * Copyright (c) Jrgen Schindele
+ * 2006
+ ************************************************************************/
+
+/*
+ * Includes/Defines
+ */
+#ifndef _TRIPEPS4_H_
+#define _TRIPEPS4_H_
+
+/* physical memory regions */
+#define TRIZEPS4_FLASH_PHYS	(PXA_CS0_PHYS)  /* Flash region */
+#define TRIZEPS4_DISK_PHYS	(PXA_CS1_PHYS)  /* Disk On Chip region */
+#define TRIZEPS4_ETH_PHYS	(PXA_CS2_PHYS)  /* Ethernet DM9000 region */
+#define TRIZEPS4_PIC_PHYS	(PXA_CS3_PHYS)	/* Logic chip on ConXS-Board */
+#define TRIZEPS4_SDRAM_BASE	0xa0000000      /* SDRAM region */
+
+#define TRIZEPS4_CFSR_PHYS	(PXA_CS3_PHYS)			/* Logic chip on ConXS-Board CSFR register */
+#define TRIZEPS4_BOCR_PHYS	(PXA_CS3_PHYS+0x02000000)	/* Logic chip on ConXS-Board BOCR register */
+#define TRIZEPS4_IRCR_PHYS	(PXA_CS3_PHYS+0x02400000)	/* Logic chip on ConXS-Board IRCR register*/
+#define TRIZEPS4_UPSR_PHYS	(PXA_CS3_PHYS+0x02800000)	/* Logic chip on ConXS-Board UPSR register*/
+#define TRIZEPS4_DICR_PHYS	(PXA_CS3_PHYS+0x03800000)	/* Logic chip on ConXS-Board DICR register*/
+
+/* virtual memory regions */
+#define TRIZEPS4_DISK_VIRT	0xF0000000	/* Disk On Chip region */
+
+#define TRIZEPS4_PIC_VIRT	0xF0100000	/* not used */
+#define TRIZEPS4_CFSR_VIRT	0xF0100000
+#define TRIZEPS4_BOCR_VIRT	0xF0200000
+#define TRIZEPS4_DICR_VIRT	0xF0300000
+#define TRIZEPS4_IRCR_VIRT	0xF0400000
+#define TRIZEPS4_UPSR_VIRT	0xF0500000
+
+/* size of flash */
+#define TRIZEPS4_FLASH_SIZE	0x02000000	/* Flash size 32 MB */
+
+/* Ethernet Controller Davicom DM9000 */
+#define GPIO_DM9000		101
+#define TRIZEPS4_ETH_IRQ	IRQ_GPIO(GPIO_DM9000)
+
+/* UCB1400 audio / TS-controller */
+#define GPIO_UCB1400		1
+#define TRIZEPS4_UCB1400_IRQ	IRQ_GPIO(GPIO_UCB1400)
+
+/* PCMCIA socket Compact Flash */
+#define GPIO_PCD		11		/* PCMCIA Card Detect */
+#define TRIZEPS4_CD_IRQ		IRQ_GPIO(GPIO_PCD)
+#define GPIO_PRDY		13		/* READY / nINT */
+#define TRIZEPS4_READY_NINT	IRQ_GPIO(GPIO_PRDY)
+
+/* MMC socket */
+#define GPIO_MMC_DET		12
+#define TRIZEPS4_MMC_IRQ	IRQ_GPIO(GPIO_MMC_DET)
+
+/* LEDS using tx2 / rx2 */
+#define GPIO_SYS_BUSY_LED	46
+#define GPIO_HEARTBEAT_LED	47
+
+/* Off-module PIC on ConXS board */
+#define GPIO_PIC		0
+#define TRIZEPS4_PIC_IRQ	IRQ_GPIO(GPIO_PIC)
+
+#define CFSR_P2V(x)		((x) - TRIZEPS4_CFSR_PHYS + TRIZEPS4_CFSR_VIRT)
+#define CFSR_V2P(x)		((x) - TRIZEPS4_CFSR_VIRT + TRIZEPS4_CFSR_PHYS)
+
+#define BCR_P2V(x)		((x) - TRIZEPS4_BOCR_PHYS + TRIZEPS4_BOCR_VIRT)
+#define BCR_V2P(x)		((x) - TRIZEPS4_BOCR_VIRT + TRIZEPS4_BOCR_PHYS)
+
+#define DCR_P2V(x)		((x) - TRIZEPS4_DICR_PHYS + TRIZEPS4_DICR_VIRT)
+#define DCR_V2P(x)		((x) - TRIZEPS4_DICR_VIRT + TRIZEPS4_DICR_PHYS)
+
+#ifndef __ASSEMBLY__
+#define ConXS_CFSR		(*((volatile unsigned short *)CFSR_P2V(0x0C000000)))
+#define ConXS_BCR		(*((volatile unsigned short *)BCR_P2V(0x0E000000)))
+#define ConXS_DCR		(*((volatile unsigned short *)DCR_P2V(0x0F800000)))
+#else
+#define ConXS_CFSR		CFSR_P2V(0x0C000000)
+#define ConXS_BCR		BCR_P2V(0x0E000000)
+#define ConXS_DCR		DCR_P2V(0x0F800000)
+#endif
+
+#define ConXS_CFSR_BVD_MASK	0x0003
+#define ConXS_CFSR_BVD1		(1 << 0)
+#define ConXS_CFSR_BVD2		(1 << 1)
+#define ConXS_CFSR_VS_MASK	0x000C
+#define ConXS_CFSR_VS1		(1 << 2)
+#define ConXS_CFSR_VS2		(1 << 3)
+#define ConXS_CFSR_VS_5V	(0x3 << 2)
+#define ConXS_CFSR_VS_3V3	0x0
+
+#define ConXS_BCR_S0_POW_EN0	(1 << 0)
+#define ConXS_BCR_S0_POW_EN1	(1 << 1)
+#define ConXS_BCR_L_DISP	(1 << 4)
+#define ConXS_BCR_CF_BUF_EN	(1 << 5)
+#define ConXS_BCR_CF_RESET	(1 << 7)
+#define ConXS_BCR_S0_VCC_3V3	0x1
+#define ConXS_BCR_S0_VCC_5V0	0x2
+#define ConXS_BCR_S0_VPP_12V	0x4
+#define ConXS_BCR_S0_VPP_3V3	0x8
+
+#define ConXS_IRCR_MODE		(1 << 0)
+#define ConXS_IRCR_SD		(1 << 1)
+
+#endif /* _TRIPEPS4_H_ */
Index: build_tree/linux/include/asm/arch/udc.h
diff -u /dev/null build_tree/linux/include/asm/arch/udc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/udc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/*
+ * linux/include/asm-arm/arch-pxa/udc.h
+ *
+ * This supports machine-specific differences in how the PXA2xx
+ * USB Device Controller (UDC) is wired.
+ *
+ */
+#include <asm/mach/udc_pxa2xx.h>
+
+extern void pxa_set_udc_info(struct pxa2xx_udc_mach_info *info);
+
+static inline int udc_gpio_to_irq(unsigned gpio)
+{
+	return IRQ_GPIO(gpio & GPIO_MD_MASK_NR);
+}
+
+static inline void udc_gpio_init_vbus(unsigned gpio)
+{
+	pxa_gpio_mode((gpio & GPIO_MD_MASK_NR) | GPIO_IN);
+}
+
+static inline void udc_gpio_init_pullup(unsigned gpio)
+{
+	pxa_gpio_mode((gpio & GPIO_MD_MASK_NR) | GPIO_OUT | GPIO_DFLT_LOW);
+}
+
+static inline int udc_gpio_get(unsigned gpio)
+{
+	return (GPLR(gpio) & GPIO_bit(gpio)) != 0;
+}
+
+static inline void udc_gpio_set(unsigned gpio, int is_on)
+{
+	int mask = GPIO_bit(gpio);
+
+	if (is_on)
+		GPSR(gpio) = mask;
+	else
+		GPCR(gpio) = mask;
+}
+
Index: build_tree/linux/include/asm/arch/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * linux/include/asm-arm/arch-pxa/uncompress.h
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define FFUART		((volatile unsigned long *)0x40100000)
+#define BTUART		((volatile unsigned long *)0x40200000)
+#define STUART		((volatile unsigned long *)0x40700000)
+#define HWUART		((volatile unsigned long *)0x41600000)
+
+#define UART		FFUART
+
+
+static inline void putc(char c)
+{
+	while (!(UART[5] & 0x20))
+		barrier();
+	UART[0] = c;
+}
+
+/*
+ * This does not append a newline
+ */
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,11 @@
+/*
+ * linux/include/asm-arm/arch-pxa/vmalloc.h
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define VMALLOC_END       (0xe8000000)
Index: build_tree/linux/include/asm/arch-aaec2000/aaec2000.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/aaec2000.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/aaec2000.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,207 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/aaec2000.h
+ *
+ *  AAEC-2000 registers definition
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_AAEC2000_H
+#define __ASM_ARCH_AAEC2000_H
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#error You must include hardware.h not this file
+#endif /* __ASM_ARCH_HARDWARE_H */
+
+/* Chip selects */
+#define AAEC_CS0	0x00000000
+#define AAEC_CS1	0x10000000
+#define AAEC_CS2	0x20000000
+#define AAEC_CS3	0x30000000
+
+/* Flash */
+#define AAEC_FLASH_BASE	AAEC_CS0
+#define AAEC_FLASH_SIZE	SZ_64M
+
+/* Interrupt controller */
+#define IRQ_BASE	__REG(0x80000500)
+#define IRQ_INTSR	__REG(0x80000500)	/* Int Status Register */
+#define IRQ_INTRSR	__REG(0x80000504)	/* Int Raw (unmasked) Status */
+#define IRQ_INTENS	__REG(0x80000508)	/* Int Enable Set */
+#define IRQ_INTENC	__REG(0x8000050c)	/* Int Enable Clear */
+
+/* UART 1 */
+#define UART1_BASE	__REG(0x80000600)
+#define UART1_DR	__REG(0x80000600) /* Data/FIFO Register */
+#define UART1_LCR	__REG(0x80000604) /* Link Control Register */
+#define UART1_BRCR	__REG(0x80000608) /* Baud Rate Control Register */
+#define UART1_CR	__REG(0x8000060c) /* Control Register */
+#define UART1_SR	__REG(0x80000610) /* Status Register */
+#define UART1_INT	__REG(0x80000614) /* Interrupt Status Register */
+#define UART1_INTM	__REG(0x80000618) /* Interrupt Mask Register */
+#define UART1_INTRES	__REG(0x8000061c) /* Int Result (masked status) Register */
+
+/* UART 2 */
+#define UART2_BASE	__REG(0x80000700)
+#define UART2_DR	__REG(0x80000700) /* Data/FIFO Register */
+#define UART2_LCR	__REG(0x80000704) /* Link Control Register */
+#define UART2_BRCR	__REG(0x80000708) /* Baud Rate Control Register */
+#define UART2_CR	__REG(0x8000070c) /* Control Register */
+#define UART2_SR	__REG(0x80000710) /* Status Register */
+#define UART2_INT	__REG(0x80000714) /* Interrupt Status Register */
+#define UART2_INTM	__REG(0x80000718) /* Interrupt Mask Register */
+#define UART2_INTRES	__REG(0x8000071c) /* Int Result (masked status) Register */
+
+/* UART 3 */
+#define UART3_BASE	__REG(0x80000800)
+#define UART3_DR	__REG(0x80000800) /* Data/FIFO Register */
+#define UART3_LCR	__REG(0x80000804) /* Link Control Register */
+#define UART3_BRCR	__REG(0x80000808) /* Baud Rate Control Register */
+#define UART3_CR	__REG(0x8000080c) /* Control Register */
+#define UART3_SR	__REG(0x80000810) /* Status Register */
+#define UART3_INT	__REG(0x80000814) /* Interrupt Status Register */
+#define UART3_INTM	__REG(0x80000818) /* Interrupt Mask Register */
+#define UART3_INTRES	__REG(0x8000081c) /* Int Result (masked status) Register */
+
+/* These are used in some places */
+#define _UART1_BASE __PREG(UART1_BASE)
+#define _UART2_BASE __PREG(UART2_BASE)
+#define _UART3_BASE __PREG(UART3_BASE)
+
+/* UART Registers Offsets */
+#define UART_DR		0x00
+#define UART_LCR	0x04
+#define UART_BRCR	0x08
+#define UART_CR		0x0c
+#define UART_SR		0x10
+#define UART_INT	0x14
+#define UART_INTM	0x18
+#define UART_INTRES	0x1c
+
+/* UART_LCR Bitmask */
+#define UART_LCR_BRK	(1 << 0) /* Send Break */
+#define UART_LCR_PEN	(1 << 1) /* Parity Enable */
+#define UART_LCR_EP	(1 << 2) /* Even/Odd Parity */
+#define UART_LCR_S2	(1 << 3) /* One/Two Stop bits */
+#define UART_LCR_FIFO	(1 << 4) /* FIFO Enable */
+#define UART_LCR_WL5	(0 << 5) /* Word Length - 5 bits */
+#define UART_LCR_WL6	(1 << 5) /* Word Length - 6 bits */
+#define UART_LCR_WL7	(1 << 6) /* Word Length - 7 bits */
+#define UART_LCR_WL8	(1 << 7) /* Word Length - 8 bits */
+
+/* UART_CR Bitmask */
+#define UART_CR_EN	(1 << 0) /* UART Enable */
+#define UART_CR_SIR	(1 << 1) /* IrDA SIR Enable */
+#define UART_CR_SIRLP	(1 << 2) /* Low Power IrDA Enable */
+#define UART_CR_RXP	(1 << 3) /* Receive Pin Polarity */
+#define UART_CR_TXP	(1 << 4) /* Transmit Pin Polarity */
+#define UART_CR_MXP	(1 << 5) /* Modem Pin Polarity */
+#define UART_CR_LOOP	(1 << 6) /* Loopback Mode */
+
+/* UART_SR Bitmask */
+#define UART_SR_CTS	(1 << 0) /* Clear To Send Status */
+#define UART_SR_DSR	(1 << 1) /* Data Set Ready Status */
+#define UART_SR_DCD	(1 << 2) /* Data Carrier Detect Status */
+#define UART_SR_TxBSY	(1 << 3) /* Transmitter Busy Status */
+#define UART_SR_RxFE	(1 << 4) /* Receive FIFO Empty Status */
+#define UART_SR_TxFF	(1 << 5) /* Transmit FIFO Full Status */
+#define UART_SR_RxFF	(1 << 6) /* Receive FIFO Full Status */
+#define UART_SR_TxFE	(1 << 7) /* Transmit FIFO Empty Status */
+
+/* UART_INT Bitmask */
+#define UART_INT_RIS	(1 << 0) /* Rx Interrupt */
+#define UART_INT_TIS	(1 << 1) /* Tx Interrupt */
+#define UART_INT_MIS	(1 << 2) /* Modem Interrupt */
+#define UART_INT_RTIS	(1 << 3) /* Receive Timeout Interrupt */
+
+/* Timer 1 */
+#define TIMER1_BASE	__REG(0x80000c00)
+#define TIMER1_LOAD	__REG(0x80000c00)	/* Timer 1 Load Register */
+#define TIMER1_VAL	__REG(0x80000c04)	/* Timer 1 Value Register */
+#define TIMER1_CTRL	__REG(0x80000c08)	/* Timer 1 Control Register */
+#define TIMER1_CLEAR	__REG(0x80000c0c)	/* Timer 1 Clear Register */
+
+/* Timer 2 */
+#define TIMER2_BASE	__REG(0x80000d00)
+#define TIMER2_LOAD	__REG(0x80000d00)	/* Timer 2 Load Register */
+#define TIMER2_VAL	__REG(0x80000d04)	/* Timer 2 Value Register */
+#define TIMER2_CTRL	__REG(0x80000d08)	/* Timer 2 Control Register */
+#define TIMER2_CLEAR	__REG(0x80000d0c)	/* Timer 2 Clear Register */
+
+/* Timer 3 */
+#define TIMER3_BASE	__REG(0x80000e00)
+#define TIMER3_LOAD	__REG(0x80000e00)	/* Timer 3 Load Register */
+#define TIMER3_VAL	__REG(0x80000e04)	/* Timer 3 Value Register */
+#define TIMER3_CTRL	__REG(0x80000e08)	/* Timer 3 Control Register */
+#define TIMER3_CLEAR	__REG(0x80000e0c)	/* Timer 3 Clear Register */
+
+/* Timer Control register bits */
+#define TIMER_CTRL_ENABLE	(1 << 7) /* Enable (Start Timer */
+#define TIMER_CTRL_PERIODIC	(1 << 6) /* Periodic Running Mode */
+#define TIMER_CTRL_FREE_RUNNING (0 << 6) /* Normal Running Mode */
+#define TIMER_CTRL_CLKSEL_508K	(1 << 3) /* 508KHz Clock select (Timer 1, 2) */
+#define TIMER_CTRL_CLKSEL_2K	(0 << 3) /* 2KHz Clock Select (Timer 1, 2)*/
+
+/* Power and State Control */
+#define POWER_BASE	__REG(0x80000400)
+#define POWER_PWRSR	__REG(0x80000400) /* Power Status Register */
+#define POWER_PWRCNT	__REG(0x80000404) /* Power/Clock control */
+#define POWER_HALT	__REG(0x80000408) /* Power Idle Mode */
+#define POWER_STDBY	__REG(0x8000040c) /* Power Standby Mode */
+#define POWER_BLEOI	__REG(0x80000410) /* Battery Low End of Interrupt */
+#define POWER_MCEOI	__REG(0x80000414) /* Media Changed EoI */
+#define POWER_TEOI	__REG(0x80000418) /* Tick EoI */
+#define POWER_STFCLR	__REG(0x8000041c) /* NbFlg, RSTFlg, PFFlg, CLDFlg Clear */
+#define POWER_CLKSET	__REG(0x80000420) /* Clock Speed Control */
+
+/* GPIO Registers */
+#define AAEC_GPIO_PHYS	0x80000e00
+
+#define AAEC_GPIO_PADR		__REG(AAEC_GPIO_PHYS + 0x00)
+#define AAEC_GPIO_PBDR		__REG(AAEC_GPIO_PHYS + 0x04)
+#define AAEC_GPIO_PCDR		__REG(AAEC_GPIO_PHYS + 0x08)
+#define AAEC_GPIO_PDDR		__REG(AAEC_GPIO_PHYS + 0x0c)
+#define AAEC_GPIO_PADDR		__REG(AAEC_GPIO_PHYS + 0x10)
+#define AAEC_GPIO_PBDDR		__REG(AAEC_GPIO_PHYS + 0x14)
+#define AAEC_GPIO_PCDDR		__REG(AAEC_GPIO_PHYS + 0x18)
+#define AAEC_GPIO_PDDDR		__REG(AAEC_GPIO_PHYS + 0x1c)
+#define AAEC_GPIO_PEDR		__REG(AAEC_GPIO_PHYS + 0x20)
+#define AAEC_GPIO_PEDDR		__REG(AAEC_GPIO_PHYS + 0x24)
+#define AAEC_GPIO_KSCAN		__REG(AAEC_GPIO_PHYS + 0x28)
+#define AAEC_GPIO_PINMUX	__REG(AAEC_GPIO_PHYS + 0x2c)
+#define AAEC_GPIO_PFDR		__REG(AAEC_GPIO_PHYS + 0x30)
+#define AAEC_GPIO_PFDDR		__REG(AAEC_GPIO_PHYS + 0x34)
+#define AAEC_GPIO_PGDR		__REG(AAEC_GPIO_PHYS + 0x38)
+#define AAEC_GPIO_PGDDR		__REG(AAEC_GPIO_PHYS + 0x3c)
+#define AAEC_GPIO_PHDR		__REG(AAEC_GPIO_PHYS + 0x40)
+#define AAEC_GPIO_PHDDR		__REG(AAEC_GPIO_PHYS + 0x44)
+#define AAEC_GPIO_RAZ		__REG(AAEC_GPIO_PHYS + 0x48)
+#define AAEC_GPIO_INTTYPE1	__REG(AAEC_GPIO_PHYS + 0x4c)
+#define AAEC_GPIO_INTTYPE2	__REG(AAEC_GPIO_PHYS + 0x50)
+#define AAEC_GPIO_FEOI		__REG(AAEC_GPIO_PHYS + 0x54)
+#define AAEC_GPIO_INTEN		__REG(AAEC_GPIO_PHYS + 0x58)
+#define AAEC_GPIO_INTSTATUS	__REG(AAEC_GPIO_PHYS + 0x5c)
+#define AAEC_GPIO_RAWINTSTATUS	__REG(AAEC_GPIO_PHYS + 0x60)
+#define AAEC_GPIO_DB		__REG(AAEC_GPIO_PHYS + 0x64)
+#define AAEC_GPIO_PAPINDR	__REG(AAEC_GPIO_PHYS + 0x68)
+#define AAEC_GPIO_PBPINDR	__REG(AAEC_GPIO_PHYS + 0x6c)
+#define AAEC_GPIO_PCPINDR	__REG(AAEC_GPIO_PHYS + 0x70)
+#define AAEC_GPIO_PDPINDR	__REG(AAEC_GPIO_PHYS + 0x74)
+#define AAEC_GPIO_PEPINDR	__REG(AAEC_GPIO_PHYS + 0x78)
+#define AAEC_GPIO_PFPINDR	__REG(AAEC_GPIO_PHYS + 0x7c)
+#define AAEC_GPIO_PGPINDR	__REG(AAEC_GPIO_PHYS + 0x80)
+#define AAEC_GPIO_PHPINDR	__REG(AAEC_GPIO_PHYS + 0x84)
+
+#define AAEC_GPIO_PINMUX_PE0CON		(1 << 0)
+#define AAEC_GPIO_PINMUX_PD0CON		(1 << 1)
+#define AAEC_GPIO_PINMUX_CODECON	(1 << 2)
+#define AAEC_GPIO_PINMUX_UART3CON	(1 << 3)
+
+/* LCD Controller */
+#define AAEC_CLCD_PHYS	0x80003000
+
+#endif /* __ARM_ARCH_AAEC2000_H */
Index: build_tree/linux/include/asm/arch-aaec2000/aaed2000.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/aaed2000.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/aaed2000.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/aaed2000.h
+ *
+ *  AAED-2000 specific bits definition
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_AAED2000_H
+#define __ASM_ARCH_AAED2000_H
+
+/* External GPIOs. */
+
+#define EXT_GPIO_PBASE	AAEC_CS3
+#define EXT_GPIO_VBASE	0xf8100000
+#define EXT_GPIO_LENGTH	0x00001000
+
+#define __ext_gpio_p2v(x)	((x) - EXT_GPIO_PBASE + EXT_GPIO_VBASE)
+#define __ext_gpio_v2p(x)	((x) + EXT_GPIO_PBASE - EXT_GPIO_VBASE)
+
+#define __EXT_GPIO_REG(x)	(*((volatile u32 *)__ext_gpio_p2v(x)))
+#define __EXT_GPIO_PREG(x)	(__ext_gpio_v2p((u32)&(x)))
+
+#define AAED_EXT_GPIO	__EXT_GPIO_REG(EXT_GPIO_PBASE)
+
+#define AAED_EGPIO_KBD_SCAN	0x00003fff /* Keyboard scan data */
+#define AAED_EGPIO_PWR_INT	0x00008fff /* Smart battery charger interrupt */
+#define AAED_EGPIO_SWITCHED	0x000f0000 /* DIP Switches */
+#define AAED_EGPIO_USB_VBUS	0x00400000 /* USB Vbus sense */
+#define AAED_EGPIO_LCD_PWR_EN	0x02000000 /* LCD and backlight PWR enable */
+#define AAED_EGPIO_nLED0	0x20000000 /* LED 0 */
+#define AAED_EGPIO_nLED1	0x20000000 /* LED 1 */
+#define AAED_EGPIO_nLED2	0x20000000 /* LED 2 */
+
+
+#endif /* __ARM_ARCH_AAED2000_H */
Index: build_tree/linux/include/asm/arch-aaec2000/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*  linux/include/asm-arm/arch-aaec2000/debug-macro.S
+ *
+ *  Debugging macro include header
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include "hardware.h"
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x80000000		@ physical
+		movne	\rx, #io_p2v(0x80000000)	@ virtual
+		orr	\rx, \rx, #0x00000800
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0]
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #0x10]
+		tst	\rd, #(1 << 7)
+		beq	1002b
+		.endm
+
+		.macro	waituart,rd,rx
+#if 0
+1001:		ldr	\rd, [\rx, #0x10]
+		tst	\rd, #(1 << 5)
+		beq	1001b
+#endif
+		.endm
Index: build_tree/linux/include/asm/arch-aaec2000/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,9 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/dma.h
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
Index: build_tree/linux/include/asm/arch-aaec2000/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/entry-macro.S
+ *
+ *  Low-level IRQ helper for aaec-2000 based platforms
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+#include <asm/arch/irqs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	r4, #0xf8000000
+		add	r4, r4, #0x00000500
+		mov	\base, r4
+		ldr	\irqstat, [\base, #0]
+		cmp	\irqstat, #0
+		bne	1001f
+		ldr	\irqnr, =NR_IRQS+1
+		b       1003f
+1001:		mov	\irqnr, #0
+1002:		ands	\tmp, \irqstat, #1
+		mov	\irqstat, \irqstat, LSR #1
+		add	\irqnr, \irqnr, #1
+		beq	1002b
+		sub	\irqnr, \irqnr, #1
+1003:
+		.endm
Index: build_tree/linux/include/asm/arch-aaec2000/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,50 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/hardware.h
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <asm/arch/aaec2000.h>
+
+/* The kernel is loaded at physical address 0xf8000000.
+ * We map the IO space a bit after
+ */
+#define PIO_APB_BASE	0x80000000
+#define VIO_APB_BASE	0xf8000000
+#define IO_APB_LENGTH	0x2000
+#define PIO_AHB_BASE	0x80002000
+#define VIO_AHB_BASE	0xf8002000
+#define IO_AHB_LENGTH	0x2000
+
+#define VIO_BASE    VIO_APB_BASE
+#define PIO_BASE    PIO_APB_BASE
+
+#define io_p2v(x) ( (x) - PIO_BASE + VIO_BASE )
+#define io_v2p(x) ( (x) + PIO_BASE - VIO_BASE )
+
+#ifndef __ASSEMBLY__
+
+#include <asm/types.h>
+
+/* FIXME: Is it needed to optimize this a la pxa ?? */
+#define __REG(x)    (*((volatile u32 *)io_p2v(x)))
+#define __PREG(x)   (io_v2p((u32)&(x)))
+
+#else /* __ASSEMBLY__ */
+
+#define __REG(x)    io_p2v(x)
+#define __PREG(x)   io_v2p(x)
+
+#endif
+
+#include "aaec2000.h"
+
+#endif /* __ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-aaec2000/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/io.h
+ *
+ *  Copied from asm/arch/sa1100/io.h
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-aaec2000/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/irqs.h
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+
+#define INT_GPIOF0_FIQ	0  /* External GPIO Port F O Fast Interrupt Input */
+#define INT_BL_FIQ	1  /* Battery Low Fast Interrupt */
+#define INT_WE_FIQ	2  /* Watchdog Expired Fast Interrupt */
+#define INT_MV_FIQ	3  /* Media Changed Interrupt */
+#define INT_SC		4  /* Sound Codec Interrupt */
+#define INT_GPIO1	5  /* GPIO Port F Configurable Int 1 */
+#define INT_GPIO2	6  /* GPIO Port F Configurable Int 2 */
+#define INT_GPIO3	7  /* GPIO Port F Configurable Int 3 */
+#define INT_TMR1_OFL	8  /* Timer 1 Overflow Interrupt */
+#define INT_TMR2_OFL	9  /* Timer 2 Overflow Interrupt */
+#define INT_RTC_CM	10 /* RTC Compare Match Interrupt */
+#define INT_TICK	11 /* 64Hz Tick Interrupt */
+#define INT_UART1	12 /* UART1 Interrupt */
+#define INT_UART2	13 /* UART2 & Modem State Changed Interrupt */
+#define INT_LCD		14 /* LCD Interrupt */
+#define INT_SSI		15 /* SSI End of Transfer Interrupt */
+#define INT_UART3	16 /* UART3 Interrupt */
+#define INT_SCI		17 /* SCI Interrupt */
+#define INT_AAC		18 /* Advanced Audio Codec Interrupt */
+#define INT_MMC		19 /* MMC Interrupt */
+#define INT_USB		20 /* USB Interrupt */
+#define INT_DMA		21 /* DMA Interrupt */
+#define INT_TMR3_UOFL	22 /* Timer 3 Underflow Interrupt */
+#define INT_GPIO4	23 /* GPIO Port F Configurable Int 4 */
+#define INT_GPIO5	24 /* GPIO Port F Configurable Int 4 */
+#define INT_GPIO6	25 /* GPIO Port F Configurable Int 4 */
+#define INT_GPIO7	26 /* GPIO Port F Configurable Int 4 */
+#define INT_BMI		27 /* BMI Interrupt */
+
+#define NR_IRQS		(INT_BMI + 1)
+
+#endif /* __ASM_ARCH_IRQS_H */
Index: build_tree/linux/include/asm/arch-aaec2000/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/memory.h
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+
+#define PHYS_OFFSET	UL(0xf0000000)
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+/*
+ * The nodes are the followings:
+ *
+ *   node 0: 0xf000.0000 - 0xf3ff.ffff
+ *   node 1: 0xf400.0000 - 0xf7ff.ffff
+ *   node 2: 0xf800.0000 - 0xfbff.ffff
+ *   node 3: 0xfc00.0000 - 0xffff.ffff
+ */
+#define NODE_MEM_SIZE_BITS	26
+
+#endif /* __ASM_ARCH_MEMORY_H */
Index: build_tree/linux/include/asm/arch-aaec2000/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ *  linux/include/asm-arm/arch-aaed2000/system.h
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	cpu_reset(0);
+}
+
+#endif /* __ASM_ARCH_SYSTEM_H */
Index: build_tree/linux/include/asm/arch-aaec2000/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/timex.h
+ *
+ *  AAEC-2000 Architecture timex specification
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#define CLOCK_TICK_RATE		508000
+
+#endif /* __ASM_ARCH_TIMEX_H */
Index: build_tree/linux/include/asm/arch-aaec2000/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/uncompress.h
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include "hardware.h"
+
+#define UART(x)         (*(volatile unsigned long *)(serial_port + (x)))
+
+static void putc(int c)
+{
+	unsigned long serial_port;
+        do {
+		serial_port = _UART3_BASE;
+		if (UART(UART_CR) & UART_CR_EN) break;
+		serial_port = _UART1_BASE;
+		if (UART(UART_CR) & UART_CR_EN) break;
+		serial_port = _UART2_BASE;
+		if (UART(UART_CR) & UART_CR_EN) break;
+		return;
+	} while (0);
+
+	/* wait for space in the UART's transmitter */
+	while ((UART(UART_SR) & UART_SR_TxFF))
+		barrier();
+
+	/* send the character out. */
+	UART(UART_DR) = c;
+}
+
+static inline void flush(void)
+{
+}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif /* __ASM_ARCH_UNCOMPRESS_H */
Index: build_tree/linux/include/asm/arch-aaec2000/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-aaec2000/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-aaec2000/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+/*
+ *  linux/include/asm-arm/arch-aaec2000/vmalloc.h
+ *
+ *  Copyright (c) 2005 Nicolas Bellido Y Ortega
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END		(PAGE_OFFSET + 0x10000000)
+
+#endif /* __ASM_ARCH_VMALLOC_H */
Index: build_tree/linux/include/asm/arch-at91/at91_aic.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_aic.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_aic.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,53 @@
+/*
+ * include/asm-arm/arch-at91/at91_aic.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Advanced Interrupt Controller (AIC) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_AIC_H
+#define AT91_AIC_H
+
+#define AT91_AIC_SMR(n)		(AT91_AIC + ((n) * 4))	/* Source Mode Registers 0-31 */
+#define		AT91_AIC_PRIOR		(7 << 0)		/* Priority Level */
+#define		AT91_AIC_SRCTYPE	(3 << 5)		/* Interrupt Source Type */
+#define			AT91_AIC_SRCTYPE_LOW		(0 << 5)
+#define			AT91_AIC_SRCTYPE_FALLING	(1 << 5)
+#define			AT91_AIC_SRCTYPE_HIGH		(2 << 5)
+#define			AT91_AIC_SRCTYPE_RISING		(3 << 5)
+
+#define AT91_AIC_SVR(n)		(AT91_AIC + 0x80 + ((n) * 4))	/* Source Vector Registers 0-31 */
+#define AT91_AIC_IVR		(AT91_AIC + 0x100)	/* Interrupt Vector Register */
+#define AT91_AIC_FVR		(AT91_AIC + 0x104)	/* Fast Interrupt Vector Register */
+#define AT91_AIC_ISR		(AT91_AIC + 0x108)	/* Interrupt Status Register */
+#define		AT91_AIC_IRQID		(0x1f << 0)		/* Current Interrupt Identifier */
+
+#define AT91_AIC_IPR		(AT91_AIC + 0x10c)	/* Interrupt Pending Register */
+#define AT91_AIC_IMR		(AT91_AIC + 0x110)	/* Interrupt Mask Register */
+#define AT91_AIC_CISR		(AT91_AIC + 0x114)	/* Core Interrupt Status Register */
+#define		AT91_AIC_NFIQ		(1 << 0)		/* nFIQ Status */
+#define		AT91_AIC_NIRQ		(1 << 1)		/* nIRQ Status */
+
+#define AT91_AIC_IECR		(AT91_AIC + 0x120)	/* Interrupt Enable Command Register */
+#define AT91_AIC_IDCR		(AT91_AIC + 0x124)	/* Interrupt Disable Command Register */
+#define AT91_AIC_ICCR		(AT91_AIC + 0x128)	/* Interrupt Clear Command Register */
+#define AT91_AIC_ISCR		(AT91_AIC + 0x12c)	/* Interrupt Set Command Register */
+#define AT91_AIC_EOICR		(AT91_AIC + 0x130)	/* End of Interrupt Command Register */
+#define AT91_AIC_SPU		(AT91_AIC + 0x134)	/* Spurious Interrupt Vector Register */
+#define AT91_AIC_DCR		(AT91_AIC + 0x138)	/* Debug Control Register */
+#define		AT91_AIC_DCR_PROT	(1 << 0)		/* Protection Mode */
+#define		AT91_AIC_DCR_GMSK	(1 << 1)		/* General Mask */
+
+#define AT91_AIC_FFER		(AT91_AIC + 0x140)	/* Fast Forcing Enable Register [SAM9 only] */
+#define AT91_AIC_FFDR		(AT91_AIC + 0x144)	/* Fast Forcing Disable Register [SAM9 only] */
+#define AT91_AIC_FFSR		(AT91_AIC + 0x148)	/* Fast Forcing Status Register [SAM9 only] */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_dbgu.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_dbgu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_dbgu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,59 @@
+/*
+ * include/asm-arm/arch-at91/at91_dbgu.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Debug Unit (DBGU) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_DBGU_H
+#define AT91_DBGU_H
+
+#define AT91_DBGU_CR		(AT91_DBGU + 0x00)	/* Control Register */
+#define AT91_DBGU_MR		(AT91_DBGU + 0x04)	/* Mode Register */
+#define AT91_DBGU_IER		(AT91_DBGU + 0x08)	/* Interrupt Enable Register */
+#define		AT91_DBGU_TXRDY		(1 << 1)		/* Transmitter Ready */
+#define		AT91_DBGU_TXEMPTY	(1 << 9)		/* Transmitter Empty */
+#define AT91_DBGU_IDR		(AT91_DBGU + 0x0c)	/* Interrupt Disable Register */
+#define AT91_DBGU_IMR		(AT91_DBGU + 0x10)	/* Interrupt Mask Register */
+#define AT91_DBGU_SR		(AT91_DBGU + 0x14)	/* Status Register */
+#define AT91_DBGU_RHR		(AT91_DBGU + 0x18)	/* Receiver Holding Register */
+#define AT91_DBGU_THR		(AT91_DBGU + 0x1c)	/* Transmitter Holding Register */
+#define AT91_DBGU_BRGR		(AT91_DBGU + 0x20)	/* Baud Rate Generator Register */
+
+#define AT91_DBGU_CIDR		(AT91_DBGU + 0x40)	/* Chip ID Register */
+#define AT91_DBGU_EXID		(AT91_DBGU + 0x44)	/* Chip ID Extension Register */
+#define		AT91_CIDR_VERSION	(0x1f << 0)		/* Version of the Device */
+#define		AT91_CIDR_EPROC		(7    << 5)		/* Embedded Processor */
+#define		AT91_CIDR_NVPSIZ	(0xf  << 8)		/* Nonvolatile Program Memory Size */
+#define		AT91_CIDR_NVPSIZ2	(0xf  << 12)		/* Second Nonvolatile Program Memory Size */
+#define		AT91_CIDR_SRAMSIZ	(0xf  << 16)		/* Internal SRAM Size */
+#define			AT91_CIDR_SRAMSIZ_1K	(1 << 16)
+#define			AT91_CIDR_SRAMSIZ_2K	(2 << 16)
+#define			AT91_CIDR_SRAMSIZ_112K	(4 << 16)
+#define			AT91_CIDR_SRAMSIZ_4K	(5 << 16)
+#define			AT91_CIDR_SRAMSIZ_80K	(6 << 16)
+#define			AT91_CIDR_SRAMSIZ_160K	(7 << 16)
+#define			AT91_CIDR_SRAMSIZ_8K	(8 << 16)
+#define			AT91_CIDR_SRAMSIZ_16K	(9 << 16)
+#define			AT91_CIDR_SRAMSIZ_32K	(10 << 16)
+#define			AT91_CIDR_SRAMSIZ_64K	(11 << 16)
+#define			AT91_CIDR_SRAMSIZ_128K	(12 << 16)
+#define			AT91_CIDR_SRAMSIZ_256K	(13 << 16)
+#define			AT91_CIDR_SRAMSIZ_96K	(14 << 16)
+#define			AT91_CIDR_SRAMSIZ_512K	(15 << 16)
+#define		AT91_CIDR_ARCH		(0xff << 20)		/* Architecture Identifier */
+#define		AT91_CIDR_NVPTYP	(7    << 28)		/* Nonvolatile Program Memory Type */
+#define		AT91_CIDR_EXT		(1    << 31)		/* Extension Flag */
+
+#define AT91_DBGU_FNR		(AT91_DBGU + 0x48)	/* Force NTRST Register [SAM9 only] */
+#define		AT91_DBGU_FNTRST	(1 << 0)		/* Force NTRST */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_ecc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_ecc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_ecc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-at91/at91_ecc.h
+ *
+ * Error Corrected Code Controller (ECC) - System peripherals regsters.
+ * Based on AT91SAM9260 datasheet revision B.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef AT91_ECC_H
+#define AT91_ECC_H
+
+#define AT91_ECC_CR		(AT91_ECC + 0x00)	/* Control register */
+#define		AT91_ECC_RST		(1 << 0)		/* Reset parity */
+
+#define AT91_ECC_MR		(AT91_ECC + 0x04)	/* Mode register */
+#define		AT91_ECC_PAGESIZE	(3 << 0)		/* Page Size */
+#define			AT91_ECC_PAGESIZE_528		(0)
+#define			AT91_ECC_PAGESIZE_1056		(1)
+#define			AT91_ECC_PAGESIZE_2112		(2)
+#define			AT91_ECC_PAGESIZE_4224		(3)
+
+#define AT91_ECC_SR		(AT91_ECC + 0x08)	/* Status register */
+#define		AT91_ECC_RECERR		(1 << 0)		/* Recoverable Error */
+#define		AT91_ECC_ECCERR		(1 << 1)		/* ECC Single Bit Error */
+#define		AT91_ECC_MULERR		(1 << 2)		/* Multiple Errors */
+
+#define AT91_ECC_PR		(AT91_ECC + 0x0c)	/* Parity register */
+#define		AT91_ECC_BITADDR	(0xf << 0)		/* Bit Error Address */
+#define		AT91_ECC_WORDADDR	(0xfff << 4)		/* Word Error Address */
+
+#define AT91_ECC_NPR		(AT91_ECC + 0x10)	/* NParity register */
+#define		AT91_ECC_NPARITY	(0xffff << 0)		/* NParity */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_lcdc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_lcdc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_lcdc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,148 @@
+/*
+ * include/asm-arm/arch-at91/at91_lcdc.h
+ *
+ * LCD Controller (LCDC).
+ * Based on AT91SAM9261 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_LCDC_H
+#define AT91_LCDC_H
+
+#define AT91_LCDC_DMABADDR1	0x00		/* DMA Base Address Register 1 */
+#define AT91_LCDC_DMABADDR2	0x04		/* DMA Base Address Register 2 */
+#define AT91_LCDC_DMAFRMPT1	0x08		/* DMA Frame Pointer Register 1 */
+#define AT91_LCDC_DMAFRMPT2	0x0c		/* DMA Frame Pointer Register 2 */
+#define AT91_LCDC_DMAFRMADD1	0x10		/* DMA Frame Address Register 1 */
+#define AT91_LCDC_DMAFRMADD2	0x14		/* DMA Frame Address Register 2 */
+
+#define AT91_LCDC_DMAFRMCFG	0x18		/* DMA Frame Configuration Register */
+#define		AT91_LCDC_FRSIZE	(0x7fffff <<  0)	/* Frame Size */
+#define		AT91_LCDC_BLENGTH	(0x7f     << 24)	/* Burst Length */
+
+#define AT91_LCDC_DMACON	0x1c		/* DMA Control Register */
+#define		AT91_LCDC_DMAEN		(0x1 << 0)	/* DMA Enable */
+#define		AT91_LCDC_DMARST	(0x1 << 1)	/* DMA Reset */
+#define		AT91_LCDC_DMABUSY	(0x1 << 2)	/* DMA Busy */
+
+#define AT91_LCDC_LCDCON1	0x0800		/* LCD Control Register 1 */
+#define		AT91_LCDC_BYPASS	(1     <<  0)	/* Bypass lcd_dotck divider */
+#define		AT91_LCDC_CLKVAL	(0x1ff << 12)	/* Clock Divider */
+#define		AT91_LCDC_LINCNT	(0x7ff << 21)	/* Line Counter */
+
+#define AT91_LCDC_LCDCON2	0x0804		/* LCD Control Register 2 */
+#define		AT91_LCDC_DISTYPE	(3 << 0)	/* Display Type */
+#define			AT91_LCDC_DISTYPE_STNMONO	(0 << 0)
+#define			AT91_LCDC_DISTYPE_STNCOLOR	(1 << 0)
+#define			AT91_LCDC_DISTYPE_TFT		(2 << 0)
+#define		AT91_LCDC_SCANMOD	(1 << 2)	/* Scan Mode */
+#define			AT91_LCDC_SCANMOD_SINGLE	(0 << 2)
+#define			AT91_LCDC_SCANMOD_DUAL		(1 << 2)
+#define		AT91_LCDC_IFWIDTH	(3 << 3)	/*Interface Width */
+#define			AT91_LCDC_IFWIDTH_4		(0 << 3)
+#define			AT91_LCDC_IFWIDTH_8		(1 << 3)
+#define			AT91_LCDC_IFWIDTH_16		(2 << 3)
+#define		AT91_LCDC_PIXELSIZE	(7 << 5)	/* Bits per pixel */
+#define			AT91_LCDC_PIXELSIZE_1		(0 << 5)
+#define			AT91_LCDC_PIXELSIZE_2		(1 << 5)
+#define			AT91_LCDC_PIXELSIZE_4		(2 << 5)
+#define			AT91_LCDC_PIXELSIZE_8		(3 << 5)
+#define			AT91_LCDC_PIXELSIZE_16		(4 << 5)
+#define			AT91_LCDC_PIXELSIZE_24		(5 << 5)
+#define		AT91_LCDC_INVVD		(1 << 8)	/* LCD Data polarity */
+#define			AT91_LCDC_INVVD_NORMAL		(0 << 8)
+#define			AT91_LCDC_INVVD_INVERTED	(1 << 8)
+#define		AT91_LCDC_INVFRAME	(1 << 9 )	/* LCD VSync polarity */
+#define			AT91_LCDC_INVFRAME_NORMAL	(0 << 9)
+#define			AT91_LCDC_INVFRAME_INVERTED	(1 << 9)
+#define		AT91_LCDC_INVLINE	(1 << 10)	/* LCD HSync polarity */
+#define			AT91_LCDC_INVLINE_NORMAL	(0 << 10)
+#define			AT91_LCDC_INVLINE_INVERTED	(1 << 10)
+#define		AT91_LCDC_INVCLK	(1 << 11)	/* LCD dotclk polarity */
+#define			AT91_LCDC_INVCLK_NORMAL		(0 << 11)
+#define			AT91_LCDC_INVCLK_INVERTED	(1 << 11)
+#define		AT91_LCDC_INVDVAL	(1 << 12)	/* LCD dval polarity */
+#define			AT91_LCDC_INVDVAL_NORMAL	(0 << 12)
+#define			AT91_LCDC_INVDVAL_INVERTED	(1 << 12)
+#define		AT91_LCDC_CLKMOD	(1 << 15)	/* LCD dotclk mode */
+#define			AT91_LCDC_CLKMOD_ACTIVEDISPLAY	(0 << 15)
+#define			AT91_LCDC_CLKMOD_ALWAYSACTIVE	(1 << 15)
+#define		AT91_LCDC_MEMOR		(1 << 31)	/* Memory Ordering Format */
+#define			AT91_LCDC_MEMOR_BIG		(0 << 31)
+#define			AT91_LCDC_MEMOR_LITTLE		(1 << 31)
+
+#define AT91_LCDC_TIM1		0x0808		/* LCD Timing Register 1 */
+#define		AT91_LCDC_VFP		(0xff <<  0)	/* Vertical Front Porch */
+#define		AT91_LCDC_VBP		(0xff <<  8)	/* Vertical Back Porch */
+#define		AT91_LCDC_VPW		(0x3f << 16)	/* Vertical Synchronization Pulse Width */
+#define		AT91_LCDC_VHDLY		(0xf  << 24)	/* Vertical to Horizontal Delay */
+
+#define AT91_LCDC_TIM2		0x080c		/* LCD Timing Register 2 */
+#define		AT91_LCDC_HBP		(0xff  <<  0)	/* Horizontal Back Porch */
+#define		AT91_LCDC_HPW		(0x3f  <<  8)	/* Horizontal Synchronization Pulse Width */
+#define		AT91_LCDC_HFP		(0x7ff << 21)	/* Horizontal Front Porch */
+
+#define AT91_LCDC_LCDFRMCFG	0x0810		/* LCD Frame Configuration Register */
+#define		AT91_LCDC_LINEVAL	(0x7ff <<  0)	/* Vertical Size of LCD Module */
+#define		AT91_LCDC_HOZVAL	(0x7ff << 21)	/* Horizontal Size of LCD Module */
+
+#define AT91_LCDC_FIFO		0x0814		/* LCD FIFO Register */
+#define		AT91_LCDC_FIFOTH	(0xffff)	/* FIFO Threshold */
+
+#define AT91_LCDC_DP1_2		0x081c		/* Dithering Pattern DP1_2 Register */
+#define AT91_LCDC_DP4_7		0x0820		/* Dithering Pattern DP4_7 Register */
+#define AT91_LCDC_DP3_5		0x0824		/* Dithering Pattern DP3_5 Register */
+#define AT91_LCDC_DP2_3		0x0828		/* Dithering Pattern DP2_3 Register */
+#define AT91_LCDC_DP5_7		0x082c		/* Dithering Pattern DP5_7 Register */
+#define AT91_LCDC_DP3_4		0x0830		/* Dithering Pattern DP3_4 Register */
+#define AT91_LCDC_DP4_5		0x0834		/* Dithering Pattern DP4_5 Register */
+#define AT91_LCDC_DP6_7		0x0838		/* Dithering Pattern DP6_7 Register */
+#define		AT91_LCDC_DP1_2_VAL	(0xff)
+#define		AT91_LCDC_DP4_7_VAL	(0xfffffff)
+#define		AT91_LCDC_DP3_5_VAL	(0xfffff)
+#define		AT91_LCDC_DP2_3_VAL	(0xfff)
+#define		AT91_LCDC_DP5_7_VAL	(0xfffffff)
+#define		AT91_LCDC_DP3_4_VAL	(0xffff)
+#define		AT91_LCDC_DP4_5_VAL	(0xfffff)
+#define		AT91_LCDC_DP6_7_VAL	(0xfffffff)
+
+#define AT91_LCDC_PWRCON	0x083c		/* Power Control Register */
+#define		AT91_LCDC_PWR		(1    <<  0)	/* LCD Module Power Control */
+#define		AT91_LCDC_GUARDT	(0x7f <<  1)	/* Delay in Frame Period */
+#define		AT91_LCDC_BUSY		(1    << 31)	/* LCD Busy */
+
+#define AT91_LCDC_CONTRAST_CTR	0x0840		/* Contrast Control Register */
+#define		AT91_LCDC_PS		(3 << 0)	/* Contrast Counter Prescaler */
+#define			AT91_LCDC_PS_DIV1		(0 << 0)
+#define			AT91_LCDC_PS_DIV2		(1 << 0)
+#define			AT91_LCDC_PS_DIV4		(2 << 0)
+#define			AT91_LCDC_PS_DIV8		(3 << 0)
+#define		AT91_LCDC_POL		(1 << 2)	/* Polarity of output Pulse */
+#define			AT91_LCDC_POL_NEGATIVE		(0 << 2)
+#define			AT91_LCDC_POL_POSITIVE		(1 << 2)
+#define		AT91_LCDC_ENA		(1 << 3)	/* PWM generator Control */
+#define			AT91_LCDC_ENA_PWMDISABLE	(0 << 3)
+#define			AT91_LCDC_ENA_PWMENABLE		(1 << 3)
+
+#define AT91_LCDC_CONTRAST_VAL	0x0844		/* Contrast Value Register */
+#define		AT91_LCDC_CVAL		(0xff)		/* PWM compare value */
+
+#define AT91_LCDC_IER		0x0848		/* Interrupt Enable Register */
+#define AT91_LCDC_IDR		0x084c		/* Interrupt Disable Register */
+#define AT91_LCDC_IMR		0x0850		/* Interrupt Mask Register */
+#define AT91_LCDC_ISR		0x0854		/* Interrupt Enable Register */
+#define AT91_LCDC_ICR		0x0858		/* Interrupt Clear Register */
+#define		AT91_LCDC_LNI		(1 << 0)	/* Line Interrupt */
+#define		AT91_LCDC_LSTLNI	(1 << 1)	/* Last Line Interrupt */
+#define		AT91_LCDC_EOFI		(1 << 2)	/* DMA End Of Frame Interrupt */
+#define		AT91_LCDC_UFLWI		(1 << 4)	/* FIFO Underflow Interrupt */
+#define		AT91_LCDC_OWRI		(1 << 5)	/* FIFO Overwrite Interrupt */
+#define		AT91_LCDC_MERI		(1 << 6)	/* DMA Memory Error Interrupt */
+
+#define AT91_LCDC_LUT_(n)	(0x0c00 + ((n)*4))	/* Palette Entry 0..255 */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_mci.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_mci.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_mci.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,106 @@
+/*
+ * include/asm-arm/arch-at91/at91_mci.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * MultiMedia Card Interface (MCI) registers.
+ * Based on AT91RM9200 datasheet revision F.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_MCI_H
+#define AT91_MCI_H
+
+#define AT91_MCI_CR		0x00		/* Control Register */
+#define		AT91_MCI_MCIEN		(1 <<  0)	/* Multi-Media Interface Enable */
+#define		AT91_MCI_MCIDIS		(1 <<  1)	/* Multi-Media Interface Disable */
+#define		AT91_MCI_PWSEN		(1 <<  2)	/* Power Save Mode Enable */
+#define		AT91_MCI_PWSDIS		(1 <<  3)	/* Power Save Mode Disable */
+#define		AT91_MCI_SWRST		(1 <<  7)	/* Software Reset */
+
+#define AT91_MCI_MR		0x04		/* Mode Register */
+#define		AT91_MCI_CLKDIV		(0xff  <<  0)	/* Clock Divider */
+#define		AT91_MCI_PWSDIV		(7     <<  8)	/* Power Saving Divider */
+#define		AT91_MCI_PDCPADV	(1     << 14)	/* PDC Padding Value */
+#define		AT91_MCI_PDCMODE	(1     << 15)	/* PDC-orientated Mode */
+#define		AT91_MCI_BLKLEN		(0xfff << 18)	/* Data Block Length */
+
+#define AT91_MCI_DTOR		0x08		/* Data Timeout Register */
+#define		AT91_MCI_DTOCYC		(0xf << 0)	/* Data Timeout Cycle Number */
+#define		AT91_MCI_DTOMUL		(7   << 4)	/* Data Timeout Multiplier */
+#define		AT91_MCI_DTOMUL_1		(0 <<  4)
+#define		AT91_MCI_DTOMUL_16		(1 <<  4)
+#define		AT91_MCI_DTOMUL_128		(2 <<  4)
+#define		AT91_MCI_DTOMUL_256		(3 <<  4)
+#define		AT91_MCI_DTOMUL_1K		(4 <<  4)
+#define		AT91_MCI_DTOMUL_4K		(5 <<  4)
+#define		AT91_MCI_DTOMUL_64K		(6 <<  4)
+#define		AT91_MCI_DTOMUL_1M		(7 <<  4)
+
+#define AT91_MCI_SDCR		0x0c		/* SD Card Register */
+#define		AT91_MCI_SDCSEL		(3 << 0)	/* SD Card Selector */
+#define		AT91_MCI_SDCBUS		(1 << 7)	/* 1-bit or 4-bit bus */
+
+#define AT91_MCI_ARGR		0x10		/* Argument Register */
+
+#define AT91_MCI_CMDR		0x14		/* Command Register */
+#define		AT91_MCI_CMDNB		(0x3f << 0)	/* Command Number */
+#define		AT91_MCI_RSPTYP		(3    << 6)	/* Response Type */
+#define			AT91_MCI_RSPTYP_NONE	(0 <<  6)
+#define			AT91_MCI_RSPTYP_48	(1 <<  6)
+#define			AT91_MCI_RSPTYP_136	(2 <<  6)
+#define		AT91_MCI_SPCMD		(7    << 8)	/* Special Command */
+#define			AT91_MCI_SPCMD_NONE	(0 <<  8)
+#define			AT91_MCI_SPCMD_INIT	(1 <<  8)
+#define			AT91_MCI_SPCMD_SYNC	(2 <<  8)
+#define			AT91_MCI_SPCMD_ICMD	(4 <<  8)
+#define			AT91_MCI_SPCMD_IRESP	(5 <<  8)
+#define		AT91_MCI_OPDCMD		(1 << 11)	/* Open Drain Command */
+#define		AT91_MCI_MAXLAT		(1 << 12)	/* Max Latency for Command to Response */
+#define		AT91_MCI_TRCMD		(3 << 16)	/* Transfer Command */
+#define			AT91_MCI_TRCMD_NONE	(0 << 16)
+#define			AT91_MCI_TRCMD_START	(1 << 16)
+#define			AT91_MCI_TRCMD_STOP	(2 << 16)
+#define		AT91_MCI_TRDIR		(1 << 18)	/* Transfer Direction */
+#define		AT91_MCI_TRTYP		(3 << 19)	/* Transfer Type */
+#define			AT91_MCI_TRTYP_BLOCK	(0 << 19)
+#define			AT91_MCI_TRTYP_MULTIPLE	(1 << 19)
+#define			AT91_MCI_TRTYP_STREAM	(2 << 19)
+
+#define AT91_MCI_RSPR(n)	(0x20 + ((n) * 4))	/* Response Registers 0-3 */
+#define AT91_MCR_RDR		0x30		/* Receive Data Register */
+#define AT91_MCR_TDR		0x34		/* Transmit Data Register */
+
+#define AT91_MCI_SR		0x40		/* Status Register */
+#define		AT91_MCI_CMDRDY		(1 <<  0)	/* Command Ready */
+#define		AT91_MCI_RXRDY		(1 <<  1)	/* Receiver Ready */
+#define		AT91_MCI_TXRDY		(1 <<  2)	/* Transmit Ready */
+#define		AT91_MCI_BLKE		(1 <<  3)	/* Data Block Ended */
+#define		AT91_MCI_DTIP		(1 <<  4)	/* Data Transfer in Progress */
+#define		AT91_MCI_NOTBUSY	(1 <<  5)	/* Data Not Busy */
+#define		AT91_MCI_ENDRX		(1 <<  6)	/* End of RX Buffer */
+#define		AT91_MCI_ENDTX		(1 <<  7)	/* End fo TX Buffer */
+#define		AT91_MCI_SDIOIRQA	(1 <<  8)	/* SDIO Interrupt for Slot A */
+#define		At91_MCI_SDIOIRQB	(1 <<  9)	/* SDIO Interrupt for Slot B [AT91RM9200 only] */
+#define		AT91_MCI_RXBUFF		(1 << 14)	/* RX Buffer Full */
+#define		AT91_MCI_TXBUFE		(1 << 15)	/* TX Buffer Empty */
+#define		AT91_MCI_RINDE		(1 << 16)	/* Response Index Error */
+#define		AT91_MCI_RDIRE		(1 << 17)	/* Response Direction Error */
+#define		AT91_MCI_RCRCE		(1 << 18)	/* Response CRC Error */
+#define		AT91_MCI_RENDE		(1 << 19)	/* Response End Bit Error */
+#define		AT91_MCI_RTOE		(1 << 20)	/* Reponse Time-out Error */
+#define		AT91_MCI_DCRCE		(1 << 21)	/* Data CRC Error */
+#define		AT91_MCI_DTOE		(1 << 22)	/* Data Time-out Error */
+#define		AT91_MCI_OVRE		(1 << 30)	/* Overrun */
+#define		AT91_MCI_UNRE		(1 << 31)	/* Underrun */
+
+#define AT91_MCI_IER		0x44		/* Interrupt Enable Register */
+#define AT91_MCI_IDR		0x48		/* Interrupt Disable Register */
+#define AT91_MCI_IMR		0x4c		/* Interrupt Mask Register */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_pio.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_pio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_pio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ * include/asm-arm/arch-at91/at91_pio.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Parallel I/O Controller (PIO) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_PIO_H
+#define AT91_PIO_H
+
+#define PIO_PER		0x00	/* Enable Register */
+#define PIO_PDR		0x04	/* Disable Register */
+#define PIO_PSR		0x08	/* Status Register */
+#define PIO_OER		0x10	/* Output Enable Register */
+#define PIO_ODR		0x14	/* Output Disable Register */
+#define PIO_OSR		0x18	/* Output Status Register */
+#define PIO_IFER	0x20	/* Glitch Input Filter Enable */
+#define PIO_IFDR	0x24	/* Glitch Input Filter Disable */
+#define PIO_IFSR	0x28	/* Glitch Input Filter Status */
+#define PIO_SODR	0x30	/* Set Output Data Register */
+#define PIO_CODR	0x34	/* Clear Output Data Register */
+#define PIO_ODSR	0x38	/* Output Data Status Register */
+#define PIO_PDSR	0x3c	/* Pin Data Status Register */
+#define PIO_IER		0x40	/* Interrupt Enable Register */
+#define PIO_IDR		0x44	/* Interrupt Disable Register */
+#define PIO_IMR		0x48	/* Interrupt Mask Register */
+#define PIO_ISR		0x4c	/* Interrupt Status Register */
+#define PIO_MDER	0x50	/* Multi-driver Enable Register */
+#define PIO_MDDR	0x54	/* Multi-driver Disable Register */
+#define PIO_MDSR	0x58	/* Multi-driver Status Register */
+#define PIO_PUDR	0x60	/* Pull-up Disable Register */
+#define PIO_PUER	0x64	/* Pull-up Enable Register */
+#define PIO_PUSR	0x68	/* Pull-up Status Register */
+#define PIO_ASR		0x70	/* Peripheral A Select Register */
+#define PIO_BSR		0x74	/* Peripheral B Select Register */
+#define PIO_ABSR	0x78	/* AB Status Register */
+#define PIO_OWER	0xa0	/* Output Write Enable Register */
+#define PIO_OWDR	0xa4	/* Output Write Disable Register */
+#define PIO_OWSR	0xa8	/* Output Write Status Register */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_pit.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_pit.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_pit.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/*
+ * include/asm-arm/arch-at91/at91_pit.h
+ *
+ * Periodic Interval Timer (PIT) - System peripherals regsters.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_PIT_H
+#define AT91_PIT_H
+
+#define AT91_PIT_MR		(AT91_PIT + 0x00)	/* Mode Register */
+#define		AT91_PIT_PITIEN		(1 << 25)		/* Timer Interrupt Enable */
+#define		AT91_PIT_PITEN		(1 << 24)		/* Timer Enabled */
+#define		AT91_PIT_PIV		(0xfffff)		/* Periodic Interval Value */
+
+#define AT91_PIT_SR		(AT91_PIT + 0x04)	/* Status Register */
+#define		AT91_PIT_PITS		(1 << 0)		/* Timer Status */
+
+#define AT91_PIT_PIVR		(AT91_PIT + 0x08)	/* Periodic Interval Value Register */
+#define AT91_PIT_PIIR		(AT91_PIT + 0x0c)	/* Periodic Interval Image Register */
+#define		AT91_PIT_PICNT		(0xfff << 20)		/* Interval Counter */
+#define		AT91_PIT_CPIV		(0xfffff)		/* Inverval Value */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_pmc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_pmc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_pmc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,92 @@
+/*
+ * include/asm-arm/arch-at91/at91_pmc.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Power Management Controller (PMC) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_PMC_H
+#define AT91_PMC_H
+
+#define	AT91_PMC_SCER		(AT91_PMC + 0x00)	/* System Clock Enable Register */
+#define	AT91_PMC_SCDR		(AT91_PMC + 0x04)	/* System Clock Disable Register */
+
+#define	AT91_PMC_SCSR		(AT91_PMC + 0x08)	/* System Clock Status Register */
+#define		AT91_PMC_PCK		(1 <<  0)		/* Processor Clock */
+#define		AT91RM9200_PMC_UDP	(1 <<  1)		/* USB Devcice Port Clock [AT91RM9200 only] */
+#define		AT91RM9200_PMC_MCKUDP	(1 <<  2)		/* USB Device Port Master Clock Automatic Disable on Suspend [AT91RM9200 only] */
+#define		AT91RM9200_PMC_UHP	(1 <<  4)		/* USB Host Port Clock [AT91RM9200 only] */
+#define		AT91SAM926x_PMC_UHP	(1 <<  6)		/* USB Host Port Clock [AT91SAM926x only] */
+#define		AT91SAM926x_PMC_UDP	(1 <<  7)		/* USB Devcice Port Clock [AT91SAM926x only] */
+#define		AT91_PMC_PCK0		(1 <<  8)		/* Programmable Clock 0 */
+#define		AT91_PMC_PCK1		(1 <<  9)		/* Programmable Clock 1 */
+#define		AT91_PMC_PCK2		(1 << 10)		/* Programmable Clock 2 */
+#define		AT91_PMC_PCK3		(1 << 11)		/* Programmable Clock 3 */
+#define		AT91_PMC_HCK0		(1 << 16)		/* AHB Clock (USB host) [AT91SAM9261 only] */
+#define		AT91_PMC_HCK1		(1 << 17)		/* AHB Clock (LCD) [AT91SAM9261 only] */
+
+#define	AT91_PMC_PCER		(AT91_PMC + 0x10)	/* Peripheral Clock Enable Register */
+#define	AT91_PMC_PCDR		(AT91_PMC + 0x14)	/* Peripheral Clock Disable Register */
+#define	AT91_PMC_PCSR		(AT91_PMC + 0x18)	/* Peripheral Clock Status Register */
+
+#define	AT91_CKGR_MOR		(AT91_PMC + 0x20)	/* Main Oscillator Register */
+#define		AT91_PMC_MOSCEN		(1    << 0)		/* Main Oscillator Enable */
+#define		AT91_PMC_OSCBYPASS	(1    << 1)		/* Oscillator Bypass [AT91SAM926x only] */
+#define		AT91_PMC_OSCOUNT	(0xff << 8)		/* Main Oscillator Start-up Time */
+
+#define	AT91_CKGR_MCFR		(AT91_PMC + 0x24)	/* Main Clock Frequency Register */
+#define		AT91_PMC_MAINF		(0xffff <<  0)		/* Main Clock Frequency */
+#define		AT91_PMC_MAINRDY	(1	<< 16)		/* Main Clock Ready */
+
+#define	AT91_CKGR_PLLAR		(AT91_PMC + 0x28)	/* PLL A Register */
+#define	AT91_CKGR_PLLBR		(AT91_PMC + 0x2c)	/* PLL B Register */
+#define		AT91_PMC_DIV		(0xff  <<  0)		/* Divider */
+#define		AT91_PMC_PLLCOUNT	(0x3f  <<  8)		/* PLL Counter */
+#define		AT91_PMC_OUT		(3     << 14)		/* PLL Clock Frequency Range */
+#define		AT91_PMC_MUL		(0x7ff << 16)		/* PLL Multiplier */
+#define		AT91_PMC_USB96M		(1     << 28)		/* Divider by 2 Enable (PLLB only) */
+
+#define	AT91_PMC_MCKR		(AT91_PMC + 0x30)	/* Master Clock Register */
+#define		AT91_PMC_CSS		(3 <<  0)		/* Master Clock Selection */
+#define			AT91_PMC_CSS_SLOW		(0 << 0)
+#define			AT91_PMC_CSS_MAIN		(1 << 0)
+#define			AT91_PMC_CSS_PLLA		(2 << 0)
+#define			AT91_PMC_CSS_PLLB		(3 << 0)
+#define		AT91_PMC_PRES		(7 <<  2)		/* Master Clock Prescaler */
+#define			AT91_PMC_PRES_1			(0 << 2)
+#define			AT91_PMC_PRES_2			(1 << 2)
+#define			AT91_PMC_PRES_4			(2 << 2)
+#define			AT91_PMC_PRES_8			(3 << 2)
+#define			AT91_PMC_PRES_16		(4 << 2)
+#define			AT91_PMC_PRES_32		(5 << 2)
+#define			AT91_PMC_PRES_64		(6 << 2)
+#define		AT91_PMC_MDIV		(3 <<  8)		/* Master Clock Division */
+#define			AT91_PMC_MDIV_1			(0 << 8)
+#define			AT91_PMC_MDIV_2			(1 << 8)
+#define			AT91_PMC_MDIV_3			(2 << 8)
+#define			AT91_PMC_MDIV_4			(3 << 8)
+
+#define	AT91_PMC_PCKR(n)	(AT91_PMC + 0x40 + ((n) * 4))	/* Programmable Clock 0-3 Registers */
+
+#define	AT91_PMC_IER		(AT91_PMC + 0x60)	/* Interrupt Enable Register */
+#define	AT91_PMC_IDR		(AT91_PMC + 0x64)	/* Interrupt Disable Register */
+#define	AT91_PMC_SR		(AT91_PMC + 0x68)	/* Status Register */
+#define		AT91_PMC_MOSCS		(1 <<  0)		/* MOSCS Flag */
+#define		AT91_PMC_LOCKA		(1 <<  1)		/* PLLA Lock */
+#define		AT91_PMC_LOCKB		(1 <<  2)		/* PLLB Lock */
+#define		AT91_PMC_MCKRDY		(1 <<  3)		/* Master Clock */
+#define		AT91_PMC_PCK0RDY	(1 <<  8)		/* Programmable Clock 0 */
+#define		AT91_PMC_PCK1RDY	(1 <<  9)		/* Programmable Clock 1 */
+#define		AT91_PMC_PCK2RDY	(1 << 10)		/* Programmable Clock 2 */
+#define		AT91_PMC_PCK3RDY	(1 << 11)		/* Programmable Clock 3 */
+#define	AT91_PMC_IMR		(AT91_PMC + 0x6c)	/* Interrupt Mask Register */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_rstc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_rstc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_rstc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-at91/at91_rstc.h
+ *
+ * Reset Controller (RSTC) - System peripherals regsters.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_RSTC_H
+#define AT91_RSTC_H
+
+#define AT91_RSTC_CR		(AT91_RSTC + 0x00)	/* Reset Controller Control Register */
+#define		AT91_RSTC_PROCRST	(1 << 0)		/* Processor Reset */
+#define		AT91_RSTC_PERRST	(1 << 2)		/* Peripheral Reset */
+#define		AT91_RSTC_EXTRST	(1 << 3)		/* External Reset */
+#define		AT91_RSTC_KEY		(0xa5 << 24)		/* KEY Password */
+
+#define AT91_RSTC_SR		(AT91_RSTC + 0x04)	/* Reset Controller Status Register */
+#define		AT91_RSTC_URSTS		(1 << 0)		/* User Reset Status */
+#define		AT91_RSTC_RSTTYP	(7 << 8)		/* Reset Type */
+#define			AT91_RSTC_RSTTYP_GENERAL	(0 << 8)
+#define			AT91_RSTC_RSTTYP_WAKEUP		(1 << 8)
+#define			AT91_RSTC_RSTTYP_WATCHDOG	(2 << 8)
+#define			AT91_RSTC_RSTTYP_SOFTWARE	(3 << 8)
+#define			AT91_RSTC_RSTTYP_USER	(4 << 8)
+#define		AT91_RSTC_NRSTL		(1 << 16)		/* NRST Pin Level */
+#define		AT91_RSTC_SRCMP		(1 << 17)		/* Software Reset Command in Progress */
+
+#define AT91_RSTC_MR		(AT91_RSTC + 0x08)	/* Reset Controller Mode Register */
+#define		AT91_RSTC_URSTEN	(1 << 0)		/* User Reset Enable */
+#define		AT91_RSTC_URSTIEN	(1 << 4)		/* User Reset Interrupt Enable */
+#define		AT91_RSTC_ERSTL		(0xf << 8)		/* External Reset Length */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_rtc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_rtc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_rtc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,75 @@
+/*
+ * include/asm-arm/arch-at91/at91_rtc.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Real Time Clock (RTC) - System peripheral registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_RTC_H
+#define AT91_RTC_H
+
+#define	AT91_RTC_CR		(AT91_RTC + 0x00)	/* Control Register */
+#define		AT91_RTC_UPDTIM		(1 <<  0)		/* Update Request Time Register */
+#define		AT91_RTC_UPDCAL		(1 <<  1)		/* Update Request Calendar Register */
+#define		AT91_RTC_TIMEVSEL	(3 <<  8)		/* Time Event Selection */
+#define			AT91_RTC_TIMEVSEL_MINUTE	(0 << 8)
+#define			AT91_RTC_TIMEVSEL_HOUR		(1 << 8)
+#define			AT91_RTC_TIMEVSEL_DAY24		(2 << 8)
+#define			AT91_RTC_TIMEVSEL_DAY12		(3 << 8)
+#define		AT91_RTC_CALEVSEL	(3 << 16)		/* Calendar Event Selection */
+#define			AT91_RTC_CALEVSEL_WEEK		(0 << 16)
+#define			AT91_RTC_CALEVSEL_MONTH		(1 << 16)
+#define			AT91_RTC_CALEVSEL_YEAR		(2 << 16)
+
+#define	AT91_RTC_MR		(AT91_RTC + 0x04)	/* Mode Register */
+#define			AT91_RTC_HRMOD		(1 <<  0)		/* 12/24 Hour Mode */
+
+#define	AT91_RTC_TIMR		(AT91_RTC + 0x08)	/* Time Register */
+#define		AT91_RTC_SEC		(0x7f <<  0)		/* Current Second */
+#define		AT91_RTC_MIN		(0x7f <<  8)		/* Current Minute */
+#define		AT91_RTC_HOUR		(0x3f << 16)		/* Current Hour */
+#define		AT91_RTC_AMPM		(1    << 22)		/* Ante Meridiem Post Meridiem Indicator */
+
+#define	AT91_RTC_CALR		(AT91_RTC + 0x0c)	/* Calendar Register */
+#define		AT91_RTC_CENT		(0x7f <<  0)		/* Current Century */
+#define		AT91_RTC_YEAR		(0xff <<  8)		/* Current Year */
+#define		AT91_RTC_MONTH		(0x1f << 16)		/* Current Month */
+#define		AT91_RTC_DAY		(7    << 21)		/* Current Day */
+#define		AT91_RTC_DATE		(0x3f << 24)		/* Current Date */
+
+#define	AT91_RTC_TIMALR		(AT91_RTC + 0x10)	/* Time Alarm Register */
+#define		AT91_RTC_SECEN		(1 <<  7)		/* Second Alarm Enable */
+#define		AT91_RTC_MINEN		(1 << 15)		/* Minute Alarm Enable */
+#define		AT91_RTC_HOUREN		(1 << 23)		/* Hour Alarm Enable */
+
+#define	AT91_RTC_CALALR		(AT91_RTC + 0x14)	/* Calendar Alarm Register */
+#define		AT91_RTC_MTHEN		(1 << 23)		/* Month Alarm Enable */
+#define		AT91_RTC_DATEEN		(1 << 31)		/* Date Alarm Enable */
+
+#define	AT91_RTC_SR		(AT91_RTC + 0x18)	/* Status Register */
+#define		AT91_RTC_ACKUPD		(1 <<  0)		/* Acknowledge for Update */
+#define		AT91_RTC_ALARM		(1 <<  1)		/* Alarm Flag */
+#define		AT91_RTC_SECEV		(1 <<  2)		/* Second Event */
+#define		AT91_RTC_TIMEV		(1 <<  3)		/* Time Event */
+#define		AT91_RTC_CALEV		(1 <<  4)		/* Calendar Event */
+
+#define	AT91_RTC_SCCR		(AT91_RTC + 0x1c)	/* Status Clear Command Register */
+#define	AT91_RTC_IER		(AT91_RTC + 0x20)	/* Interrupt Enable Register */
+#define	AT91_RTC_IDR		(AT91_RTC + 0x24)	/* Interrupt Disable Register */
+#define	AT91_RTC_IMR		(AT91_RTC + 0x28)	/* Interrupt Mask Register */
+
+#define	AT91_RTC_VER		(AT91_RTC + 0x2c)	/* Valid Entry Register */
+#define		AT91_RTC_NVTIM		(1 <<  0)		/* Non valid Time */
+#define		AT91_RTC_NVCAL		(1 <<  1)		/* Non valid Calendar */
+#define		AT91_RTC_NVTIMALR	(1 <<  2)		/* Non valid Time Alarm */
+#define		AT91_RTC_NVCALALR	(1 <<  3)		/* Non valid Calendar Alarm */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_rtt.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_rtt.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_rtt.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-at91/at91_rtt.h
+ *
+ * Real-time Timer (RTT) - System peripherals regsters.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_RTT_H
+#define AT91_RTT_H
+
+#define AT91_RTT_MR		(AT91_RTT + 0x00)	/* Real-time Mode Register */
+#define		AT91_RTT_RTPRES		(0xffff << 0)		/* Real-time Timer Prescaler Value */
+#define		AT91_RTT_ALMIEN		(1 << 16)		/* Alarm Interrupt Enable */
+#define		AT91_RTT_RTTINCIEN	(1 << 17)		/* Real Time Timer Increment Interrupt Enable */
+#define		AT91_RTT_RTTRST		(1 << 18)		/* Real Time Timer Restart */
+
+#define AT91_RTT_AR		(AT91_RTT + 0x04)	/* Real-time Alarm Register */
+#define		AT91_RTT_ALMV		(0xffffffff)		/* Alarm Value */
+
+#define AT91_RTT_VR		(AT91_RTT + 0x08)	/* Real-time Value Register */
+#define		AT91_RTT_CRTV		(0xffffffff)		/* Current Real-time Value */
+
+#define AT91_RTT_SR		(AT91_RTT + 0x0c)	/* Real-time Status Register */
+#define		AT91_RTT_ALMS		(1 << 0)		/* Real-time Alarm Status */
+#define		AT91_RTT_RTTINC		(1 << 1)		/* Real-time Timer Increment */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_shdwc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_shdwc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_shdwc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-at91/at91_shdwc.h
+ *
+ * Shutdown Controller (SHDWC) - System peripherals regsters.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_SHDWC_H
+#define AT91_SHDWC_H
+
+#define AT91_SHDW_CR		(AT91_SHDWC + 0x00)	/* Shut Down Control Register */
+#define		AT91_SHDW_SHDW		(1    << 0)		/* Processor Reset */
+#define		AT91_SHDW_KEY		(0xff << 24)		/* KEY Password */
+
+#define AT91_SHDW_MR		(AT91_SHDWC + 0x04)	/* Shut Down Mode Register */
+#define		AT91_SHDW_WKMODE0	(3 << 0)		/* Wake-up 0 Mode Selection */
+#define			AT91_SHDW_WKMODE0_NONE		0
+#define			AT91_SHDW_WKMODE0_HIGH		1
+#define			AT91_SHDW_WKMODE0_LOW		2
+#define			AT91_SHDW_WKMODE0_ANYLEVEL	3
+#define		AT91_SHDW_CPTWK0	(0xf << 4)		/* Counter On Wake Up 0 */
+#define		AT91_SHDW_RTTWKEN	(1   << 16)		/* Real Time Timer Wake-up Enable */
+
+#define AT91_SHDW_SR		(AT91_SHDWC + 0x08)	/* Shut Down Status Register */
+#define		AT91_SHDW_WAKEUP0	(1 <<  0)		/* Wake-up 0 Status */
+#define		AT91_SHDW_RTTWK		(1 << 16)		/* Real-time Timer Wake-up */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_spi.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_spi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_spi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,81 @@
+/*
+ * include/asm-arm/arch-at91/at91_spi.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Serial Peripheral Interface (SPI) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_SPI_H
+#define AT91_SPI_H
+
+#define AT91_SPI_CR			0x00		/* Control Register */
+#define		AT91_SPI_SPIEN		(1 <<  0)		/* SPI Enable */
+#define		AT91_SPI_SPIDIS		(1 <<  1)		/* SPI Disable */
+#define		AT91_SPI_SWRST		(1 <<  7)		/* SPI Software Reset */
+#define		AT91_SPI_LASTXFER	(1 << 24)		/* Last Transfer [SAM9261 only] */
+
+#define AT91_SPI_MR			0x04		/* Mode Register */
+#define		AT91_SPI_MSTR		(1    <<  0)		/* Master/Slave Mode */
+#define		AT91_SPI_PS		(1    <<  1)		/* Peripheral Select */
+#define			AT91_SPI_PS_FIXED	(0 << 1)
+#define			AT91_SPI_PS_VARIABLE	(1 << 1)
+#define		AT91_SPI_PCSDEC		(1    <<  2)		/* Chip Select Decode */
+#define		AT91_SPI_DIV32		(1    <<  3)		/* Clock Selection [AT91RM9200 only] */
+#define		AT91_SPI_MODFDIS	(1    <<  4)		/* Mode Fault Detection */
+#define		AT91_SPI_LLB		(1    <<  7)		/* Local Loopback Enable */
+#define		AT91_SPI_PCS		(0xf  << 16)		/* Peripheral Chip Select */
+#define		AT91_SPI_DLYBCS		(0xff << 24)		/* Delay Between Chip Selects */
+
+#define AT91_SPI_RDR		0x08			/* Receive Data Register */
+#define		AT91_SPI_RD		(0xffff <<  0)		/* Receive Data */
+#define		AT91_SPI_PCS		(0xf	<< 16)		/* Peripheral Chip Select */
+
+#define AT91_SPI_TDR		0x0c			/* Transmit Data Register */
+#define		AT91_SPI_TD		(0xffff <<  0)		/* Transmit Data */
+#define		AT91_SPI_PCS		(0xf	<< 16)		/* Peripheral Chip Select */
+#define		AT91_SPI_LASTXFER	(1	<< 24)		/* Last Transfer [SAM9261 only] */
+
+#define AT91_SPI_SR		0x10			/* Status Register */
+#define		AT91_SPI_RDRF		(1 <<  0)		/* Receive Data Register Full */
+#define		AT91_SPI_TDRE		(1 <<  1)		/* Transmit Data Register Full */
+#define		AT91_SPI_MODF		(1 <<  2)		/* Mode Fault Error */
+#define		AT91_SPI_OVRES		(1 <<  3)		/* Overrun Error Status */
+#define		AT91_SPI_ENDRX		(1 <<  4)		/* End of RX buffer */
+#define		AT91_SPI_ENDTX		(1 <<  5)		/* End of TX buffer */
+#define		AT91_SPI_RXBUFF		(1 <<  6)		/* RX Buffer Full */
+#define		AT91_SPI_TXBUFE		(1 <<  7)		/* TX Buffer Empty */
+#define		AT91_SPI_NSSR		(1 <<  8)		/* NSS Rising [SAM9261 only] */
+#define		AT91_SPI_TXEMPTY	(1 <<  9)		/* Transmission Register Empty [SAM9261 only] */
+#define		AT91_SPI_SPIENS		(1 << 16)		/* SPI Enable Status */
+
+#define AT91_SPI_IER		0x14			/* Interrupt Enable Register */
+#define AT91_SPI_IDR		0x18			/* Interrupt Disable Register */
+#define AT91_SPI_IMR		0x1c			/* Interrupt Mask Register */
+
+#define AT91_SPI_CSR(n)		(0x30 + ((n) * 4))	/* Chip Select Registers 0-3 */
+#define		AT91_SPI_CPOL		(1    <<  0)		/* Clock Polarity */
+#define		AT91_SPI_NCPHA		(1    <<  1)		/* Clock Phase */
+#define		AT91_SPI_CSAAT		(1    <<  3)		/* Chip Select Active After Transfer [SAM9261 only] */
+#define		AT91_SPI_BITS		(0xf  <<  4)		/* Bits Per Transfer */
+#define			AT91_SPI_BITS_8		(0 << 4)
+#define			AT91_SPI_BITS_9		(1 << 4)
+#define			AT91_SPI_BITS_10	(2 << 4)
+#define			AT91_SPI_BITS_11	(3 << 4)
+#define			AT91_SPI_BITS_12	(4 << 4)
+#define			AT91_SPI_BITS_13	(5 << 4)
+#define			AT91_SPI_BITS_14	(6 << 4)
+#define			AT91_SPI_BITS_15	(7 << 4)
+#define			AT91_SPI_BITS_16	(8 << 4)
+#define		AT91_SPI_SCBR		(0xff <<  8)		/* Serial Clock Baud Rate */
+#define		AT91_SPI_DLYBS		(0xff << 16)		/* Delay before SPCK */
+#define		AT91_SPI_DLYBCT		(0xff << 24)		/* Delay between Consecutive Transfers */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_ssc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_ssc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_ssc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,106 @@
+/*
+ * include/asm-arm/arch-at91/at91_ssc.h
+ *
+ * Copyright (C) SAN People
+ *
+ * Serial Synchronous Controller (SSC) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_SSC_H
+#define AT91_SSC_H
+
+#define AT91_SSC_CR		0x00	/* Control Register */
+#define		AT91_SSC_RXEN		(1 <<  0)	/* Receive Enable */
+#define		AT91_SSC_RXDIS		(1 <<  1)	/* Receive Disable */
+#define		AT91_SSC_TXEN		(1 <<  8)	/* Transmit Enable */
+#define		AT91_SSC_TXDIS		(1 <<  9)	/* Transmit Disable */
+#define		AT91_SSC_SWRST		(1 << 15)	/* Software Reset */
+
+#define AT91_SSC_CMR		0x04	/* Clock Mode Register */
+#define		AT91_SSC_CMR_DIV	(0xfff << 0)	/* Clock Divider */
+
+#define AT91_SSC_RCMR		0x10	/* Receive Clock Mode Register */
+#define		AT91_SSC_CKS		(3    <<  0)	/* Clock Selection */
+#define			AT91_SSC_CKS_DIV		(0 << 0)
+#define			AT91_SSC_CKS_CLOCK		(1 << 0)
+#define			AT91_SSC_CKS_PIN		(2 << 0)
+#define		AT91_SSC_CKO		(7    <<  2)	/* Clock Output Mode Selection */
+#define			AT91_SSC_CKO_NONE		(0 << 2)
+#define			AT91_SSC_CKO_CONTINUOUS		(1 << 2)
+#define		AT91_SSC_CKI		(1    <<  5)	/* Clock Inversion */
+#define			AT91_SSC_CKI_FALLING		(0 << 5)
+#define			AT91_SSC_CK_RISING		(1 << 5)
+#define		AT91_SSC_CKG		(1    <<  6)	/* Receive Clock Gating Selection [AT91SAM9261 only] */
+#define			AT91_SSC_CKG_NONE		(0 << 6)
+#define			AT91_SSC_CKG_RFLOW		(1 << 6)
+#define			AT91_SSC_CKG_RFHIGH		(2 << 6)
+#define		AT91_SSC_START		(0xf  <<  8)	/* Start Selection */
+#define			AT91_SSC_START_CONTINUOUS	(0 << 8)
+#define			AT91_SSC_START_TX_RX		(1 << 8)
+#define			AT91_SSC_START_LOW_RF		(2 << 8)
+#define			AT91_SSC_START_HIGH_RF		(3 << 8)
+#define			AT91_SSC_START_FALLING_RF	(4 << 8)
+#define			AT91_SSC_START_RISING_RF	(5 << 8)
+#define			AT91_SSC_START_LEVEL_RF		(6 << 8)
+#define			AT91_SSC_START_EDGE_RF		(7 << 8)
+#define		AT91_SSC_STOP		(1    << 12)	/* Receive Stop Selection [AT91SAM9261 only] */
+#define		AT91_SSC_STTDLY		(0xff << 16)	/* Start Delay */
+#define		AT91_SSC_PERIOD		(0xff << 24)	/* Period Divider Selection */
+
+#define AT91_SSC_RFMR		0x14	/* Receive Frame Mode Register */
+#define		AT91_SSC_DATALEN	(0x1f <<  0)	/* Data Length */
+#define		AT91_SSC_LOOP		(1    <<  5)	/* Loop Mode */
+#define		AT91_SSC_MSBF		(1    <<  7)	/* Most Significant Bit First */
+#define		AT91_SSC_DATNB		(0xf  <<  8)	/* Data Number per Frame */
+#define		AT91_SSC_FSLEN		(0xf  << 16)	/* Frame Sync Length */
+#define		AT91_SSC_FSOS		(7    << 20)	/* Frame Sync Output Selection */
+#define			AT91_SSC_FSOS_NONE		(0 << 20)
+#define			AT91_SSC_FSOS_NEGATIVE		(1 << 20)
+#define			AT91_SSC_FSOS_POSITIVE		(2 << 20)
+#define			AT91_SSC_FSOS_LOW		(3 << 20)
+#define			AT91_SSC_FSOS_HIGH		(4 << 20)
+#define			AT91_SSC_FSOS_TOGGLE		(5 << 20)
+#define		AT91_SSC_FSEDGE		(1    << 24)	/* Frame Sync Edge Detection */
+#define			AT91_SSC_FSEDGE_POSITIVE	(0 << 24)
+#define			AT91_SSC_FSEDGE_NEGATIVE	(1 << 24)
+
+#define AT91_SSC_TCMR		0x18	/* Transmit Clock Mode Register */
+#define AT91_SSC_TFMR		0x1c	/* Transmit Fram Mode Register */
+#define		AT91_SSC_DATDEF		(1 <<  5)	/* Data Default Value */
+#define		AT91_SSC_FSDEN		(1 << 23)	/* Frame Sync Data Enable */
+
+#define AT91_SSC_RHR		0x20	/* Receive Holding Register */
+#define AT91_SSC_THR		0x24	/* Transmit Holding Register */
+#define AT91_SSC_RSHR		0x30	/* Receive Sync Holding Register */
+#define AT91_SSC_TSHR		0x34	/* Transmit Sync Holding Register */
+
+#define AT91_SSC_RC0R		0x38	/* Receive Compare 0 Register [AT91SAM9261 only] */
+#define AT91_SSC_RC1R		0x3c	/* Receive Compare 1 Register [AT91SAM9261 only] */
+
+#define AT91_SSC_SR		0x40	/* Status Register */
+#define		AT91_SSC_TXRDY		(1 <<  0)	/* Transmit Ready */
+#define		AT91_SSC_TXEMPTY	(1 <<  1)	/* Transmit Empty */
+#define		AT91_SSC_ENDTX		(1 <<  2)	/* End of Transmission */
+#define		AT91_SSC_TXBUFE		(1 <<  3)	/* Transmit Buffer Empty */
+#define		AT91_SSC_RXRDY		(1 <<  4)	/* Receive Ready */
+#define		AT91_SSC_OVRUN		(1 <<  5)	/* Receive Overrun */
+#define		AT91_SSC_ENDRX		(1 <<  6)	/* End of Reception */
+#define		AT91_SSC_RXBUFF		(1 <<  7)	/* Receive Buffer Full */
+#define		AT91_SSC_CP0		(1 <<  8)	/* Compare 0 [AT91SAM9261 only] */
+#define		AT91_SSC_CP1		(1 <<  9)	/* Compare 1 [AT91SAM9261 only] */
+#define		AT91_SSC_TXSYN		(1 << 10)	/* Transmit Sync */
+#define		AT91_SSC_RXSYN		(1 << 11)	/* Receive Sync */
+#define		AT91_SSC_TXENA		(1 << 16)	/* Transmit Enable */
+#define		AT91_SSC_RXENA		(1 << 17)	/* Receive Enable */
+
+#define AT91_SSC_IER		0x44	/* Interrupt Enable Register */
+#define AT91_SSC_IDR		0x48	/* Interrupt Disable Register */
+#define AT91_SSC_IMR		0x4c	/* Interrupt Mask Register */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_st.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_st.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_st.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ * include/asm-arm/arch-at91/at91_st.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * System Timer (ST) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_ST_H
+#define AT91_ST_H
+
+#define	AT91_ST_CR		(AT91_ST + 0x00)	/* Control Register */
+#define 	AT91_ST_WDRST		(1 << 0)		/* Watchdog Timer Restart */
+
+#define	AT91_ST_PIMR		(AT91_ST + 0x04)	/* Period Interval Mode Register */
+#define		AT91_ST_PIV		(0xffff <<  0)		/* Period Interval Value */
+
+#define	AT91_ST_WDMR		(AT91_ST + 0x08)	/* Watchdog Mode Register */
+#define		AT91_ST_WDV		(0xffff <<  0)		/* Watchdog Counter Value */
+#define		AT91_ST_RSTEN		(1	<< 16)		/* Reset Enable */
+#define		AT91_ST_EXTEN		(1	<< 17)		/* External Signal Assertion Enable */
+
+#define	AT91_ST_RTMR		(AT91_ST + 0x0c)	/* Real-time Mode Register */
+#define		AT91_ST_RTPRES		(0xffff <<  0)		/* Real-time Prescalar Value */
+
+#define	AT91_ST_SR		(AT91_ST + 0x10)	/* Status Register */
+#define		AT91_ST_PITS		(1 << 0)		/* Period Interval Timer Status */
+#define		AT91_ST_WDOVF		(1 << 1) 		/* Watchdog Overflow */
+#define		AT91_ST_RTTINC		(1 << 2) 		/* Real-time Timer Increment */
+#define		AT91_ST_ALMS		(1 << 3) 		/* Alarm Status */
+
+#define	AT91_ST_IER		(AT91_ST + 0x14)	/* Interrupt Enable Register */
+#define	AT91_ST_IDR		(AT91_ST + 0x18)	/* Interrupt Disable Register */
+#define	AT91_ST_IMR		(AT91_ST + 0x1c)	/* Interrupt Mask Register */
+
+#define	AT91_ST_RTAR		(AT91_ST + 0x20)	/* Real-time Alarm Register */
+#define		AT91_ST_ALMV		(0xfffff << 0)		/* Alarm Value */
+
+#define	AT91_ST_CRTR		(AT91_ST + 0x24)	/* Current Real-time Register */
+#define		AT91_ST_CRTV		(0xfffff << 0)		/* Current Real-Time Value */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_tc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_tc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_tc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,146 @@
+/*
+ * include/asm-arm/arch-at91/at91_tc.h
+ *
+ * Copyright (C) SAN People
+ *
+ * Timer/Counter Unit (TC) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_TC_H
+#define AT91_TC_H
+
+#define AT91_TC_BCR		0xc0		/* TC Block Control Register */
+#define		AT91_TC_SYNC		(1 << 0)	/* Synchro Command */
+
+#define AT91_TC_BMR		0xc4		/* TC Block Mode Register */
+#define		AT91_TC_TC0XC0S		(3 << 0)	/* External Clock Signal 0 Selection */
+#define			AT91_TC_TC0XC0S_TCLK0		(0 << 0)
+#define			AT91_TC_TC0XC0S_NONE		(1 << 0)
+#define			AT91_TC_TC0XC0S_TIOA1		(2 << 0)
+#define			AT91_TC_TC0XC0S_TIOA2		(3 << 0)
+#define		AT91_TC_TC1XC1S		(3 << 2)	/* External Clock Signal 1 Selection */
+#define			AT91_TC_TC1XC1S_TCLK1		(0 << 2)
+#define			AT91_TC_TC1XC1S_NONE		(1 << 2)
+#define			AT91_TC_TC1XC1S_TIOA0		(2 << 2)
+#define			AT91_TC_TC1XC1S_TIOA2		(3 << 2)
+#define		AT91_TC_TC2XC2S		(3 << 4)	/* External Clock Signal 2 Selection */
+#define			AT91_TC_TC2XC2S_TCLK2		(0 << 4)
+#define			AT91_TC_TC2XC2S_NONE		(1 << 4)
+#define			AT91_TC_TC2XC2S_TIOA0		(2 << 4)
+#define			AT91_TC_TC2XC2S_TIOA1		(3 << 4)
+
+
+#define AT91_TC_CCR		0x00		/* Channel Control Register */
+#define		AT91_TC_CLKEN		(1 << 0)	/* Counter Clock Enable Command */
+#define		AT91_TC_CLKDIS		(1 << 1)	/* Counter CLock Disable Command */
+#define		AT91_TC_SWTRG		(1 << 2)	/* Software Trigger Command */
+
+#define AT91_TC_CMR		0x04		/* Channel Mode Register */
+#define		AT91_TC_TCCLKS		(7 << 0)	/* Capture/Waveform Mode: Clock Selection */
+#define			AT91_TC_TIMER_CLOCK1		(0 << 0)
+#define			AT91_TC_TIMER_CLOCK2		(1 << 0)
+#define			AT91_TC_TIMER_CLOCK3		(2 << 0)
+#define			AT91_TC_TIMER_CLOCK4		(3 << 0)
+#define			AT91_TC_TIMER_CLOCK5		(4 << 0)
+#define			AT91_TC_XC0			(5 << 0)
+#define			AT91_TC_XC1			(6 << 0)
+#define			AT91_TC_XC2			(7 << 0)
+#define		AT91_TC_CLKI		(1 << 3)	/* Capture/Waveform Mode: Clock Invert */
+#define		AT91_TC_BURST		(3 << 4)	/* Capture/Waveform Mode: Burst Signal Selection */
+#define		AT91_TC_LDBSTOP		(1 << 6)	/* Capture Mode: Counter Clock Stopped with TB Loading */
+#define		AT91_TC_LDBDIS		(1 << 7)	/* Capture Mode: Counter Clock Disable with RB Loading */
+#define		AT91_TC_ETRGEDG		(3 << 8)	/* Capture Mode: External Trigger Edge Selection */
+#define		AT91_TC_ABETRG		(1 << 10)	/* Capture Mode: TIOA or TIOB External Trigger Selection */
+#define		AT91_TC_CPCTRG		(1 << 14)	/* Capture Mode: RC Compare Trigger Enable */
+#define		AT91_TC_WAVE		(1 << 15)	/* Capture/Waveform mode */
+#define		AT91_TC_LDRA		(3 << 16)	/* Capture Mode: RA Loading Selection */
+#define		AT91_TC_LDRB		(3 << 18)	/* Capture Mode: RB Loading Selection */
+
+#define		AT91_TC_CPCSTOP		(1 <<  6)	/* Waveform Mode: Counter Clock Stopped with RC Compare */
+#define		AT91_TC_CPCDIS		(1 <<  7)	/* Waveform Mode: Counter Clock Disable with RC Compare */
+#define		AT91_TC_EEVTEDG		(3 <<  8)	/* Waveform Mode: External Event Edge Selection */
+#define			AT91_TC_EEVTEDG_NONE		(0 << 8)
+#define			AT91_TC_EEVTEDG_RISING		(1 << 8)
+#define			AT91_TC_EEVTEDG_FALLING		(2 << 8)
+#define			AT91_TC_EEVTEDG_BOTH		(3 << 8)
+#define		AT91_TC_EEVT		(3 << 10)	/* Waveform Mode: External Event Selection */
+#define			AT91_TC_EEVT_TIOB		(0 << 10)
+#define			AT91_TC_EEVT_XC0		(1 << 10)
+#define			AT91_TC_EEVT_XC1		(2 << 10)
+#define			AT91_TC_EEVT_XC2		(3 << 10)
+#define		AT91_TC_ENETRG		(1 << 12)	/* Waveform Mode: External Event Trigger Enable */
+#define		AT91_TC_WAVESEL		(3 << 13)	/* Waveform Mode: Waveform Selection */
+#define			AT91_TC_WAVESEL_UP		(0 << 13)
+#define			AT91_TC_WAVESEL_UP_AUTO		(2 << 13)
+#define			AT91_TC_WAVESEL_UPDOWN		(1 << 13)
+#define			AT91_TC_WAVESEL_UPDOWN_AUTO	(3 << 13)
+#define		AT91_TC_ACPA		(3 << 16)	/* Waveform Mode: RA Compare Effect on TIOA */
+#define			AT91_TC_ACPA_NONE		(0 << 16)
+#define			AT91_TC_ACPA_SET		(1 << 16)
+#define			AT91_TC_ACPA_CLEAR		(2 << 16)
+#define			AT91_TC_ACPA_TOGGLE		(3 << 16)
+#define		AT91_TC_ACPC		(3 << 18)	/* Waveform Mode: RC Compre Effect on TIOA */
+#define			AT91_TC_ACPC_NONE		(0 << 18)
+#define			AT91_TC_ACPC_SET		(1 << 18)
+#define			AT91_TC_ACPC_CLEAR		(2 << 18)
+#define			AT91_TC_ACPC_TOGGLE		(3 << 18)
+#define		AT91_TC_AEEVT		(3 << 20)	/* Waveform Mode: External Event Effect on TIOA */
+#define			AT91_TC_AEEVT_NONE		(0 << 20)
+#define			AT91_TC_AEEVT_SET		(1 << 20)
+#define			AT91_TC_AEEVT_CLEAR		(2 << 20)
+#define			AT91_TC_AEEVT_TOGGLE		(3 << 20)
+#define		AT91_TC_ASWTRG		(3 << 22)	/* Waveform Mode: Software Trigger Effect on TIOA */
+#define			AT91_TC_ASWTRG_NONE		(0 << 22)
+#define			AT91_TC_ASWTRG_SET		(1 << 22)
+#define			AT91_TC_ASWTRG_CLEAR		(2 << 22)
+#define			AT91_TC_ASWTRG_TOGGLE		(3 << 22)
+#define		AT91_TC_BCPB		(3 << 24)	/* Waveform Mode: RB Compare Effect on TIOB */
+#define			AT91_TC_BCPB_NONE		(0 << 24)
+#define			AT91_TC_BCPB_SET		(1 << 24)
+#define			AT91_TC_BCPB_CLEAR		(2 << 24)
+#define			AT91_TC_BCPB_TOGGLE		(3 << 24)
+#define		AT91_TC_BCPC		(3 << 26)	/* Waveform Mode: RC Compare Effect on TIOB */
+#define			AT91_TC_BCPC_NONE		(0 << 26)
+#define			AT91_TC_BCPC_SET		(1 << 26)
+#define			AT91_TC_BCPC_CLEAR		(2 << 26)
+#define			AT91_TC_BCPC_TOGGLE		(3 << 26)
+#define		AT91_TC_BEEVT		(3 << 28)	/* Waveform Mode: External Event Effect on TIOB */
+#define			AT91_TC_BEEVT_NONE		(0 << 28)
+#define			AT91_TC_BEEVT_SET		(1 << 28)
+#define			AT91_TC_BEEVT_CLEAR		(2 << 28)
+#define			AT91_TC_BEEVT_TOGGLE		(3 << 28)
+#define		AT91_TC_BSWTRG		(3 << 30)	/* Waveform Mode: Software Trigger Effect on TIOB */
+#define			AT91_TC_BSWTRG_NONE		(0 << 30)
+#define			AT91_TC_BSWTRG_SET		(1 << 30)
+#define			AT91_TC_BSWTRG_CLEAR		(2 << 30)
+#define			AT91_TC_BSWTRG_TOGGLE		(3 << 30)
+
+#define AT91_TC_CV		0x10		/* Counter Value */
+#define AT91_TC_RA		0x14		/* Register A */
+#define AT91_TC_RB		0x18		/* Register B */
+#define AT91_TC_RC		0x1c		/* Register C */
+
+#define AT91_TC_SR		0x20		/* Status Register */
+#define		AT91_TC_COVFS		(1 <<  0)	/* Counter Overflow Status */
+#define		AT91_TC_LOVRS		(1 <<  1)	/* Load Overrun Status */
+#define		AT91_TC_CPAS		(1 <<  2)	/* RA Compare Status */
+#define		AT91_TC_CPBS		(1 <<  3)	/* RB Compare Status */
+#define		AT91_TC_CPCS		(1 <<  4)	/* RC Compare Status */
+#define		AT91_TC_LDRAS		(1 <<  5)	/* RA Loading Status */
+#define		AT91_TC_LDRBS		(1 <<  6)	/* RB Loading Status */
+#define		AT91_TC_ETRGS		(1 <<  7)	/* External Trigger Status */
+#define		AT91_TC_CLKSTA		(1 << 16)	/* Clock Enabling Status */
+#define		AT91_TC_MTIOA		(1 << 17)	/* TIOA Mirror */
+#define		AT91_TC_MTIOB		(1 << 18)	/* TIOB Mirror */
+
+#define AT91_TC_IER		0x24		/* Interrupt Enable Register */
+#define AT91_TC_IDR		0x28		/* Interrupt Disable Register */
+#define AT91_TC_IMR		0x2c		/* Interrupt Mask Register */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91_twi.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_twi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_twi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/*
+ * include/asm-arm/arch-at91/at91_twi.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Two-wire Interface (TWI) registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_TWI_H
+#define AT91_TWI_H
+
+#define	AT91_TWI_CR		0x00		/* Control Register */
+#define		AT91_TWI_START		(1 <<  0)	/* Send a Start Condition */
+#define		AT91_TWI_STOP		(1 <<  1)	/* Send a Stop Condition */
+#define		AT91_TWI_MSEN		(1 <<  2)	/* Master Transfer Enable */
+#define		AT91_TWI_MSDIS		(1 <<  3)	/* Master Transfer Disable */
+#define		AT91_TWI_SWRST		(1 <<  7)	/* Software Reset */
+
+#define	AT91_TWI_MMR		0x04		/* Master Mode Register */
+#define		AT91_TWI_IADRSZ		(3    <<  8)	/* Internal Device Address Size */
+#define			AT91_TWI_IADRSZ_NO		(0 << 8)
+#define			AT91_TWI_IADRSZ_1		(1 << 8)
+#define			AT91_TWI_IADRSZ_2		(2 << 8)
+#define			AT91_TWI_IADRSZ_3		(3 << 8)
+#define		AT91_TWI_MREAD		(1    << 12)	/* Master Read Direction */
+#define		AT91_TWI_DADR		(0x7f << 16)	/* Device Address */
+
+#define	AT91_TWI_IADR		0x0c		/* Internal Address Register */
+
+#define	AT91_TWI_CWGR		0x10		/* Clock Waveform Generator Register */
+#define		AT91_TWI_CLDIV		(0xff <<  0)	/* Clock Low Divisor */
+#define		AT91_TWI_CHDIV		(0xff <<  8)	/* Clock High Divisor */
+#define		AT91_TWI_CKDIV		(7    << 16)	/* Clock Divider */
+
+#define	AT91_TWI_SR		0x20		/* Status Register */
+#define		AT91_TWI_TXCOMP		(1 <<  0)	/* Transmission Complete */
+#define		AT91_TWI_RXRDY		(1 <<  1)	/* Receive Holding Register Ready */
+#define		AT91_TWI_TXRDY		(1 <<  2)	/* Transmit Holding Register Ready */
+#define		AT91_TWI_OVRE		(1 <<  6)	/* Overrun Error [AT91RM9200 only] */
+#define		AT91_TWI_UNRE		(1 <<  7)	/* Underrun Error [AT91RM9200 only] */
+#define		AT91_TWI_NACK		(1 <<  8)	/* Not Acknowledged */
+
+#define	AT91_TWI_IER		0x24		/* Interrupt Enable Register */
+#define	AT91_TWI_IDR		0x28		/* Interrupt Disable Register */
+#define	AT91_TWI_IMR		0x2c		/* Interrupt Mask Register */
+#define	AT91_TWI_RHR		0x30		/* Receive Holding Register */
+#define	AT91_TWI_THR		0x34		/* Transmit Holding Register */
+
+#endif
+
Index: build_tree/linux/include/asm/arch-at91/at91_wdt.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91_wdt.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91_wdt.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,34 @@
+/*
+ * include/asm-arm/arch-at91/at91_wdt.h
+ *
+ * Watchdog Timer (WDT) - System peripherals regsters.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_WDT_H
+#define AT91_WDT_H
+
+#define AT91_WDT_CR		(AT91_WDT + 0x00)	/* Watchdog Control Register */
+#define		AT91_WDT_WDRSTT		(1    << 0)		/* Restart */
+#define		AT91_WDT_KEY		(0xff << 24)		/* KEY Password */
+
+#define AT91_WDT_MR		(AT91_WDT + 0x04)	/* Watchdog Mode Register */
+#define		AT91_WDT_WDV		(0xfff << 0)		/* Counter Value */
+#define		AT91_WDT_WDFIEN		(1     << 12)		/* Fault Interrupt Enable */
+#define		AT91_WDT_WDRSTEN	(1     << 13)		/* Reset Processor */
+#define		AT91_WDT_WDRPROC	(1     << 14)		/* Timer Restart */
+#define		AT91_WDT_WDDIS		(1     << 15)		/* Watchdog Disable */
+#define		AT91_WDT_WDD		(0xfff << 16)		/* Delta Value */
+#define		AT91_WDT_WDDBGHLT	(1     << 28)		/* Debug Halt */
+#define		AT91_WDT_WDIDLEHLT	(1     << 29)		/* Idle Halt */
+
+#define AT91_WDT_SR		(AT91_WDT + 0x08)	/* Watchdog Status Register */
+#define		AT91_WDT_WDUNF		(1 << 0)		/* Watchdog Underflow */
+#define		AT91_WDT_WDERR		(1 << 1)		/* Watchdog Error */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91rm9200.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91rm9200.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91rm9200.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,291 @@
+/*
+ * include/asm-arm/arch-at91/at91rm9200.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Common definitions.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_H
+#define AT91RM9200_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ		0	/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS		1	/* System Peripheral */
+#define AT91RM9200_ID_PIOA	2	/* Parallel IO Controller A */
+#define AT91RM9200_ID_PIOB	3	/* Parallel IO Controller B */
+#define AT91RM9200_ID_PIOC	4	/* Parallel IO Controller C */
+#define AT91RM9200_ID_PIOD	5	/* Parallel IO Controller D */
+#define AT91RM9200_ID_US0	6	/* USART 0 */
+#define AT91RM9200_ID_US1	7	/* USART 1 */
+#define AT91RM9200_ID_US2	8	/* USART 2 */
+#define AT91RM9200_ID_US3	9	/* USART 3 */
+#define AT91RM9200_ID_MCI	10	/* Multimedia Card Interface */
+#define AT91RM9200_ID_UDP	11	/* USB Device Port */
+#define AT91RM9200_ID_TWI	12	/* Two-Wire Interface */
+#define AT91RM9200_ID_SPI	13	/* Serial Peripheral Interface */
+#define AT91RM9200_ID_SSC0	14	/* Serial Synchronous Controller 0 */
+#define AT91RM9200_ID_SSC1	15	/* Serial Synchronous Controller 1 */
+#define AT91RM9200_ID_SSC2	16	/* Serial Synchronous Controller 2 */
+#define AT91RM9200_ID_TC0	17	/* Timer Counter 0 */
+#define AT91RM9200_ID_TC1	18	/* Timer Counter 1 */
+#define AT91RM9200_ID_TC2	19	/* Timer Counter 2 */
+#define AT91RM9200_ID_TC3	20	/* Timer Counter 3 */
+#define AT91RM9200_ID_TC4	21	/* Timer Counter 4 */
+#define AT91RM9200_ID_TC5	22	/* Timer Counter 5 */
+#define AT91RM9200_ID_UHP	23	/* USB Host port */
+#define AT91RM9200_ID_EMAC	24	/* Ethernet MAC */
+#define AT91RM9200_ID_IRQ0	25	/* Advanced Interrupt Controller (IRQ0) */
+#define AT91RM9200_ID_IRQ1	26	/* Advanced Interrupt Controller (IRQ1) */
+#define AT91RM9200_ID_IRQ2	27	/* Advanced Interrupt Controller (IRQ2) */
+#define AT91RM9200_ID_IRQ3	28	/* Advanced Interrupt Controller (IRQ3) */
+#define AT91RM9200_ID_IRQ4	29	/* Advanced Interrupt Controller (IRQ4) */
+#define AT91RM9200_ID_IRQ5	30	/* Advanced Interrupt Controller (IRQ5) */
+#define AT91RM9200_ID_IRQ6	31	/* Advanced Interrupt Controller (IRQ6) */
+
+
+/*
+ * Peripheral physical base addresses.
+ */
+#define AT91RM9200_BASE_TCB0	0xfffa0000
+#define AT91RM9200_BASE_TC0	0xfffa0000
+#define AT91RM9200_BASE_TC1	0xfffa0040
+#define AT91RM9200_BASE_TC2	0xfffa0080
+#define AT91RM9200_BASE_TCB1	0xfffa4000
+#define AT91RM9200_BASE_TC3	0xfffa4000
+#define AT91RM9200_BASE_TC4	0xfffa4040
+#define AT91RM9200_BASE_TC5	0xfffa4080
+#define AT91RM9200_BASE_UDP	0xfffb0000
+#define AT91RM9200_BASE_MCI	0xfffb4000
+#define AT91RM9200_BASE_TWI	0xfffb8000
+#define AT91RM9200_BASE_EMAC	0xfffbc000
+#define AT91RM9200_BASE_US0	0xfffc0000
+#define AT91RM9200_BASE_US1	0xfffc4000
+#define AT91RM9200_BASE_US2	0xfffc8000
+#define AT91RM9200_BASE_US3	0xfffcc000
+#define AT91RM9200_BASE_SSC0	0xfffd0000
+#define AT91RM9200_BASE_SSC1	0xfffd4000
+#define AT91RM9200_BASE_SSC2	0xfffd8000
+#define AT91RM9200_BASE_SPI	0xfffe0000
+#define AT91_BASE_SYS		0xfffff000
+
+
+/*
+ * System Peripherals (offset from AT91_BASE_SYS)
+ */
+#define AT91_AIC	(0xfffff000 - AT91_BASE_SYS)	/* Advanced Interrupt Controller */
+#define AT91_DBGU	(0xfffff200 - AT91_BASE_SYS)	/* Debug Unit */
+#define AT91_PIOA	(0xfffff400 - AT91_BASE_SYS)	/* PIO Controller A */
+#define AT91_PIOB	(0xfffff600 - AT91_BASE_SYS)	/* PIO Controller B */
+#define AT91_PIOC	(0xfffff800 - AT91_BASE_SYS)	/* PIO Controller C */
+#define AT91_PIOD	(0xfffffa00 - AT91_BASE_SYS)	/* PIO Controller D */
+#define AT91_PMC	(0xfffffc00 - AT91_BASE_SYS)	/* Power Management Controller */
+#define AT91_ST		(0xfffffd00 - AT91_BASE_SYS)	/* System Timer */
+#define AT91_RTC	(0xfffffe00 - AT91_BASE_SYS)	/* Real-Time Clock */
+#define AT91_MC		(0xffffff00 - AT91_BASE_SYS)	/* Memory Controllers */
+
+#define AT91_MATRIX	0	/* not supported */
+
+/*
+ * Internal Memory.
+ */
+#define AT91RM9200_ROM_BASE	0x00100000	/* Internal ROM base address */
+#define AT91RM9200_ROM_SIZE	SZ_128K		/* Internal ROM size (128Kb) */
+
+#define AT91RM9200_SRAM_BASE	0x00200000	/* Internal SRAM base address */
+#define AT91RM9200_SRAM_SIZE	SZ_16K		/* Internal SRAM size (16Kb) */
+
+#define AT91RM9200_UHP_BASE	0x00300000	/* USB Host controller */
+
+
+#if 0
+/*
+ * PIO pin definitions (peripheral A/B multiplexing).
+ */
+#define AT91_PA0_MISO		(1 <<  0)	/* A: SPI Master-In Slave-Out */
+#define AT91_PA0_PCK3		(1 <<  0)	/* B: PMC Programmable Clock Output 3 */
+#define AT91_PA1_MOSI		(1 <<  1)	/* A: SPI Master-Out Slave-In */
+#define AT91_PA1_PCK0		(1 <<  1)	/* B: PMC Programmable Clock Output 0 */
+#define AT91_PA2_SPCK		(1 <<  2)	/* A: SPI Serial Clock */
+#define AT91_PA2_IRQ4		(1 <<  2)	/* B: External Interrupt 4 */
+#define AT91_PA3_NPCS0		(1 <<  3)	/* A: SPI Peripheral Chip Select 0 */
+#define AT91_PA3_IRQ5		(1 <<  3)	/* B: External Interrupt 5 */
+#define AT91_PA4_NPCS1		(1 <<  4)	/* A: SPI Peripheral Chip Select 1 */
+#define AT91_PA4_PCK1		(1 <<  4)	/* B: PMC Programmable Clock Output 1 */
+#define AT91_PA5_NPCS2		(1 <<  5)	/* A: SPI Peripheral Chip Select 2 */
+#define AT91_PA5_TXD3		(1 <<  5)	/* B: USART Transmit Data 3 */
+#define AT91_PA6_NPCS3		(1 <<  6)	/* A: SPI Peripheral Chip Select 3 */
+#define AT91_PA6_RXD3		(1 <<  6)	/* B: USART Receive Data 3 */
+#define AT91_PA7_ETXCK_EREFCK	(1 <<  7)	/* A: Ethernet Reference Clock / Transmit Clock */
+#define AT91_PA7_PCK2		(1 <<  7)	/* B: PMC Programmable Clock Output 2 */
+#define AT91_PA8_ETXEN		(1 <<  8)	/* A: Ethernet Transmit Enable */
+#define AT91_PA8_MCCDB		(1 <<  8)	/* B: MMC Multimedia Card B Command */
+#define AT91_PA9_ETX0		(1 <<  9)	/* A: Ethernet Transmit Data 0 */
+#define AT91_PA9_MCDB0		(1 <<  9)	/* B: MMC Multimedia Card B Data 0 */
+#define AT91_PA10_ETX1		(1 << 10)	/* A: Ethernet Transmit Data 1 */
+#define AT91_PA10_MCDB1		(1 << 10)	/* B: MMC Multimedia Card B Data 1 */
+#define AT91_PA11_ECRS_ECRSDV	(1 << 11)	/* A: Ethernet Carrier Sense / Data Valid */
+#define AT91_PA11_MCDB2		(1 << 11)	/* B: MMC Multimedia Card B Data 2 */
+#define AT91_PA12_ERX0		(1 << 12)	/* A: Ethernet Receive Data 0 */
+#define AT91_PA12_MCDB3		(1 << 12)	/* B: MMC Multimedia Card B Data 3 */
+#define AT91_PA13_ERX1		(1 << 13)	/* A: Ethernet Receive Data 1 */
+#define AT91_PA13_TCLK0		(1 << 13)	/* B: TC External Clock Input 0 */
+#define AT91_PA14_ERXER		(1 << 14)	/* A: Ethernet Receive Error */
+#define AT91_PA14_TCLK1		(1 << 14)	/* B: TC External Clock Input 1 */
+#define AT91_PA15_EMDC		(1 << 15)	/* A: Ethernet Management Data Clock */
+#define AT91_PA15_TCLK2		(1 << 15)	/* B: TC External Clock Input 2 */
+#define AT91_PA16_EMDIO		(1 << 16)	/* A: Ethernet Management Data I/O */
+#define AT91_PA16_IRQ6		(1 << 16)	/* B: External Interrupt 6 */
+#define AT91_PA17_TXD0		(1 << 17)	/* A: USART Transmit Data 0 */
+#define AT91_PA17_TIOA0		(1 << 17)	/* B: TC I/O Line A 0 */
+#define AT91_PA18_RXD0		(1 << 18)	/* A: USART Receive Data 0 */
+#define AT91_PA18_TIOB0		(1 << 18)	/* B: TC I/O Line B 0 */
+#define AT91_PA19_SCK0		(1 << 19)	/* A: USART Serial Clock 0 */
+#define AT91_PA19_TIOA1		(1 << 19)	/* B: TC I/O Line A 1 */
+#define AT91_PA20_CTS0		(1 << 20)	/* A: USART Clear To Send 0 */
+#define AT91_PA20_TIOB1		(1 << 20)	/* B: TC I/O Line B 1 */
+#define AT91_PA21_RTS0		(1 << 21)	/* A: USART Ready To Send 0 */
+#define AT91_PA21_TIOA2		(1 << 21)	/* B: TC I/O Line A 2 */
+#define AT91_PA22_RXD2		(1 << 22)	/* A: USART Receive Data 2 */
+#define AT91_PA22_TIOB2		(1 << 22)	/* B: TC I/O Line B 2 */
+#define AT91_PA23_TXD2		(1 << 23)	/* A: USART Transmit Data 2 */
+#define AT91_PA23_IRQ3		(1 << 23)	/* B: External Interrupt 3 */
+#define AT91_PA24_SCK2		(1 << 24)	/* A: USART Serial Clock 2 */
+#define AT91_PA24_PCK1		(1 << 24)	/* B: PMC Programmable Clock Output 1 */
+#define AT91_PA25_TWD		(1 << 25)	/* A: TWI Two-wire Serial Data */
+#define AT91_PA25_IRQ2		(1 << 25)	/* B: External Interrupt 2 */
+#define AT91_PA26_TWCK		(1 << 26)	/* A: TWI Two-wire Serial Clock */
+#define AT91_PA26_IRQ1		(1 << 26)	/* B: External Interrupt 1 */
+#define AT91_PA27_MCCK		(1 << 27)	/* A: MMC Multimedia Card Clock */
+#define AT91_PA27_TCLK3		(1 << 27)	/* B: TC External Clock Input 3 */
+#define AT91_PA28_MCCDA		(1 << 28)	/* A: MMC Multimedia Card A Command */
+#define AT91_PA28_TCLK4		(1 << 28)	/* B: TC External Clock Input 4 */
+#define AT91_PA29_MCDA0		(1 << 29)	/* A: MMC Multimedia Card A Data 0 */
+#define AT91_PA29_TCLK5		(1 << 29)	/* B: TC External Clock Input 5 */
+#define AT91_PA30_DRXD		(1 << 30)	/* A: DBGU Receive Data */
+#define AT91_PA30_CTS2		(1 << 30)	/* B: USART Clear To Send 2 */
+#define AT91_PA31_DTXD		(1 << 31)	/* A: DBGU Transmit Data */
+#define AT91_PA31_RTS2		(1 << 31)	/* B: USART Ready To Send 2 */
+
+#define AT91_PB0_TF0		(1 <<  0)	/* A: SSC Transmit Frame Sync 0 */
+#define AT91_PB0_RTS3		(1 <<  0)	/* B: USART Ready To Send 3 */
+#define AT91_PB1_TK0		(1 <<  1)	/* A: SSC Transmit Clock 0 */
+#define AT91_PB1_CTS3		(1 <<  1)	/* B: USART Clear To Send 3 */
+#define AT91_PB2_TD0		(1 <<  2)	/* A: SSC Transmit Data 0 */
+#define AT91_PB2_SCK3		(1 <<  2)	/* B: USART Serial Clock 3 */
+#define AT91_PB3_RD0		(1 <<  3)	/* A: SSC Receive Data 0 */
+#define AT91_PB3_MCDA1		(1 <<  3)	/* B: MMC Multimedia Card A Data 1 */
+#define AT91_PB4_RK0		(1 <<  4)	/* A: SSC Receive Clock 0 */
+#define AT91_PB4_MCDA2		(1 <<  4)	/* B: MMC Multimedia Card A Data 2 */
+#define AT91_PB5_RF0		(1 <<  5)	/* A: SSC Receive Frame Sync 0 */
+#define AT91_PB5_MCDA3		(1 <<  5)	/* B: MMC Multimedia Card A Data 3 */
+#define AT91_PB6_TF1		(1 <<  6)	/* A: SSC Transmit Frame Sync 1 */
+#define AT91_PB6_TIOA3		(1 <<  6)	/* B: TC I/O Line A 3 */
+#define AT91_PB7_TK1		(1 <<  7)	/* A: SSC Transmit Clock 1 */
+#define AT91_PB7_TIOB3		(1 <<  7)	/* B: TC I/O Line B 3 */
+#define AT91_PB8_TD1		(1 <<  8)	/* A: SSC Transmit Data 1 */
+#define AT91_PB8_TIOA4		(1 <<  8)	/* B: TC I/O Line A 4 */
+#define AT91_PB9_RD1		(1 <<  9)	/* A: SSC Receive Data 1 */
+#define AT91_PB9_TIOB4		(1 <<  9)	/* B: TC I/O Line B 4 */
+#define AT91_PB10_RK1		(1 << 10)	/* A: SSC Receive Clock 1 */
+#define AT91_PB10_TIOA5		(1 << 10)	/* B: TC I/O Line A 5 */
+#define AT91_PB11_RF1		(1 << 11)	/* A: SSC Receive Frame Sync 1 */
+#define AT91_PB11_TIOB5		(1 << 11)	/* B: TC I/O Line B 5 */
+#define AT91_PB12_TF2		(1 << 12)	/* A: SSC Transmit Frame Sync 2 */
+#define AT91_PB12_ETX2		(1 << 12)	/* B: Ethernet Transmit Data 2 */
+#define AT91_PB13_TK2		(1 << 13)	/* A: SSC Transmit Clock 3 */
+#define AT91_PB13_ETX3		(1 << 13)	/* B: Ethernet Transmit Data 3 */
+#define AT91_PB14_TD2		(1 << 14)	/* A: SSC Transmit Data 2 */
+#define AT91_PB14_ETXER		(1 << 14)	/* B: Ethernet Transmit Coding Error */
+#define AT91_PB15_RD2		(1 << 15)	/* A: SSC Receive Data 2 */
+#define AT91_PB15_ERX2		(1 << 15)	/* B: Ethernet Receive Data 2 */
+#define AT91_PB16_RK2		(1 << 16)	/* A: SSC Receive Clock 2 */
+#define AT91_PB16_ERX3		(1 << 16)	/* B: Ethernet Receive Data 3 */
+#define AT91_PB17_RF2		(1 << 17)	/* A: SSC Receive Frame Sync 2 */
+#define AT91_PB17_ERXDV		(1 << 17)	/* B: Ethernet Receive Data Valid */
+#define AT91_PB18_RI1		(1 << 18)	/* A: USART Ring Indicator 1 */
+#define AT91_PB18_ECOL		(1 << 18)	/* B: Ethernet Collision Detected */
+#define AT91_PB19_DTR1		(1 << 19)	/* A: USART Data Terminal Ready 1 */
+#define AT91_PB19_ERXCK		(1 << 19)	/* B: Ethernet Receive Clock */
+#define AT91_PB20_TXD1		(1 << 20)	/* A: USART Transmit Data 1 */
+#define AT91_PB21_RXD1		(1 << 21)	/* A: USART Receive Data 1 */
+#define AT91_PB22_SCK1		(1 << 22)	/* A: USART Serial Clock 1 */
+#define AT91_PB23_DCD1		(1 << 23)	/* A: USART Data Carrier Detect 1 */
+#define AT91_PB24_CTS1		(1 << 24)	/* A: USART Clear To Send 1 */
+#define AT91_PB25_DSR1		(1 << 25)	/* A: USART Data Set Ready 1 */
+#define AT91_PB25_EF100		(1 << 25)	/* B: Ethernet Force 100 Mbit */
+#define AT91_PB26_RTS1		(1 << 26)	/* A: USART Ready To Send 1 */
+#define AT91_PB27_PCK0		(1 << 27)	/* B: PMC Programmable Clock Output 0 */
+#define AT91_PB28_FIQ		(1 << 28)	/* A: Fast Interrupt */
+#define AT91_PB29_IRQ0		(1 << 29)	/* A: External Interrupt 0 */
+
+#define AT91_PC0_BFCK		(1 <<  0)	/* A: Burst Flash Clock */
+#define AT91_PC1_BFRDY_SMOE	(1 <<  1)	/* A: Burst Flash Ready / SmartMedia Output Enable */
+#define AT91_PC2_BFAVD		(1 <<  2)	/* A: Burst Flash Address Valid */
+#define AT91_PC3_BFBAA_SMWE	(1 <<  3)	/* A: Burst Flash Address Advance / SmartMedia Write Enable */
+#define AT91_PC4_BFOE		(1 <<  4)	/* A: Burst Flash Output Enable */
+#define AT91_PC5_BFWE		(1 <<  5)	/* A: Burst Flash Write Enable */
+#define AT91_PC6_NWAIT		(1 <<  6)	/* A: SMC Wait Signal */
+#define AT91_PC7_A23		(1 <<  7)	/* A: Address Bus 23 */
+#define AT91_PC8_A24		(1 <<  8)	/* A: Address Bus 24 */
+#define AT91_PC9_A25_CFRNW	(1 <<  9)	/* A: Address Bus 25 / Compact Flash Read Not Write */
+#define AT91_PC10_NCS4_CFCS	(1 << 10)	/* A: SMC Chip Select 4 / Compact Flash Chip Select */
+#define AT91_PC11_NCS5_CFCE1	(1 << 11)	/* A: SMC Chip Select 5 / Compact Flash Chip Enable 1 */
+#define AT91_PC12_NCS6_CFCE2	(1 << 12)	/* A: SMC Chip Select 6 / Compact Flash Chip Enable 2 */
+#define AT91_PC13_NCS7		(1 << 13)	/* A: Chip Select 7 */
+
+#define AT91_PD0_ETX0		(1 <<  0)	/* A: Ethernet Transmit Data 0 */
+#define AT91_PD1_ETX1		(1 <<  1)	/* A: Ethernet Transmit Data 1 */
+#define AT91_PD2_ETX2		(1 <<  2)	/* A: Ethernet Transmit Data 2 */
+#define AT91_PD3_ETX3		(1 <<  3)	/* A: Ethernet Transmit Data 3 */
+#define AT91_PD4_ETXEN		(1 <<  4)	/* A: Ethernet Transmit Enable */
+#define AT91_PD5_ETXER		(1 <<  5)	/* A: Ethernet Transmit Coding Error */
+#define AT91_PD6_DTXD		(1 <<  6)	/* A: DBGU Transmit Data */
+#define AT91_PD7_PCK0		(1 <<  7)	/* A: PMC Programmable Clock Output 0 */
+#define AT91_PD7_TSYNC		(1 <<  7)	/* B: ETM Trace Synchronization Signal */
+#define AT91_PD8_PCK1		(1 <<  8)	/* A: PMC Programmable Clock Output 1 */
+#define AT91_PD8_TCLK		(1 <<  8)	/* B: ETM Trace Clock */
+#define AT91_PD9_PCK2		(1 <<  9)	/* A: PMC Programmable Clock Output 2 */
+#define AT91_PD9_TPS0		(1 <<  9)	/* B: ETM Trace ARM Pipeline Status 0 */
+#define AT91_PD10_PCK3		(1 << 10)	/* A: PMC Programmable Clock Output 3 */
+#define AT91_PD10_TPS1		(1 << 10)	/* B: ETM Trace ARM Pipeline Status 1 */
+#define AT91_PD11_TPS2		(1 << 11)	/* B: ETM Trace ARM Pipeline Status 2 */
+#define AT91_PD12_TPK0		(1 << 12)	/* B: ETM Trace Packet Port 0 */
+#define AT91_PD13_TPK1		(1 << 13)	/* B: ETM Trace Packet Port 1 */
+#define AT91_PD14_TPK2		(1 << 14)	/* B: ETM Trace Packet Port 2 */
+#define AT91_PD15_TD0		(1 << 15)	/* A: SSC Transmit Data 0 */
+#define AT91_PD15_TPK3		(1 << 15)	/* B: ETM Trace Packet Port 3 */
+#define AT91_PD16_TD1		(1 << 16)	/* A: SSC Transmit Data 1 */
+#define AT91_PD16_TPK4		(1 << 16)	/* B: ETM Trace Packet Port 4 */
+#define AT91_PD17_TD2		(1 << 17)	/* A: SSC Transmit Data 2 */
+#define AT91_PD17_TPK5		(1 << 17)	/* B: ETM Trace Packet Port 5 */
+#define AT91_PD18_NPCS1		(1 << 18)	/* A: SPI Peripheral Chip Select 1 */
+#define AT91_PD18_TPK6		(1 << 18)	/* B: ETM Trace Packet Port 6 */
+#define AT91_PD19_NPCS2		(1 << 19)	/* A: SPI Peripheral Chip Select 2 */
+#define AT91_PD19_TPK7		(1 << 19)	/* B: ETM Trace Packet Port 7 */
+#define AT91_PD20_NPCS3		(1 << 20)	/* A: SPI Peripheral Chip Select 3 */
+#define AT91_PD20_TPK8		(1 << 20)	/* B: ETM Trace Packet Port 8 */
+#define AT91_PD21_RTS0		(1 << 21)	/* A: USART Ready To Send 0 */
+#define AT91_PD21_TPK9		(1 << 21)	/* B: ETM Trace Packet Port 9 */
+#define AT91_PD22_RTS1		(1 << 22)	/* A: USART Ready To Send 1 */
+#define AT91_PD22_TPK10		(1 << 22)	/* B: ETM Trace Packet Port 10 */
+#define AT91_PD23_RTS2		(1 << 23)	/* A: USART Ready To Send 2 */
+#define AT91_PD23_TPK11		(1 << 23)	/* B: ETM Trace Packet Port 11 */
+#define AT91_PD24_RTS3		(1 << 24)	/* A: USART Ready To Send 3 */
+#define AT91_PD24_TPK12		(1 << 24)	/* B: ETM Trace Packet Port 12 */
+#define AT91_PD25_DTR1		(1 << 25)	/* A: USART Data Terminal Ready 1 */
+#define AT91_PD25_TPK13		(1 << 25)	/* B: ETM Trace Packet Port 13 */
+#define AT91_PD26_TPK14		(1 << 26)	/* B: ETM Trace Packet Port 14 */
+#define AT91_PD27_TPK15		(1 << 27)	/* B: ETM Trace Packet Port 15 */
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91rm9200_emac.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91rm9200_emac.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91rm9200_emac.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,138 @@
+/*
+ * include/asm-arm/arch-at91/at91rm9200_emac.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Ethernet MAC registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_EMAC_H
+#define AT91RM9200_EMAC_H
+
+#define	AT91_EMAC_CTL		0x00	/* Control Register */
+#define		AT91_EMAC_LB		(1 <<  0)	/* Loopback */
+#define		AT91_EMAC_LBL		(1 <<  1)	/* Loopback Local */
+#define		AT91_EMAC_RE		(1 <<  2)	/* Receive Enable */
+#define		AT91_EMAC_TE		(1 <<  3)	/* Transmit Enable */
+#define		AT91_EMAC_MPE		(1 <<  4)	/* Management Port Enable */
+#define		AT91_EMAC_CSR		(1 <<  5)	/* Clear Statistics Registers */
+#define		AT91_EMAC_INCSTAT	(1 <<  6)	/* Increment Statistics Registers */
+#define		AT91_EMAC_WES		(1 <<  7)	/* Write Enable for Statistics Registers */
+#define		AT91_EMAC_BP		(1 <<  8)	/* Back Pressure */
+
+#define	AT91_EMAC_CFG		0x04	/* Configuration Register */
+#define		AT91_EMAC_SPD		(1 <<  0)	/* Speed */
+#define		AT91_EMAC_FD		(1 <<  1)	/* Full Duplex */
+#define		AT91_EMAC_BR		(1 <<  2)	/* Bit Rate */
+#define		AT91_EMAC_CAF		(1 <<  4)	/* Copy All Frames */
+#define		AT91_EMAC_NBC		(1 <<  5)	/* No Broadcast */
+#define		AT91_EMAC_MTI		(1 <<  6)	/* Multicast Hash Enable */
+#define		AT91_EMAC_UNI		(1 <<  7)	/* Unicast Hash Enable */
+#define		AT91_EMAC_BIG		(1 <<  8)	/* Receive 1522 Bytes */
+#define		AT91_EMAC_EAE		(1 <<  9)	/* External Address Match Enable */
+#define		AT91_EMAC_CLK		(3 << 10)	/* MDC Clock Divisor */
+#define		AT91_EMAC_CLK_DIV8		(0 << 10)
+#define		AT91_EMAC_CLK_DIV16		(1 << 10)
+#define		AT91_EMAC_CLK_DIV32		(2 << 10)
+#define		AT91_EMAC_CLK_DIV64		(3 << 10)
+#define		AT91_EMAC_RTY		(1 << 12)	/* Retry Test */
+#define		AT91_EMAC_RMII		(1 << 13)	/* Reduce MII (RMII) */
+
+#define	AT91_EMAC_SR		0x08	/* Status Register */
+#define		AT91_EMAC_SR_LINK	(1 <<  0)	/* Link */
+#define		AT91_EMAC_SR_MDIO	(1 <<  1)	/* MDIO pin */
+#define		AT91_EMAC_SR_IDLE	(1 <<  2)	/* PHY idle */
+
+#define	AT91_EMAC_TAR		0x0c	/* Transmit Address Register */
+
+#define	AT91_EMAC_TCR		0x10	/* Transmit Control Register */
+#define		AT91_EMAC_LEN		(0x7ff << 0)	/* Transmit Frame Length */
+#define		AT91_EMAC_NCRC		(1     << 15)	/* No CRC */
+
+#define	AT91_EMAC_TSR		0x14	/* Transmit Status Register */
+#define		AT91_EMAC_TSR_OVR	(1 <<  0)	/* Transmit Buffer Overrun */
+#define		AT91_EMAC_TSR_COL	(1 <<  1)	/* Collision Occurred */
+#define		AT91_EMAC_TSR_RLE	(1 <<  2)	/* Retry Limit Exceeded */
+#define		AT91_EMAC_TSR_IDLE	(1 <<  3)	/* Transmitter Idle */
+#define		AT91_EMAC_TSR_BNQ	(1 <<  4)	/* Transmit Buffer not Queued */
+#define		AT91_EMAC_TSR_COMP	(1 <<  5)	/* Transmit Complete */
+#define		AT91_EMAC_TSR_UND	(1 <<  6)	/* Transmit Underrun */
+
+#define	AT91_EMAC_RBQP		0x18	/* Receive Buffer Queue Pointer */
+
+#define	AT91_EMAC_RSR		0x20	/* Receive Status Register */
+#define		AT91_EMAC_RSR_BNA	(1 <<  0)	/* Buffer Not Available */
+#define		AT91_EMAC_RSR_REC	(1 <<  1)	/* Frame Received */
+#define		AT91_EMAC_RSR_OVR	(1 <<  2)	/* RX Overrun */
+
+#define	AT91_EMAC_ISR		0x24	/* Interrupt Status Register */
+#define		AT91_EMAC_DONE		(1 <<  0)	/* Management Done */
+#define		AT91_EMAC_RCOM		(1 <<  1)	/* Receive Complete */
+#define		AT91_EMAC_RBNA		(1 <<  2)	/* Receive Buffer Not Available */
+#define		AT91_EMAC_TOVR		(1 <<  3)	/* Transmit Buffer Overrun */
+#define		AT91_EMAC_TUND		(1 <<  4)	/* Transmit Buffer Underrun */
+#define		AT91_EMAC_RTRY		(1 <<  5)	/* Retry Limit */
+#define		AT91_EMAC_TBRE		(1 <<  6)	/* Transmit Buffer Register Empty */
+#define		AT91_EMAC_TCOM		(1 <<  7)	/* Transmit Complete */
+#define		AT91_EMAC_TIDLE		(1 <<  8)	/* Transmit Idle */
+#define		AT91_EMAC_LINK		(1 <<  9)	/* Link */
+#define		AT91_EMAC_ROVR		(1 << 10)	/* RX Overrun */
+#define		AT91_EMAC_ABT		(1 << 11)	/* Abort */
+
+#define	AT91_EMAC_IER		0x28	/* Interrupt Enable Register */
+#define	AT91_EMAC_IDR		0x2c	/* Interrupt Disable Register */
+#define	AT91_EMAC_IMR		0x30	/* Interrupt Mask Register */
+
+#define	AT91_EMAC_MAN		0x34	/* PHY Maintenance Register */
+#define		AT91_EMAC_DATA		(0xffff << 0)	/* MDIO Data */
+#define		AT91_EMAC_REGA		(0x1f	<< 18)	/* MDIO Register */
+#define		AT91_EMAC_PHYA		(0x1f	<< 23)	/* MDIO PHY Address */
+#define		AT91_EMAC_RW		(3	<< 28)	/* Read/Write operation */
+#define			AT91_EMAC_RW_W		(1 << 28)
+#define			AT91_EMAC_RW_R		(2 << 28)
+#define		AT91_EMAC_MAN_802_3	0x40020000	/* IEEE 802.3 value */
+
+/*
+ * Statistics Registers.
+ */
+#define AT91_EMAC_FRA		0x40	/* Frames Transmitted OK */
+#define AT91_EMAC_SCOL		0x44	/* Single Collision Frame */
+#define AT91_EMAC_MCOL		0x48	/* Multiple Collision Frame */
+#define AT91_EMAC_OK		0x4c	/* Frames Received OK */
+#define AT91_EMAC_SEQE		0x50	/* Frame Check Sequence Error */
+#define AT91_EMAC_ALE		0x54	/* Alignmemt Error */
+#define AT91_EMAC_DTE		0x58	/* Deffered Transmission Frame */
+#define AT91_EMAC_LCOL		0x5c	/* Late Collision */
+#define AT91_EMAC_ECOL		0x60	/* Excessive Collision */
+#define AT91_EMAC_TUE		0x64	/* Transmit Underrun Error */
+#define AT91_EMAC_CSE		0x68	/* Carrier Sense Error */
+#define AT91_EMAC_DRFC		0x6c	/* Discard RX Frame */
+#define AT91_EMAC_ROV		0x70	/* Receive Overrun */
+#define AT91_EMAC_CDE		0x74	/* Code Error */
+#define AT91_EMAC_ELR		0x78	/* Excessive Length Error */
+#define AT91_EMAC_RJB		0x7c	/* Receive Jabber */
+#define AT91_EMAC_USF		0x80	/* Undersize Frame */
+#define AT91_EMAC_SQEE		0x84	/* SQE Test Error */
+
+/*
+ * Address Registers.
+ */
+#define AT91_EMAC_HSL		0x90	/* Hash Address Low [31:0] */
+#define AT91_EMAC_HSH		0x94	/* Hash Address High [63:32] */
+#define AT91_EMAC_SA1L		0x98	/* Specific Address 1 Low, bytes 0-3 */
+#define AT91_EMAC_SA1H		0x9c	/* Specific Address 1 High, bytes 4-5 */
+#define AT91_EMAC_SA2L		0xa0	/* Specific Address 2 Low, bytes 0-3 */
+#define AT91_EMAC_SA2H		0xa4	/* Specific Address 2 High, bytes 4-5 */
+#define AT91_EMAC_SA3L		0xa8	/* Specific Address 3 Low, bytes 0-3 */
+#define AT91_EMAC_SA3H		0xac	/* Specific Address 3 High, bytes 4-5 */
+#define AT91_EMAC_SA4L		0xb0	/* Specific Address 4 Low, bytes 0-3 */
+#define AT91_EMAC_SA4H		0xb4	/* Specific Address 4 High, bytes 4-5 */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91rm9200_mc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91rm9200_mc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91rm9200_mc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,160 @@
+/*
+ * include/asm-arm/arch-at91/at91rm9200_mc.h
+ *
+ * Copyright (C) 2005 Ivan Kokshaysky
+ * Copyright (C) SAN People
+ *
+ * Memory Controllers (MC, EBI, SMC, SDRAMC, BFC) - System peripherals registers.
+ * Based on AT91RM9200 datasheet revision E.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91RM9200_MC_H
+#define AT91RM9200_MC_H
+
+/* Memory Controller */
+#define AT91_MC_RCR		(AT91_MC + 0x00)	/* MC Remap Control Register */
+#define		AT91_MC_RCB		(1 <<  0)		/* Remap Command Bit */
+
+#define AT91_MC_ASR		(AT91_MC + 0x04)	/* MC Abort Status Register */
+#define		AT91_MC_UNADD		(1 <<  0)		/* Undefined Address Abort Status */
+#define		AT91_MC_MISADD		(1 <<  1)		/* Misaligned Address Abort Status */
+#define		AT91_MC_ABTSZ		(3 <<  8)		/* Abort Size Status */
+#define			AT91_MC_ABTSZ_BYTE		(0 << 8)
+#define			AT91_MC_ABTSZ_HALFWORD		(1 << 8)
+#define			AT91_MC_ABTSZ_WORD		(2 << 8)
+#define		AT91_MC_ABTTYP		(3 << 10)		/* Abort Type Status */
+#define			AT91_MC_ABTTYP_DATAREAD		(0 << 10)
+#define			AT91_MC_ABTTYP_DATAWRITE	(1 << 10)
+#define			AT91_MC_ABTTYP_FETCH		(2 << 10)
+#define		AT91_MC_MST0		(1 << 16)		/* ARM920T Abort Source */
+#define		AT91_MC_MST1		(1 << 17)		/* PDC Abort Source */
+#define		AT91_MC_MST2		(1 << 18)		/* UHP Abort Source */
+#define		AT91_MC_MST3		(1 << 19)		/* EMAC Abort Source */
+#define		AT91_MC_SVMST0		(1 << 24)		/* Saved ARM920T Abort Source */
+#define		AT91_MC_SVMST1		(1 << 25)		/* Saved PDC Abort Source */
+#define		AT91_MC_SVMST2		(1 << 26)		/* Saved UHP Abort Source */
+#define		AT91_MC_SVMST3		(1 << 27)		/* Saved EMAC Abort Source */
+
+#define AT91_MC_AASR		(AT91_MC + 0x08)	/* MC Abort Address Status Register */
+
+#define AT91_MC_MPR		(AT91_MC + 0x0c)	/* MC Master Priority Register */
+#define		AT91_MPR_MSTP0		(7 <<  0)		/* ARM920T Priority */
+#define		AT91_MPR_MSTP1		(7 <<  4)		/* PDC Priority */
+#define		AT91_MPR_MSTP2		(7 <<  8)		/* UHP Priority */
+#define		AT91_MPR_MSTP3		(7 << 12)		/* EMAC Priority */
+
+/* External Bus Interface (EBI) registers */
+#define AT91_EBI_CSA		(AT91_MC + 0x60)	/* Chip Select Assignment Register */
+#define		AT91_EBI_CS0A		(1 << 0)		/* Chip Select 0 Assignment */
+#define			AT91_EBI_CS0A_SMC		(0 << 0)
+#define			AT91_EBI_CS0A_BFC		(1 << 0)
+#define		AT91_EBI_CS1A		(1 << 1)		/* Chip Select 1 Assignment */
+#define			AT91_EBI_CS1A_SMC		(0 << 1)
+#define			AT91_EBI_CS1A_SDRAMC		(1 << 1)
+#define		AT91_EBI_CS3A		(1 << 3)		/* Chip Select 2 Assignment */
+#define			AT91_EBI_CS3A_SMC		(0 << 3)
+#define			AT91_EBI_CS3A_SMC_SMARTMEDIA	(1 << 3)
+#define		AT91_EBI_CS4A		(1 << 4)		/* Chip Select 3 Assignment */
+#define			AT91_EBI_CS4A_SMC		(0 << 4)
+#define			AT91_EBI_CS4A_SMC_COMPACTFLASH	(1 << 4)
+#define AT91_EBI_CFGR		(AT91_MC + 0x64)	/* Configuration Register */
+#define		AT91_EBI_DBPUC		(1 << 0)		/* Data Bus Pull-Up Configuration */
+
+/* Static Memory Controller (SMC) registers */
+#define	AT91_SMC_CSR(n)		(AT91_MC + 0x70 + ((n) * 4))/* SMC Chip Select Register */
+#define		AT91_SMC_NWS		(0x7f <<  0)		/* Number of Wait States */
+#define			AT91_SMC_NWS_(x)	((x) << 0)
+#define		AT91_SMC_WSEN		(1    <<  7)		/* Wait State Enable */
+#define		AT91_SMC_TDF		(0xf  <<  8)		/* Data Float Time */
+#define			AT91_SMC_TDF_(x)	((x) << 8)
+#define		AT91_SMC_BAT		(1    << 12)		/* Byte Access Type */
+#define		AT91_SMC_DBW		(3    << 13)		/* Data Bus Width */
+#define			AT91_SMC_DBW_16		(1 << 13)
+#define			AT91_SMC_DBW_8		(2 << 13)
+#define		AT91_SMC_DPR		(1 << 15)		/* Data Read Protocol */
+#define		AT91_SMC_ACSS		(3 << 16)		/* Address to Chip Select Setup */
+#define			AT91_SMC_ACSS_STD	(0 << 16)
+#define			AT91_SMC_ACSS_1		(1 << 16)
+#define			AT91_SMC_ACSS_2		(2 << 16)
+#define			AT91_SMC_ACSS_3		(3 << 16)
+#define		AT91_SMC_RWSETUP	(7 << 24)		/* Read & Write Signal Time Setup */
+#define			AT91_SMC_RWSETUP_(x)	((x) << 24)
+#define		AT91_SMC_RWHOLD		(7 << 28)		/* Read & Write Signal Hold Time */
+#define			AT91_SMC_RWHOLD_(x)	((x) << 28)
+
+/* SDRAM Controller registers */
+#define AT91_SDRAMC_MR		(AT91_MC + 0x90)	/* Mode Register */
+#define		AT91_SDRAMC_MODE	(0xf << 0)		/* Command Mode */
+#define			AT91_SDRAMC_MODE_NORMAL		(0 << 0)
+#define			AT91_SDRAMC_MODE_NOP		(1 << 0)
+#define			AT91_SDRAMC_MODE_PRECHARGE	(2 << 0)
+#define			AT91_SDRAMC_MODE_LMR		(3 << 0)
+#define			AT91_SDRAMC_MODE_REFRESH	(4 << 0)
+#define		AT91_SDRAMC_DBW		(1   << 4)		/* Data Bus Width */
+#define			AT91_SDRAMC_DBW_32	(0 << 4)
+#define			AT91_SDRAMC_DBW_16	(1 << 4)
+
+#define AT91_SDRAMC_TR		(AT91_MC + 0x94)	/* Refresh Timer Register */
+#define		AT91_SDRAMC_COUNT	(0xfff << 0)		/* Refresh Timer Count */
+
+#define AT91_SDRAMC_CR		(AT91_MC + 0x98)	/* Configuration Register */
+#define		AT91_SDRAMC_NC		(3   <<  0)		/* Number of Column Bits */
+#define			AT91_SDRAMC_NC_8	(0 << 0)
+#define			AT91_SDRAMC_NC_9	(1 << 0)
+#define			AT91_SDRAMC_NC_10	(2 << 0)
+#define			AT91_SDRAMC_NC_11	(3 << 0)
+#define		AT91_SDRAMC_NR		(3   <<  2)		/* Number of Row Bits */
+#define			AT91_SDRAMC_NR_11	(0 << 2)
+#define			AT91_SDRAMC_NR_12	(1 << 2)
+#define			AT91_SDRAMC_NR_13	(2 << 2)
+#define		AT91_SDRAMC_NB		(1   <<  4)		/* Number of Banks */
+#define			AT91_SDRAMC_NB_2	(0 << 4)
+#define			AT91_SDRAMC_NB_4	(1 << 4)
+#define		AT91_SDRAMC_CAS		(3   <<  5)		/* CAS Latency */
+#define			AT91_SDRAMC_CAS_2	(2 << 5)
+#define		AT91_SDRAMC_TWR		(0xf <<  7)		/* Write Recovery Delay */
+#define		AT91_SDRAMC_TRC		(0xf << 11)		/* Row Cycle Delay */
+#define		AT91_SDRAMC_TRP		(0xf << 15)		/* Row Precharge Delay */
+#define		AT91_SDRAMC_TRCD	(0xf << 19)		/* Row to Column Delay */
+#define		AT91_SDRAMC_TRAS	(0xf << 23)		/* Active to Precharge Delay */
+#define		AT91_SDRAMC_TXSR	(0xf << 27)		/* Exit Self Refresh to Active Delay */
+
+#define AT91_SDRAMC_SRR		(AT91_MC + 0x9c)	/* Self Refresh Register */
+#define AT91_SDRAMC_LPR		(AT91_MC + 0xa0)	/* Low Power Register */
+#define AT91_SDRAMC_IER		(AT91_MC + 0xa4)	/* Interrupt Enable Register */
+#define AT91_SDRAMC_IDR		(AT91_MC + 0xa8)	/* Interrupt Disable Register */
+#define AT91_SDRAMC_IMR		(AT91_MC + 0xac)	/* Interrupt Mask Register */
+#define AT91_SDRAMC_ISR		(AT91_MC + 0xb0)	/* Interrupt Status Register */
+
+/* Burst Flash Controller register */
+#define AT91_BFC_MR		(AT91_MC + 0xc0)	/* Mode Register */
+#define		AT91_BFC_BFCOM		(3   <<  0)		/* Burst Flash Controller Operating Mode */
+#define			AT91_BFC_BFCOM_DISABLED	(0 << 0)
+#define			AT91_BFC_BFCOM_ASYNC	(1 << 0)
+#define			AT91_BFC_BFCOM_BURST	(2 << 0)
+#define		AT91_BFC_BFCC		(3   <<  2)		/* Burst Flash Controller Clock */
+#define			AT91_BFC_BFCC_MCK	(1 << 2)
+#define			AT91_BFC_BFCC_DIV2	(2 << 2)
+#define			AT91_BFC_BFCC_DIV4	(3 << 2)
+#define		AT91_BFC_AVL		(0xf <<  4)		/* Address Valid Latency */
+#define		AT91_BFC_PAGES		(7   <<  8)		/* Page Size */
+#define			AT91_BFC_PAGES_NO_PAGE	(0 << 8)
+#define			AT91_BFC_PAGES_16	(1 << 8)
+#define			AT91_BFC_PAGES_32	(2 << 8)
+#define			AT91_BFC_PAGES_64	(3 << 8)
+#define			AT91_BFC_PAGES_128	(4 << 8)
+#define			AT91_BFC_PAGES_256	(5 << 8)
+#define			AT91_BFC_PAGES_512	(6 << 8)
+#define			AT91_BFC_PAGES_1024	(7 << 8)
+#define		AT91_BFC_OEL		(3   << 12)		/* Output Enable Latency */
+#define		AT91_BFC_BAAEN		(1   << 16)		/* Burst Address Advance Enable */
+#define		AT91_BFC_BFOEH		(1   << 17)		/* Burst Flash Output Enable Handling */
+#define		AT91_BFC_MUXEN		(1   << 18)		/* Multiplexed Bus Enable */
+#define		AT91_BFC_RDYEN		(1   << 19)		/* Ready Enable Mode */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91sam9260.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91sam9260.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91sam9260.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,129 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9260.h
+ *
+ * (C) 2006 Andrew Victor
+ *
+ * Common definitions.
+ * Based on AT91SAM9260 datasheet revision A (Preliminary).
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9260_H
+#define AT91SAM9260_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ		0	/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS		1	/* System Peripherals */
+#define AT91SAM9260_ID_PIOA	2	/* Parallel IO Controller A */
+#define AT91SAM9260_ID_PIOB	3	/* Parallel IO Controller B */
+#define AT91SAM9260_ID_PIOC	4	/* Parallel IO Controller C */
+#define AT91SAM9260_ID_ADC	5	/* Analog-to-Digital Converter */
+#define AT91SAM9260_ID_US0	6	/* USART 0 */
+#define AT91SAM9260_ID_US1	7	/* USART 1 */
+#define AT91SAM9260_ID_US2	8	/* USART 2 */
+#define AT91SAM9260_ID_MCI	9	/* Multimedia Card Interface */
+#define AT91SAM9260_ID_UDP	10	/* USB Device Port */
+#define AT91SAM9260_ID_TWI	11	/* Two-Wire Interface */
+#define AT91SAM9260_ID_SPI0	12	/* Serial Peripheral Interface 0 */
+#define AT91SAM9260_ID_SPI1	13	/* Serial Peripheral Interface 1 */
+#define AT91SAM9260_ID_SSC	14	/* Serial Synchronous Controller */
+#define AT91SAM9260_ID_TC0	17	/* Timer Counter 0 */
+#define AT91SAM9260_ID_TC1	18	/* Timer Counter 1 */
+#define AT91SAM9260_ID_TC2	19	/* Timer Counter 2 */
+#define AT91SAM9260_ID_UHP	20	/* USB Host port */
+#define AT91SAM9260_ID_EMAC	21	/* Ethernet */
+#define AT91SAM9260_ID_ISI	22	/* Image Sensor Interface */
+#define AT91SAM9260_ID_US3	23	/* USART 3 */
+#define AT91SAM9260_ID_US4	24	/* USART 4 */
+#define AT91SAM9260_ID_US5	25	/* USART 5 */
+#define AT91SAM9260_ID_TC3	26	/* Timer Counter 3 */
+#define AT91SAM9260_ID_TC4	27	/* Timer Counter 4 */
+#define AT91SAM9260_ID_TC5	28	/* Timer Counter 5 */
+#define AT91SAM9260_ID_IRQ0	29	/* Advanced Interrupt Controller (IRQ0) */
+#define AT91SAM9260_ID_IRQ1	30	/* Advanced Interrupt Controller (IRQ1) */
+#define AT91SAM9260_ID_IRQ2	31	/* Advanced Interrupt Controller (IRQ2) */
+
+
+/*
+ * User Peripheral physical base addresses.
+ */
+#define AT91SAM9260_BASE_TCB0		0xfffa0000
+#define AT91SAM9260_BASE_TC0		0xfffa0000
+#define AT91SAM9260_BASE_TC1		0xfffa0040
+#define AT91SAM9260_BASE_TC2		0xfffa0080
+#define AT91SAM9260_BASE_UDP		0xfffa4000
+#define AT91SAM9260_BASE_MCI		0xfffa8000
+#define AT91SAM9260_BASE_TWI		0xfffac000
+#define AT91SAM9260_BASE_US0		0xfffb0000
+#define AT91SAM9260_BASE_US1		0xfffb4000
+#define AT91SAM9260_BASE_US2		0xfffb8000
+#define AT91SAM9260_BASE_SSC		0xfffbc000
+#define AT91SAM9260_BASE_ISI		0xfffc0000
+#define AT91SAM9260_BASE_EMAC		0xfffc4000
+#define AT91SAM9260_BASE_SPI0		0xfffc8000
+#define AT91SAM9260_BASE_SPI1		0xfffcc000
+#define AT91SAM9260_BASE_US3		0xfffd0000
+#define AT91SAM9260_BASE_US4		0xfffd4000
+#define AT91SAM9260_BASE_US5		0xfffd8000
+#define AT91SAM9260_BASE_TCB1		0xfffdc000
+#define AT91SAM9260_BASE_TC3		0xfffdc000
+#define AT91SAM9260_BASE_TC4		0xfffdc040
+#define AT91SAM9260_BASE_TC5		0xfffdc080
+#define AT91SAM9260_BASE_ADC		0xfffe0000
+#define AT91_BASE_SYS			0xffffe800
+
+/*
+ * System Peripherals (offset from AT91_BASE_SYS)
+ */
+#define AT91_ECC	(0xffffe800 - AT91_BASE_SYS)
+#define AT91_SDRAMC	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_SMC	(0xffffec00 - AT91_BASE_SYS)
+#define AT91_MATRIX	(0xffffee00 - AT91_BASE_SYS)
+#define AT91_CCFG	(0xffffef10 - AT91_BASE_SYS)
+#define AT91_AIC	(0xfffff000 - AT91_BASE_SYS)
+#define AT91_DBGU	(0xfffff200 - AT91_BASE_SYS)
+#define AT91_PIOA	(0xfffff400 - AT91_BASE_SYS)
+#define AT91_PIOB	(0xfffff600 - AT91_BASE_SYS)
+#define AT91_PIOC	(0xfffff800 - AT91_BASE_SYS)
+#define AT91_PMC	(0xfffffc00 - AT91_BASE_SYS)
+#define AT91_RSTC	(0xfffffd00 - AT91_BASE_SYS)
+#define AT91_SHDWC	(0xfffffd10 - AT91_BASE_SYS)
+#define AT91_RTT	(0xfffffd20 - AT91_BASE_SYS)
+#define AT91_PIT	(0xfffffd30 - AT91_BASE_SYS)
+#define AT91_WDT	(0xfffffd40 - AT91_BASE_SYS)
+#define AT91_GPBR	(0xfffffd50 - AT91_BASE_SYS)
+
+
+/*
+ * Internal Memory.
+ */
+#define AT91SAM9260_ROM_BASE	0x00100000	/* Internal ROM base address */
+#define AT91SAM9260_ROM_SIZE	SZ_32K		/* Internal ROM size (32Kb) */
+
+#define AT91SAM9260_SRAM0_BASE	0x00200000	/* Internal SRAM 0 base address */
+#define AT91SAM9260_SRAM0_SIZE	SZ_4K		/* Internal SRAM 0 size (4Kb) */
+#define AT91SAM9260_SRAM1_BASE	0x00300000	/* Internal SRAM 1 base address */
+#define AT91SAM9260_SRAM1_SIZE	SZ_4K		/* Internal SRAM 1 size (4Kb) */
+
+#define AT91SAM9260_UHP_BASE	0x00500000	/* USB Host controller */
+
+#define AT91SAM9XE_FLASH_BASE	0x00200000	/* Internal FLASH base address */
+#define AT91SAM9XE_SRAM_BASE	0x00300000	/* Internal SRAM base address */
+
+
+#if 0
+/*
+ * PIO pin definitions (peripheral A/B multiplexing).
+ */
+
+// TODO: Add
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91sam9260_matrix.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91sam9260_matrix.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91sam9260_matrix.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,78 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9260_matrix.h
+ *
+ * Memory Controllers (MATRIX, EBI) - System peripherals registers.
+ * Based on AT91SAM9260 datasheet revision B.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9260_MATRIX_H
+#define AT91SAM9260_MATRIX_H
+
+#define AT91_MATRIX_MCFG0	(AT91_MATRIX + 0x00)	/* Master Configuration Register 0 */
+#define AT91_MATRIX_MCFG1	(AT91_MATRIX + 0x04)	/* Master Configuration Register 1 */
+#define AT91_MATRIX_MCFG2	(AT91_MATRIX + 0x08)	/* Master Configuration Register 2 */
+#define AT91_MATRIX_MCFG3	(AT91_MATRIX + 0x0C)	/* Master Configuration Register 3 */
+#define AT91_MATRIX_MCFG4	(AT91_MATRIX + 0x10)	/* Master Configuration Register 4 */
+#define AT91_MATRIX_MCFG5	(AT91_MATRIX + 0x14)	/* Master Configuration Register 5 */
+#define		AT91_MATRIX_ULBT		(7 << 0)	/* Undefined Length Burst Type */
+#define			AT91_MATRIX_ULBT_INFINITE	(0 << 0)
+#define			AT91_MATRIX_ULBT_SINGLE		(1 << 0)
+#define			AT91_MATRIX_ULBT_FOUR		(2 << 0)
+#define			AT91_MATRIX_ULBT_EIGHT		(3 << 0)
+#define			AT91_MATRIX_ULBT_SIXTEEN	(4 << 0)
+
+#define AT91_MATRIX_SCFG0	(AT91_MATRIX + 0x40)	/* Slave Configuration Register 0 */
+#define AT91_MATRIX_SCFG1	(AT91_MATRIX + 0x44)	/* Slave Configuration Register 1 */
+#define AT91_MATRIX_SCFG2	(AT91_MATRIX + 0x48)	/* Slave Configuration Register 2 */
+#define AT91_MATRIX_SCFG3	(AT91_MATRIX + 0x4C)	/* Slave Configuration Register 3 */
+#define AT91_MATRIX_SCFG4	(AT91_MATRIX + 0x50)	/* Slave Configuration Register 4 */
+#define		AT91_MATRIX_SLOT_CYCLE		(0xff <<  0)	/* Maximum Number of Allowed Cycles for a Burst */
+#define		AT91_MATRIX_DEFMSTR_TYPE	(3    << 16)	/* Default Master Type */
+#define			AT91_MATRIX_DEFMSTR_TYPE_NONE	(0 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_LAST	(1 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_FIXED	(2 << 16)
+#define		AT91_MATRIX_FIXED_DEFMSTR	(7    << 18)	/* Fixed Index of Default Master */
+#define		AT91_MATRIX_ARBT		(3    << 24)	/* Arbitration Type */
+#define			AT91_MATRIX_ARBT_ROUND_ROBIN	(0 << 24)
+#define			AT91_MATRIX_ARBT_FIXED_PRIORITY	(1 << 24)
+
+#define AT91_MATRIX_PRAS0	(AT91_MATRIX + 0x80)	/* Priority Register A for Slave 0 */
+#define AT91_MATRIX_PRAS1	(AT91_MATRIX + 0x88)	/* Priority Register A for Slave 1 */
+#define AT91_MATRIX_PRAS2	(AT91_MATRIX + 0x90)	/* Priority Register A for Slave 2 */
+#define AT91_MATRIX_PRAS3	(AT91_MATRIX + 0x98)	/* Priority Register A for Slave 3 */
+#define AT91_MATRIX_PRAS4	(AT91_MATRIX + 0xA0)	/* Priority Register A for Slave 4 */
+#define		AT91_MATRIX_M0PR		(3 << 0)	/* Master 0 Priority */
+#define		AT91_MATRIX_M1PR		(3 << 4)	/* Master 1 Priority */
+#define		AT91_MATRIX_M2PR		(3 << 8)	/* Master 2 Priority */
+#define		AT91_MATRIX_M3PR		(3 << 12)	/* Master 3 Priority */
+#define		AT91_MATRIX_M4PR		(3 << 16)	/* Master 4 Priority */
+#define		AT91_MATRIX_M5PR		(3 << 20)	/* Master 5 Priority */
+
+#define AT91_MATRIX_MRCR	(AT91_MATRIX + 0x100)	/* Master Remap Control Register */
+#define		AT91_MATRIX_RCB0		(1 << 0)	/* Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master) */
+#define		AT91_MATRIX_RCB1		(1 << 1)	/* Remap Command for AHB Master 1 (ARM926EJ-S Data Master) */
+
+#define AT91_MATRIX_EBICSA	(AT91_MATRIX + 0x11C)	/* EBI Chip Select Assignment Register */
+#define		AT91_MATRIX_CS1A		(1 << 1)	/* Chip Select 1 Assignment */
+#define			AT91_MATRIX_CS1A_SMC		(0 << 1)
+#define			AT91_MATRIX_CS1A_SDRAMC		(1 << 1)
+#define		AT91_MATRIX_CS3A		(1 << 3)	/* Chip Select 3 Assignment */
+#define			AT91_MATRIX_CS3A_SMC		(0 << 3)
+#define			AT91_MATRIX_CS3A_SMC_SMARTMEDIA	(1 << 3)
+#define		AT91_MATRIX_CS4A		(1 << 4)	/* Chip Select 4 Assignment */
+#define			AT91_MATRIX_CS4A_SMC		(0 << 4)
+#define			AT91_MATRIX_CS4A_SMC_CF1	(1 << 4)
+#define		AT91_MATRIX_CS5A		(1 << 5 )	/* Chip Select 5 Assignment */
+#define			AT91_MATRIX_CS5A_SMC		(0 << 5)
+#define			AT91_MATRIX_CS5A_SMC_CF2	(1 << 5)
+#define		AT91_MATRIX_DBPUC		(1 << 8)	/* Data Bus Pull-up Configuration */
+#define		AT91_MATRIX_VDDIOMSEL		(1 << 16)	/* Memory voltage selection */
+#define			AT91_MATRIX_VDDIOMSEL_1_8V	(0 << 16)
+#define			AT91_MATRIX_VDDIOMSEL_3_3V	(1 << 16)
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91sam9261.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91sam9261.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91sam9261.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,292 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9261.h
+ *
+ * Copyright (C) SAN People
+ *
+ * Common definitions.
+ * Based on AT91SAM9261 datasheet revision E. (Preliminary)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9261_H
+#define AT91SAM9261_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ		0	/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS		1	/* System Peripherals */
+#define AT91SAM9261_ID_PIOA	2	/* Parallel IO Controller A */
+#define AT91SAM9261_ID_PIOB	3	/* Parallel IO Controller B */
+#define AT91SAM9261_ID_PIOC	4	/* Parallel IO Controller C */
+#define AT91SAM9261_ID_US0	6	/* USART 0 */
+#define AT91SAM9261_ID_US1	7	/* USART 1 */
+#define AT91SAM9261_ID_US2	8	/* USART 2 */
+#define AT91SAM9261_ID_MCI	9	/* Multimedia Card Interface */
+#define AT91SAM9261_ID_UDP	10	/* USB Device Port */
+#define AT91SAM9261_ID_TWI	11	/* Two-Wire Interface */
+#define AT91SAM9261_ID_SPI0	12	/* Serial Peripheral Interface 0 */
+#define AT91SAM9261_ID_SPI1	13	/* Serial Peripheral Interface 1 */
+#define AT91SAM9261_ID_SSC0	14	/* Serial Synchronous Controller 0 */
+#define AT91SAM9261_ID_SSC1	15	/* Serial Synchronous Controller 1 */
+#define AT91SAM9261_ID_SSC2	16	/* Serial Synchronous Controller 2 */
+#define AT91SAM9261_ID_TC0	17	/* Timer Counter 0 */
+#define AT91SAM9261_ID_TC1	18	/* Timer Counter 1 */
+#define AT91SAM9261_ID_TC2	19	/* Timer Counter 2 */
+#define AT91SAM9261_ID_UHP	20	/* USB Host port */
+#define AT91SAM9261_ID_LCDC	21	/* LDC Controller */
+#define AT91SAM9261_ID_IRQ0	29	/* Advanced Interrupt Controller (IRQ0) */
+#define AT91SAM9261_ID_IRQ1	30	/* Advanced Interrupt Controller (IRQ1) */
+#define AT91SAM9261_ID_IRQ2	31	/* Advanced Interrupt Controller (IRQ2) */
+
+
+/*
+ * User Peripheral physical base addresses.
+ */
+#define AT91SAM9261_BASE_TCB0		0xfffa0000
+#define AT91SAM9261_BASE_TC0		0xfffa0000
+#define AT91SAM9261_BASE_TC1		0xfffa0040
+#define AT91SAM9261_BASE_TC2		0xfffa0080
+#define AT91SAM9261_BASE_UDP		0xfffa4000
+#define AT91SAM9261_BASE_MCI		0xfffa8000
+#define AT91SAM9261_BASE_TWI		0xfffac000
+#define AT91SAM9261_BASE_US0		0xfffb0000
+#define AT91SAM9261_BASE_US1		0xfffb4000
+#define AT91SAM9261_BASE_US2		0xfffb8000
+#define AT91SAM9261_BASE_SSC0		0xfffbc000
+#define AT91SAM9261_BASE_SSC1		0xfffc0000
+#define AT91SAM9261_BASE_SSC2		0xfffc4000
+#define AT91SAM9261_BASE_SPI0		0xfffc8000
+#define AT91SAM9261_BASE_SPI1		0xfffcc000
+#define AT91_BASE_SYS			0xffffea00
+
+
+/*
+ * System Peripherals (offset from AT91_BASE_SYS)
+ */
+#define AT91_SDRAMC	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_SMC	(0xffffec00 - AT91_BASE_SYS)
+#define AT91_MATRIX	(0xffffee00 - AT91_BASE_SYS)
+#define AT91_AIC	(0xfffff000 - AT91_BASE_SYS)
+#define AT91_DBGU	(0xfffff200 - AT91_BASE_SYS)
+#define AT91_PIOA	(0xfffff400 - AT91_BASE_SYS)
+#define AT91_PIOB	(0xfffff600 - AT91_BASE_SYS)
+#define AT91_PIOC	(0xfffff800 - AT91_BASE_SYS)
+#define AT91_PMC	(0xfffffc00 - AT91_BASE_SYS)
+#define AT91_RSTC	(0xfffffd00 - AT91_BASE_SYS)
+#define AT91_SHDWC	(0xfffffd10 - AT91_BASE_SYS)
+#define AT91_RTT	(0xfffffd20 - AT91_BASE_SYS)
+#define AT91_PIT	(0xfffffd30 - AT91_BASE_SYS)
+#define AT91_WDT	(0xfffffd40 - AT91_BASE_SYS)
+#define AT91_GPBR	(0xfffffd50 - AT91_BASE_SYS)
+
+
+/*
+ * Internal Memory.
+ */
+#define AT91SAM9261_SRAM_BASE	0x00300000	/* Internal SRAM base address */
+#define AT91SAM9261_SRAM_SIZE	0x00028000	/* Internal SRAM size (160Kb) */
+
+#define AT91SAM9261_ROM_BASE	0x00400000	/* Internal ROM base address */
+#define AT91SAM9261_ROM_SIZE	SZ_32K		/* Internal ROM size (32Kb) */
+
+#define AT91SAM9261_UHP_BASE	0x00500000	/* USB Host controller */
+#define AT91SAM9261_LCDC_BASE	0x00600000	/* LDC controller */
+
+
+#if 0
+/*
+ * PIO pin definitions (peripheral A/B multiplexing).
+ */
+#define AT91_PA0_SPI0_MISO	(1 <<  0)	/* A: SPI0 Master In Slave */
+#define AT91_PA0_MCDA0		(1 <<  0)	/* B: Multimedia Card A Data 0 */
+#define AT91_PA1_SPI0_MOSI	(1 <<  1)	/* A: SPI0 Master Out Slave */
+#define AT91_PA1_MCCDA		(1 <<  1)	/* B: Multimedia Card A Command */
+#define AT91_PA2_SPI0_SPCK	(1 <<  2)	/* A: SPI0 Serial Clock */
+#define AT91_PA2_MCCK		(1 <<  2)	/* B: Multimedia Card Clock */
+#define AT91_PA3_SPI0_NPCS0	(1 <<  3)	/* A: SPI0 Peripheral Chip Select 0 */
+#define AT91_PA4_SPI0_NPCS1	(1 <<  4)	/* A: SPI0 Peripheral Chip Select 1 */
+#define AT91_PA4_MCDA1		(1 <<  4)	/* B: Multimedia Card A Data 1 */
+#define AT91_PA5_SPI0_NPCS2	(1 <<  5)	/* A: SPI0 Peripheral Chip Select 2 */
+#define AT91_PA5_MCDA2		(1 <<  5)	/* B: Multimedia Card A Data 2 */
+#define AT91_PA6_SPI0_NPCS3	(1 <<  6)	/* A: SPI0 Peripheral Chip Select 3 */
+#define AT91_PA6_MCDA3		(1 <<  6)	/* B: Multimedia Card A Data 3 */
+#define AT91_PA7_TWD		(1 <<  7)	/* A: TWI Two-wire Serial Data */
+#define AT91_PA7_PCK0		(1 <<  7)	/* B: PMC Programmable clock Output 0 */
+#define AT91_PA8_TWCK		(1 <<  8)	/* A: TWI Two-wire Serial Clock */
+#define AT91_PA8_PCK1		(1 <<  8)	/* B: PMC Programmable clock Output 1 */
+#define AT91_PA9_DRXD		(1 <<  9)	/* A: DBGU Debug Receive Data */
+#define AT91_PA9_PCK2		(1 <<  9)	/* B: PMC Programmable clock Output 2 */
+#define AT91_PA10_DTXD		(1 << 10)	/* A: DBGU Debug Transmit Data */
+#define AT91_PA10_PCK3		(1 << 10)	/* B: PMC Programmable clock Output 3 */
+#define AT91_PA11_TSYNC		(1 << 11)	/* A: Trace Synchronization Signal */
+#define AT91_PA11_SCK1		(1 << 11)	/* B: USART1 Serial Clock */
+#define AT91_PA12_TCLK		(1 << 12)	/* A: Trace Clock */
+#define AT91_PA12_RTS1		(1 << 12)	/* B: USART1 Ready To Send */
+#define AT91_PA13_TPS0		(1 << 13)	/* A: Trace ARM Pipeline Status 0 */
+#define AT91_PA13_CTS1		(1 << 13)	/* B: USART1 Clear To Send */
+#define AT91_PA14_TPS1		(1 << 14)	/* A: Trace ARM Pipeline Status 1 */
+#define AT91_PA14_SCK2		(1 << 14)	/* B: USART2 Serial Clock */
+#define AT91_PA15_TPS2		(1 << 15)	/* A: Trace ARM Pipeline Status 2 */
+#define AT91_PA15_RTS2		(1 << 15)	/* B: USART2 Ready To Send */
+#define AT91_PA16_TPK0		(1 << 16)	/* A: Trace Packet Port 0 */
+#define AT91_PA16_CTS2		(1 << 16)	/* B: USART2 Clear To Send */
+#define AT91_PA17_TPK1		(1 << 17)	/* A: Trace Packet Port 1 */
+#define AT91_PA17_TF1		(1 << 17)	/* B: SSC1 Transmit Frame Sync */
+#define AT91_PA18_TPK2		(1 << 18)	/* A: Trace Packet Port 2 */
+#define AT91_PA18_TK1		(1 << 18)	/* B: SSC1 Transmit Clock */
+#define AT91_PA19_TPK3		(1 << 19)	/* A: Trace Packet Port 3 */
+#define AT91_PA19_TD1		(1 << 19)	/* B: SSC1 Transmit Data */
+#define AT91_PA20_TPK4		(1 << 20)	/* A: Trace Packet Port 4 */
+#define AT91_PA20_RD1		(1 << 20)	/* B: SSC1 Receive Data */
+#define AT91_PA21_TPK5		(1 << 21)	/* A: Trace Packet Port 5 */
+#define AT91_PA21_RK1		(1 << 21)	/* B: SSC1 Receive Clock */
+#define AT91_PA22_TPK6		(1 << 22)	/* A: Trace Packet Port 6 */
+#define AT91_PA22_RF1		(1 << 22)	/* B: SSC1 Receive Frame Sync */
+#define AT91_PA23_TPK7		(1 << 23)	/* A: Trace Packet Port 7 */
+#define AT91_PA23_RTS0		(1 << 23)	/* B: USART0 Ready To Send */
+#define AT91_PA24_TPK8		(1 << 24)	/* A: Trace Packet Port 8 */
+#define AT91_PA24_SPI1_NPCS1	(1 << 24)	/* B: SPI1 Peripheral Chip Select 1 */
+#define AT91_PA25_TPK9		(1 << 25)	/* A: Trace Packet Port 9 */
+#define AT91_PA25_SPI1_NPCS2	(1 << 25)	/* B: SPI1 Peripheral Chip Select 2 */
+#define AT91_PA26_TPK10		(1 << 26)	/* A: Trace Packet Port 10 */
+#define AT91_PA26_SPI1_NPCS3	(1 << 26)	/* B: SPI1 Peripheral Chip Select 3 */
+#define AT91_PA27_TPK11		(1 << 27)	/* A: Trace Packet Port 11 */
+#define AT91_PA27_SPI0_NPCS1	(1 << 27)	/* B: SPI0 Peripheral Chip Select 1 */
+#define AT91_PA28_TPK12		(1 << 28)	/* A: Trace Packet Port 12 */
+#define AT91_PA28_SPI0_NPCS2	(1 << 28)	/* B: SPI0 Peripheral Chip Select 2 */
+#define AT91_PA29_TPK13		(1 << 29)	/* A: Trace Packet Port 13 */
+#define AT91_PA29_SPI0_NPCS3	(1 << 29)	/* B: SPI0 Peripheral Chip Select 3 */
+#define AT91_PA30_TPK14		(1 << 30)	/* A: Trace Packet Port 14 */
+#define AT91_PA30_A23		(1 << 30)	/* B: Address Bus bit 23 */
+#define AT91_PA31_TPK15		(1 << 31)	/* A: Trace Packet Port 15 */
+#define AT91_PA31_A24		(1 << 31)	/* B: Address Bus bit 24 */
+
+#define AT91_PB0_LCDVSYNC	(1 <<  0)	/* A: LCD Vertical Synchronization */
+#define AT91_PB1_LCDHSYNC	(1 <<  1)	/* A: LCD Horizontal Synchronization */
+#define AT91_PB2_LCDDOTCK	(1 <<  2)	/* A: LCD Dot Clock */
+#define AT91_PB2_PCK0		(1 <<  2)	/* B: PMC Programmable clock Output 0 */
+#define AT91_PB3_LCDDEN		(1 <<  3)	/* A: LCD Data Enable */
+#define AT91_PB4_LCDCC		(1 <<  4)	/* A: LCD Contrast Control */
+#define AT91_PB4_LCDD2		(1 <<  4)	/* B: LCD Data Bus Bit 2 */
+#define AT91_PB5_LCDD0		(1 <<  5)	/* A: LCD Data Bus Bit 0 */
+#define AT91_PB5_LCDD3		(1 <<  5)	/* B: LCD Data Bus Bit 3 */
+#define AT91_PB6_LCDD1		(1 <<  6)	/* A: LCD Data Bus Bit 1 */
+#define AT91_PB6_LCDD4		(1 <<  6)	/* B: LCD Data Bus Bit 4 */
+#define AT91_PB7_LCDD2		(1 <<  7)	/* A: LCD Data Bus Bit 2 */
+#define AT91_PB7_LCDD5		(1 <<  7)	/* B: LCD Data Bus Bit 5 */
+#define AT91_PB8_LCDD3		(1 <<  8)	/* A: LCD Data Bus Bit 3 */
+#define AT91_PB8_LCDD6		(1 <<  8)	/* B: LCD Data Bus Bit 6 */
+#define AT91_PB9_LCDD4		(1 <<  9)	/* A: LCD Data Bus Bit 4 */
+#define AT91_PB9_LCDD7		(1 <<  9)	/* B: LCD Data Bus Bit 7 */
+#define AT91_PB10_LCDD5		(1 << 10)	/* A: LCD Data Bus Bit 5 */
+#define AT91_PB10_LCDD10	(1 << 10)	/* B: LCD Data Bus Bit 10 */
+#define AT91_PB11_LCDD6		(1 << 11)	/* A: LCD Data Bus Bit 6 */
+#define AT91_PB11_LCDD11	(1 << 11)	/* B: LCD Data Bus Bit 11 */
+#define AT91_PB12_LCDD7		(1 << 12)	/* A: LCD Data Bus Bit 7 */
+#define AT91_PB12_LCDD12	(1 << 12)	/* B: LCD Data Bus Bit 12 */
+#define AT91_PB13_LCDD8		(1 << 13)	/* A: LCD Data Bus Bit 8 */
+#define AT91_PB13_LCDD13	(1 << 13)	/* B: LCD Data Bus Bit 13 */
+#define AT91_PB14_LCDD9		(1 << 14)	/* A: LCD Data Bus Bit 9 */
+#define AT91_PB14_LCDD14	(1 << 14)	/* B: LCD Data Bus Bit 14 */
+#define AT91_PB15_LCDD10	(1 << 15)	/* A: LCD Data Bus Bit 10 */
+#define AT91_PB15_LCDD15	(1 << 15)	/* B: LCD Data Bus Bit 15 */
+#define AT91_PB16_LCDD11	(1 << 16)	/* A: LCD Data Bus Bit 11 */
+#define AT91_PB16_LCDD19	(1 << 16)	/* B: LCD Data Bus Bit 19 */
+#define AT91_PB17_LCDD12	(1 << 17)	/* A: LCD Data Bus Bit 12 */
+#define AT91_PB17_LCDD20	(1 << 17)	/* B: LCD Data Bus Bit 20 */
+#define AT91_PB18_LCDD13	(1 << 18)	/* A: LCD Data Bus Bit 13 */
+#define AT91_PB18_LCDD21	(1 << 18)	/* B: LCD Data Bus Bit 21 */
+#define AT91_PB19_LCDD14	(1 << 19)	/* A: LCD Data Bus Bit 14 */
+#define AT91_PB19_LCDD22	(1 << 19)	/* B: LCD Data Bus Bit 22 */
+#define AT91_PB20_LCDD15	(1 << 20)	/* A: LCD Data Bus Bit 15 */
+#define AT91_PB20_LCDD23	(1 << 20)	/* B: LCD Data Bus Bit 23 */
+#define AT91_PB21_TF0		(1 << 21)	/* A: SSC0 Transmit Frame Sync */
+#define AT91_PB21_LCDD16	(1 << 21)	/* B: LCD Data Bus Bit 16 */
+#define AT91_PB22_TK0		(1 << 22)	/* A: SSC0 Transmit Clock */
+#define AT91_PB22_LCDD17	(1 << 22)	/* B: LCD Data Bus Bit 17 */
+#define AT91_PB23_TD0		(1 << 23)	/* A: SSC0 Transmit Data */
+#define AT91_PB23_LCDD18	(1 << 23)	/* B: LCD Data Bus Bit 18 */
+#define AT91_PB24_RD0		(1 << 24)	/* A: SSC0 Receive Data */
+#define AT91_PB24_LCDD19	(1 << 24)	/* B: LCD Data Bus Bit 19 */
+#define AT91_PB25_RK0		(1 << 25)	/* A: SSC0 Receive Clock */
+#define AT91_PB25_LCDD20	(1 << 25)	/* B: LCD Data Bus Bit 20 */
+#define AT91_PB26_RF0		(1 << 26)	/* A: SSC0 Receive Frame Sync */
+#define AT91_PB26_LCDD21	(1 << 26)	/* B: LCD Data Bus Bit 21 */
+#define AT91_PB27_SPI1_NPCS1	(1 << 27)	/* A: SPI1 Peripheral Chip Select 1 */
+#define AT91_PB27_LCDD22	(1 << 27)	/* B: LCD Data Bus Bit 22 */
+#define AT91_PB28_SPI1_NPCS0	(1 << 28)	/* A: SPI1 Peripheral Chip Select 0 */
+#define AT91_PB28_LCDD23	(1 << 28)	/* B: LCD Data Bus Bit 23 */
+#define AT91_PB29_SPI1_SPCK	(1 << 29)	/* A: SPI1 Serial Clock */
+#define AT91_PB29_IRQ2		(1 << 29)	/* B: Interrupt input 2 */
+#define AT91_PB30_SPI1_MISO	(1 << 30)	/* A: SPI1 Master In Slave */
+#define AT91_PB30_IRQ1		(1 << 30)	/* B: Interrupt input 1 */
+#define AT91_PB31_SPI1_MOSI	(1 << 31)	/* A: SPI1 Master Out Slave */
+#define AT91_PB31_PCK2		(1 << 31)	/* B: PMC Programmable clock Output 2 */
+
+#define AT91_PC0_SMOE		(1 << 0)	/* A: SmartMedia Output Enable */
+#define AT91_PC0_NCS6		(1 << 0)	/* B: Chip Select 6 */
+#define AT91_PC1_SMWE		(1 << 1)	/* A: SmartMedia Write Enable */
+#define AT91_PC1_NCS7		(1 << 1)	/* B: Chip Select 7 */
+#define AT91_PC2_NWAIT		(1 << 2)	/* A: NWAIT */
+#define AT91_PC2_IRQ0		(1 << 2)	/* B: Interrupt input 0 */
+#define AT91_PC3_A25_CFRNW	(1 << 3)	/* A: Address Bus[25] / Compact Flash Read Not Write */
+#define AT91_PC4_NCS4_CFCS0	(1 << 4)	/* A: Chip Select 4 / CompactFlash Chip Select 0 */
+#define AT91_PC5_NCS5_CFCS1	(1 << 5)	/* A: Chip Select 5 / CompactFlash Chip Select 1 */
+#define AT91_PC6_CFCE1		(1 << 6)	/* A: CompactFlash Chip Enable 1 */
+#define AT91_PC7_CFCE2		(1 << 7)	/* A: CompactFlash Chip Enable 2 */
+#define AT91_PC8_TXD0		(1 << 8)	/* A: USART0 Transmit Data */
+#define AT91_PC8_PCK2		(1 << 8)	/* B: PMC Programmable clock Output 2 */
+#define AT91_PC9_RXD0		(1 << 9)	/* A: USART0 Receive Data */
+#define AT91_PC9_PCK3		(1 << 9)	/* B: PMC Programmable clock Output 3 */
+#define AT91_PC10_RTS0		(1 << 10)	/* A: USART0 Ready To Send */
+#define AT91_PC10_SCK0		(1 << 10)	/* B: USART0 Serial Clock */
+#define AT91_PC11_CTS0		(1 << 11)	/* A: USART0 Clear To Send */
+#define AT91_PC11_FIQ		(1 << 11)	/* B: AIC Fast Interrupt Input */
+#define AT91_PC12_TXD1		(1 << 12)	/* A: USART1 Transmit Data */
+#define AT91_PC12_NCS6		(1 << 12)	/* B: Chip Select 6 */
+#define AT91_PC13_RXD1		(1 << 13)	/* A: USART1 Receive Data */
+#define AT91_PC13_NCS7		(1 << 13)	/* B: Chip Select 7 */
+#define AT91_PC14_TXD2		(1 << 14)	/* A: USART2 Transmit Data */
+#define AT91_PC14_SPI1_NPCS2	(1 << 14)	/* B: SPI1 Peripheral Chip Select 2 */
+#define AT91_PC15_RXD2		(1 << 15)	/* A: USART2 Receive Data */
+#define AT91_PC15_SPI1_NPCS3	(1 << 15)	/* B: SPI1 Peripheral Chip Select 3 */
+#define AT91_PC16_D16		(1 << 16)	/* A: Data Bus [16] */
+#define AT91_PC16_TCLK0		(1 << 16)	/* B: Timer Counter 0 external clock input */
+#define AT91_PC17_D17		(1 << 17)	/* A: Data Bus [17] */
+#define AT91_PC17_TCLK1		(1 << 17)	/* B: Timer Counter 1 external clock input */
+#define AT91_PC18_D18		(1 << 18)	/* A: Data Bus [18] */
+#define AT91_PC18_TCLK2		(1 << 18)	/* B: Timer Counter 2 external clock input */
+#define AT91_PC19_D19		(1 << 19)	/* A: Data Bus [19] */
+#define AT91_PC19_TIOA0		(1 << 19)	/* B: Timer Counter 0 Multipurpose Timer I/O Pin A */
+#define AT91_PC20_D20		(1 << 20)	/* A: Data Bus [20] */
+#define AT91_PC20_TIOB0		(1 << 20)	/* B: Timer Counter 0 Multipurpose Timer I/O Pin B */
+#define AT91_PC21_D21		(1 << 21)	/* A: Data Bus [21] */
+#define AT91_PC21_TIOA1		(1 << 21)	/* B: Timer Counter 1 Multipurpose Timer I/O Pin A */
+#define AT91_PC22_D22		(1 << 22)	/* A: Data Bus [22] */
+#define AT91_PC22_TIOB1		(1 << 22)	/* B: Timer Counter 1 Multipurpose Timer I/O Pin B */
+#define AT91_PC23_D23		(1 << 23)	/* A: Data Bus [23] */
+#define AT91_PC23_TIOA2		(1 << 23)	/* B: Timer Counter 2 Multipurpose Timer I/O Pin A */
+#define AT91_PC24_D24		(1 << 24)	/* A: Data Bus [24] */
+#define AT91_PC24_TIOB2		(1 << 24)	/* B: Timer Counter 2 Multipurpose Timer I/O Pin B */
+#define AT91_PC25_D25		(1 << 25)	/* A: Data Bus [25] */
+#define AT91_PC25_TF2		(1 << 25)	/* B: SSC2 Transmit Frame Sync */
+#define AT91_PC26_D26		(1 << 26)	/* A: Data Bus [26] */
+#define AT91_PC26_TK2		(1 << 26)	/* B: SSC2 Transmit Clock */
+#define AT91_PC27_D27		(1 << 27)	/* A: Data Bus [27] */
+#define AT91_PC27_TD2		(1 << 27)	/* B: SSC2 Transmit Data */
+#define AT91_PC28_D28		(1 << 28)	/* A: Data Bus [28] */
+#define AT91_PC28_RD2		(1 << 28)	/* B: SSC2 Receive Data */
+#define AT91_PC29_D29		(1 << 29)	/* A: Data Bus [29] */
+#define AT91_PC29_RK2		(1 << 29)	/* B: SSC2 Receive Clock */
+#define AT91_PC30_D30		(1 << 30)	/* A: Data Bus [30] */
+#define AT91_PC30_RF2		(1 << 30)	/* B: SSC2 Receive Frame Sync */
+#define AT91_PC31_D31		(1 << 31)	/* A: Data Bus [31] */
+#define AT91_PC31_PCK1		(1 << 31)	/* B: PMC Programmable clock Output 1 */
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91sam9261_matrix.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91sam9261_matrix.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91sam9261_matrix.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,62 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9261_matrix.h
+ *
+ * Memory Controllers (MATRIX, EBI) - System peripherals registers.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9261_MATRIX_H
+#define AT91SAM9261_MATRIX_H
+
+#define AT91_MATRIX_MCFG	(AT91_MATRIX + 0x00)	/* Master Configuration Register */
+#define		AT91_MATRIX_RCB0	(1 << 0)		/* Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master) */
+#define		AT91_MATRIX_RCB1	(1 << 1)		/* Remap Command for AHB Master 1 (ARM926EJ-S Data Master) */
+
+#define AT91_MATRIX_SCFG0	(AT91_MATRIX + 0x04)	/* Slave Configuration Register 0 */
+#define AT91_MATRIX_SCFG1	(AT91_MATRIX + 0x08)	/* Slave Configuration Register 1 */
+#define AT91_MATRIX_SCFG2	(AT91_MATRIX + 0x0C)	/* Slave Configuration Register 2 */
+#define AT91_MATRIX_SCFG3	(AT91_MATRIX + 0x10)	/* Slave Configuration Register 3 */
+#define AT91_MATRIX_SCFG4	(AT91_MATRIX + 0x14)	/* Slave Configuration Register 4 */
+#define		AT91_MATRIX_SLOT_CYCLE		(0xff << 0)	/* Maximum Number of Allowed Cycles for a Burst */
+#define		AT91_MATRIX_DEFMSTR_TYPE	(3    << 16)	/* Default Master Type */
+#define			AT91_MATRIX_DEFMSTR_TYPE_NONE	(0 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_LAST	(1 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_FIXED	(2 << 16)
+#define		AT91_MATRIX_FIXED_DEFMSTR	(7    << 18)	/* Fixed Index of Default Master */
+
+#define AT91_MATRIX_TCR		(AT91_MATRIX + 0x24)	/* TCM Configuration Register */
+#define		AT91_MATRIX_ITCM_SIZE		(0xf << 0)	/* Size of ITCM enabled memory block */
+#define			AT91_MATRIX_ITCM_0		(0 << 0)
+#define			AT91_MATRIX_ITCM_16		(5 << 0)
+#define			AT91_MATRIX_ITCM_32		(6 << 0)
+#define			AT91_MATRIX_ITCM_64		(7 << 0)
+#define		AT91_MATRIX_DTCM_SIZE		(0xf << 4)	/* Size of DTCM enabled memory block */
+#define			AT91_MATRIX_DTCM_0		(0 << 4)
+#define			AT91_MATRIX_DTCM_16		(5 << 4)
+#define			AT91_MATRIX_DTCM_32		(6 << 4)
+#define			AT91_MATRIX_DTCM_64		(7 << 4)
+
+#define AT91_MATRIX_EBICSA	(AT91_MATRIX + 0x30)	/* EBI Chip Select Assignment Register */
+#define		AT91_MATRIX_CS1A		(1 << 1)	/* Chip Select 1 Assignment */
+#define			AT91_MATRIX_CS1A_SMC		(0 << 1)
+#define			AT91_MATRIX_CS1A_SDRAMC		(1 << 1)
+#define		AT91_MATRIX_CS3A		(1 << 3)	/* Chip Select 3 Assignment */
+#define			AT91_MATRIX_CS3A_SMC		(0 << 3)
+#define			AT91_MATRIX_CS3A_SMC_SMARTMEDIA	(1 << 3)
+#define		AT91_MATRIX_CS4A		(1 << 4)	/* Chip Select 4 Assignment */
+#define			AT91_MATRIX_CS4A_SMC		(0 << 4)
+#define			AT91_MATRIX_CS4A_SMC_CF1	(1 << 4)
+#define		AT91_MATRIX_CS5A		(1 << 5)	/* Chip Select 5 Assignment */
+#define			AT91_MATRIX_CS5A_SMC		(0 << 5)
+#define			AT91_MATRIX_CS5A_SMC_CF2	(1 << 5)
+#define		AT91_MATRIX_DBPUC		(1 << 8)	/* Data Bus Pull-up Configuration */
+
+#define AT91_MATRIX_USBPUCR	(AT91_MATRIX + 0x34)	/* USB Pad Pull-Up Control Register */
+#define		AT91_MATRIX_USBPUCR_PUON	(1 << 30)	/* USB Device PAD Pull-up Enable */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91sam9263.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91sam9263.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91sam9263.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,131 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9263.h
+ *
+ * (C) 2007 Atmel Corporation.
+ *
+ * Common definitions.
+ * Based on AT91SAM9263 datasheet revision B (Preliminary).
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9263_H
+#define AT91SAM9263_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ		0	/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS		1	/* System Peripherals */
+#define AT91SAM9263_ID_PIOA	2	/* Parallel IO Controller A */
+#define AT91SAM9263_ID_PIOB	3	/* Parallel IO Controller B */
+#define AT91SAM9263_ID_PIOCDE	4	/* Parallel IO Controller C, D and E */
+#define AT91SAM9263_ID_US0	7	/* USART 0 */
+#define AT91SAM9263_ID_US1	8	/* USART 1 */
+#define AT91SAM9263_ID_US2	9	/* USART 2 */
+#define AT91SAM9263_ID_MCI0	10	/* Multimedia Card Interface 0 */
+#define AT91SAM9263_ID_MCI1	11	/* Multimedia Card Interface 1 */
+#define AT91SAM9263_ID_CAN	12	/* CAN */
+#define AT91SAM9263_ID_TWI	13	/* Two-Wire Interface */
+#define AT91SAM9263_ID_SPI0	14	/* Serial Peripheral Interface 0 */
+#define AT91SAM9263_ID_SPI1	15	/* Serial Peripheral Interface 1 */
+#define AT91SAM9263_ID_SSC0	16	/* Serial Synchronous Controller 0 */
+#define AT91SAM9263_ID_SSC1	17	/* Serial Synchronous Controller 1 */
+#define AT91SAM9263_ID_AC97C	18	/* AC97 Controller */
+#define AT91SAM9263_ID_TCB	19	/* Timer Counter 0, 1 and 2 */
+#define AT91SAM9263_ID_PWMC	20	/* Pulse Width Modulation Controller */
+#define AT91SAM9263_ID_EMAC	21	/* Ethernet */
+#define AT91SAM9263_ID_2DGE	23	/* 2D Graphic Engine */
+#define AT91SAM9263_ID_UDP	24	/* USB Device Port */
+#define AT91SAM9263_ID_ISI	25	/* Image Sensor Interface */
+#define AT91SAM9263_ID_LCDC	26	/* LCD Controller */
+#define AT91SAM9263_ID_DMA	27	/* DMA Controller */
+#define AT91SAM9263_ID_UHP	29	/* USB Host port */
+#define AT91SAM9263_ID_IRQ0	30	/* Advanced Interrupt Controller (IRQ0) */
+#define AT91SAM9263_ID_IRQ1	31	/* Advanced Interrupt Controller (IRQ1) */
+
+
+/*
+ * User Peripheral physical base addresses.
+ */
+#define AT91SAM9263_BASE_UDP		0xfff78000
+#define AT91SAM9263_BASE_TCB0		0xfff7c000
+#define AT91SAM9263_BASE_TC0		0xfff7c000
+#define AT91SAM9263_BASE_TC1		0xfff7c040
+#define AT91SAM9263_BASE_TC2		0xfff7c080
+#define AT91SAM9263_BASE_MCI0		0xfff80000
+#define AT91SAM9263_BASE_MCI1		0xfff84000
+#define AT91SAM9263_BASE_TWI		0xfff88000
+#define AT91SAM9263_BASE_US0		0xfff8c000
+#define AT91SAM9263_BASE_US1		0xfff90000
+#define AT91SAM9263_BASE_US2		0xfff94000
+#define AT91SAM9263_BASE_SSC0		0xfff98000
+#define AT91SAM9263_BASE_SSC1		0xfff9c000
+#define AT91SAM9263_BASE_AC97C		0xfffa0000
+#define AT91SAM9263_BASE_SPI0		0xfffa4000
+#define AT91SAM9263_BASE_SPI1		0xfffa8000
+#define AT91SAM9263_BASE_CAN		0xfffac000
+#define AT91SAM9263_BASE_PWMC		0xfffb8000
+#define AT91SAM9263_BASE_EMAC		0xfffbc000
+#define AT91SAM9263_BASE_ISI		0xfffc4000
+#define AT91SAM9263_BASE_2DGE		0xfffc8000
+#define AT91_BASE_SYS			0xffffe000
+
+/*
+ * System Peripherals (offset from AT91_BASE_SYS)
+ */
+#define AT91_ECC0	(0xffffe000 - AT91_BASE_SYS)
+#define AT91_SDRAMC0	(0xffffe200 - AT91_BASE_SYS)
+#define AT91_SMC0	(0xffffe400 - AT91_BASE_SYS)
+#define AT91_ECC1	(0xffffe600 - AT91_BASE_SYS)
+#define AT91_SDRAMC1	(0xffffe800 - AT91_BASE_SYS)
+#define AT91_SMC1	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_MATRIX	(0xffffec00 - AT91_BASE_SYS)
+#define AT91_CCFG	(0xffffed10 - AT91_BASE_SYS)
+#define AT91_DBGU	(0xffffee00 - AT91_BASE_SYS)
+#define AT91_AIC	(0xfffff000 - AT91_BASE_SYS)
+#define AT91_PIOA	(0xfffff200 - AT91_BASE_SYS)
+#define AT91_PIOB	(0xfffff400 - AT91_BASE_SYS)
+#define AT91_PIOC	(0xfffff600 - AT91_BASE_SYS)
+#define AT91_PIOD	(0xfffff800 - AT91_BASE_SYS)
+#define AT91_PIOE	(0xfffffa00 - AT91_BASE_SYS)
+#define AT91_PMC	(0xfffffc00 - AT91_BASE_SYS)
+#define AT91_RSTC	(0xfffffd00 - AT91_BASE_SYS)
+#define AT91_SHDWC	(0xfffffd10 - AT91_BASE_SYS)
+#define AT91_RTT0	(0xfffffd20 - AT91_BASE_SYS)
+#define AT91_PIT	(0xfffffd30 - AT91_BASE_SYS)
+#define AT91_WDT	(0xfffffd40 - AT91_BASE_SYS)
+#define AT91_RTT1	(0xfffffd50 - AT91_BASE_SYS)
+#define AT91_GPBR	(0xfffffd60 - AT91_BASE_SYS)
+
+#define AT91_SMC	AT91_SMC0
+
+/*
+ * Internal Memory.
+ */
+#define AT91SAM9263_SRAM0_BASE	0x00300000	/* Internal SRAM 0 base address */
+#define AT91SAM9263_SRAM0_SIZE	(80 * SZ_1K)	/* Internal SRAM 0 size (80Kb) */
+
+#define AT91SAM9263_ROM_BASE	0x00400000	/* Internal ROM base address */
+#define AT91SAM9263_ROM_SIZE	SZ_128K		/* Internal ROM size (128Kb) */
+
+#define AT91SAM9263_SRAM1_BASE	0x00500000	/* Internal SRAM 1 base address */
+#define AT91SAM9263_SRAM1_SIZE	SZ_16K		/* Internal SRAM 1 size (16Kb) */
+
+#define AT91SAM9263_LCDC_BASE	0x00700000	/* LCD Controller */
+#define AT91SAM9263_DMAC_BASE	0x00800000	/* DMA Controller */
+#define AT91SAM9263_UHP_BASE	0x00a00000	/* USB Host controller */
+
+#if 0
+/*
+ * PIO pin definitions (peripheral A/B multiplexing).
+ */
+
+// TODO: Add
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91sam9263_matrix.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91sam9263_matrix.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91sam9263_matrix.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,129 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9263_matrix.h
+ *
+ *  Copyright (C) 2006 Atmel Corporation.
+ *
+ * Memory Controllers (MATRIX, EBI) - System peripherals registers.
+ * Based on AT91SAM9263 datasheet revision B (Preliminary).
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9263_MATRIX_H
+#define AT91SAM9263_MATRIX_H
+
+#define AT91_MATRIX_MCFG0	(AT91_MATRIX + 0x00)	/* Master Configuration Register 0 */
+#define AT91_MATRIX_MCFG1	(AT91_MATRIX + 0x04)	/* Master Configuration Register 1 */
+#define AT91_MATRIX_MCFG2	(AT91_MATRIX + 0x08)	/* Master Configuration Register 2 */
+#define AT91_MATRIX_MCFG3	(AT91_MATRIX + 0x0C)	/* Master Configuration Register 3 */
+#define AT91_MATRIX_MCFG4	(AT91_MATRIX + 0x10)	/* Master Configuration Register 4 */
+#define AT91_MATRIX_MCFG5	(AT91_MATRIX + 0x14)	/* Master Configuration Register 5 */
+#define AT91_MATRIX_MCFG6	(AT91_MATRIX + 0x18)	/* Master Configuration Register 6 */
+#define AT91_MATRIX_MCFG7	(AT91_MATRIX + 0x1C)	/* Master Configuration Register 7 */
+#define AT91_MATRIX_MCFG8	(AT91_MATRIX + 0x20)	/* Master Configuration Register 8 */
+#define		AT91_MATRIX_ULBT	(7 << 0)	/* Undefined Length Burst Type */
+#define			AT91_MATRIX_ULBT_INFINITE	(0 << 0)
+#define			AT91_MATRIX_ULBT_SINGLE		(1 << 0)
+#define			AT91_MATRIX_ULBT_FOUR		(2 << 0)
+#define			AT91_MATRIX_ULBT_EIGHT		(3 << 0)
+#define			AT91_MATRIX_ULBT_SIXTEEN	(4 << 0)
+
+#define AT91_MATRIX_SCFG0	(AT91_MATRIX + 0x40)	/* Slave Configuration Register 0 */
+#define AT91_MATRIX_SCFG1	(AT91_MATRIX + 0x44)	/* Slave Configuration Register 1 */
+#define AT91_MATRIX_SCFG2	(AT91_MATRIX + 0x48)	/* Slave Configuration Register 2 */
+#define AT91_MATRIX_SCFG3	(AT91_MATRIX + 0x4C)	/* Slave Configuration Register 3 */
+#define AT91_MATRIX_SCFG4	(AT91_MATRIX + 0x50)	/* Slave Configuration Register 4 */
+#define AT91_MATRIX_SCFG5	(AT91_MATRIX + 0x54)	/* Slave Configuration Register 5 */
+#define AT91_MATRIX_SCFG6	(AT91_MATRIX + 0x58)	/* Slave Configuration Register 6 */
+#define AT91_MATRIX_SCFG7	(AT91_MATRIX + 0x5C)	/* Slave Configuration Register 7 */
+#define		AT91_MATRIX_SLOT_CYCLE		(0xff << 0)	/* Maximum Number of Allowed Cycles for a Burst */
+#define		AT91_MATRIX_DEFMSTR_TYPE	(3    << 16)	/* Default Master Type */
+#define			AT91_MATRIX_DEFMSTR_TYPE_NONE	(0 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_LAST	(1 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_FIXED	(2 << 16)
+#define		AT91_MATRIX_FIXED_DEFMSTR	(7    << 18)	/* Fixed Index of Default Master */
+#define		AT91_MATRIX_ARBT		(3    << 24)	/* Arbitration Type */
+#define			AT91_MATRIX_ARBT_ROUND_ROBIN	(0 << 24)
+#define			AT91_MATRIX_ARBT_FIXED_PRIORITY	(1 << 24)
+
+#define AT91_MATRIX_PRAS0	(AT91_MATRIX + 0x80)	/* Priority Register A for Slave 0 */
+#define AT91_MATRIX_PRBS0	(AT91_MATRIX + 0x84)	/* Priority Register B for Slave 0 */
+#define AT91_MATRIX_PRAS1	(AT91_MATRIX + 0x88)	/* Priority Register A for Slave 1 */
+#define AT91_MATRIX_PRBS1	(AT91_MATRIX + 0x8C)	/* Priority Register B for Slave 1 */
+#define AT91_MATRIX_PRAS2	(AT91_MATRIX + 0x90)	/* Priority Register A for Slave 2 */
+#define AT91_MATRIX_PRBS2	(AT91_MATRIX + 0x94)	/* Priority Register B for Slave 2 */
+#define AT91_MATRIX_PRAS3	(AT91_MATRIX + 0x98)	/* Priority Register A for Slave 3 */
+#define AT91_MATRIX_PRBS3	(AT91_MATRIX + 0x9C)	/* Priority Register B for Slave 3 */
+#define AT91_MATRIX_PRAS4	(AT91_MATRIX + 0xA0)	/* Priority Register A for Slave 4 */
+#define AT91_MATRIX_PRBS4	(AT91_MATRIX + 0xA4)	/* Priority Register B for Slave 4 */
+#define AT91_MATRIX_PRAS5	(AT91_MATRIX + 0xA8)	/* Priority Register A for Slave 5 */
+#define AT91_MATRIX_PRBS5	(AT91_MATRIX + 0xAC)	/* Priority Register B for Slave 5 */
+#define AT91_MATRIX_PRAS6	(AT91_MATRIX + 0xB0)	/* Priority Register A for Slave 6 */
+#define AT91_MATRIX_PRBS6	(AT91_MATRIX + 0xB4)	/* Priority Register B for Slave 6 */
+#define AT91_MATRIX_PRAS7	(AT91_MATRIX + 0xB8)	/* Priority Register A for Slave 7 */
+#define AT91_MATRIX_PRBS7	(AT91_MATRIX + 0xBC)	/* Priority Register B for Slave 7 */
+#define		AT91_MATRIX_M0PR		(3 << 0)	/* Master 0 Priority */
+#define		AT91_MATRIX_M1PR		(3 << 4)	/* Master 1 Priority */
+#define		AT91_MATRIX_M2PR		(3 << 8)	/* Master 2 Priority */
+#define		AT91_MATRIX_M3PR		(3 << 12)	/* Master 3 Priority */
+#define		AT91_MATRIX_M4PR		(3 << 16)	/* Master 4 Priority */
+#define		AT91_MATRIX_M5PR		(3 << 20)	/* Master 5 Priority */
+#define		AT91_MATRIX_M6PR		(3 << 24)	/* Master 6 Priority */
+#define		AT91_MATRIX_M7PR		(3 << 28)	/* Master 7 Priority */
+#define		AT91_MATRIX_M8PR		(3 << 0)	/* Master 8 Priority (in Register B) */
+
+#define AT91_MATRIX_MRCR	(AT91_MATRIX + 0x100)	/* Master Remap Control Register */
+#define		AT91_MATRIX_RCB0		(1 << 0)	/* Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master) */
+#define		AT91_MATRIX_RCB1		(1 << 1)	/* Remap Command for AHB Master 1 (ARM926EJ-S Data Master) */
+#define		AT91_MATRIX_RCB2		(1 << 2)
+#define		AT91_MATRIX_RCB3		(1 << 3)
+#define		AT91_MATRIX_RCB4		(1 << 4)
+#define		AT91_MATRIX_RCB5		(1 << 5)
+#define		AT91_MATRIX_RCB6		(1 << 6)
+#define		AT91_MATRIX_RCB7		(1 << 7)
+#define		AT91_MATRIX_RCB8		(1 << 8)
+
+#define AT91_MATRIX_TCMR	(AT91_MATRIX + 0x114)	/* TCM Configuration Register */
+#define		AT91_MATRIX_ITCM_SIZE		(0xf << 0)	/* Size of ITCM enabled memory block */
+#define			AT91_MATRIX_ITCM_0		(0 << 0)
+#define			AT91_MATRIX_ITCM_16		(5 << 0)
+#define			AT91_MATRIX_ITCM_32		(6 << 0)
+#define		AT91_MATRIX_DTCM_SIZE		(0xf << 4)	/* Size of DTCM enabled memory block */
+#define			AT91_MATRIX_DTCM_0		(0 << 4)
+#define			AT91_MATRIX_DTCM_16		(5 << 4)
+#define			AT91_MATRIX_DTCM_32		(6 << 4)
+
+#define AT91_MATRIX_EBI0CSA	(AT91_MATRIX + 0x120)	/* EBI0 Chip Select Assignment Register */
+#define		AT91_MATRIX_EBI0_CS1A		(1 << 1)	/* Chip Select 1 Assignment */
+#define			AT91_MATRIX_EBI0_CS1A_SMC		(0 << 1)
+#define			AT91_MATRIX_EBI0_CS1A_SDRAMC		(1 << 1)
+#define		AT91_MATRIX_EBI0_CS3A		(1 << 3)	/* Chip Select 3 Assignment */
+#define			AT91_MATRIX_EBI0_CS3A_SMC		(0 << 3)
+#define			AT91_MATRIX_EBI0_CS3A_SMC_SMARTMEDIA	(1 << 3)
+#define		AT91_MATRIX_EBI0_CS4A		(1 << 4)	/* Chip Select 4 Assignment */
+#define			AT91_MATRIX_EBI0_CS4A_SMC		(0 << 4)
+#define			AT91_MATRIX_EBI0_CS4A_SMC_CF1		(1 << 4)
+#define		AT91_MATRIX_EBI0_CS5A		(1 << 5)	/* Chip Select 5 Assignment */
+#define			AT91_MATRIX_EBI0_CS5A_SMC		(0 << 5)
+#define			AT91_MATRIX_EBI0_CS5A_SMC_CF2		(1 << 5)
+#define		AT91_MATRIX_EBI0_DBPUC		(1 << 8)	/* Data Bus Pull-up Configuration */
+#define		AT91_MATRIX_EBI0_VDDIOMSEL	(1 << 16)	/* Memory voltage selection */
+#define			AT91_MATRIX_EBI0_VDDIOMSEL_1_8V		(0 << 16)
+#define			AT91_MATRIX_EBI0_VDDIOMSEL_3_3V		(1 << 16)
+
+#define AT91_MATRIX_EBI1CSA	(AT91_MATRIX + 0x124)	/* EBI1 Chip Select Assignment Register */
+#define		AT91_MATRIX_EBI1_CS1A		(1 << 1)	/* Chip Select 1 Assignment */
+#define			AT91_MATRIX_EBI1_CS1A_SMC		(0 << 1)
+#define			AT91_MATRIX_EBI1_CS1A_SDRAMC		(1 << 1)
+#define		AT91_MATRIX_EBI1_CS2A		(1 << 3)	/* Chip Select 3 Assignment */
+#define			AT91_MATRIX_EBI1_CS2A_SMC		(0 << 3)
+#define			AT91_MATRIX_EBI1_CS2A_SMC_SMARTMEDIA	(1 << 3)
+#define		AT91_MATRIX_EBI1_DBPUC		(1 << 8)	/* Data Bus Pull-up Configuration */
+#define		AT91_MATRIX_EBI1_VDDIOMSEL	(1 << 16)	/* Memory voltage selection */
+#define			AT91_MATRIX_EBI1_VDDIOMSEL_1_8V		(0 << 16)
+#define			AT91_MATRIX_EBI1_VDDIOMSEL_3_3V		(1 << 16)
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/at91sam926x_mc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/at91sam926x_mc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/at91sam926x_mc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,141 @@
+/*
+ * include/asm-arm/arch-at91/at91sam926x_mc.h
+ *
+ * Memory Controllers (SMC, SDRAMC) - System peripherals registers.
+ * Based on AT91SAM9261 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM926x_MC_H
+#define AT91SAM926x_MC_H
+
+/* SDRAM Controller (SDRAMC) registers */
+#define AT91_SDRAMC_MR		(AT91_SDRAMC + 0x00)	/* SDRAM Controller Mode Register */
+#define		AT91_SDRAMC_MODE	(0xf << 0)		/* Command Mode */
+#define			AT91_SDRAMC_MODE_NORMAL		0
+#define			AT91_SDRAMC_MODE_NOP		1
+#define			AT91_SDRAMC_MODE_PRECHARGE	2
+#define			AT91_SDRAMC_MODE_LMR		3
+#define			AT91_SDRAMC_MODE_REFRESH	4
+#define			AT91_SDRAMC_MODE_EXT_LMR	5
+#define			AT91_SDRAMC_MODE_DEEP		6
+
+#define AT91_SDRAMC_TR		(AT91_SDRAMC + 0x04)	/* SDRAM Controller Refresh Timer Register */
+#define		AT91_SDRAMC_COUNT	(0xfff << 0)		/* Refresh Timer Counter */
+
+#define AT91_SDRAMC_CR		(AT91_SDRAMC + 0x08)	/* SDRAM Controller Configuration Register */
+#define		AT91_SDRAMC_NC		(3 << 0)		/* Number of Column Bits */
+#define			AT91_SDRAMC_NC_8	(0 << 0)
+#define			AT91_SDRAMC_NC_9	(1 << 0)
+#define			AT91_SDRAMC_NC_10	(2 << 0)
+#define			AT91_SDRAMC_NC_11	(3 << 0)
+#define		AT91_SDRAMC_NR		(3 << 2)		/* Number of Row Bits */
+#define			AT91_SDRAMC_NR_11	(0 << 2)
+#define			AT91_SDRAMC_NR_12	(1 << 2)
+#define			AT91_SDRAMC_NR_13	(2 << 2)
+#define		AT91_SDRAMC_NB		(1 << 4)		/* Number of Banks */
+#define			AT91_SDRAMC_NB_2	(0 << 4)
+#define			AT91_SDRAMC_NB_4	(1 << 4)
+#define		AT91_SDRAMC_CAS		(3 << 5)		/* CAS Latency */
+#define			AT91_SDRAMC_CAS_1	(1 << 5)
+#define			AT91_SDRAMC_CAS_2	(2 << 5)
+#define			AT91_SDRAMC_CAS_3	(3 << 5)
+#define		AT91_SDRAMC_DBW		(1 << 7)		/* Data Bus Width */
+#define			AT91_SDRAMC_DBW_32	(0 << 7)
+#define			AT91_SDRAMC_DBW_16	(1 << 7)
+#define		AT91_SDRAMC_TWR		(0xf <<  8)		/* Write Recovery Delay */
+#define		AT91_SDRAMC_TRC		(0xf << 12)		/* Row Cycle Delay */
+#define		AT91_SDRAMC_TRP		(0xf << 16)		/* Row Precharge Delay */
+#define		AT91_SDRAMC_TRCD	(0xf << 20)		/* Row to Column Delay */
+#define		AT91_SDRAMC_TRAS	(0xf << 24)		/* Active to Precharge Delay */
+#define		AT91_SDRAMC_TXSR	(0xf << 28)		/* Exit Self Refresh to Active Delay */
+
+#define AT91_SDRAMC_LPR		(AT91_SDRAMC + 0x10)	/* SDRAM Controller Low Power Register */
+#define		AT91_SDRAMC_LPCB		(3 << 0)	/* Low-power Configurations */
+#define			AT91_SDRAMC_LPCB_DISABLE		0
+#define			AT91_SDRAMC_LPCB_SELF_REFRESH		1
+#define			AT91_SDRAMC_LPCB_POWER_DOWN		2
+#define			AT91_SDRAMC_LPCB_DEEP_POWER_DOWN	3
+#define		AT91_SDRAMC_PASR		(7 << 4)	/* Partial Array Self Refresh */
+#define		AT91_SDRAMC_TCSR		(3 << 8)	/* Temperature Compensated Self Refresh */
+#define		AT91_SDRAMC_DS			(3 << 10)	/* Drive Strenght */
+#define		AT91_SDRAMC_TIMEOUT		(3 << 12)	/* Time to define when Low Power Mode is enabled */
+#define			AT91_SDRAMC_TIMEOUT_0_CLK_CYCLES	(0 << 12)
+#define			AT91_SDRAMC_TIMEOUT_64_CLK_CYCLES	(1 << 12)
+#define			AT91_SDRAMC_TIMEOUT_128_CLK_CYCLES	(2 << 12)
+
+#define AT91_SDRAMC_IER		(AT91_SDRAMC + 0x14)	/* SDRAM Controller Interrupt Enable Register */
+#define AT91_SDRAMC_IDR		(AT91_SDRAMC + 0x18)	/* SDRAM Controller Interrupt Disable Register */
+#define AT91_SDRAMC_IMR		(AT91_SDRAMC + 0x1C)	/* SDRAM Controller Interrupt Mask Register */
+#define AT91_SDRAMC_ISR		(AT91_SDRAMC + 0x20)	/* SDRAM Controller Interrupt Status Register */
+#define		AT91_SDRAMC_RES		(1 << 0)		/* Refresh Error Status */
+
+#define AT91_SDRAMC_MDR		(AT91_SDRAMC + 0x24)	/* SDRAM Memory Device Register */
+#define		AT91_SDRAMC_MD		(3 << 0)		/* Memory Device Type */
+#define			AT91_SDRAMC_MD_SDRAM		0
+#define			AT91_SDRAMC_MD_LOW_POWER_SDRAM	1
+
+
+/* Static Memory Controller (SMC) registers */
+#define AT91_SMC_SETUP(n)	(AT91_SMC + 0x00 + ((n)*0x10))	/* Setup Register for CS n */
+#define		AT91_SMC_NWESETUP	(0x3f << 0)			/* NWE Setup Length */
+#define			AT91_SMC_NWESETUP_(x)	((x) << 0)
+#define		AT91_SMC_NCS_WRSETUP	(0x3f << 8)			/* NCS Setup Length in Write Access */
+#define			AT91_SMC_NCS_WRSETUP_(x)	((x) << 8)
+#define		AT91_SMC_NRDSETUP	(0x3f << 16)			/* NRD Setup Length */
+#define			AT91_SMC_NRDSETUP_(x)	((x) << 16)
+#define		AT91_SMC_NCS_RDSETUP	(0x3f << 24)			/* NCS Setup Length in Read Access */
+#define			AT91_SMC_NCS_RDSETUP_(x)	((x) << 24)
+
+#define AT91_SMC_PULSE(n)	(AT91_SMC + 0x04 + ((n)*0x10))	/* Pulse Register for CS n */
+#define		AT91_SMC_NWEPULSE	(0x7f <<  0)			/* NWE Pulse Length */
+#define			AT91_SMC_NWEPULSE_(x)	((x) << 0)
+#define		AT91_SMC_NCS_WRPULSE	(0x7f <<  8)			/* NCS Pulse Length in Write Access */
+#define			AT91_SMC_NCS_WRPULSE_(x)((x) << 8)
+#define		AT91_SMC_NRDPULSE	(0x7f << 16)			/* NRD Pulse Length */
+#define			AT91_SMC_NRDPULSE_(x)	((x) << 16)
+#define		AT91_SMC_NCS_RDPULSE	(0x7f << 24)			/* NCS Pulse Length in Read Access */
+#define			AT91_SMC_NCS_RDPULSE_(x)((x) << 24)
+
+#define AT91_SMC_CYCLE(n)	(AT91_SMC + 0x08 + ((n)*0x10))	/* Cycle Register for CS n */
+#define		AT91_SMC_NWECYCLE	(0x1ff << 0 )			/* Total Write Cycle Length */
+#define			AT91_SMC_NWECYCLE_(x)	((x) << 0)
+#define		AT91_SMC_NRDCYCLE	(0x1ff << 16)			/* Total Read Cycle Length */
+#define			AT91_SMC_NRDCYCLE_(x)	((x) << 16)
+
+#define AT91_SMC_MODE(n)	(AT91_SMC + 0x0c + ((n)*0x10))	/* Mode Register for CS n */
+#define		AT91_SMC_READMODE	(1 <<  0)			/* Read Mode */
+#define		AT91_SMC_WRITEMODE	(1 <<  1)			/* Write Mode */
+#define		AT91_SMC_EXNWMODE	(3 <<  4)			/* NWAIT Mode */
+#define			AT91_SMC_EXNWMODE_DISABLE	(0 << 4)
+#define			AT91_SMC_EXNWMODE_FROZEN	(2 << 4)
+#define			AT91_SMC_EXNWMODE_READY		(3 << 4)
+#define		AT91_SMC_BAT		(1 <<  8)			/* Byte Access Type */
+#define			AT91_SMC_BAT_SELECT		(0 << 8)
+#define			AT91_SMC_BAT_WRITE		(1 << 8)
+#define		AT91_SMC_DBW		(3 << 12)			/* Data Bus Width */
+#define			AT91_SMC_DBW_8			(0 << 12)
+#define			AT91_SMC_DBW_16			(1 << 12)
+#define			AT91_SMC_DBW_32			(2 << 12)
+#define		AT91_SMC_TDF		(0xf << 16)			/* Data Float Time. */
+#define			AT91_SMC_TDF_(x)		((x) << 16)
+#define		AT91_SMC_TDFMODE	(1 << 20)			/* TDF Optimization - Enabled */
+#define		AT91_SMC_PMEN		(1 << 24)			/* Page Mode Enabled */
+#define		AT91_SMC_PS		(3 << 28)			/* Page Size */
+#define			AT91_SMC_PS_4			(0 << 28)
+#define			AT91_SMC_PS_8			(1 << 28)
+#define			AT91_SMC_PS_16			(2 << 28)
+#define			AT91_SMC_PS_32			(3 << 28)
+
+#if defined(AT91_SMC1)		/* The AT91SAM9263 has 2 Static Memory contollers */
+#define AT91_SMC1_SETUP(n)	(AT91_SMC1 + 0x00 + ((n)*0x10))	/* Setup Register for CS n */
+#define AT91_SMC1_PULSE(n)	(AT91_SMC1 + 0x04 + ((n)*0x10))	/* Pulse Register for CS n */
+#define AT91_SMC1_CYCLE(n)	(AT91_SMC1 + 0x08 + ((n)*0x10))	/* Cycle Register for CS n */
+#define AT91_SMC1_MODE(n)	(AT91_SMC1 + 0x0c + ((n)*0x10))	/* Mode Register for CS n */
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/board.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/board.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/board.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,122 @@
+/*
+ * include/asm-arm/arch-at91/board.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * These are data structures found in platform_device.dev.platform_data,
+ * and describing board-specific data needed by drivers.  For example,
+ * which pin is used for a given GPIO role.
+ *
+ * In 2.6, drivers should strongly avoid board-specific knowledge so
+ * that supporting new boards normally won't require driver patches.
+ * Most board-specific knowledge should be in arch/.../board-*.c files.
+ */
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+#include <linux/mtd/partitions.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+
+ /* USB Device */
+struct at91_udc_data {
+	u8	vbus_pin;		/* high == host powering us */
+	u8	pullup_pin;		/* high == D+ pulled up */
+};
+extern void __init at91_add_device_udc(struct at91_udc_data *data);
+
+ /* Compact Flash */
+struct at91_cf_data {
+	u8	irq_pin;		/* I/O IRQ */
+	u8	det_pin;		/* Card detect */
+	u8	vcc_pin;		/* power switching */
+	u8	rst_pin;		/* card reset */
+	u8	chipselect;		/* EBI Chip Select number */
+};
+extern void __init at91_add_device_cf(struct at91_cf_data *data);
+
+ /* MMC / SD */
+struct at91_mmc_data {
+	u8		det_pin;	/* card detect IRQ */
+	unsigned	slot_b:1;	/* uses Slot B */
+	unsigned	wire4:1;	/* (SD) supports DAT0..DAT3 */
+	u8		wp_pin;		/* (SD) writeprotect detect */
+	u8		vcc_pin;	/* power switching (high == on) */
+};
+extern void __init at91_add_device_mmc(short mmc_id, struct at91_mmc_data *data);
+
+ /* Ethernet */
+struct at91_eth_data {
+	u8		phy_irq_pin;	/* PHY IRQ */
+	u8		is_rmii;	/* using RMII interface? */
+};
+extern void __init at91_add_device_eth(struct at91_eth_data *data);
+
+#if defined(CONFIG_ARCH_AT91SAM9260) || defined(CONFIG_ARCH_AT91SAM9263)
+#define eth_platform_data	at91_eth_data
+#endif
+
+ /* USB Host */
+struct at91_usbh_data {
+	u8		ports;		/* number of ports on root hub */
+	u8		vbus_pin[];	/* port power-control pin */
+};
+extern void __init at91_add_device_usbh(struct at91_usbh_data *data);
+
+ /* NAND / SmartMedia */
+struct at91_nand_data {
+	u8		enable_pin;	/* chip enable */
+	u8		det_pin;	/* card detect */
+	u8		rdy_pin;	/* ready/busy */
+	u8		ale;		/* address line number connected to ALE */
+	u8		cle;		/* address line number connected to CLE */
+	u8		bus_width_16;	/* buswidth is 16 bit */
+	struct mtd_partition* (*partition_info)(int, int*);
+};
+extern void __init at91_add_device_nand(struct at91_nand_data *data);
+
+ /* I2C*/
+extern void __init at91_add_device_i2c(void);
+
+ /* SPI */
+extern void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices);
+
+ /* Serial */
+struct at91_uart_config {
+	unsigned short	console_tty;	/* tty number of serial console */
+	unsigned short	nr_tty;		/* number of serial tty's */
+	short		tty_map[];	/* map UART to tty number */
+};
+extern struct platform_device *atmel_default_console_device;
+extern void __init at91_init_serial(struct at91_uart_config *config);
+
+struct atmel_uart_data {
+	short		use_dma_tx;	/* use transmit DMA? */
+	short		use_dma_rx;	/* use receive DMA? */
+	void __iomem	*regs;		/* virtual base address, if any */
+};
+extern void __init at91_add_device_serial(void);
+
+ /* LEDs */
+extern u8 at91_leds_cpu;
+extern u8 at91_leds_timer;
+extern void __init at91_init_leds(u8 cpu_led, u8 timer_led);
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/cpu.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/cpu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/cpu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,71 @@
+/*
+ * include/asm-arm/arch-at91/cpu.h
+ *
+ *  Copyright (C) 2006 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_CPU_H
+#define __ASM_ARCH_CPU_H
+
+#include <asm/hardware.h>
+#include <asm/arch/at91_dbgu.h>
+
+
+#define ARCH_ID_AT91RM9200	0x09290780
+#define ARCH_ID_AT91SAM9260	0x019803a0
+#define ARCH_ID_AT91SAM9261	0x019703a0
+#define ARCH_ID_AT91SAM9263	0x019607a0
+
+#define ARCH_ID_AT91SAM9XE128	0x329973a0
+#define ARCH_ID_AT91SAM9XE256	0x329a93a0
+#define ARCH_ID_AT91SAM9XE512	0x329aa3a0
+
+static inline unsigned long at91_cpu_identify(void)
+{
+	return (at91_sys_read(AT91_DBGU_CIDR) & ~AT91_CIDR_VERSION);
+}
+
+
+#define ARCH_FAMILY_AT91X92	0x09200000
+#define ARCH_FAMILY_AT91SAM9	0x01900000
+#define ARCH_FAMILY_AT91SAM9XE	0x02900000
+
+static inline unsigned long at91_arch_identify(void)
+{
+	return (at91_sys_read(AT91_DBGU_CIDR) & AT91_CIDR_ARCH);
+}
+
+
+#ifdef CONFIG_ARCH_AT91RM9200
+#define cpu_is_at91rm9200()	(at91_cpu_identify() == ARCH_ID_AT91RM9200)
+#else
+#define cpu_is_at91rm9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91SAM9260
+#define cpu_is_at91sam9xe()	(at91_arch_identify() == ARCH_FAMILY_AT91SAM9XE)
+#define cpu_is_at91sam9260()	((at91_cpu_identify() == ARCH_ID_AT91SAM9260) || cpu_is_at91sam9xe())
+#else
+#define cpu_is_at91sam9xe()	(0)
+#define cpu_is_at91sam9260()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91SAM9261
+#define cpu_is_at91sam9261()	(at91_cpu_identify() == ARCH_ID_AT91SAM9261)
+#else
+#define cpu_is_at91sam9261()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91SAM9263
+#define cpu_is_at91sam9263()	(at91_cpu_identify() == ARCH_ID_AT91SAM9263)
+#else
+#define cpu_is_at91sam9263()	(0)
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-at91/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-at91/debug-macro.S
+ *
+ *  Copyright (C) 2003-2005 SAN People
+ *
+ * Debugging macro include header
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <asm/hardware.h>
+#include <asm/arch/at91_dbgu.h>
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1						@ MMU enabled?
+	ldreq	\rx, =(AT91_BASE_SYS + AT91_DBGU)		@ System peripherals (phys address)
+	ldrne	\rx, =(AT91_VA_BASE_SYS	+ AT91_DBGU)		@ System peripherals (virt address)
+	.endm
+
+	.macro	senduart,rd,rx
+	strb	\rd, [\rx, #(AT91_DBGU_THR - AT91_DBGU)]	@ Write to Transmitter Holding Register
+	.endm
+
+	.macro	waituart,rd,rx
+1001:	ldr	\rd, [\rx, #(AT91_DBGU_SR - AT91_DBGU)]		@ Read Status Register
+	tst	\rd, #AT91_DBGU_TXRDY				@ DBGU_TXRDY = 1 when ready to transmit
+	beq	1001b
+	.endm
+
+	.macro	busyuart,rd,rx
+1001:	ldr	\rd, [\rx, #(AT91_DBGU_SR - AT91_DBGU)]		@ Read Status Register
+	tst	\rd, #AT91_DBGU_TXEMPTY				@ DBGU_TXEMPTY = 1 when transmission complete
+	beq	1001b
+	.endm
+
Index: build_tree/linux/include/asm/arch-at91/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,19 @@
+/*
+ * include/asm-arm/arch-at91/dma.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
Index: build_tree/linux/include/asm/arch-at91/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-at91/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-at91/entry-macro.S
+ *
+ *  Copyright (C) 2003-2005 SAN People
+ *
+ * Low-level IRQ helper macros for AT91RM9200 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/hardware.h>
+#include <asm/arch/at91_aic.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =(AT91_VA_BASE_SYS + AT91_AIC)		@ base virtual address of AIC peripheral
+	ldr	\irqnr, [\base, #(AT91_AIC_IVR - AT91_AIC)]	@ read IRQ vector register: de-asserts nIRQ to processor (and clears interrupt)
+	ldr	\irqstat, [\base, #(AT91_AIC_ISR - AT91_AIC)]	@ read interrupt source number
+	teq	\irqstat, #0					@ ISR is 0 when no current interrupt, or spurious interrupt
+	streq	\tmp, [\base, #(AT91_AIC_EOICR - AT91_AIC)]	@ not going to be handled further, then ACK it now.
+	.endm
+
Index: build_tree/linux/include/asm/arch-at91/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,252 @@
+/*
+ * include/asm-arm/arch-at91/gpio.h
+ *
+ *  Copyright (C) 2005 HP Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_AT91RM9200_GPIO_H
+#define __ASM_ARCH_AT91RM9200_GPIO_H
+
+#include <asm/irq.h>
+
+#define PIN_BASE		NR_AIC_IRQS
+
+#define MAX_GPIO_BANKS		5
+
+/* these pin numbers double as IRQ numbers, like AT91xxx_ID_* values */
+
+#define	AT91_PIN_PA0	(PIN_BASE + 0x00 + 0)
+#define	AT91_PIN_PA1	(PIN_BASE + 0x00 + 1)
+#define	AT91_PIN_PA2	(PIN_BASE + 0x00 + 2)
+#define	AT91_PIN_PA3	(PIN_BASE + 0x00 + 3)
+#define	AT91_PIN_PA4	(PIN_BASE + 0x00 + 4)
+#define	AT91_PIN_PA5	(PIN_BASE + 0x00 + 5)
+#define	AT91_PIN_PA6	(PIN_BASE + 0x00 + 6)
+#define	AT91_PIN_PA7	(PIN_BASE + 0x00 + 7)
+#define	AT91_PIN_PA8	(PIN_BASE + 0x00 + 8)
+#define	AT91_PIN_PA9	(PIN_BASE + 0x00 + 9)
+#define	AT91_PIN_PA10	(PIN_BASE + 0x00 + 10)
+#define	AT91_PIN_PA11	(PIN_BASE + 0x00 + 11)
+#define	AT91_PIN_PA12	(PIN_BASE + 0x00 + 12)
+#define	AT91_PIN_PA13	(PIN_BASE + 0x00 + 13)
+#define	AT91_PIN_PA14	(PIN_BASE + 0x00 + 14)
+#define	AT91_PIN_PA15	(PIN_BASE + 0x00 + 15)
+#define	AT91_PIN_PA16	(PIN_BASE + 0x00 + 16)
+#define	AT91_PIN_PA17	(PIN_BASE + 0x00 + 17)
+#define	AT91_PIN_PA18	(PIN_BASE + 0x00 + 18)
+#define	AT91_PIN_PA19	(PIN_BASE + 0x00 + 19)
+#define	AT91_PIN_PA20	(PIN_BASE + 0x00 + 20)
+#define	AT91_PIN_PA21	(PIN_BASE + 0x00 + 21)
+#define	AT91_PIN_PA22	(PIN_BASE + 0x00 + 22)
+#define	AT91_PIN_PA23	(PIN_BASE + 0x00 + 23)
+#define	AT91_PIN_PA24	(PIN_BASE + 0x00 + 24)
+#define	AT91_PIN_PA25	(PIN_BASE + 0x00 + 25)
+#define	AT91_PIN_PA26	(PIN_BASE + 0x00 + 26)
+#define	AT91_PIN_PA27	(PIN_BASE + 0x00 + 27)
+#define	AT91_PIN_PA28	(PIN_BASE + 0x00 + 28)
+#define	AT91_PIN_PA29	(PIN_BASE + 0x00 + 29)
+#define	AT91_PIN_PA30	(PIN_BASE + 0x00 + 30)
+#define	AT91_PIN_PA31	(PIN_BASE + 0x00 + 31)
+
+#define	AT91_PIN_PB0	(PIN_BASE + 0x20 + 0)
+#define	AT91_PIN_PB1	(PIN_BASE + 0x20 + 1)
+#define	AT91_PIN_PB2	(PIN_BASE + 0x20 + 2)
+#define	AT91_PIN_PB3	(PIN_BASE + 0x20 + 3)
+#define	AT91_PIN_PB4	(PIN_BASE + 0x20 + 4)
+#define	AT91_PIN_PB5	(PIN_BASE + 0x20 + 5)
+#define	AT91_PIN_PB6	(PIN_BASE + 0x20 + 6)
+#define	AT91_PIN_PB7	(PIN_BASE + 0x20 + 7)
+#define	AT91_PIN_PB8	(PIN_BASE + 0x20 + 8)
+#define	AT91_PIN_PB9	(PIN_BASE + 0x20 + 9)
+#define	AT91_PIN_PB10	(PIN_BASE + 0x20 + 10)
+#define	AT91_PIN_PB11	(PIN_BASE + 0x20 + 11)
+#define	AT91_PIN_PB12	(PIN_BASE + 0x20 + 12)
+#define	AT91_PIN_PB13	(PIN_BASE + 0x20 + 13)
+#define	AT91_PIN_PB14	(PIN_BASE + 0x20 + 14)
+#define	AT91_PIN_PB15	(PIN_BASE + 0x20 + 15)
+#define	AT91_PIN_PB16	(PIN_BASE + 0x20 + 16)
+#define	AT91_PIN_PB17	(PIN_BASE + 0x20 + 17)
+#define	AT91_PIN_PB18	(PIN_BASE + 0x20 + 18)
+#define	AT91_PIN_PB19	(PIN_BASE + 0x20 + 19)
+#define	AT91_PIN_PB20	(PIN_BASE + 0x20 + 20)
+#define	AT91_PIN_PB21	(PIN_BASE + 0x20 + 21)
+#define	AT91_PIN_PB22	(PIN_BASE + 0x20 + 22)
+#define	AT91_PIN_PB23	(PIN_BASE + 0x20 + 23)
+#define	AT91_PIN_PB24	(PIN_BASE + 0x20 + 24)
+#define	AT91_PIN_PB25	(PIN_BASE + 0x20 + 25)
+#define	AT91_PIN_PB26	(PIN_BASE + 0x20 + 26)
+#define	AT91_PIN_PB27	(PIN_BASE + 0x20 + 27)
+#define	AT91_PIN_PB28	(PIN_BASE + 0x20 + 28)
+#define	AT91_PIN_PB29	(PIN_BASE + 0x20 + 29)
+#define	AT91_PIN_PB30	(PIN_BASE + 0x20 + 30)
+#define	AT91_PIN_PB31	(PIN_BASE + 0x20 + 31)
+
+#define	AT91_PIN_PC0	(PIN_BASE + 0x40 + 0)
+#define	AT91_PIN_PC1	(PIN_BASE + 0x40 + 1)
+#define	AT91_PIN_PC2	(PIN_BASE + 0x40 + 2)
+#define	AT91_PIN_PC3	(PIN_BASE + 0x40 + 3)
+#define	AT91_PIN_PC4	(PIN_BASE + 0x40 + 4)
+#define	AT91_PIN_PC5	(PIN_BASE + 0x40 + 5)
+#define	AT91_PIN_PC6	(PIN_BASE + 0x40 + 6)
+#define	AT91_PIN_PC7	(PIN_BASE + 0x40 + 7)
+#define	AT91_PIN_PC8	(PIN_BASE + 0x40 + 8)
+#define	AT91_PIN_PC9	(PIN_BASE + 0x40 + 9)
+#define	AT91_PIN_PC10	(PIN_BASE + 0x40 + 10)
+#define	AT91_PIN_PC11	(PIN_BASE + 0x40 + 11)
+#define	AT91_PIN_PC12	(PIN_BASE + 0x40 + 12)
+#define	AT91_PIN_PC13	(PIN_BASE + 0x40 + 13)
+#define	AT91_PIN_PC14	(PIN_BASE + 0x40 + 14)
+#define	AT91_PIN_PC15	(PIN_BASE + 0x40 + 15)
+#define	AT91_PIN_PC16	(PIN_BASE + 0x40 + 16)
+#define	AT91_PIN_PC17	(PIN_BASE + 0x40 + 17)
+#define	AT91_PIN_PC18	(PIN_BASE + 0x40 + 18)
+#define	AT91_PIN_PC19	(PIN_BASE + 0x40 + 19)
+#define	AT91_PIN_PC20	(PIN_BASE + 0x40 + 20)
+#define	AT91_PIN_PC21	(PIN_BASE + 0x40 + 21)
+#define	AT91_PIN_PC22	(PIN_BASE + 0x40 + 22)
+#define	AT91_PIN_PC23	(PIN_BASE + 0x40 + 23)
+#define	AT91_PIN_PC24	(PIN_BASE + 0x40 + 24)
+#define	AT91_PIN_PC25	(PIN_BASE + 0x40 + 25)
+#define	AT91_PIN_PC26	(PIN_BASE + 0x40 + 26)
+#define	AT91_PIN_PC27	(PIN_BASE + 0x40 + 27)
+#define	AT91_PIN_PC28	(PIN_BASE + 0x40 + 28)
+#define	AT91_PIN_PC29	(PIN_BASE + 0x40 + 29)
+#define	AT91_PIN_PC30	(PIN_BASE + 0x40 + 30)
+#define	AT91_PIN_PC31	(PIN_BASE + 0x40 + 31)
+
+#define	AT91_PIN_PD0	(PIN_BASE + 0x60 + 0)
+#define	AT91_PIN_PD1	(PIN_BASE + 0x60 + 1)
+#define	AT91_PIN_PD2	(PIN_BASE + 0x60 + 2)
+#define	AT91_PIN_PD3	(PIN_BASE + 0x60 + 3)
+#define	AT91_PIN_PD4	(PIN_BASE + 0x60 + 4)
+#define	AT91_PIN_PD5	(PIN_BASE + 0x60 + 5)
+#define	AT91_PIN_PD6	(PIN_BASE + 0x60 + 6)
+#define	AT91_PIN_PD7	(PIN_BASE + 0x60 + 7)
+#define	AT91_PIN_PD8	(PIN_BASE + 0x60 + 8)
+#define	AT91_PIN_PD9	(PIN_BASE + 0x60 + 9)
+#define	AT91_PIN_PD10	(PIN_BASE + 0x60 + 10)
+#define	AT91_PIN_PD11	(PIN_BASE + 0x60 + 11)
+#define	AT91_PIN_PD12	(PIN_BASE + 0x60 + 12)
+#define	AT91_PIN_PD13	(PIN_BASE + 0x60 + 13)
+#define	AT91_PIN_PD14	(PIN_BASE + 0x60 + 14)
+#define	AT91_PIN_PD15	(PIN_BASE + 0x60 + 15)
+#define	AT91_PIN_PD16	(PIN_BASE + 0x60 + 16)
+#define	AT91_PIN_PD17	(PIN_BASE + 0x60 + 17)
+#define	AT91_PIN_PD18	(PIN_BASE + 0x60 + 18)
+#define	AT91_PIN_PD19	(PIN_BASE + 0x60 + 19)
+#define	AT91_PIN_PD20	(PIN_BASE + 0x60 + 20)
+#define	AT91_PIN_PD21	(PIN_BASE + 0x60 + 21)
+#define	AT91_PIN_PD22	(PIN_BASE + 0x60 + 22)
+#define	AT91_PIN_PD23	(PIN_BASE + 0x60 + 23)
+#define	AT91_PIN_PD24	(PIN_BASE + 0x60 + 24)
+#define	AT91_PIN_PD25	(PIN_BASE + 0x60 + 25)
+#define	AT91_PIN_PD26	(PIN_BASE + 0x60 + 26)
+#define	AT91_PIN_PD27	(PIN_BASE + 0x60 + 27)
+#define	AT91_PIN_PD28	(PIN_BASE + 0x60 + 28)
+#define	AT91_PIN_PD29	(PIN_BASE + 0x60 + 29)
+#define	AT91_PIN_PD30	(PIN_BASE + 0x60 + 30)
+#define	AT91_PIN_PD31	(PIN_BASE + 0x60 + 31)
+
+#define	AT91_PIN_PE0	(PIN_BASE + 0x80 + 0)
+#define	AT91_PIN_PE1	(PIN_BASE + 0x80 + 1)
+#define	AT91_PIN_PE2	(PIN_BASE + 0x80 + 2)
+#define	AT91_PIN_PE3	(PIN_BASE + 0x80 + 3)
+#define	AT91_PIN_PE4	(PIN_BASE + 0x80 + 4)
+#define	AT91_PIN_PE5	(PIN_BASE + 0x80 + 5)
+#define	AT91_PIN_PE6	(PIN_BASE + 0x80 + 6)
+#define	AT91_PIN_PE7	(PIN_BASE + 0x80 + 7)
+#define	AT91_PIN_PE8	(PIN_BASE + 0x80 + 8)
+#define	AT91_PIN_PE9	(PIN_BASE + 0x80 + 9)
+#define	AT91_PIN_PE10	(PIN_BASE + 0x80 + 10)
+#define	AT91_PIN_PE11	(PIN_BASE + 0x80 + 11)
+#define	AT91_PIN_PE12	(PIN_BASE + 0x80 + 12)
+#define	AT91_PIN_PE13	(PIN_BASE + 0x80 + 13)
+#define	AT91_PIN_PE14	(PIN_BASE + 0x80 + 14)
+#define	AT91_PIN_PE15	(PIN_BASE + 0x80 + 15)
+#define	AT91_PIN_PE16	(PIN_BASE + 0x80 + 16)
+#define	AT91_PIN_PE17	(PIN_BASE + 0x80 + 17)
+#define	AT91_PIN_PE18	(PIN_BASE + 0x80 + 18)
+#define	AT91_PIN_PE19	(PIN_BASE + 0x80 + 19)
+#define	AT91_PIN_PE20	(PIN_BASE + 0x80 + 20)
+#define	AT91_PIN_PE21	(PIN_BASE + 0x80 + 21)
+#define	AT91_PIN_PE22	(PIN_BASE + 0x80 + 22)
+#define	AT91_PIN_PE23	(PIN_BASE + 0x80 + 23)
+#define	AT91_PIN_PE24	(PIN_BASE + 0x80 + 24)
+#define	AT91_PIN_PE25	(PIN_BASE + 0x80 + 25)
+#define	AT91_PIN_PE26	(PIN_BASE + 0x80 + 26)
+#define	AT91_PIN_PE27	(PIN_BASE + 0x80 + 27)
+#define	AT91_PIN_PE28	(PIN_BASE + 0x80 + 28)
+#define	AT91_PIN_PE29	(PIN_BASE + 0x80 + 29)
+#define	AT91_PIN_PE30	(PIN_BASE + 0x80 + 30)
+#define	AT91_PIN_PE31	(PIN_BASE + 0x80 + 31)
+
+#ifndef __ASSEMBLY__
+/* setup setup routines, called from board init or driver probe() */
+extern int __init_or_module at91_set_GPIO_periph(unsigned pin, int use_pullup);
+extern int __init_or_module at91_set_A_periph(unsigned pin, int use_pullup);
+extern int __init_or_module at91_set_B_periph(unsigned pin, int use_pullup);
+extern int __init_or_module at91_set_gpio_input(unsigned pin, int use_pullup);
+extern int __init_or_module at91_set_gpio_output(unsigned pin, int value);
+extern int __init_or_module at91_set_deglitch(unsigned pin, int is_on);
+extern int __init_or_module at91_set_multi_drive(unsigned pin, int is_on);
+
+/* callable at any time */
+extern int at91_set_gpio_value(unsigned pin, int value);
+extern int at91_get_gpio_value(unsigned pin);
+
+/* callable only from core power-management code */
+extern void at91_gpio_suspend(void);
+extern void at91_gpio_resume(void);
+
+/*-------------------------------------------------------------------------*/
+
+/* wrappers for "new style" GPIO calls. the old AT91-specfic ones should
+ * eventually be removed (along with this errno.h inclusion), and the
+ * gpio request/free calls should probably be implemented.
+ */
+
+#include <asm/errno.h>
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+}
+
+extern int gpio_direction_input(unsigned gpio);
+extern int gpio_direction_output(unsigned gpio, int value);
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return at91_get_gpio_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	at91_set_gpio_value(gpio, value);
+}
+
+#include <asm-generic/gpio.h>		/* cansleep wrappers */
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+	return gpio;
+}
+
+static inline int irq_to_gpio(unsigned irq)
+{
+	return irq;
+}
+
+#endif	/* __ASSEMBLY__ */
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,90 @@
+/*
+ * include/asm-arm/arch-at91/hardware.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *  Copyright (C) 2003 ATMEL
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#if defined(CONFIG_ARCH_AT91RM9200)
+#include <asm/arch/at91rm9200.h>
+#elif defined(CONFIG_ARCH_AT91SAM9260)
+#include <asm/arch/at91sam9260.h>
+#elif defined(CONFIG_ARCH_AT91SAM9261)
+#include <asm/arch/at91sam9261.h>
+#elif defined(CONFIG_ARCH_AT91SAM9263)
+#include <asm/arch/at91sam9263.h>
+#else
+#error "Unsupported AT91 processor"
+#endif
+
+
+/*
+ * Remap the peripherals from address 0xFFF78000 .. 0xFFFFFFFF
+ * to 0xFEF78000 .. 0xFF000000.  (544Kb)
+ */
+#define AT91_IO_PHYS_BASE	0xFFF78000
+#define AT91_IO_SIZE		(0xFFFFFFFF - AT91_IO_PHYS_BASE + 1)
+#define AT91_IO_VIRT_BASE	(0xFF000000 - AT91_IO_SIZE)
+
+ /* Convert a physical IO address to virtual IO address */
+#define AT91_IO_P2V(x)		((x) - AT91_IO_PHYS_BASE + AT91_IO_VIRT_BASE)
+
+/*
+ * Virtual to Physical Address mapping for IO devices.
+ */
+#define AT91_VA_BASE_SYS	AT91_IO_P2V(AT91_BASE_SYS)
+#define AT91_VA_BASE_EMAC	AT91_IO_P2V(AT91RM9200_BASE_EMAC)
+
+ /* Internal SRAM is mapped below the IO devices */
+#define AT91_SRAM_MAX		SZ_1M
+#define AT91_VIRT_BASE		(AT91_IO_VIRT_BASE - AT91_SRAM_MAX)
+
+/* Serial ports */
+#define ATMEL_MAX_UART		7		/* 6 USART3's and one DBGU port (SAM9260) */
+
+/* External Memory Map */
+#define AT91_CHIPSELECT_0	0x10000000
+#define AT91_CHIPSELECT_1	0x20000000
+#define AT91_CHIPSELECT_2	0x30000000
+#define AT91_CHIPSELECT_3	0x40000000
+#define AT91_CHIPSELECT_4	0x50000000
+#define AT91_CHIPSELECT_5	0x60000000
+#define AT91_CHIPSELECT_6	0x70000000
+#define AT91_CHIPSELECT_7	0x80000000
+
+/* SDRAM */
+#define AT91_SDRAM_BASE		AT91_CHIPSELECT_1
+
+/* Clocks */
+#define AT91_SLOW_CLOCK		32768		/* slow clock */
+
+#ifndef __ASSEMBLY__
+#include <asm/io.h>
+
+static inline unsigned int at91_sys_read(unsigned int reg_offset)
+{
+	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
+
+	return __raw_readl(addr + reg_offset);
+}
+
+static inline void at91_sys_write(unsigned int reg_offset, unsigned long value)
+{
+	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
+
+	__raw_writel(value, addr + reg_offset);
+}
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-at91/io.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include <asm/io.h>
+
+#define IO_SPACE_LIMIT		0xFFFFFFFF
+
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,44 @@
+/*
+ * include/asm-arm/arch-at91/irqs.h
+ *
+ *  Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include <asm/arch/at91_aic.h>
+
+#define NR_AIC_IRQS 32
+
+
+/*
+ * Acknowledge interrupt with AIC after interrupt has been handled.
+ *   (by kernel/irq.c)
+ */
+#define irq_finish(irq) do { at91_sys_write(AT91_AIC_EOICR, 0); } while (0)
+
+
+/*
+ * IRQ interrupt symbols are the AT91xxx_ID_* symbols
+ * for IRQs handled directly through the AIC, or else the AT91_PIN_*
+ * symbols in gpio.h for ones handled indirectly as GPIOs.
+ * We make provision for 5 banks of GPIO.
+ */
+#define	NR_IRQS		(NR_AIC_IRQS + (5 * 32))
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-at91/memory.h
+ *
+ *  Copyright (C) 2004 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/hardware.h>
+
+#define PHYS_OFFSET	(AT91_SDRAM_BASE)
+
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,53 @@
+/*
+ * include/asm-arm/arch-at91/system.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/arch/at91_st.h>
+#include <asm/arch/at91_dbgu.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * Disable the processor clock.  The processor will be automatically
+	 * re-enabled by an interrupt or by a reset.
+	 */
+//	at91_sys_write(AT91_PMC_SCDR, AT91_PMC_PCK);
+
+	/*
+	 * Set the processor (CP15) into 'Wait for Interrupt' mode.
+	 * Unlike disabling the processor clock via the PMC (above)
+	 *  this allows the processor to be woken via JTAG.
+	 */
+	cpu_do_idle();
+}
+
+void (*at91_arch_reset)(void);
+
+static inline void arch_reset(char mode)
+{
+	/* call the CPU-specific reset function */
+	if (at91_arch_reset)
+		(at91_arch_reset)();
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ * include/asm-arm/arch-at91/timex.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <asm/hardware.h>
+
+#if defined(CONFIG_ARCH_AT91RM9200)
+
+#define CLOCK_TICK_RATE		(AT91_SLOW_CLOCK)
+
+#elif defined(CONFIG_ARCH_AT91SAM9260) || defined(CONFIG_ARCH_AT91SAM9261)
+
+#define AT91SAM9_MASTER_CLOCK	99300000
+#define CLOCK_TICK_RATE		(AT91SAM9_MASTER_CLOCK/16)
+
+#elif defined(CONFIG_ARCH_AT91SAM9263)
+
+#define AT91SAM9_MASTER_CLOCK	99959500
+#define CLOCK_TICK_RATE		(AT91SAM9_MASTER_CLOCK/16)
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,56 @@
+/*
+ * include/asm-arm/arch-at91/uncompress.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <asm/hardware.h>
+#include <asm/arch/at91_dbgu.h>
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putc(int c)
+{
+	void __iomem *sys = (void __iomem *) AT91_BASE_SYS;	/* physical address */
+
+	while (!(__raw_readl(sys + AT91_DBGU_SR) & AT91_DBGU_TXRDY))
+		barrier();
+	__raw_writel(c, sys + AT91_DBGU_THR);
+}
+
+static inline void flush(void)
+{
+	void __iomem *sys = (void __iomem *) AT91_BASE_SYS;	/* physical address */
+
+	/* wait for transmission to complete */
+	while (!(__raw_readl(sys + AT91_DBGU_SR) & AT91_DBGU_TXEMPTY))
+		barrier();
+}
+
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif
Index: build_tree/linux/include/asm/arch-at91/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-at91/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-at91/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-at91/vmalloc.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END		(AT91_VIRT_BASE & PGDIR_MASK)
+
+#endif
Index: build_tree/linux/include/asm/arch-cl7500/acornfb.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/acornfb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/acornfb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+#define acornfb_valid_pixrate(var) (var->pixclock >= 39325 && var->pixclock <= 40119)
+
+static inline void
+acornfb_vidc20_find_rates(struct vidc_timing *vidc,
+			  struct fb_var_screeninfo *var)
+{
+	u_int bandwidth;
+  
+	vidc->control |= VIDC20_CTRL_PIX_CK;
+
+	/* Calculate bandwidth */
+	bandwidth = var->pixclock * 8 / var->bits_per_pixel;
+
+	/* Encode bandwidth as VIDC20 setting */
+	if (bandwidth > 16667*2)
+		vidc->control |= VIDC20_CTRL_FIFO_16;
+	else if (bandwidth > 13333*2)
+		vidc->control |= VIDC20_CTRL_FIFO_20;
+	else if (bandwidth > 11111*2)
+		vidc->control |= VIDC20_CTRL_FIFO_24;
+	else
+		vidc->control |= VIDC20_CTRL_FIFO_28;
+
+	vidc->pll_ctl  = 0x2020;
+}
+
+#ifdef CONFIG_CHRONTEL_7003
+#define acornfb_default_control()	VIDC20_CTRL_PIX_HCLK
+#else
+#define acornfb_default_control()	VIDC20_CTRL_PIX_VCLK
+#endif
+
+#define acornfb_default_econtrol()	VIDC20_ECTL_DAC | VIDC20_ECTL_REG(3) | VIDC20_ECTL_ECK
Index: build_tree/linux/include/asm/arch-cl7500/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/* linux/include/asm-arm/arch-cl7500/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mov	\rx, #0xe0000000
+		orr	\rx, \rx, #0x00010000
+		orr	\rx, \rx, #0x00000be0
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-cl7500/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/dma.h
+ *
+ * Copyright (C) 1999 Nexus Electronics Ltd.
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/* DMA is not yet implemented! It should be the same as acorn, copy over.. */
+
+/*
+ * This is the maximum DMA address that can be DMAd to.
+ * There should not be more than (0xd0000000 - 0xc0000000)
+ * bytes of RAM.
+ */
+#define MAX_DMA_ADDRESS		0xd0000000
+
+#define DMA_S0			0
+
+#endif /* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-cl7500/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,8 @@
+#include <asm/hardware.h>
+#include <asm/hardware/entry-macro-iomd.S>
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
Index: build_tree/linux/include/asm/arch-cl7500/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,67 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/hardware.h
+ *
+ * Copyright (C) 1996-1999 Russell King.
+ * Copyright (C) 1999 Nexus Electronics Ltd.
+ *
+ * This file contains the hardware definitions of the 
+ * CL7500 evaluation board.
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/memory.h>
+#include <asm/hardware/iomd.h>
+
+#ifdef __ASSEMBLY__
+#define IOMEM(x) x
+#else
+#define IOMEM(x) ((void __iomem *)(x))
+#endif
+
+/*
+ * What hardware must be present
+ */
+#define HAS_IOMD
+#define HAS_VIDC20
+
+/* Hardware addresses of major areas.
+ *  *_START is the physical address
+ *  *_SIZE  is the size of the region
+ *  *_BASE  is the virtual address
+ */
+
+#define IO_START		0x03000000	/* I/O */
+#define IO_SIZE			0x01000000
+#define IO_BASE			IOMEM(0xe0000000)
+
+#define ISA_START		0x0c000000	/* ISA */
+#define ISA_SIZE		0x00010000
+#define ISA_BASE		0xe1000000
+
+#define FLASH_START		0x01000000	/* XXX */
+#define FLASH_SIZE		0x01000000
+#define FLASH_BASE		0xe2000000
+
+#define LED_START		0x0302B000
+#define LED_SIZE		0x00001000
+#define LED_BASE		0xe3000000
+#define LED_ADDRESS		(LED_BASE + 0xa00)
+
+/* Let's define SCREEN_START for CL7500, even though it's a lie. */
+#define SCREEN_START		0x02000000	/* VRAM */
+#define SCREEN_END		0xdfc00000
+#define SCREEN_BASE		0xdf800000
+
+#define VIDC_BASE		(void __iomem *)0xe0400000
+#define IOMD_BASE		IOMEM(0xe0200000)
+#define IOC_BASE		IOMEM(0xe0200000)
+#define FLOPPYDMA_BASE		IOMEM(0xe002a000)
+#define PCIO_BASE		IOMEM(0xe0010000)
+
+#define vidc_writel(val)	__raw_writel(val, VIDC_BASE)
+
+/* in/out bias for the ISA slot region */
+#define ISASLOT_IO		0x80400000
+
+#endif
Index: build_tree/linux/include/asm/arch-cl7500/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,255 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/io.h
+ *  from linux/include/asm-arm/arch-rpc/io.h
+ *
+ * Copyright (C) 1997 Russell King
+ *
+ * Modifications:
+ *  06-Dec-1997	RMK	Created.
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * GCC is totally crap at loading/storing data.  We try to persuade it
+ * to do the right thing by using these whereever possible instead of
+ * the above.
+ */
+#define __arch_base_getb(b,o)			\
+ ({						\
+	unsigned int v, r = (b);		\
+	__asm__ __volatile__(			\
+		"ldrb	%0, [%1, %2]"		\
+		: "=r" (v)			\
+		: "r" (r), "Ir" (o));		\
+	v;					\
+ })
+
+#define __arch_base_getl(b,o)			\
+ ({						\
+	unsigned int v, r = (b);		\
+	__asm__ __volatile__(			\
+		"ldr	%0, [%1, %2]"		\
+		: "=r" (v)			\
+		: "r" (r), "Ir" (o));		\
+	v;					\
+ })
+
+#define __arch_base_putb(v,b,o)			\
+ ({						\
+	unsigned int r = (b);			\
+	__asm__ __volatile__(			\
+		"strb	%0, [%1, %2]"		\
+		:				\
+		: "r" (v), "r" (r), "Ir" (o));	\
+ })
+
+#define __arch_base_putl(v,b,o)			\
+ ({						\
+	unsigned int r = (b);			\
+	__asm__ __volatile__(			\
+		"str	%0, [%1, %2]"		\
+		:				\
+		: "r" (v), "r" (r), "Ir" (o));	\
+ })
+
+/*
+ * We use two different types of addressing - PC style addresses, and ARM
+ * addresses.  PC style accesses the PC hardware with the normal PC IO
+ * addresses, eg 0x3f8 for serial#1.  ARM addresses are 0x80000000+
+ * and are translated to the start of IO.  Note that all addresses are
+ * shifted left!
+ */
+#define __PORT_PCIO(x)	(!((x) & 0x80000000))
+
+/*
+ * Dynamic IO functions - let the compiler
+ * optimize the expressions
+ */
+static inline void __outb (unsigned int value, unsigned int port)
+{
+	unsigned long temp;
+	__asm__ __volatile__(
+	"tst	%2, #0x80000000\n\t"
+	"mov	%0, %4\n\t"
+	"addeq	%0, %0, %3\n\t"
+	"strb	%1, [%0, %2, lsl #2]	@ outb"
+	: "=&r" (temp)
+	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
+	: "cc");
+}
+
+static inline void __outw (unsigned int value, unsigned int port)
+{
+	unsigned long temp;
+	__asm__ __volatile__(
+	"tst	%2, #0x80000000\n\t"
+	"mov	%0, %4\n\t"
+	"addeq	%0, %0, %3\n\t"
+	"str	%1, [%0, %2, lsl #2]	@ outw"
+	: "=&r" (temp)
+	: "r" (value|value<<16), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
+	: "cc");
+}
+
+static inline void __outl (unsigned int value, unsigned int port)
+{
+	unsigned long temp;
+	__asm__ __volatile__(
+	"tst	%2, #0x80000000\n\t"
+	"mov	%0, %4\n\t"
+	"addeq	%0, %0, %3\n\t"
+	"str	%1, [%0, %2, lsl #2]	@ outl"
+	: "=&r" (temp)
+	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
+	: "cc");
+}
+
+#define DECLARE_DYN_IN(sz,fnsuffix,instr)					\
+static inline unsigned sz __in##fnsuffix (unsigned int port)		\
+{										\
+	unsigned long temp, value;						\
+	__asm__ __volatile__(							\
+	"tst	%2, #0x80000000\n\t"						\
+	"mov	%0, %4\n\t"							\
+	"addeq	%0, %0, %3\n\t"							\
+	"ldr" instr "	%1, [%0, %2, lsl #2]	@ in" #fnsuffix			\
+	: "=&r" (temp), "=r" (value)						\
+	: "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)		\
+	: "cc");								\
+	return (unsigned sz)value;						\
+}
+
+static inline unsigned int __ioaddr (unsigned int port)			\
+{										\
+	if (__PORT_PCIO(port))							\
+		return (unsigned int)(PCIO_BASE + (port << 2));			\
+	else									\
+		return (unsigned int)(IO_BASE + (port << 2));			\
+}
+
+#define DECLARE_IO(sz,fnsuffix,instr)	\
+	DECLARE_DYN_IN(sz,fnsuffix,instr)
+
+DECLARE_IO(char,b,"b")
+DECLARE_IO(short,w,"")
+DECLARE_IO(int,l,"")
+
+#undef DECLARE_IO
+#undef DECLARE_DYN_IN
+
+/*
+ * Constant address IO functions
+ *
+ * These have to be macros for the 'J' constraint to work -
+ * +/-4096 immediate operand.
+ */
+#define __outbc(value,port)							\
+({										\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"strb	%0, [%1, %2]	@ outbc"				\
+		: : "r" (value), "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"strb	%0, [%1, %2]	@ outbc"				\
+		: : "r" (value), "r" (IO_BASE), "r" ((port) << 2));		\
+})
+
+#define __inbc(port)								\
+({										\
+	unsigned char result;							\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"ldrb	%0, [%1, %2]	@ inbc"					\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"ldrb	%0, [%1, %2]	@ inbc"					\
+		: "=r" (result) : "r" (IO_BASE), "r" ((port) << 2));		\
+	result;									\
+})
+
+#define __outwc(value,port)							\
+({										\
+	unsigned long v = value;						\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outwc"				\
+		: : "r" (v|v<<16), "r" (PCIO_BASE), "Jr" ((port) << 2));	\
+	else									\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outwc"				\
+		: : "r" (v|v<<16), "r" (IO_BASE), "r" ((port) << 2));		\
+})
+
+#define __inwc(port)								\
+({										\
+	unsigned short result;							\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inwc"					\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inwc"					\
+		: "=r" (result) : "r" (IO_BASE), "r" ((port) << 2));		\
+	result & 0xffff;							\
+})
+
+#define __outlc(value,port)							\
+({										\
+	unsigned long v = value;						\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outlc"				\
+		: : "r" (v), "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outlc"				\
+		: : "r" (v), "r" (IO_BASE), "r" ((port) << 2));			\
+})
+
+#define __inlc(port)								\
+({										\
+	unsigned long result;							\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inlc"					\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inlc"					\
+		: "=r" (result) : "r" (IO_BASE), "r" ((port) << 2));		\
+	result;									\
+})
+
+#define __ioaddrc(port)								\
+	(__PORT_PCIO((port)) ? PCIO_BASE + ((port) << 2) : IO_BASE + ((port) << 2))
+
+#define inb(p)	 	(__builtin_constant_p((p)) ? __inbc(p)    : __inb(p))
+#define inw(p)	 	(__builtin_constant_p((p)) ? __inwc(p)    : __inw(p))
+#define inl(p)	 	(__builtin_constant_p((p)) ? __inlc(p)    : __inl(p))
+#define outb(v,p)	(__builtin_constant_p((p)) ? __outbc(v,p) : __outb(v,p))
+#define outw(v,p)	(__builtin_constant_p((p)) ? __outwc(v,p) : __outw(v,p))
+#define outl(v,p)	(__builtin_constant_p((p)) ? __outlc(v,p) : __outl(v,p))
+#define __ioaddr(p)	(__builtin_constant_p((p)) ? __ioaddr(p)  : __ioaddrc(p))
+/* the following macro is deprecated */
+#define ioaddr(port)			__ioaddr((port))
+
+#define insb(p,d,l)	__raw_readsb(__ioaddr(p),d,l)
+#define insw(p,d,l)	__raw_readsw(__ioaddr(p),d,l)
+
+#define outsb(p,d,l)	__raw_writesb(__ioaddr(p),d,l)
+#define outsw(p,d,l)	__raw_writesw(__ioaddr(p),d,l)
+
+/*
+ * 1:1 mapping for ioremapped regions.
+ */
+#define __mem_pci(x)	(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-cl7500/irq.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/irq.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-cl7500/irq.h
+ *
+ * Copyright (C) 1996 Russell King
+ * Copyright (C) 1999, 2001 Nexus Electronics Ltd.
+ *
+ * Changelog:
+ *   10-10-1996	RMK	Brought up to date with arch-sa110eval
+ *   22-08-1998	RMK	Restructured IRQ routines
+ *   11-08-1999	PJB	Created ARM7500 version, derived from RiscPC code
+ */
+
+#include <asm/hardware/iomd.h>
+#include <asm/io.h>
+
+static inline int fixup_irq(unsigned int irq)
+{
+	if (irq == IRQ_ISA) {
+		int isabits = *((volatile unsigned int *)0xe002b700);
+		if (isabits == 0) {
+			printk("Spurious ISA IRQ!\n");
+			return irq;
+		}
+		irq = IRQ_ISA_BASE;
+		while (!(isabits & 1)) {
+			irq++;
+			isabits >>= 1;
+		}
+	}
+
+	return irq;
+}
Index: build_tree/linux/include/asm/arch-cl7500/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,66 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/irqs.h
+ *
+ * Copyright (C) 1999 Nexus Electronics Ltd
+ */
+
+#define IRQ_INT2		0
+#define IRQ_INT1		2
+#define IRQ_VSYNCPULSE		3
+#define IRQ_POWERON		4
+#define IRQ_TIMER0		5
+#define IRQ_TIMER1		6
+#define IRQ_FORCE		7
+#define IRQ_INT8		8
+#define IRQ_ISA			9
+#define IRQ_INT6		10
+#define IRQ_INT5		11
+#define IRQ_INT4		12
+#define IRQ_INT3		13
+#define IRQ_KEYBOARDTX		14
+#define IRQ_KEYBOARDRX		15
+
+#define IRQ_DMA0		16
+#define IRQ_DMA1		17
+#define IRQ_DMA2		18
+#define IRQ_DMA3		19
+#define IRQ_DMAS0		20
+#define IRQ_DMAS1		21
+
+#define IRQ_IOP0		24
+#define IRQ_IOP1		25
+#define IRQ_IOP2		26
+#define IRQ_IOP3		27
+#define IRQ_IOP4		28
+#define IRQ_IOP5		29
+#define IRQ_IOP6		30
+#define IRQ_IOP7		31
+
+#define IRQ_MOUSERX		40
+#define IRQ_MOUSETX		41
+#define IRQ_ADC			42
+#define IRQ_EVENT1		43
+#define IRQ_EVENT2		44
+
+#define IRQ_ISA_BASE		48
+#define IRQ_ISA_3		48
+#define IRQ_ISA_4		49
+#define IRQ_ISA_5		50
+#define IRQ_ISA_7		51
+#define IRQ_ISA_9		52
+#define IRQ_ISA_10		53
+#define IRQ_ISA_11		54
+#define IRQ_ISA_14		55	
+
+#define FIQ_INT9		0
+#define FIQ_INT5		1
+#define FIQ_INT6		4
+#define FIQ_INT8		6
+#define FIQ_FORCE		7
+
+/*
+ * This is the offset of the FIQ "IRQ" numbers
+ */
+#define FIQ_START		64
+
+#define IRQ_TIMER		IRQ_TIMER0
Index: build_tree/linux/include/asm/arch-cl7500/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/memory.h
+ *
+ * Copyright (c) 1996,1997,1998 Russell King.
+ *
+ * Changelog:
+ *  20-Oct-1996	RMK	Created
+ *  31-Dec-1997	RMK	Fixed definitions to reduce warnings
+ *  11-Jan-1998	RMK	Uninlined to reduce hits on cache
+ *  08-Feb-1998	RMK	Added __virt_to_bus and __bus_to_virt
+ *  21-Mar-1999	RMK	Renamed to memory.h
+ *		RMK	Added TASK_SIZE and PAGE_OFFSET
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x10000000)
+
+/*
+ * These are exactly the same on the RiscPC as the
+ * physical memory view.
+ */
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+/*
+ * Cache flushing area - ROM
+ */
+#define FLUSH_BASE_PHYS		0x00000000
+#define FLUSH_BASE		0xdf000000
+
+#endif
Index: build_tree/linux/include/asm/arch-cl7500/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/system.h
+ *
+ * Copyright (c) 1999 Nexus Electronics Ltd.
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware/iomd.h>
+#include <asm/io.h>
+
+static inline void arch_idle(void)
+{
+	iomd_writeb(0, IOMD_SUSMODE);
+}
+
+#define arch_reset(mode)			\
+	do {					\
+		iomd_writeb(0, IOMD_ROMCR0);	\
+		cpu_reset(0);			\
+	} while (0)
+
+#endif
Index: build_tree/linux/include/asm/arch-cl7500/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,13 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/timex.h
+ *
+ * CL7500 architecture timex specifications
+ *
+ * Copyright (C) 1999 Nexus Electronics Ltd
+ */
+
+/*
+ * On the ARM7500, the clock ticks at 2MHz.
+ */
+#define CLOCK_TICK_RATE		2000000
+
Index: build_tree/linux/include/asm/arch-cl7500/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/uncompress.h
+ *
+ * Copyright (C) 1999, 2000 Nexus Electronics Ltd.
+ */
+#define BASE 0x03010000
+#define SERBASE (BASE + (0x2f8 << 2))
+
+static inline void putc(char c)
+{
+	while (!(*((volatile unsigned int *)(SERBASE + 0x14)) & 0x20))
+		barrier();
+
+	*((volatile unsigned int *)(SERBASE)) = c;
+}
+
+static inline void flush(void)
+{
+}
+
+static __inline__ void arch_decomp_setup(void)
+{
+	int baud = 3686400 / (9600 * 32);
+
+	*((volatile unsigned int *)(SERBASE + 0xC)) = 0x80;
+	*((volatile unsigned int *)(SERBASE + 0x0)) = baud & 0xff;
+	*((volatile unsigned int *)(SERBASE + 0x4)) = (baud & 0xff00) >> 8;
+	*((volatile unsigned int *)(SERBASE + 0xC)) = 3; /* 8 bits */
+	*((volatile unsigned int *)(SERBASE + 0x10)) = 3; /* DTR, RTS */
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-cl7500/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-cl7500/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-cl7500/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,4 @@
+/*
+ * linux/include/asm-arm/arch-cl7500/vmalloc.h
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x1c000000)
Index: build_tree/linux/include/asm/arch-clps711x/autcpu12.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/autcpu12.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/autcpu12.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,78 @@
+/*
+ * AUTCPU12 specific defines
+ *
+ * (c) 2001 Thomas Gleixner, autronix automation <gleixner@autronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_AUTCPU12_H
+#define __ASM_ARCH_AUTCPU12_H
+
+/*
+ * The CS8900A ethernet chip has its I/O registers wired to chip select 2
+ * (nCS2). This is the mapping for it.
+ */
+#define AUTCPU12_PHYS_CS8900A		CS2_PHYS_BASE		/* physical */
+#define AUTCPU12_VIRT_CS8900A		(0xfe000000)		/* virtual */
+
+/*
+ * The flash bank is wired to chip select 0
+ */
+#define AUTCPU12_PHYS_FLASH		CS0_PHYS_BASE		/* physical */
+
+/* offset for device specific information structure */
+#define AUTCPU12_LCDINFO_OFFS		(0x00010000)	
+/*
+* Videomemory is the internal SRAM (CS 6)	
+*/
+#define AUTCPU12_PHYS_VIDEO		CS6_PHYS_BASE
+#define AUTCPU12_VIRT_VIDEO		(0xfd000000)
+
+/*
+* All special IO's are tied to CS1
+*/
+#define AUTCPU12_PHYS_CHAR_LCD         	CS1_PHYS_BASE +0x00000000  /* physical */
+
+#define AUTCPU12_PHYS_NVRAM            	CS1_PHYS_BASE +0x02000000  /* physical */
+
+#define AUTCPU12_PHYS_CSAUX1           	CS1_PHYS_BASE +0x04000000  /* physical */
+
+#define AUTCPU12_PHYS_SMC              	CS1_PHYS_BASE +0x06000000  /* physical */
+
+#define AUTCPU12_PHYS_CAN              	CS1_PHYS_BASE +0x08000000  /* physical */
+
+#define AUTCPU12_PHYS_TOUCH            	CS1_PHYS_BASE +0x0A000000  /* physical */
+
+#define AUTCPU12_PHYS_IO               	CS1_PHYS_BASE +0x0C000000  /* physical */
+
+#define AUTCPU12_PHYS_LPT              	CS1_PHYS_BASE +0x0E000000  /* physical */
+
+/* 
+* defines for smartmedia card access 
+*/
+#define AUTCPU12_SMC_RDY		(1<<2)
+#define AUTCPU12_SMC_ALE		(1<<3)
+#define AUTCPU12_SMC_CLE  		(1<<4)
+#define AUTCPU12_SMC_PORT_OFFSET	PBDR
+#define AUTCPU12_SMC_SELECT_OFFSET 	0x10
+/*
+* defines for lcd contrast 
+*/
+#define AUTCPU12_DPOT_PORT_OFFSET	PEDR
+#define	AUTCPU12_DPOT_CS		(1<<0)
+#define AUTCPU12_DPOT_CLK    		(1<<1)
+#define	AUTCPU12_DPOT_UD		(1<<2)
+
+#endif
Index: build_tree/linux/include/asm/arch-clps711x/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/* linux/include/asm-arm/arch-clps711x/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <asm/hardware/clps7111.h>
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #CLPS7111_PHYS_BASE
+		movne	\rx, #CLPS7111_VIRT_BASE
+#ifndef CONFIG_DEBUG_CLPS711X_UART2
+		add	\rx, \rx, #0x0000	@ UART1
+#else
+		add	\rx, \rx, #0x1000	@ UART2
+#endif
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0x0480]	@ UARTDR
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldr	\rd, [\rx, #0x0140]	@ SYSFLGx
+		tst	\rd, #1 << 11		@ UBUSYx
+		bne	1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+		tst	\rx, #0x1000		@ UART2 does not have CTS here
+		bne	1002f
+1001:		ldr	\rd, [\rx, #0x0140]	@ SYSFLGx
+		tst	\rd, #1 << 8		@ CTS
+		bne	1001b
+1002:
+		.endm
+
Index: build_tree/linux/include/asm/arch-clps711x/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
Index: build_tree/linux/include/asm/arch-clps711x/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,58 @@
+/*
+ * include/asm-arm/arch-clps711x/entry-macro.S
+ *
+ * Low-level IRQ helper macros for CLPS711X-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/hardware/clps7111.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro	get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro	arch_ret_to_user, tmp1, tmp2
+		.endm
+
+#if (INTSR2 - INTSR1) != (INTMR2 - INTMR1)
+#error INTSR stride != INTMR stride
+#endif
+
+		.macro	get_irqnr_and_base, irqnr, stat, base, mask
+		mov	\base, #CLPS7111_BASE
+		ldr	\stat, [\base, #INTSR1]
+		ldr	\mask, [\base, #INTMR1]
+		mov	\irqnr, #4
+		mov	\mask, \mask, lsl #16
+		and	\stat, \stat, \mask, lsr #16
+		movs	\stat, \stat, lsr #4
+		bne	1001f
+
+		add	\base, \base, #INTSR2 - INTSR1
+		ldr	\stat, [\base, #INTSR1]
+		ldr	\mask, [\base, #INTMR1]
+		mov	\irqnr, #16
+		mov	\mask, \mask, lsl #16
+		and	\stat, \stat, \mask, lsr #16
+
+1001:		tst	\stat, #255
+		addeq	\irqnr, \irqnr, #8
+		moveq	\stat, \stat, lsr #8
+		tst	\stat, #15
+		addeq	\irqnr, \irqnr, #4
+		moveq	\stat, \stat, lsr #4
+		tst	\stat, #3
+		addeq	\irqnr, \irqnr, #2
+		moveq	\stat, \stat, lsr #2
+		tst	\stat, #1
+		addeq	\irqnr, \irqnr, #1
+		moveq	\stat, \stat, lsr #1
+		tst	\stat, #1			@ bit 0 should be set
+		.endm
+
+
Index: build_tree/linux/include/asm/arch-clps711x/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,237 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/hardware.h
+ *
+ *  This file contains the hardware definitions of the Prospector P720T.
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+
+#define CLPS7111_VIRT_BASE	0xff000000
+#define CLPS7111_BASE		CLPS7111_VIRT_BASE
+
+/*
+ * The physical addresses that the external chip select signals map to is
+ * dependent on the setting of the nMEDCHG signal on EP7211 and EP7212
+ * processors.  CONFIG_EP72XX_BOOT_ROM is only available if these
+ * processors are in use.
+ */
+#ifndef CONFIG_EP72XX_ROM_BOOT
+#define CS0_PHYS_BASE		(0x00000000)
+#define CS1_PHYS_BASE		(0x10000000)
+#define CS2_PHYS_BASE		(0x20000000)
+#define CS3_PHYS_BASE		(0x30000000)
+#define CS4_PHYS_BASE		(0x40000000)
+#define CS5_PHYS_BASE		(0x50000000)
+#define CS6_PHYS_BASE		(0x60000000)
+#define CS7_PHYS_BASE		(0x70000000)
+#else
+#define CS0_PHYS_BASE		(0x70000000)
+#define CS1_PHYS_BASE		(0x60000000)
+#define CS2_PHYS_BASE		(0x50000000)
+#define CS3_PHYS_BASE		(0x40000000)
+#define CS4_PHYS_BASE		(0x30000000)
+#define CS5_PHYS_BASE		(0x20000000)
+#define CS6_PHYS_BASE		(0x10000000)
+#define CS7_PHYS_BASE		(0x00000000)
+#endif
+
+#if defined (CONFIG_ARCH_EP7211)
+
+#define EP7211_VIRT_BASE	CLPS7111_VIRT_BASE
+#define EP7211_BASE		CLPS7111_VIRT_BASE
+#include <asm/hardware/ep7211.h>
+
+#elif defined (CONFIG_ARCH_EP7212)
+
+#define EP7212_VIRT_BASE	CLPS7111_VIRT_BASE
+#define EP7212_BASE		CLPS7111_VIRT_BASE
+#include <asm/hardware/ep7212.h>
+
+#endif
+
+#define SYSPLD_VIRT_BASE	0xfe000000
+#define SYSPLD_BASE		SYSPLD_VIRT_BASE
+
+#ifndef __ASSEMBLER__
+
+#define PCIO_BASE		IO_BASE
+
+#endif
+
+
+#if  defined (CONFIG_ARCH_AUTCPU12)
+
+#define  CS89712_VIRT_BASE	CLPS7111_VIRT_BASE
+#define  CS89712_BASE		CLPS7111_VIRT_BASE
+
+#include <asm/hardware/clps7111.h>
+#include <asm/hardware/ep7212.h>
+#include <asm/hardware/cs89712.h>
+
+#endif
+
+
+#if defined (CONFIG_ARCH_CDB89712)
+
+#include <asm/hardware/clps7111.h>
+#include <asm/hardware/ep7212.h>
+#include <asm/hardware/cs89712.h>
+
+/* dynamic ioremap() areas */
+#define FLASH_START      0x00000000
+#define FLASH_SIZE       0x800000
+#define FLASH_WIDTH      4
+
+#define SRAM_START       0x60000000
+#define SRAM_SIZE        0xc000
+#define SRAM_WIDTH       4
+
+#define BOOTROM_START    0x70000000
+#define BOOTROM_SIZE     0x80
+#define BOOTROM_WIDTH    4
+
+
+/* static cdb89712_map_io() areas */
+#define REGISTER_START   0x80000000
+#define REGISTER_SIZE    0x4000
+#define REGISTER_BASE    0xff000000
+
+#define ETHER_START      0x20000000
+#define ETHER_SIZE       0x1000
+#define ETHER_BASE       0xfe000000
+
+#endif
+
+
+#if defined (CONFIG_ARCH_EDB7211)
+
+/*
+ * The extra 8 lines of the keyboard matrix are wired to chip select 3 (nCS3) 
+ * and repeat across it. This is the mapping for it.
+ *
+ * In jumpered boot mode, nCS3 is mapped to 0x4000000, not 0x3000000. This 
+ * was cause for much consternation and headscratching. This should probably
+ * be made a compile/run time kernel option.
+ */
+#define EP7211_PHYS_EXTKBD		CS3_PHYS_BASE	/* physical */
+
+#define EP7211_VIRT_EXTKBD		(0xfd000000)	/* virtual */
+
+
+/*
+ * The CS8900A ethernet chip has its I/O registers wired to chip select 2 
+ * (nCS2). This is the mapping for it.
+ *
+ * In jumpered boot mode, nCS2 is mapped to 0x5000000, not 0x2000000. This 
+ * was cause for much consternation and headscratching. This should probably
+ * be made a compile/run time kernel option.
+ */
+#define EP7211_PHYS_CS8900A		CS2_PHYS_BASE	/* physical */
+
+#define EP7211_VIRT_CS8900A		(0xfc000000)	/* virtual */
+
+
+/*
+ * The two flash banks are wired to chip selects 0 and 1. This is the mapping
+ * for them.
+ *
+ * nCS0 and nCS1 are at 0x70000000 and 0x60000000, respectively, when running
+ * in jumpered boot mode.
+ */
+#define EP7211_PHYS_FLASH1		CS0_PHYS_BASE	/* physical */
+#define EP7211_PHYS_FLASH2		CS1_PHYS_BASE	/* physical */
+
+#define EP7211_VIRT_FLASH1		(0xfa000000)	/* virtual */
+#define EP7211_VIRT_FLASH2		(0xfb000000)	/* virtual */
+
+#endif /* CONFIG_ARCH_EDB7211 */
+
+
+/*
+ * Relevant bits in port D, which controls power to the various parts of
+ * the LCD on the EDB7211.
+ */
+#define EDB_PD1_LCD_DC_DC_EN	(1<<1)
+#define EDB_PD2_LCDEN		(1<<2)
+#define EDB_PD3_LCDBL		(1<<3)
+
+
+#if defined (CONFIG_ARCH_CEIVA)
+
+#define  CEIVA_VIRT_BASE	CLPS7111_VIRT_BASE
+#define  CEIVA_BASE		CLPS7111_VIRT_BASE
+
+#include <asm/hardware/clps7111.h>
+#include <asm/hardware/ep7212.h>
+
+
+/*
+ * The two flash banks are wired to chip selects 0 and 1. This is the mapping
+ * for them.
+ *
+ * nCS0 and nCS1 are at 0x70000000 and 0x60000000, respectively, when running
+ * in jumpered boot mode.
+ */
+#define CEIVA_PHYS_FLASH1	CS0_PHYS_BASE	/* physical */
+#define CEIVA_PHYS_FLASH2	CS1_PHYS_BASE	/* physical */
+
+#define CEIVA_VIRT_FLASH1	(0xfa000000)	/* virtual */
+#define CEIVA_VIRT_FLASH2	(0xfb000000)	/* virtual */
+
+#define CEIVA_FLASH_SIZE        0x100000
+#define CEIVA_FLASH_WIDTH       2
+
+#define SRAM_START       0x60000000
+#define SRAM_SIZE        0xc000
+#define SRAM_WIDTH       4
+
+#define BOOTROM_START    0x70000000
+#define BOOTROM_SIZE     0x80
+#define BOOTROM_WIDTH    4
+
+/*
+ * SED1355 LCD controller
+ */
+#define CEIVA_PHYS_SED1355	CS2_PHYS_BASE
+#define CEIVA_VIRT_SED1355	(0xfc000000)
+
+/*
+ * Relevant bits in port D, which controls power to the various parts of
+ * the LCD on the Ceiva Photo Max, and reset to the LCD controller.
+ */
+
+// Reset line to SED1355 (must be high to operate)
+#define CEIVA_PD1_LCDRST	(1<<1)
+// LCD panel enable (set to one, to enable LCD)
+#define CEIVA_PD4_LCDEN		(1<<4)
+// Backlight (set to one, to turn on backlight
+#define CEIVA_PD5_LCDBL		(1<<5)
+
+/*
+ * Relevant bits in port B, which report the status of the buttons.
+ */
+
+// White button
+#define CEIVA_PB4_WHT_BTN	(1<<4)
+// Black button
+#define CEIVA_PB0_BLK_BTN	(1<<0)
+#endif // #if defined (CONFIG_ARCH_CEIVA)
+
+#endif
Index: build_tree/linux/include/asm/arch-clps711x/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/io.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+/*
+ * We don't support ins[lb]/outs[lb].  Make them fault.
+ */
+#define __raw_readsb(p,d,l)	do { *(int *)0 = 0; } while (0)
+#define __raw_readsl(p,d,l)	do { *(int *)0 = 0; } while (0)
+#define __raw_writesb(p,d,l)	do { *(int *)0 = 0; } while (0)
+#define __raw_writesl(p,d,l)	do { *(int *)0 = 0; } while (0)
+
+#endif
Index: build_tree/linux/include/asm/arch-clps711x/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,53 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/irqs.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Interrupts from INTSR1
+ */
+#define IRQ_CSINT			4
+#define IRQ_EINT1			5
+#define IRQ_EINT2			6
+#define IRQ_EINT3			7
+#define IRQ_TC1OI			8
+#define IRQ_TC2OI			9
+#define IRQ_RTCMI			10
+#define IRQ_TINT			11
+#define IRQ_UTXINT1			12
+#define IRQ_URXINT1			13
+#define IRQ_UMSINT			14
+#define IRQ_SSEOTI			15
+
+#define INT1_IRQS			(0x0000fff0)
+#define INT1_ACK_IRQS			(0x00004f10)
+
+/*
+ * Interrupts from INTSR2
+ */
+#define IRQ_KBDINT			(16+0)	/* bit 0 */
+#define IRQ_SS2RX			(16+1)	/* bit 1 */
+#define IRQ_SS2TX			(16+2)	/* bit 2 */
+#define IRQ_UTXINT2			(16+12)	/* bit 12 */
+#define IRQ_URXINT2			(16+13)	/* bit 13 */
+
+#define INT2_IRQS			(0x30070000)
+#define INT2_ACK_IRQS			(0x00010000)
+
+#define NR_IRQS                         30
+
Index: build_tree/linux/include/asm/arch-clps711x/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,94 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/memory.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0xc0000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+
+#if defined(CONFIG_ARCH_CDB89712)
+
+#define __virt_to_bus(x)	(x)
+#define __bus_to_virt(x)	(x)
+
+#elif defined (CONFIG_ARCH_AUTCPU12)
+
+#define __virt_to_bus(x)	(x)
+#define __bus_to_virt(x)	(x)
+
+#else
+
+#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
+#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+
+#endif
+
+
+/*
+ * Like the SA1100, the EDB7211 has a large gap between physical RAM
+ * banks.  In 2.2, the Psion (CL-PS7110) port added custom support for
+ * discontiguous physical memory.  In 2.4, we can use the standard
+ * Linux NUMA support.
+ *
+ * This is not necessary for EP7211 implementations with only one used
+ * memory bank.  For those systems, simply undefine CONFIG_DISCONTIGMEM.
+ */
+
+/*
+ * The PS7211 allows up to 256MB max per DRAM bank, but the EDB7211
+ * uses only one of the two banks (bank #1).  However, even within
+ * bank #1, memory is discontiguous.
+ *
+ * The EDB7211 has two 8MB DRAM areas with 8MB of empty space between
+ * them, so we use 24 for the node max shift to get 16MB node sizes.
+ */
+
+/*
+ * Because of the wide memory address space between physical RAM banks on the 
+ * SA1100, it's much more convenient to use Linux's NUMA support to implement
+ * our memory map representation.  Assuming all memory nodes have equal access 
+ * characteristics, we then have generic discontiguous memory support.
+ *
+ * Of course, all this isn't mandatory for SA1100 implementations with only
+ * one used memory bank.  For those, simply undefine CONFIG_DISCONTIGMEM.
+ *
+ * The nodes are matched with the physical memory bank addresses which are 
+ * incidentally the same as virtual addresses.
+ * 
+ * 	node 0:  0xc0000000 - 0xc7ffffff
+ * 	node 1:  0xc8000000 - 0xcfffffff
+ * 	node 2:  0xd0000000 - 0xd7ffffff
+ * 	node 3:  0xd8000000 - 0xdfffffff
+ */
+#define NODE_MEM_SIZE_BITS	24
+
+#endif
+
Index: build_tree/linux/include/asm/arch-clps711x/syspld.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/syspld.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/syspld.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,121 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/syspld.h
+ *
+ *  System Control PLD register definitions.
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSPLD_H
+#define __ASM_ARCH_SYSPLD_H
+
+#define SYSPLD_PHYS_BASE	(0x10000000)
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+#define SYSPLD_REG(type,off)	(*(volatile type *)(SYSPLD_BASE + off))
+#else
+#define SYSPLD_REG(type,off)	(off)
+#endif
+
+#define PLD_INT		SYSPLD_REG(u32, 0x000000)
+#define PLD_INT_PENIRQ		(1 << 5)
+#define PLD_INT_UCB_IRQ		(1 << 1)
+#define PLD_INT_KBD_ATN		(1 << 0)	/* EINT1 */
+
+#define PLD_PWR		SYSPLD_REG(u32, 0x000004)
+#define PLD_PWR_EXT		(1 << 5)
+#define PLD_PWR_MODE		(1 << 4)	/* 1 = PWM, 0 = PFM */
+#define PLD_S4_ON		(1 << 3)	/* LCD bias voltage enable */
+#define PLD_S3_ON		(1 << 2)	/* LCD backlight enable */
+#define PLD_S2_ON		(1 << 1)	/* LCD 3V3 supply enable */
+#define PLD_S1_ON		(1 << 0)	/* LCD 3V supply enable */
+
+#define PLD_KBD		SYSPLD_REG(u32, 0x000008)
+#define PLD_KBD_WAKE		(1 << 1)
+#define PLD_KBD_EN		(1 << 0)
+
+#define PLD_SPI		SYSPLD_REG(u32, 0x00000c)
+#define PLD_SPI_EN		(1 << 0)
+
+#define PLD_IO		SYSPLD_REG(u32, 0x000010)
+#define PLD_IO_BOOTSEL		(1 << 6)	/* boot sel switch */
+#define PLD_IO_USER		(1 << 5)	/* user defined switch */
+#define PLD_IO_LED3		(1 << 4)
+#define PLD_IO_LED2		(1 << 3)
+#define PLD_IO_LED1		(1 << 2)
+#define PLD_IO_LED0		(1 << 1)
+#define PLD_IO_LEDEN		(1 << 0)
+
+#define PLD_IRDA	SYSPLD_REG(u32, 0x000014)
+#define PLD_IRDA_EN		(1 << 0)
+
+#define PLD_COM2	SYSPLD_REG(u32, 0x000018)
+#define PLD_COM2_EN		(1 << 0)
+
+#define PLD_COM1	SYSPLD_REG(u32, 0x00001c)
+#define PLD_COM1_EN		(1 << 0)
+
+#define PLD_AUD		SYSPLD_REG(u32, 0x000020)
+#define PLD_AUD_DIV1		(1 << 6)
+#define PLD_AUD_DIV0		(1 << 5)
+#define PLD_AUD_CLK_SEL1	(1 << 4)
+#define PLD_AUD_CLK_SEL0	(1 << 3)
+#define PLD_AUD_MIC_PWR		(1 << 2)
+#define PLD_AUD_MIC_GAIN	(1 << 1)
+#define PLD_AUD_CODEC_EN	(1 << 0)
+
+#define PLD_CF		SYSPLD_REG(u32, 0x000024)
+#define PLD_CF2_SLEEP		(1 << 5)
+#define PLD_CF1_SLEEP		(1 << 4)
+#define PLD_CF2_nPDREQ		(1 << 3)
+#define PLD_CF1_nPDREQ		(1 << 2)
+#define PLD_CF2_nIRQ		(1 << 1)
+#define PLD_CF1_nIRQ		(1 << 0)
+
+#define PLD_SDC		SYSPLD_REG(u32, 0x000028)
+#define PLD_SDC_INT_EN		(1 << 2)
+#define PLD_SDC_WP		(1 << 1)
+#define PLD_SDC_CD		(1 << 0)
+
+#define PLD_FPGA	SYSPLD_REG(u32, 0x00002c)
+
+#define PLD_CODEC	SYSPLD_REG(u32, 0x400000)
+#define PLD_CODEC_IRQ3		(1 << 4)
+#define PLD_CODEC_IRQ2		(1 << 3)
+#define PLD_CODEC_IRQ1		(1 << 2)
+#define PLD_CODEC_EN		(1 << 0)
+
+#define PLD_BRITE	SYSPLD_REG(u32, 0x400004)
+#define PLD_BRITE_UP		(1 << 1)
+#define PLD_BRITE_DN		(1 << 0)
+
+#define PLD_LCDEN	SYSPLD_REG(u32, 0x400008)
+#define PLD_LCDEN_EN		(1 << 0)
+
+#define PLD_ID		SYSPLD_REG(u32, 0x40000c)
+
+#define PLD_TCH		SYSPLD_REG(u32, 0x400010)
+#define PLD_TCH_PENIRQ		(1 << 1)
+#define PLD_TCH_EN		(1 << 0)
+
+#define PLD_GPIO	SYSPLD_REG(u32, 0x400014)
+#define PLD_GPIO2		(1 << 2)
+#define PLD_GPIO1		(1 << 1)
+#define PLD_GPIO0		(1 << 0)
+
+#endif
Index: build_tree/linux/include/asm/arch-clps711x/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/system.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/hardware/clps7111.h>
+#include <asm/io.h>
+
+static inline void arch_idle(void)
+{
+	clps_writel(1, HALT);
+	__asm__ __volatile__(
+	"mov	r0, r0\n\
+	mov	r0, r0");
+}
+
+static inline void arch_reset(char mode)
+{
+	cpu_reset(0);
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-clps711x/time.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/time.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/time.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/time.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/leds.h>
+#include <asm/hardware/clps7111.h>
+
+extern void clps711x_setup_timer(void);
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+p720t_timer_interrupt(int irq, void *dev_id)
+{
+	struct pt_regs *regs = get_irq_regs();
+	do_leds();
+	do_timer(1);
+#ifndef CONFIG_SMP
+	update_process_times(user_mode(regs));
+#endif
+	do_profile(regs);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+void __init time_init(void)
+{
+	clps711x_setup_timer();
+	timer_irq.handler = p720t_timer_interrupt;
+	setup_irq(IRQ_TC2OI, &timer_irq);
+}
Index: build_tree/linux/include/asm/arch-clps711x/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/timex.h
+ *
+ *  Prospector 720T architecture timex specifications
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE 512000
Index: build_tree/linux/include/asm/arch-clps711x/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,59 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/uncompress.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/arch/io.h>
+#include <asm/hardware.h>
+#include <asm/hardware/clps7111.h>
+
+#undef CLPS7111_BASE
+#define CLPS7111_BASE CLPS7111_PHYS_BASE
+
+#define __raw_readl(p)		(*(unsigned long *)(p))
+#define __raw_writel(v,p)	(*(unsigned long *)(p) = (v))
+
+#ifdef CONFIG_DEBUG_CLPS711X_UART2
+#define SYSFLGx	SYSFLG2
+#define UARTDRx	UARTDR2
+#else
+#define SYSFLGx	SYSFLG1
+#define UARTDRx	UARTDR1
+#endif
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	while (clps_readl(SYSFLGx) & SYSFLG_UTXFF)
+		barrier();
+	clps_writel(c, UARTDRx);
+}
+
+static inline void flush(void)
+{
+	while (clps_readl(SYSFLGx) & SYSFLG_UBUSY)
+		barrier();
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-clps711x/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-clps711x/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-clps711x/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-clps711x/vmalloc.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
Index: build_tree/linux/include/asm/arch-ebsa110/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/* linux/include/asm-arm/arch-ebsa110/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+**/
+
+		.macro	addruart,rx
+		mov	\rx, #0xf0000000
+		orr	\rx, \rx, #0x00000be0
+		.endm
+
+#define UART_SHIFT	2
+#define FLOW_CONTROL
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-ebsa110/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,11 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  EBSA110 DMA definitions
+ */
Index: build_tree/linux/include/asm/arch-ebsa110/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-ebsa110/entry-macro.S
+ *
+ * Low-level IRQ helper macros for ebsa110 platform.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+
+
+#define IRQ_STAT		0xff000000	/* read */
+
+	.macro	disable_fiq
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, stat, base, tmp
+	mov	\base, #IRQ_STAT
+	ldrb	\stat, [\base]			@ get interrupts
+	mov	\irqnr, #0
+	tst	\stat, #15
+	addeq	\irqnr, \irqnr, #4
+	moveq	\stat, \stat, lsr #4
+	tst	\stat, #3
+	addeq	\irqnr, \irqnr, #2
+	moveq	\stat, \stat, lsr #2
+	tst	\stat, #1
+	addeq	\irqnr, \irqnr, #1
+	moveq	\stat, \stat, lsr #1
+	tst	\stat, #1			@ bit 0 should be set
+	.endm
+
Index: build_tree/linux/include/asm/arch-ebsa110/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,63 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/hardware.h
+ *
+ *  Copyright (C) 1996-2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains the hardware definitions of the EBSA-110.
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/*
+ * The EBSA110 has a weird "ISA IO" region:
+ *
+ * Region 0 (addr = 0xf0000000 + io << 2)
+ * --------------------------------------------------------
+ * Physical region	IO region
+ * f0000fe0 - f0000ffc	3f8 - 3ff  ttyS0
+ * f0000e60 - f0000e64	398 - 399
+ * f0000de0 - f0000dfc	378 - 37f  lp0
+ * f0000be0 - f0000bfc	2f8 - 2ff  ttyS1
+ *
+ * Region 1 (addr = 0xf0000000 + (io & ~1) << 1 + (io & 1))
+ * --------------------------------------------------------
+ * Physical region	IO region
+ * f00014f1             a79        pnp write data
+ * f00007c0 - f00007c1	3e0 - 3e1  pcmcia
+ * f00004f1		279        pnp address
+ * f0000440 - f000046c  220 - 236  eth0
+ * f0000405		203        pnp read data
+ */
+
+#define ISAMEM_PHYS		0xe0000000
+#define ISAMEM_SIZE		0x10000000
+
+#define ISAIO_PHYS		0xf0000000
+#define ISAIO_SIZE		PGDIR_SIZE
+
+#define TRICK0_PHYS		0xf2000000
+#define TRICK1_PHYS		0xf2400000
+#define TRICK2_PHYS		0xf2800000
+#define TRICK3_PHYS		0xf2c00000
+#define TRICK4_PHYS		0xf3000000
+#define TRICK5_PHYS		0xf3400000
+#define TRICK6_PHYS		0xf3800000
+#define TRICK7_PHYS		0xf3c00000
+
+#define ISAMEM_BASE		0xe0000000
+#define ISAIO_BASE		0xf0000000
+
+#define PIT_BASE		0xfc000000
+#define SOFT_BASE		0xfd000000
+
+/*
+ * RAM definitions
+ */
+#define UNCACHEABLE_ADDR	0xff000000	/* IRQ_STAT */
+
+#endif
+
Index: build_tree/linux/include/asm/arch-ebsa110/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,84 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/io.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Modifications:
+ *  06-Dec-1997	RMK	Created.
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffff
+
+u8 __inb8(unsigned int port);
+void __outb8(u8  val, unsigned int port);
+
+u8 __inb16(unsigned int port);
+void __outb16(u8  val, unsigned int port);
+
+u16 __inw(unsigned int port);
+void __outw(u16 val, unsigned int port);
+
+u32 __inl(unsigned int port);
+void __outl(u32 val, unsigned int port);
+
+u8  __readb(const volatile void __iomem *addr);
+u16 __readw(const volatile void __iomem *addr);
+u32 __readl(const volatile void __iomem *addr);
+
+void __writeb(u8  val, void __iomem *addr);
+void __writew(u16 val, void __iomem *addr);
+void __writel(u32 val, void __iomem *addr);
+
+/*
+ * Argh, someone forgot the IOCS16 line.  We therefore have to handle
+ * the byte stearing by selecting the correct byte IO functions here.
+ */
+#ifdef ISA_SIXTEEN_BIT_PERIPHERAL
+#define inb(p) 			__inb16(p)
+#define outb(v,p)		__outb16(v,p)
+#else
+#define inb(p)			__inb8(p)
+#define outb(v,p)		__outb8(v,p)
+#endif
+
+#define inw(p)			__inw(p)
+#define outw(v,p)		__outw(v,p)
+
+#define inl(p)			__inl(p)
+#define outl(v,p)		__outl(v,p)
+
+#define readb(b)		__readb(b)
+#define readw(b)		__readw(b)
+#define readl(b)		__readl(b)
+#define readb_relaxed(addr)	readb(addr)
+#define readw_relaxed(addr)	readw(addr)
+#define readl_relaxed(addr)	readl(addr)
+
+#define writeb(v,b)		__writeb(v,b)
+#define writew(v,b)		__writew(v,b)
+#define writel(v,b)		__writel(v,b)
+
+static inline void __iomem *__arch_ioremap(unsigned long cookie, size_t size,
+					   unsigned int flags)
+{
+	return (void __iomem *)cookie;
+}
+
+#define __arch_ioremap		__arch_ioremap
+#define __arch_iounmap(cookie)	do { } while (0)
+
+extern void insb(unsigned int port, void *buf, int sz);
+extern void insw(unsigned int port, void *buf, int sz);
+extern void insl(unsigned int port, void *buf, int sz);
+
+extern void outsb(unsigned int port, const void *buf, int sz);
+extern void outsw(unsigned int port, const void *buf, int sz);
+extern void outsl(unsigned int port, const void *buf, int sz);
+
+#endif
Index: build_tree/linux/include/asm/arch-ebsa110/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/irqs.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define NR_IRQS			8
+
+#define IRQ_EBSA110_PRINTER	0
+#define IRQ_EBSA110_COM1	1
+#define IRQ_EBSA110_COM2	2
+#define IRQ_EBSA110_ETHERNET	3
+#define IRQ_EBSA110_TIMER0	4
+#define IRQ_EBSA110_TIMER1	5
+#define IRQ_EBSA110_PCMCIA	6
+#define IRQ_EBSA110_IMMEDIATE	7
Index: build_tree/linux/include/asm/arch-ebsa110/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/memory.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-Oct-1996 RMK	Created
+ *   31-Dec-1997 RMK	Fixed definitions to reduce warnings
+ *   21-Mar-1999 RMK	Renamed to memory.h
+ *		 RMK	Moved TASK_SIZE and PAGE_OFFSET here
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+
+/*
+ * We keep this 1:1 so that we don't interfere
+ * with the PCMCIA memory regions
+ */
+#define __virt_to_bus(x)	(x)
+#define __bus_to_virt(x)	(x)
+
+/*
+ * Cache flushing area - SRAM
+ */
+#define FLUSH_BASE_PHYS		0x40000000
+#define FLUSH_BASE		0xdf000000
+
+#endif
Index: build_tree/linux/include/asm/arch-ebsa110/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/system.h
+ *
+ *  Copyright (C) 1996-2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+/*
+ * EBSA110 idling methodology:
+ *
+ * We can not execute the "wait for interrupt" instruction since that
+ * will stop our MCLK signal (which provides the clock for the glue
+ * logic, and therefore the timer interrupt).
+ *
+ * Instead, we spin, polling the IRQ_STAT register for the occurrence
+ * of any interrupt with core clock down to the memory clock.
+ */
+static inline void arch_idle(void)
+{
+	const char *irq_stat = (char *)0xff000000;
+
+	/* disable clock switching */
+	asm volatile ("mcr p15, 0, ip, c15, c2, 2" : : : "cc");
+
+	/* wait for an interrupt to occur */
+	while (!*irq_stat);
+
+	/* enable clock switching */
+	asm volatile ("mcr p15, 0, ip, c15, c1, 2" : : : "cc");
+}
+
+#define arch_reset(mode)	cpu_reset(0x80000000)
+
+#endif
Index: build_tree/linux/include/asm/arch-ebsa110/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/timex.h
+ *
+ *  Copyright (C) 1997, 1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  EBSA110 architecture timex specifications
+ */
+
+/*
+ * On the EBSA, the clock ticks at weird rates.
+ * This is therefore not used to calculate the
+ * divisor.
+ */
+#define CLOCK_TICK_RATE		47894000
+
Index: build_tree/linux/include/asm/arch-ebsa110/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,45 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/uncompress.h
+ *
+ *  Copyright (C) 1996,1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/serial_reg.h>
+
+#define SERIAL_BASE	((unsigned char *)0xf0000be0)
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	unsigned char v, *base = SERIAL_BASE;
+
+	do {
+		v = base[UART_LSR << 2];
+		barrier();
+	} while (!(v & UART_LSR_THRE));
+
+	base[UART_TX << 2] = c;
+}
+
+static inline void flush(void)
+{
+	unsigned char v, *base = SERIAL_BASE;
+
+	do {
+		v = base[UART_LSR << 2];
+		barrier();
+	} while ((v & (UART_LSR_TEMT|UART_LSR_THRE)) !=
+		 (UART_LSR_TEMT|UART_LSR_THRE));
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-ebsa110/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa110/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa110/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,10 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa110/vmalloc.h
+ *
+ *  Copyright (C) 1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x1f000000)
Index: build_tree/linux/include/asm/arch-ebsa285/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/* linux/include/asm-arm/arch-ebsa285/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <asm/hardware/dec21285.h>
+
+#ifndef CONFIG_DEBUG_DC21285_PORT
+	/* For NetWinder debugging */
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x7c000000	@ physical
+		movne	\rx, #0xff000000	@ virtual
+		orr	\rx, \rx, #0x000003f8
+		.endm
+
+#define UART_SHIFT	0
+#define FLOW_CONTROL
+#include <asm/hardware/debug-8250.S>
+
+#else
+	/* For EBSA285 debugging */
+		.equ	dc21285_high, ARMCSR_BASE & 0xff000000
+		.equ	dc21285_low,  ARMCSR_BASE & 0x00ffffff
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x42000000
+		movne	\rx, #dc21285_high
+		.if	dc21285_low
+		orrne	\rx, \rx, #dc21285_low
+		.endif
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0x160]	@ UARTDR
+		.endm
+
+		.macro	busyuart,rd,rx
+1001:		ldr	\rd, [\rx, #0x178]	@ UARTFLG
+		tst	\rd, #1 << 3
+		bne	1001b
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
+#endif
Index: build_tree/linux/include/asm/arch-ebsa285/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,25 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/dma.h
+ *
+ *  Architecture DMA routines
+ *
+ *  Copyright (C) 1998,1999 Russell King
+ *  Copyright (C) 1998,1999 Philip Blundell
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/*
+ * The 21285 has two internal DMA channels; we call these 8 and 9.
+ * On CATS hardware we have an additional eight ISA dma channels
+ * numbered 0..7.
+ */
+#define _ISA_DMA(x)		(0+(x))
+#define _DC21285_DMA(x)		(8+(x))
+
+#define MAX_DMA_CHANNELS	10
+
+#define DMA_FLOPPY		_ISA_DMA(2)
+#define DMA_ISA_CASCADE		_ISA_DMA(4)
+
+#endif /* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-ebsa285/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,113 @@
+/*
+ * include/asm-arm/arch-ebsa285/entry-macro.S
+ *
+ * Low-level IRQ helper macros for footbridge-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/arch/irqs.h>
+#include <asm/hardware/dec21285.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.equ	dc21285_high, ARMCSR_BASE & 0xff000000
+		.equ	dc21285_low, ARMCSR_BASE & 0x00ffffff
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	r4, #dc21285_high
+		.if	dc21285_low
+		orr	r4, r4, #dc21285_low
+		.endif
+		ldr	\irqstat, [r4, #0x180]		@ get interrupts
+
+		mov	\irqnr, #IRQ_SDRAMPARITY
+		tst	\irqstat, #IRQ_MASK_SDRAMPARITY
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_UART_RX
+		movne	\irqnr, #IRQ_CONRX
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_DMA1
+		movne	\irqnr, #IRQ_DMA1
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_DMA2
+		movne	\irqnr, #IRQ_DMA2
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_IN0
+		movne	\irqnr, #IRQ_IN0
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_IN1
+		movne	\irqnr, #IRQ_IN1
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_IN2
+		movne	\irqnr, #IRQ_IN2
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_IN3
+		movne	\irqnr, #IRQ_IN3
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_PCI
+		movne	\irqnr, #IRQ_PCI
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_DOORBELLHOST
+		movne	\irqnr, #IRQ_DOORBELLHOST
+		bne     1001f
+
+		tst	\irqstat, #IRQ_MASK_I2OINPOST
+		movne	\irqnr, #IRQ_I2OINPOST
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_TIMER1
+		movne	\irqnr, #IRQ_TIMER1
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_TIMER2
+		movne	\irqnr, #IRQ_TIMER2
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_TIMER3
+		movne	\irqnr, #IRQ_TIMER3
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_UART_TX
+		movne	\irqnr, #IRQ_CONTX
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_PCI_ABORT
+		movne	\irqnr, #IRQ_PCI_ABORT
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_PCI_SERR
+		movne	\irqnr, #IRQ_PCI_SERR
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_DISCARD_TIMER
+		movne	\irqnr, #IRQ_DISCARD_TIMER
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_PCI_DPERR
+		movne	\irqnr, #IRQ_PCI_DPERR
+		bne	1001f
+
+		tst	\irqstat, #IRQ_MASK_PCI_PERR
+		movne	\irqnr, #IRQ_PCI_PERR
+1001:
+		.endm
+
Index: build_tree/linux/include/asm/arch-ebsa285/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,131 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/hardware.h
+ *
+ *  Copyright (C) 1998-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file contains the hardware definitions of the EBSA-285.
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/memory.h>
+
+#ifdef CONFIG_ARCH_FOOTBRIDGE
+/*   Virtual      Physical	Size
+ * 0xff800000	0x40000000	1MB	X-Bus
+ * 0xff000000	0x7c000000	1MB	PCI I/O space
+ * 0xfe000000	0x42000000	1MB	CSR
+ * 0xfd000000	0x78000000	1MB	Outbound write flush (not supported)
+ * 0xfc000000	0x79000000	1MB	PCI IACK/special space
+ * 0xfb000000	0x7a000000	16MB	PCI Config type 1
+ * 0xfa000000	0x7b000000	16MB	PCI Config type 0
+ * 0xf9000000	0x50000000	1MB	Cache flush
+ * 0xf0000000	0x80000000	16MB	ISA memory
+ */
+#define XBUS_SIZE		0x00100000
+#define XBUS_BASE		0xff800000
+
+#define PCIO_SIZE		0x00100000
+#define PCIO_BASE		0xff000000
+
+#define ARMCSR_SIZE		0x00100000
+#define ARMCSR_BASE		0xfe000000
+
+#define WFLUSH_SIZE		0x00100000
+#define WFLUSH_BASE		0xfd000000
+
+#define PCIIACK_SIZE		0x00100000
+#define PCIIACK_BASE		0xfc000000
+
+#define PCICFG1_SIZE		0x01000000
+#define PCICFG1_BASE		0xfb000000
+
+#define PCICFG0_SIZE		0x01000000
+#define PCICFG0_BASE		0xfa000000
+
+#define PCIMEM_SIZE		0x01000000
+#define PCIMEM_BASE		0xf0000000
+
+#elif defined(CONFIG_ARCH_CO285)
+/*
+ * This is the COEBSA285 cut-down mapping
+ */
+#define PCIMEM_SIZE		0x80000000
+#define PCIMEM_BASE		0x80000000
+
+#define WFLUSH_SIZE		0x01000000
+#define WFLUSH_BASE		0x7d000000
+
+#define ARMCSR_SIZE		0x00100000
+#define ARMCSR_BASE		0x7cf00000
+
+#define XBUS_SIZE		0x00020000
+#define XBUS_BASE		0x7cee0000
+
+#define PCIO_SIZE		0x00010000
+#define PCIO_BASE		0x7ced0000
+
+#else
+
+#error "Undefined footbridge architecture"
+
+#endif
+
+#define XBUS_LEDS		((volatile unsigned char *)(XBUS_BASE + 0x12000))
+#define XBUS_LED_AMBER		(1 << 0)
+#define XBUS_LED_GREEN		(1 << 1)
+#define XBUS_LED_RED		(1 << 2)
+#define XBUS_LED_TOGGLE		(1 << 8)
+
+#define XBUS_SWITCH		((volatile unsigned char *)(XBUS_BASE + 0x12000))
+#define XBUS_SWITCH_SWITCH	((*XBUS_SWITCH) & 15)
+#define XBUS_SWITCH_J17_13	((*XBUS_SWITCH) & (1 << 4))
+#define XBUS_SWITCH_J17_11	((*XBUS_SWITCH) & (1 << 5))
+#define XBUS_SWITCH_J17_9	((*XBUS_SWITCH) & (1 << 6))
+
+#define UNCACHEABLE_ADDR	(ARMCSR_BASE + 0x108)
+
+
+/* PIC irq control */
+#define PIC_LO			0x20
+#define PIC_MASK_LO		0x21
+#define PIC_HI			0xA0
+#define PIC_MASK_HI		0xA1
+
+/* GPIO pins */
+#define GPIO_CCLK		0x800
+#define GPIO_DSCLK		0x400
+#define GPIO_E2CLK		0x200
+#define GPIO_IOLOAD		0x100
+#define GPIO_RED_LED		0x080
+#define GPIO_WDTIMER		0x040
+#define GPIO_DATA		0x020
+#define GPIO_IOCLK		0x010
+#define GPIO_DONE		0x008
+#define GPIO_FAN		0x004
+#define GPIO_GREEN_LED		0x002
+#define GPIO_RESET		0x001
+
+/* CPLD pins */
+#define CPLD_DS_ENABLE		8
+#define CPLD_7111_DISABLE	4
+#define CPLD_UNMUTE		2
+#define CPLD_FLASH_WR_ENABLE	1
+
+#ifndef __ASSEMBLY__
+extern void gpio_modify_op(int mask, int set);
+extern void gpio_modify_io(int mask, int in);
+extern int  gpio_read(void);
+extern void cpld_modify(int mask, int set);
+#endif
+
+#define pcibios_assign_all_busses()	1
+
+#define PCIBIOS_MIN_IO		0x1000
+#define PCIBIOS_MIN_MEM 	0x81000000
+
+#endif
Index: build_tree/linux/include/asm/arch-ebsa285/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/io.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Modifications:
+ *   06-12-1997	RMK	Created.
+ *   07-04-1999	RMK	Major cleanup
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffff
+
+/*
+ * Translation of various region addresses to virtual addresses
+ */
+#define __io(a)			((void __iomem *)(PCIO_BASE + (a)))
+#if 1
+#define __mem_pci(a)		(a)
+#else
+
+static inline void __iomem *___mem_pci(void __iomem *p)
+{
+	unsigned long a = (unsigned long)p;
+	BUG_ON(a <= 0xc0000000 || a >= 0xe0000000);
+	return p;
+}
+
+#define __mem_pci(a)		___mem_pci(a)
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-ebsa285/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,98 @@
+/*
+ * linux/include/asm-arm/arch-ebsa285/irqs.h
+ *
+ * Copyright (C) 1998 Russell King
+ * Copyright (C) 1998 Phil Blundell
+ *
+ * Changelog:
+ *  20-Jan-1998	RMK	Started merge of EBSA286, CATS and NetWinder
+ *  01-Feb-1999	PJB	ISA IRQs start at 0 not 16
+ */
+#include <asm/mach-types.h>
+
+#define NR_IRQS			36
+#define NR_DC21285_IRQS		16
+
+#define _ISA_IRQ(x)		(0 + (x))
+#define _ISA_INR(x)		((x) - 0)
+#define _DC21285_IRQ(x)		(16 + (x))
+#define _DC21285_INR(x)		((x) - 16)
+
+/*
+ * This is a list of all interrupts that the 21285
+ * can generate and we handle.
+ */
+#define IRQ_CONRX		_DC21285_IRQ(0)
+#define IRQ_CONTX		_DC21285_IRQ(1)
+#define IRQ_TIMER1		_DC21285_IRQ(2)
+#define IRQ_TIMER2		_DC21285_IRQ(3)
+#define IRQ_TIMER3		_DC21285_IRQ(4)
+#define IRQ_IN0			_DC21285_IRQ(5)
+#define IRQ_IN1			_DC21285_IRQ(6)
+#define IRQ_IN2			_DC21285_IRQ(7)
+#define IRQ_IN3			_DC21285_IRQ(8)
+#define IRQ_DOORBELLHOST	_DC21285_IRQ(9)
+#define IRQ_DMA1		_DC21285_IRQ(10)
+#define IRQ_DMA2		_DC21285_IRQ(11)
+#define IRQ_PCI			_DC21285_IRQ(12)
+#define IRQ_SDRAMPARITY		_DC21285_IRQ(13)
+#define IRQ_I2OINPOST		_DC21285_IRQ(14)
+#define IRQ_PCI_ABORT		_DC21285_IRQ(15)
+#define IRQ_PCI_SERR		_DC21285_IRQ(16)
+#define IRQ_DISCARD_TIMER	_DC21285_IRQ(17)
+#define IRQ_PCI_DPERR		_DC21285_IRQ(18)
+#define IRQ_PCI_PERR		_DC21285_IRQ(19)
+
+#define IRQ_ISA_TIMER		_ISA_IRQ(0)
+#define IRQ_ISA_KEYBOARD	_ISA_IRQ(1)
+#define IRQ_ISA_CASCADE		_ISA_IRQ(2)
+#define IRQ_ISA_UART2		_ISA_IRQ(3)
+#define IRQ_ISA_UART		_ISA_IRQ(4)
+#define IRQ_ISA_FLOPPY		_ISA_IRQ(6)
+#define IRQ_ISA_PRINTER		_ISA_IRQ(7)
+#define IRQ_ISA_RTC_ALARM	_ISA_IRQ(8)
+#define IRQ_ISA_2		_ISA_IRQ(9)
+#define IRQ_ISA_PS2MOUSE	_ISA_IRQ(12)
+#define IRQ_ISA_HARDDISK1	_ISA_IRQ(14)
+#define IRQ_ISA_HARDDISK2	_ISA_IRQ(15)
+
+#define IRQ_MASK_UART_RX	(1 << 2)
+#define IRQ_MASK_UART_TX	(1 << 3)
+#define IRQ_MASK_TIMER1		(1 << 4)
+#define IRQ_MASK_TIMER2		(1 << 5)
+#define IRQ_MASK_TIMER3		(1 << 6)
+#define IRQ_MASK_IN0		(1 << 8)
+#define IRQ_MASK_IN1		(1 << 9)
+#define IRQ_MASK_IN2		(1 << 10)
+#define IRQ_MASK_IN3		(1 << 11)
+#define IRQ_MASK_DOORBELLHOST	(1 << 15)
+#define IRQ_MASK_DMA1		(1 << 16)
+#define IRQ_MASK_DMA2		(1 << 17)
+#define IRQ_MASK_PCI		(1 << 18)
+#define IRQ_MASK_SDRAMPARITY	(1 << 24)
+#define IRQ_MASK_I2OINPOST	(1 << 25)
+#define IRQ_MASK_PCI_ABORT	((1 << 29) | (1 << 30))
+#define IRQ_MASK_PCI_SERR	(1 << 23)
+#define IRQ_MASK_DISCARD_TIMER	(1 << 27)
+#define IRQ_MASK_PCI_DPERR	(1 << 28)
+#define IRQ_MASK_PCI_PERR	(1 << 31)
+
+/*
+ * Netwinder interrupt allocations
+ */
+#define IRQ_NETWINDER_ETHER10	IRQ_IN0
+#define IRQ_NETWINDER_ETHER100	IRQ_IN1
+#define IRQ_NETWINDER_VIDCOMP	IRQ_IN2
+#define IRQ_NETWINDER_PS2MOUSE	_ISA_IRQ(5)
+#define IRQ_NETWINDER_IR	_ISA_IRQ(6)
+#define IRQ_NETWINDER_BUTTON	_ISA_IRQ(10)
+#define IRQ_NETWINDER_VGA	_ISA_IRQ(11)
+#define IRQ_NETWINDER_SOUND	_ISA_IRQ(12)
+
+#undef RTC_IRQ
+#define RTC_IRQ		IRQ_ISA_RTC_ALARM
+#define I8042_KBD_IRQ	IRQ_ISA_KEYBOARD
+#define I8042_AUX_IRQ	(machine_is_netwinder() ? IRQ_NETWINDER_PS2MOUSE : IRQ_ISA_PS2MOUSE)
+#define IRQ_FLOPPYDISK	IRQ_ISA_FLOPPY
+
+#define irq_canonicalize(_i)	(((_i) == IRQ_ISA_CASCADE) ? IRQ_ISA_2 : _i)
Index: build_tree/linux/include/asm/arch-ebsa285/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,86 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/memory.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-Oct-1996 RMK	Created
+ *   31-Dec-1997 RMK	Fixed definitions to reduce warnings.
+ *   17-May-1998 DAG	Added __virt_to_bus and __bus_to_virt functions.
+ *   21-Nov-1998 RMK	Changed __virt_to_bus and __bus_to_virt to macros.
+ *   21-Mar-1999 RMK	Added PAGE_OFFSET for co285 architecture.
+ *			Renamed to memory.h
+ *			Moved PAGE_OFFSET and TASK_SIZE here
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+
+#if defined(CONFIG_FOOTBRIDGE_ADDIN)
+/*
+ * If we may be using add-in footbridge mode, then we must
+ * use the out-of-line translation that makes use of the
+ * PCI BAR
+ */
+#ifndef __ASSEMBLY__
+extern unsigned long __virt_to_bus(unsigned long);
+extern unsigned long __bus_to_virt(unsigned long);
+#endif
+
+#elif defined(CONFIG_FOOTBRIDGE_HOST)
+
+#define __virt_to_bus(x)	((x) - 0xe0000000)
+#define __bus_to_virt(x)	((x) + 0xe0000000)
+
+#else
+
+#error "Undefined footbridge mode"
+
+#endif
+
+#if defined(CONFIG_ARCH_FOOTBRIDGE)
+
+/* Task size and page offset at 3GB */
+#define TASK_SIZE		UL(0xbf000000)
+#define PAGE_OFFSET		UL(0xc0000000)
+
+/*
+ * Cache flushing area.
+ */
+#define FLUSH_BASE		0xf9000000
+
+#elif defined(CONFIG_ARCH_CO285)
+
+/* Task size and page offset at 1.5GB */
+#define TASK_SIZE		UL(0x5f000000)
+#define PAGE_OFFSET		UL(0x60000000)
+
+/*
+ * Cache flushing area.
+ */
+#define FLUSH_BASE		0x7e000000
+
+#else
+
+#error "Undefined footbridge architecture"
+
+#endif
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET		UL(0x00000000)
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE ((TASK_SIZE + 0x01000000) / 3)
+
+#define FLUSH_BASE_PHYS		0x50000000
+
+#endif
Index: build_tree/linux/include/asm/arch-ebsa285/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,69 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/system.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm/hardware/dec21285.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	if (mode == 's') {
+		/*
+		 * Jump into the ROM
+		 */
+		cpu_reset(0x41000000);
+	} else {
+		if (machine_is_netwinder()) {
+			/* open up the SuperIO chip
+			 */
+			outb(0x87, 0x370);
+			outb(0x87, 0x370);
+
+			/* aux function group 1 (logical device 7)
+			 */
+			outb(0x07, 0x370);
+			outb(0x07, 0x371);
+
+			/* set GP16 for WD-TIMER output
+			 */
+			outb(0xe6, 0x370);
+			outb(0x00, 0x371);
+
+			/* set a RED LED and toggle WD_TIMER for rebooting
+			 */
+			outb(0xc4, 0x338);
+		} else {
+			/* 
+			 * Force the watchdog to do a CPU reset.
+			 *
+			 * After making sure that the watchdog is disabled
+			 * (so we can change the timer registers) we first
+			 * enable the timer to autoreload itself.  Next, the
+			 * timer interval is set really short and any
+			 * current interrupt request is cleared (so we can
+			 * see an edge transition).  Finally, TIMER4 is
+			 * enabled as the watchdog.
+			 */
+			*CSR_SA110_CNTL &= ~(1 << 13);
+			*CSR_TIMER4_CNTL = TIMER_CNTL_ENABLE |
+					   TIMER_CNTL_AUTORELOAD |
+					   TIMER_CNTL_DIV16;
+			*CSR_TIMER4_LOAD = 0x2;
+			*CSR_TIMER4_CLR  = 0;
+			*CSR_SA110_CNTL |= (1 << 13);
+		}
+	}
+}
Index: build_tree/linux/include/asm/arch-ebsa285/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/timex.h
+ *
+ *  Copyright (C) 1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  EBSA285 architecture timex specifications
+ */
+
+/*
+ * We assume a constant here; this satisfies the maths in linux/timex.h
+ * and linux/time.h.  CLOCK_TICK_RATE is actually system dependent, but
+ * this must be a constant.
+ */
+#define CLOCK_TICK_RATE		(50000000/16)
Index: build_tree/linux/include/asm/arch-ebsa285/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/uncompress.h
+ *
+ *  Copyright (C) 1996-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm/mach-types.h>
+
+/*
+ * Note! This could cause problems on the NetWinder
+ */
+#define DC21285_BASE ((volatile unsigned int *)0x42000160)
+#define SER0_BASE    ((volatile unsigned char *)0x7c0003f8)
+
+static inline void putc(char c)
+{
+	if (machine_is_netwinder()) {
+		while ((SER0_BASE[5] & 0x60) != 0x60)
+			barrier();
+		SER0_BASE[0] = c;
+	} else {
+		while (DC21285_BASE[6] & 8);
+		DC21285_BASE[0] = c;
+	}
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-ebsa285/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ebsa285/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ebsa285/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,14 @@
+/*
+ *  linux/include/asm-arm/arch-ebsa285/vmalloc.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifdef CONFIG_ARCH_FOOTBRIDGE
+#define VMALLOC_END       (PAGE_OFFSET + 0x30000000)
+#else
+#define VMALLOC_END       (PAGE_OFFSET + 0x20000000)
+#endif
Index: build_tree/linux/include/asm/arch-ep93xx/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/debug-macro.S
+ * Debugging macro include header
+ *
+ * Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+#include <asm/arch/ep93xx-regs.h>
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1				@ MMU enabled?
+		ldreq	\rx, =EP93XX_APB_PHYS_BASE	@ Physical base
+		ldrne	\rx, =EP93XX_APB_VIRT_BASE	@ virtual base
+		orr	\rx, \rx, #0x000c0000
+		.endm
+
+#include <asm/hardware/debug-pl01x.S>
Index: build_tree/linux/include/asm/arch-ep93xx/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,3 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/dma.h
+ */
Index: build_tree/linux/include/asm/arch-ep93xx/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,59 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/entry-macro.S
+ * IRQ demultiplexing for EP93xx
+ *
+ * Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+#include <asm/arch/ep93xx-regs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =(EP93XX_AHB_VIRT_BASE)
+		orr	\base, \base, #0x000b0000
+		mov	\irqnr, #0
+		ldr	\irqstat, [\base]		@ lower 32 interrupts
+		cmp	\irqstat, #0
+		bne	1001f
+
+		eor	\base, \base, #0x00070000
+		ldr	\irqstat, [\base]		@ upper 32 interrupts
+		cmp	\irqstat, #0
+		beq	1002f
+		mov	\irqnr, #0x20
+
+1001:
+		movs	\tmp, \irqstat, lsl #16
+		movne	\irqstat, \tmp
+		addeq	\irqnr, \irqnr, #16
+
+		movs	\tmp, \irqstat, lsl #8
+		movne	\irqstat, \tmp
+		addeq	\irqnr, \irqnr, #8
+
+		movs	\tmp, \irqstat, lsl #4
+		movne	\irqstat, \tmp
+		addeq	\irqnr, \irqnr, #4
+
+		movs	\tmp, \irqstat, lsl #2
+		movne	\irqstat, \tmp
+		addeq	\irqnr, \irqnr, #2
+
+		movs	\tmp, \irqstat, lsl #1
+		addeq	\irqnr, \irqnr, #1
+		orrs	\base, \base, #1
+
+1002:
+		.endm
Index: build_tree/linux/include/asm/arch-ep93xx/ep93xx-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/ep93xx-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/ep93xx-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,133 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/ep93xx-regs.h
+ */
+
+#ifndef __ASM_ARCH_EP93XX_REGS_H
+#define __ASM_ARCH_EP93XX_REGS_H
+
+/*
+ * EP93xx linux memory map:
+ *
+ * virt		phys		size
+ * fe800000			5M		per-platform mappings
+ * fed00000	80800000	2M		APB
+ * fef00000	80000000	1M		AHB
+ */
+
+#define EP93XX_AHB_PHYS_BASE		0x80000000
+#define EP93XX_AHB_VIRT_BASE		0xfef00000
+#define EP93XX_AHB_SIZE			0x00100000
+
+#define EP93XX_APB_PHYS_BASE		0x80800000
+#define EP93XX_APB_VIRT_BASE		0xfed00000
+#define EP93XX_APB_SIZE			0x00200000
+
+
+/* AHB peripherals */
+#define EP93XX_DMA_BASE			(EP93XX_AHB_VIRT_BASE + 0x00000000)
+
+#define EP93XX_ETHERNET_BASE		(EP93XX_AHB_VIRT_BASE + 0x00010000)
+#define EP93XX_ETHERNET_PHYS_BASE	(EP93XX_AHB_PHYS_BASE + 0x00010000)
+
+#define EP93XX_USB_BASE			(EP93XX_AHB_VIRT_BASE + 0x00020000)
+#define EP93XX_USB_PHYS_BASE		(EP93XX_AHB_PHYS_BASE + 0x00020000)
+
+#define EP93XX_RASTER_BASE		(EP93XX_AHB_VIRT_BASE + 0x00030000)
+
+#define EP93XX_GRAPHICS_ACCEL_BASE	(EP93XX_AHB_VIRT_BASE + 0x00040000)
+
+#define EP93XX_SDRAM_CONTROLLER_BASE	(EP93XX_AHB_VIRT_BASE + 0x00060000)
+
+#define EP93XX_PCMCIA_CONTROLLER_BASE	(EP93XX_AHB_VIRT_BASE + 0x00080000)
+
+#define EP93XX_BOOT_ROM_BASE		(EP93XX_AHB_VIRT_BASE + 0x00090000)
+
+#define EP93XX_IDE_BASE			(EP93XX_AHB_VIRT_BASE + 0x000a0000)
+
+#define EP93XX_VIC1_BASE		(EP93XX_AHB_VIRT_BASE + 0x000b0000)
+
+#define EP93XX_VIC2_BASE		(EP93XX_AHB_VIRT_BASE + 0x000c0000)
+
+
+/* APB peripherals */
+#define EP93XX_TIMER_BASE		(EP93XX_APB_VIRT_BASE + 0x00010000)
+#define EP93XX_TIMER_REG(x)		(EP93XX_TIMER_BASE + (x))
+#define EP93XX_TIMER1_LOAD		EP93XX_TIMER_REG(0x00)
+#define EP93XX_TIMER1_VALUE		EP93XX_TIMER_REG(0x04)
+#define EP93XX_TIMER1_CONTROL		EP93XX_TIMER_REG(0x08)
+#define EP93XX_TIMER1_CLEAR		EP93XX_TIMER_REG(0x0c)
+#define EP93XX_TIMER2_LOAD		EP93XX_TIMER_REG(0x20)
+#define EP93XX_TIMER2_VALUE		EP93XX_TIMER_REG(0x24)
+#define EP93XX_TIMER2_CONTROL		EP93XX_TIMER_REG(0x28)
+#define EP93XX_TIMER2_CLEAR		EP93XX_TIMER_REG(0x2c)
+#define EP93XX_TIMER4_VALUE_LOW		EP93XX_TIMER_REG(0x60)
+#define EP93XX_TIMER4_VALUE_HIGH	EP93XX_TIMER_REG(0x64)
+#define EP93XX_TIMER3_LOAD		EP93XX_TIMER_REG(0x80)
+#define EP93XX_TIMER3_VALUE		EP93XX_TIMER_REG(0x84)
+#define EP93XX_TIMER3_CONTROL		EP93XX_TIMER_REG(0x88)
+#define EP93XX_TIMER3_CLEAR		EP93XX_TIMER_REG(0x8c)
+
+#define EP93XX_I2S_BASE			(EP93XX_APB_VIRT_BASE + 0x00020000)
+
+#define EP93XX_SECURITY_BASE		(EP93XX_APB_VIRT_BASE + 0x00030000)
+
+#define EP93XX_GPIO_BASE		(EP93XX_APB_VIRT_BASE + 0x00040000)
+#define EP93XX_GPIO_REG(x)		(EP93XX_GPIO_BASE + (x))
+#define EP93XX_GPIO_F_INT_TYPE1		EP93XX_GPIO_REG(0x4c)
+#define EP93XX_GPIO_F_INT_TYPE2		EP93XX_GPIO_REG(0x50)
+#define EP93XX_GPIO_F_INT_ACK		EP93XX_GPIO_REG(0x54)
+#define EP93XX_GPIO_F_INT_ENABLE	EP93XX_GPIO_REG(0x58)
+#define EP93XX_GPIO_F_INT_STATUS	EP93XX_GPIO_REG(0x5c)
+#define EP93XX_GPIO_A_INT_TYPE1		EP93XX_GPIO_REG(0x90)
+#define EP93XX_GPIO_A_INT_TYPE2		EP93XX_GPIO_REG(0x94)
+#define EP93XX_GPIO_A_INT_ACK		EP93XX_GPIO_REG(0x98)
+#define EP93XX_GPIO_A_INT_ENABLE	EP93XX_GPIO_REG(0x9c)
+#define EP93XX_GPIO_A_INT_STATUS	EP93XX_GPIO_REG(0xa0)
+#define EP93XX_GPIO_B_INT_TYPE1		EP93XX_GPIO_REG(0xac)
+#define EP93XX_GPIO_B_INT_TYPE2		EP93XX_GPIO_REG(0xb0)
+#define EP93XX_GPIO_B_INT_ACK		EP93XX_GPIO_REG(0xb4)
+#define EP93XX_GPIO_B_INT_ENABLE	EP93XX_GPIO_REG(0xb8)
+#define EP93XX_GPIO_B_INT_STATUS	EP93XX_GPIO_REG(0xbc)
+
+#define EP93XX_AAC_BASE			(EP93XX_APB_VIRT_BASE + 0x00080000)
+
+#define EP93XX_SPI_BASE			(EP93XX_APB_VIRT_BASE + 0x000a0000)
+
+#define EP93XX_IRDA_BASE		(EP93XX_APB_VIRT_BASE + 0x000b0000)
+
+#define EP93XX_UART1_BASE		(EP93XX_APB_VIRT_BASE + 0x000c0000)
+#define EP93XX_UART1_PHYS_BASE		(EP93XX_APB_PHYS_BASE + 0x000c0000)
+
+#define EP93XX_UART2_BASE		(EP93XX_APB_VIRT_BASE + 0x000d0000)
+#define EP93XX_UART2_PHYS_BASE		(EP93XX_APB_PHYS_BASE + 0x000d0000)
+
+#define EP93XX_UART3_BASE		(EP93XX_APB_VIRT_BASE + 0x000e0000)
+#define EP93XX_UART3_PHYS_BASE		(EP93XX_APB_PHYS_BASE + 0x000e0000)
+
+#define EP93XX_KEY_MATRIX_BASE		(EP93XX_APB_VIRT_BASE + 0x000f0000)
+
+#define EP93XX_ADC_BASE			(EP93XX_APB_VIRT_BASE + 0x00100000)
+#define EP93XX_TOUCHSCREEN_BASE		(EP93XX_APB_VIRT_BASE + 0x00100000)
+
+#define EP93XX_PWM_BASE			(EP93XX_APB_VIRT_BASE + 0x00110000)
+
+#define EP93XX_RTC_BASE			(EP93XX_APB_VIRT_BASE + 0x00120000)
+
+#define EP93XX_SYSCON_BASE		(EP93XX_APB_VIRT_BASE + 0x00130000)
+#define EP93XX_SYSCON_REG(x)		(EP93XX_SYSCON_BASE + (x))
+#define EP93XX_SYSCON_POWER_STATE	EP93XX_SYSCON_REG(0x00)
+#define EP93XX_SYSCON_CLOCK_CONTROL	EP93XX_SYSCON_REG(0x04)
+#define EP93XX_SYSCON_CLOCK_UARTBAUD	0x20000000
+#define EP93XX_SYSCON_CLOCK_USH_EN	0x10000000
+#define EP93XX_SYSCON_HALT		EP93XX_SYSCON_REG(0x08)
+#define EP93XX_SYSCON_STANDBY		EP93XX_SYSCON_REG(0x0c)
+#define EP93XX_SYSCON_CLOCK_SET1	EP93XX_SYSCON_REG(0x20)
+#define EP93XX_SYSCON_CLOCK_SET2	EP93XX_SYSCON_REG(0x24)
+#define EP93XX_SYSCON_DEVICE_CONFIG	EP93XX_SYSCON_REG(0x80)
+#define EP93XX_SYSCON_DEVICE_CONFIG_CRUNCH_ENABLE	0x00800000
+#define EP93XX_SYSCON_SWLOCK		EP93XX_SYSCON_REG(0xc0)
+
+#define EP93XX_WATCHDOG_BASE		(EP93XX_APB_VIRT_BASE + 0x00140000)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ep93xx/gesbc9312.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/gesbc9312.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/gesbc9312.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,3 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/gesbc9312.h
+ */
Index: build_tree/linux/include/asm/arch-ep93xx/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,107 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/gpio.h
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#define GPIO_IN				0
+#define GPIO_OUT			1
+
+#define EP93XX_GPIO_LOW			0
+#define EP93XX_GPIO_HIGH		1
+
+extern void gpio_line_config(int line, int direction);
+extern int  gpio_line_get(int line);
+extern void gpio_line_set(int line, int value);
+
+/* GPIO port A.  */
+#define EP93XX_GPIO_LINE_A(x)		((x) + 0)
+#define EP93XX_GPIO_LINE_EGPIO0		EP93XX_GPIO_LINE_A(0)
+#define EP93XX_GPIO_LINE_EGPIO1		EP93XX_GPIO_LINE_A(1)
+#define EP93XX_GPIO_LINE_EGPIO2		EP93XX_GPIO_LINE_A(2)
+#define EP93XX_GPIO_LINE_EGPIO3		EP93XX_GPIO_LINE_A(3)
+#define EP93XX_GPIO_LINE_EGPIO4		EP93XX_GPIO_LINE_A(4)
+#define EP93XX_GPIO_LINE_EGPIO5		EP93XX_GPIO_LINE_A(5)
+#define EP93XX_GPIO_LINE_EGPIO6		EP93XX_GPIO_LINE_A(6)
+#define EP93XX_GPIO_LINE_EGPIO7		EP93XX_GPIO_LINE_A(7)
+
+/* GPIO port B.  */
+#define EP93XX_GPIO_LINE_B(x)		((x) + 8)
+#define EP93XX_GPIO_LINE_EGPIO8		EP93XX_GPIO_LINE_B(0)
+#define EP93XX_GPIO_LINE_EGPIO9		EP93XX_GPIO_LINE_B(1)
+#define EP93XX_GPIO_LINE_EGPIO10	EP93XX_GPIO_LINE_B(2)
+#define EP93XX_GPIO_LINE_EGPIO11	EP93XX_GPIO_LINE_B(3)
+#define EP93XX_GPIO_LINE_EGPIO12	EP93XX_GPIO_LINE_B(4)
+#define EP93XX_GPIO_LINE_EGPIO13	EP93XX_GPIO_LINE_B(5)
+#define EP93XX_GPIO_LINE_EGPIO14	EP93XX_GPIO_LINE_B(6)
+#define EP93XX_GPIO_LINE_EGPIO15	EP93XX_GPIO_LINE_B(7)
+
+/* GPIO port C.  */
+#define EP93XX_GPIO_LINE_C(x)		((x) + 16)
+#define EP93XX_GPIO_LINE_ROW0		EP93XX_GPIO_LINE_C(0)
+#define EP93XX_GPIO_LINE_ROW1		EP93XX_GPIO_LINE_C(1)
+#define EP93XX_GPIO_LINE_ROW2		EP93XX_GPIO_LINE_C(2)
+#define EP93XX_GPIO_LINE_ROW3		EP93XX_GPIO_LINE_C(3)
+#define EP93XX_GPIO_LINE_ROW4		EP93XX_GPIO_LINE_C(4)
+#define EP93XX_GPIO_LINE_ROW5		EP93XX_GPIO_LINE_C(5)
+#define EP93XX_GPIO_LINE_ROW6		EP93XX_GPIO_LINE_C(6)
+#define EP93XX_GPIO_LINE_ROW7		EP93XX_GPIO_LINE_C(7)
+
+/* GPIO port D.  */
+#define EP93XX_GPIO_LINE_D(x)		((x) + 24)
+#define EP93XX_GPIO_LINE_COL0		EP93XX_GPIO_LINE_D(0)
+#define EP93XX_GPIO_LINE_COL1		EP93XX_GPIO_LINE_D(1)
+#define EP93XX_GPIO_LINE_COL2		EP93XX_GPIO_LINE_D(2)
+#define EP93XX_GPIO_LINE_COL3		EP93XX_GPIO_LINE_D(3)
+#define EP93XX_GPIO_LINE_COL4		EP93XX_GPIO_LINE_D(4)
+#define EP93XX_GPIO_LINE_COL5		EP93XX_GPIO_LINE_D(5)
+#define EP93XX_GPIO_LINE_COL6		EP93XX_GPIO_LINE_D(6)
+#define EP93XX_GPIO_LINE_COL7		EP93XX_GPIO_LINE_D(7)
+
+/* GPIO port E.  */
+#define EP93XX_GPIO_LINE_E(x)		((x) + 32)
+#define EP93XX_GPIO_LINE_GRLED		EP93XX_GPIO_LINE_E(0)
+#define EP93XX_GPIO_LINE_RDLED		EP93XX_GPIO_LINE_E(1)
+#define EP93XX_GPIO_LINE_DIORn		EP93XX_GPIO_LINE_E(2)
+#define EP93XX_GPIO_LINE_IDECS1n	EP93XX_GPIO_LINE_E(3)
+#define EP93XX_GPIO_LINE_IDECS2n	EP93XX_GPIO_LINE_E(4)
+#define EP93XX_GPIO_LINE_IDEDA0		EP93XX_GPIO_LINE_E(5)
+#define EP93XX_GPIO_LINE_IDEDA1		EP93XX_GPIO_LINE_E(6)
+#define EP93XX_GPIO_LINE_IDEDA2		EP93XX_GPIO_LINE_E(7)
+
+/* GPIO port F.  */
+#define EP93XX_GPIO_LINE_F(x)		((x) + 40)
+#define EP93XX_GPIO_LINE_WP		EP93XX_GPIO_LINE_F(0)
+#define EP93XX_GPIO_LINE_MCCD1		EP93XX_GPIO_LINE_F(1)
+#define EP93XX_GPIO_LINE_MCCD2		EP93XX_GPIO_LINE_F(2)
+#define EP93XX_GPIO_LINE_MCBVD1		EP93XX_GPIO_LINE_F(3)
+#define EP93XX_GPIO_LINE_MCBVD2		EP93XX_GPIO_LINE_F(4)
+#define EP93XX_GPIO_LINE_VS1		EP93XX_GPIO_LINE_F(5)
+#define EP93XX_GPIO_LINE_READY		EP93XX_GPIO_LINE_F(6)
+#define EP93XX_GPIO_LINE_VS2		EP93XX_GPIO_LINE_F(7)
+
+/* GPIO port G.  */
+#define EP93XX_GPIO_LINE_G(x)		((x) + 48)
+#define EP93XX_GPIO_LINE_EECLK		EP93XX_GPIO_LINE_G(0)
+#define EP93XX_GPIO_LINE_EEDAT		EP93XX_GPIO_LINE_G(1)
+#define EP93XX_GPIO_LINE_SLA0		EP93XX_GPIO_LINE_G(2)
+#define EP93XX_GPIO_LINE_SLA1		EP93XX_GPIO_LINE_G(3)
+#define EP93XX_GPIO_LINE_DD12		EP93XX_GPIO_LINE_G(4)
+#define EP93XX_GPIO_LINE_DD13		EP93XX_GPIO_LINE_G(5)
+#define EP93XX_GPIO_LINE_DD14		EP93XX_GPIO_LINE_G(6)
+#define EP93XX_GPIO_LINE_DD15		EP93XX_GPIO_LINE_G(7)
+
+/* GPIO port H.  */
+#define EP93XX_GPIO_LINE_H(x)		((x) + 56)
+#define EP93XX_GPIO_LINE_DD0		EP93XX_GPIO_LINE_H(0)
+#define EP93XX_GPIO_LINE_DD1		EP93XX_GPIO_LINE_H(1)
+#define EP93XX_GPIO_LINE_DD2		EP93XX_GPIO_LINE_H(2)
+#define EP93XX_GPIO_LINE_DD3		EP93XX_GPIO_LINE_H(3)
+#define EP93XX_GPIO_LINE_DD4		EP93XX_GPIO_LINE_H(4)
+#define EP93XX_GPIO_LINE_DD5		EP93XX_GPIO_LINE_H(5)
+#define EP93XX_GPIO_LINE_DD6		EP93XX_GPIO_LINE_H(6)
+#define EP93XX_GPIO_LINE_DD7		EP93XX_GPIO_LINE_H(7)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ep93xx/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,12 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/hardware.h
+ */
+
+#include "ep93xx-regs.h"
+
+#define pcibios_assign_all_busses()	0
+
+#include "platform.h"
+
+#include "gesbc9312.h"
+#include "ts72xx.h"
Index: build_tree/linux/include/asm/arch-ep93xx/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,8 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/io.h
+ */
+
+#define IO_SPACE_LIMIT		0xffffffff
+
+#define __io(p)			((void __iomem *)(p))
+#define __mem_pci(p)		(p)
Index: build_tree/linux/include/asm/arch-ep93xx/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,84 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/irqs.h
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define IRQ_EP93XX_COMMRX		2
+#define IRQ_EP93XX_COMMTX		3
+#define IRQ_EP93XX_TIMER1		4
+#define IRQ_EP93XX_TIMER2		5
+#define IRQ_EP93XX_AACINTR		6
+#define IRQ_EP93XX_DMAM2P0		7
+#define IRQ_EP93XX_DMAM2P1		8
+#define IRQ_EP93XX_DMAM2P2		9
+#define IRQ_EP93XX_DMAM2P3		10
+#define IRQ_EP93XX_DMAM2P4		11
+#define IRQ_EP93XX_DMAM2P5		12
+#define IRQ_EP93XX_DMAM2P6		13
+#define IRQ_EP93XX_DMAM2P7		14
+#define IRQ_EP93XX_DMAM2P8		15
+#define IRQ_EP93XX_DMAM2P9		16
+#define IRQ_EP93XX_DMAM2M0		17
+#define IRQ_EP93XX_DMAM2M1		18
+#define IRQ_EP93XX_GPIO0MUX		19
+#define IRQ_EP93XX_GPIO1MUX		20
+#define IRQ_EP93XX_GPIO2MUX		21
+#define IRQ_EP93XX_GPIO3MUX		22
+#define IRQ_EP93XX_UART1RX		23
+#define IRQ_EP93XX_UART1TX		24
+#define IRQ_EP93XX_UART2RX		25
+#define IRQ_EP93XX_UART2TX		26
+#define IRQ_EP93XX_UART3RX		27
+#define IRQ_EP93XX_UART3TX		28
+#define IRQ_EP93XX_KEY			29
+#define IRQ_EP93XX_TOUCH		30
+#define EP93XX_VIC1_VALID_IRQ_MASK	0x7ffffffc
+
+#define IRQ_EP93XX_EXT0			32
+#define IRQ_EP93XX_EXT1			33
+#define IRQ_EP93XX_EXT2			34
+#define IRQ_EP93XX_64HZ			35
+#define IRQ_EP93XX_WATCHDOG		36
+#define IRQ_EP93XX_RTC			37
+#define IRQ_EP93XX_IRDA			38
+#define IRQ_EP93XX_ETHERNET		39
+#define IRQ_EP93XX_EXT3			40
+#define IRQ_EP93XX_PROG			41
+#define IRQ_EP93XX_1HZ			42
+#define IRQ_EP93XX_VSYNC		43
+#define IRQ_EP93XX_VIDEO_FIFO		44
+#define IRQ_EP93XX_SSP1RX		45
+#define IRQ_EP93XX_SSP1TX		46
+#define IRQ_EP93XX_GPIO4MUX		47
+#define IRQ_EP93XX_GPIO5MUX		48
+#define IRQ_EP93XX_GPIO6MUX		49
+#define IRQ_EP93XX_GPIO7MUX		50
+#define IRQ_EP93XX_TIMER3		51
+#define IRQ_EP93XX_UART1		52
+#define IRQ_EP93XX_SSP			53
+#define IRQ_EP93XX_UART2		54
+#define IRQ_EP93XX_UART3		55
+#define IRQ_EP93XX_USB			56
+#define IRQ_EP93XX_ETHERNET_PME		57
+#define IRQ_EP93XX_DSP			58
+#define IRQ_EP93XX_GPIO_AB		59
+#define IRQ_EP93XX_SAI			60
+#define EP93XX_VIC2_VALID_IRQ_MASK	0x1fffffff
+
+/*
+ * Map GPIO A0..A7 to irq 64..71, B0..B7 to 72..79, and
+ * F0..F7 to 80..87.
+ */
+#define IRQ_EP93XX_GPIO(x)		(64 + (((x) + (((x) >> 2) & 8)) & 0x1f))
+
+#define NR_EP93XX_IRQS			(64 + 24)
+
+#define EP93XX_BOARD_IRQ(x)		(NR_EP93XX_IRQS + (x))
+#define EP93XX_BOARD_IRQS		32
+
+#define NR_IRQS				(NR_EP93XX_IRQS + EP93XX_BOARD_IRQS)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ep93xx/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,14 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET		UL(0x00000000)
+
+#define __bus_to_virt(x)	__phys_to_virt(x)
+#define __virt_to_bus(x)	__virt_to_phys(x)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ep93xx/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/platform.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/platform.h
+ */
+
+#ifndef __ASSEMBLY__
+
+void ep93xx_map_io(void);
+void ep93xx_init_irq(void);
+void ep93xx_init_time(unsigned long);
+void ep93xx_init_devices(void);
+extern struct sys_timer ep93xx_timer;
+
+struct ep93xx_eth_data
+{
+	unsigned char	dev_addr[6];
+	unsigned char	phy_id;
+};
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ep93xx/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/system.h
+ */
+
+#include <asm/hardware.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	u32 devicecfg;
+
+	local_irq_disable();
+
+	devicecfg = __raw_readl(EP93XX_SYSCON_DEVICE_CONFIG);
+	__raw_writel(0xaa, EP93XX_SYSCON_SWLOCK);
+	__raw_writel(devicecfg | 0x80000000, EP93XX_SYSCON_DEVICE_CONFIG);
+	__raw_writel(0xaa, EP93XX_SYSCON_SWLOCK);
+	__raw_writel(devicecfg & ~0x80000000, EP93XX_SYSCON_DEVICE_CONFIG);
+
+	while (1)
+		;
+}
Index: build_tree/linux/include/asm/arch-ep93xx/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,5 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/timex.h
+ */
+
+#define CLOCK_TICK_RATE		983040
Index: build_tree/linux/include/asm/arch-ep93xx/ts72xx.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/ts72xx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/ts72xx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,101 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/ts72xx.h
+ */
+
+/*
+ * TS72xx memory map:
+ *
+ * virt		phys		size
+ * febff000	22000000	4K	model number register
+ * febfe000	22400000	4K	options register
+ * febfd000	22800000	4K	options register #2
+ * febfc000	[67]0000000	4K	NAND data register
+ * febfb000	[67]0400000	4K	NAND control register
+ * febfa000	[67]0800000	4K	NAND busy register
+ * febf9000	10800000	4K	TS-5620 RTC index register
+ * febf8000	11700000	4K	TS-5620 RTC data register
+ */
+
+#define TS72XX_MODEL_PHYS_BASE		0x22000000
+#define TS72XX_MODEL_VIRT_BASE		0xfebff000
+#define TS72XX_MODEL_SIZE		0x00001000
+
+#define TS72XX_MODEL_TS7200		0x00
+#define TS72XX_MODEL_TS7250		0x01
+#define TS72XX_MODEL_TS7260		0x02
+
+
+#define TS72XX_OPTIONS_PHYS_BASE	0x22400000
+#define TS72XX_OPTIONS_VIRT_BASE	0xfebfe000
+#define TS72XX_OPTIONS_SIZE		0x00001000
+
+#define TS72XX_OPTIONS_COM2_RS485	0x02
+#define TS72XX_OPTIONS_MAX197		0x01
+
+
+#define TS72XX_OPTIONS2_PHYS_BASE	0x22800000
+#define TS72XX_OPTIONS2_VIRT_BASE	0xfebfd000
+#define TS72XX_OPTIONS2_SIZE		0x00001000
+
+#define TS72XX_OPTIONS2_TS9420		0x04
+#define TS72XX_OPTIONS2_TS9420_BOOT	0x02
+
+
+#define TS72XX_NOR_PHYS_BASE		0x60000000
+#define TS72XX_NOR2_PHYS_BASE		0x62000000
+
+#define TS72XX_NAND1_DATA_PHYS_BASE	0x60000000
+#define TS72XX_NAND2_DATA_PHYS_BASE	0x70000000
+#define TS72XX_NAND_DATA_VIRT_BASE	0xfebfc000
+#define TS72XX_NAND_DATA_SIZE		0x00001000
+
+#define TS72XX_NAND1_CONTROL_PHYS_BASE	0x60400000
+#define TS72XX_NAND2_CONTROL_PHYS_BASE	0x70400000
+#define TS72XX_NAND_CONTROL_VIRT_BASE	0xfebfb000
+#define TS72XX_NAND_CONTROL_SIZE	0x00001000
+
+#define TS72XX_NAND1_BUSY_PHYS_BASE	0x60800000
+#define TS72XX_NAND2_BUSY_PHYS_BASE	0x70800000
+#define TS72XX_NAND_BUSY_VIRT_BASE	0xfebfa000
+#define TS72XX_NAND_BUSY_SIZE		0x00001000
+
+
+#define TS72XX_RTC_INDEX_VIRT_BASE	0xfebf9000
+#define TS72XX_RTC_INDEX_PHYS_BASE	0x10800000
+#define TS72XX_RTC_INDEX_SIZE		0x00001000
+
+#define TS72XX_RTC_DATA_VIRT_BASE	0xfebf8000
+#define TS72XX_RTC_DATA_PHYS_BASE	0x11700000
+#define TS72XX_RTC_DATA_SIZE		0x00001000
+
+
+#ifndef __ASSEMBLY__
+#include <asm/io.h>
+
+static inline int board_is_ts7200(void)
+{
+	return __raw_readb(TS72XX_MODEL_VIRT_BASE) == TS72XX_MODEL_TS7200;
+}
+
+static inline int board_is_ts7250(void)
+{
+	return __raw_readb(TS72XX_MODEL_VIRT_BASE) == TS72XX_MODEL_TS7250;
+}
+
+static inline int board_is_ts7260(void)
+{
+	return __raw_readb(TS72XX_MODEL_VIRT_BASE) == TS72XX_MODEL_TS7260;
+}
+
+static inline int is_max197_installed(void)
+{
+	return !!(__raw_readb(TS72XX_OPTIONS_VIRT_BASE) &
+					TS72XX_OPTIONS_MAX197);
+}
+
+static inline int is_ts9420_installed(void)
+{
+	return !!(__raw_readb(TS72XX_OPTIONS2_VIRT_BASE) &
+					TS72XX_OPTIONS2_TS9420);
+}
+#endif
Index: build_tree/linux/include/asm/arch-ep93xx/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,85 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/uncompress.h
+ *
+ * Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <asm/arch/ep93xx-regs.h>
+
+static unsigned char __raw_readb(unsigned int ptr)
+{
+	return *((volatile unsigned char *)ptr);
+}
+
+static unsigned int __raw_readl(unsigned int ptr)
+{
+	return *((volatile unsigned int *)ptr);
+}
+
+static void __raw_writeb(unsigned char value, unsigned int ptr)
+{
+	*((volatile unsigned char *)ptr) = value;
+}
+
+static void __raw_writel(unsigned int value, unsigned int ptr)
+{
+	*((volatile unsigned int *)ptr) = value;
+}
+
+
+#define PHYS_UART1_DATA		0x808c0000
+#define PHYS_UART1_FLAG		0x808c0018
+#define UART1_FLAG_TXFF		0x20
+
+static inline void putc(int c)
+{
+	int i;
+
+	for (i = 0; i < 1000; i++) {
+		/* Transmit fifo not full?  */
+		if (!(__raw_readb(PHYS_UART1_FLAG) & UART1_FLAG_TXFF))
+			break;
+	}
+
+	__raw_writeb(c, PHYS_UART1_DATA);
+}
+
+static inline void flush(void)
+{
+}
+
+
+/*
+ * Some bootloaders don't turn off DMA from the ethernet MAC before
+ * jumping to linux, which means that we might end up with bits of RX
+ * status and packet data scribbled over the uncompressed kernel image.
+ * Work around this by resetting the ethernet MAC before we uncompress.
+ */
+#define PHYS_ETH_SELF_CTL		0x80010020
+#define ETH_SELF_CTL_RESET		0x00000001
+
+static void ethernet_reset(void)
+{
+	unsigned int v;
+
+	/* Reset the ethernet MAC.  */
+	v = __raw_readl(PHYS_ETH_SELF_CTL);
+	__raw_writel(v | ETH_SELF_CTL_RESET, PHYS_ETH_SELF_CTL);
+
+	/* Wait for reset to finish.  */
+	while (__raw_readl(PHYS_ETH_SELF_CTL) & ETH_SELF_CTL_RESET)
+		;
+}
+
+
+static void arch_decomp_setup(void)
+{
+	ethernet_reset();
+}
+
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-ep93xx/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ep93xx/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ep93xx/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,5 @@
+/*
+ * linux/include/asm-arm/arch-ep93xx/vmalloc.h
+ */
+
+#define VMALLOC_END	0xfe800000
Index: build_tree/linux/include/asm/arch-h720x/boards.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/boards.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/boards.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,53 @@
+/*
+ * linux/include/asm-arm/arch-h720x/boards.h
+ *
+ * Copyright (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *           (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *
+ * This file contains the board specific defines for various devices
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_INCMACH_H
+#error Do not include this file directly. Include asm/hardware.h instead !
+#endif
+
+/* Hynix H7202 developer board specific device defines */
+#ifdef CONFIG_ARCH_H7202
+
+/* FLASH */
+#define FLASH_VIRT		0xd0000000
+#define FLASH_PHYS		0x00000000
+#define FLASH_SIZE		0x02000000
+
+/* onboard LAN controller */
+# define ETH0_PHYS		0x08000000
+
+/* Touch screen defines */
+/* GPIO Port */
+#define PEN_GPIO		GPIO_B_VIRT
+/* Bitmask for pen down interrupt */
+#define PEN_INT_BIT		(1<<7)
+/* Bitmask for pen up interrupt */
+#define PEN_ENA_BIT		(1<<6)
+/* pen up interrupt */
+#define IRQ_PEN			IRQ_MUX_GPIOB(7)
+
+#endif
+
+/* Hynix H7201 developer board specific device defines */
+#if defined (CONFIG_ARCH_H7201)
+/* ROM DISK SPACE */
+#define ROM_DISK_BASE           0xc1800000
+#define ROM_DISK_START          0x41800000
+#define ROM_DISK_SIZE           0x00700000
+
+/* SRAM DISK SPACE */
+#define SRAM_DISK_BASE          0xf1000000
+#define SRAM_DISK_START         0x04000000
+#define SRAM_DISK_SIZE          0x00400000
+#endif
+
Index: build_tree/linux/include/asm/arch-h720x/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/* linux/include/asm-arm/arch-h720x/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.equ    io_virt, IO_BASE
+		.equ    io_phys, IO_START
+
+		.macro  addruart,rx
+		mrc     p15, 0, \rx, c1, c0
+		tst     \rx, #1  	       @ MMU enabled?
+		moveq   \rx, #io_phys	       @ physical base address
+		movne   \rx, #io_virt	       @ virtual address
+		add     \rx, \rx, #0x00020000   @ UART1
+		.endm
+
+		.macro  senduart,rd,rx
+		str     \rd, [\rx, #0x0]        @ UARTDR
+
+		.endm
+
+		.macro  waituart,rd,rx
+1001:		ldr     \rd, [\rx, #0x18]       @ UARTFLG
+		tst     \rd, #1 << 5	       @ UARTFLGUTXFF - 1 when full
+		bne     1001b
+		.endm
+
+		.macro  busyuart,rd,rx
+1001:		ldr     \rd, [\rx, #0x18]       @ UARTFLG
+		tst     \rd, #1 << 3	       @ UARTFLGUBUSY - 1 when busy
+		bne     1001b
+		.endm
Index: build_tree/linux/include/asm/arch-h720x/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-arm/arch-h720x/dma.h
+ *
+ * Architecture DMA routes
+ *
+ * Copyright (C) 1997.1998 Russell King
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address that can be DMAd to.
+ * There should not be more than (0xd0000000 - 0xc0000000)
+ * bytes of RAM.
+ */
+#define MAX_DMA_ADDRESS		0xd0000000
+
+#if defined (CONFIG_CPU_H7201)
+#define MAX_DMA_CHANNELS	3
+#elif defined (CONFIG_CPU_H7202)
+#define MAX_DMA_CHANNELS	4
+#else
+#error processor definition missmatch
+#endif
+
+#endif /* __ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-h720x/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,66 @@
+/*
+ * include/asm-arm/arch-h720x/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Hynix HMS720x based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+		.macro  disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+#if defined (CONFIG_CPU_H7201) || defined (CONFIG_CPU_H7202)
+		@ we could use the id register on H7202, but this is not
+		@ properly updated when we come back from asm_do_irq
+		@ without a previous return from interrupt
+		@ (see loops below in irq_svc, irq_usr)
+		@ We see unmasked pending ints only, as the masked pending ints
+		@ are not visible here
+
+		mov     \base, #0xf0000000	       @ base register
+		orr     \base, \base, #0x24000	       @ irqbase
+		ldr     \irqstat, [\base, #0x04]        @ get interrupt status
+#if defined (CONFIG_CPU_H7201)
+		ldr	\tmp, =0x001fffff
+#else
+		mvn     \tmp, #0xc0000000
+#endif
+		and     \irqstat, \irqstat, \tmp        @ mask out unused ints
+		mov     \irqnr, #0
+
+		mov     \tmp, #0xff00
+		orr     \tmp, \tmp, #0xff
+		tst     \irqstat, \tmp
+		addeq   \irqnr, \irqnr, #16
+		moveq   \irqstat, \irqstat, lsr #16
+		tst     \irqstat, #255
+		addeq   \irqnr, \irqnr, #8
+		moveq   \irqstat, \irqstat, lsr #8
+		tst     \irqstat, #15
+		addeq   \irqnr, \irqnr, #4
+		moveq   \irqstat, \irqstat, lsr #4
+		tst     \irqstat, #3
+		addeq   \irqnr, \irqnr, #2
+		moveq   \irqstat, \irqstat, lsr #2
+		tst     \irqstat, #1
+		addeq   \irqnr, \irqnr, #1
+		moveq   \irqstat, \irqstat, lsr #1
+		tst     \irqstat, #1		       @ bit 0 should be set
+		.endm
+
+		.macro  irq_prio_table
+		.endm
+
+#else
+#error hynix processor selection missmatch
+#endif
+
Index: build_tree/linux/include/asm/arch-h720x/h7201-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/h7201-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/h7201-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,67 @@
+/*
+ * linux/include/asm-arm/arch-h720x/h7201-regs.h
+ *
+ * Copyright (C) 2000 Jungjun Kim, Hynix Semiconductor Inc.
+ *           (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *           (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *           (C) 2004 Sascha Hauer    <s.hauer@pengutronix.de>
+ *
+ * This file contains the hardware definitions of the h720x processors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Do not add implementations specific defines here. This files contains
+ * only defines of the onchip peripherals. Add those defines to boards.h,
+ * which is included by this file.
+ */
+
+#define SERIAL2_VIRT 		(IO_VIRT + 0x50100)
+#define SERIAL3_VIRT 		(IO_VIRT + 0x50200)
+
+/*
+ * PCMCIA
+ */
+#define PCMCIA0_ATT_BASE        0xe5000000
+#define PCMCIA0_ATT_SIZE        0x00200000
+#define PCMCIA0_ATT_START       0x20000000
+#define PCMCIA0_MEM_BASE        0xe5200000
+#define PCMCIA0_MEM_SIZE        0x00200000
+#define PCMCIA0_MEM_START       0x24000000
+#define PCMCIA0_IO_BASE         0xe5400000
+#define PCMCIA0_IO_SIZE         0x00200000
+#define PCMCIA0_IO_START        0x28000000
+
+#define PCMCIA1_ATT_BASE        0xe5600000
+#define PCMCIA1_ATT_SIZE        0x00200000
+#define PCMCIA1_ATT_START       0x30000000
+#define PCMCIA1_MEM_BASE        0xe5800000
+#define PCMCIA1_MEM_SIZE        0x00200000
+#define PCMCIA1_MEM_START       0x34000000
+#define PCMCIA1_IO_BASE         0xe5a00000
+#define PCMCIA1_IO_SIZE         0x00200000
+#define PCMCIA1_IO_START        0x38000000
+
+#define PRIME3C_BASE            0xf0050000
+#define PRIME3C_SIZE            0x00001000
+#define PRIME3C_START           0x10000000
+
+/* VGA Controller */
+#define VGA_RAMBASE 		0x50
+#define VGA_TIMING0 		0x60
+#define VGA_TIMING1 		0x64
+#define VGA_TIMING2 		0x68
+#define VGA_TIMING3 		0x6c
+
+#define LCD_CTRL_VGA_ENABLE   	0x00000100
+#define LCD_CTRL_VGA_BPP_MASK 	0x00000600
+#define LCD_CTRL_VGA_4BPP    	0x00000000
+#define LCD_CTRL_VGA_8BPP    	0x00000200
+#define LCD_CTRL_VGA_16BPP   	0x00000300
+#define LCD_CTRL_SHARE_DMA    	0x00000800
+#define LCD_CTRL_VDE          	0x00100000
+#define LCD_CTRL_LPE          	0x00400000	/* LCD Power enable */
+#define LCD_CTRL_BLE          	0x00800000	/* LCD backlight enable */
+
+#define VGA_PALETTE_BASE	(IO_VIRT + 0x10800)
Index: build_tree/linux/include/asm/arch-h720x/h7202-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/h7202-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/h7202-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,155 @@
+/*
+ * linux/include/asm-arm/arch-h720x/h7202-regs.h
+ *
+ * Copyright (C) 2000 Jungjun Kim, Hynix Semiconductor Inc.
+ *           (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *           (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *           (C) 2004 Sascha Hauer    <s.hauer@pengutronix.de>
+ *
+ * This file contains the hardware definitions of the h720x processors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Do not add implementations specific defines here. This files contains
+ * only defines of the onchip peripherals. Add those defines to boards.h,
+ * which is included by this file.
+ */
+
+#define SERIAL2_OFS		0x2d000
+#define SERIAL2_BASE		(IO_PHYS + SERIAL2_OFS)
+#define SERIAL2_VIRT 		(IO_VIRT + SERIAL2_OFS)
+#define SERIAL3_OFS		0x2e000
+#define SERIAL3_BASE		(IO_PHYS + SERIAL3_OFS)
+#define SERIAL3_VIRT 		(IO_VIRT + SERIAL3_OFS)
+
+/* Matrix Keyboard Controller */
+#define KBD_VIRT		(IO_VIRT + 0x22000)
+#define KBD_KBCR		0x00
+#define KBD_KBSC		0x04
+#define KBD_KBTR		0x08
+#define KBD_KBVR0		0x0C
+#define KBD_KBVR1		0x10
+#define KBD_KBSR		0x18
+
+#define KBD_KBCR_SCANENABLE	(1 << 7)
+#define KBD_KBCR_NPOWERDOWN	(1 << 2)
+#define KBD_KBCR_CLKSEL_MASK	(3)
+#define KBD_KBCR_CLKSEL_PCLK2	0x0
+#define KBD_KBCR_CLKSEL_PCLK128	0x1
+#define KBD_KBCR_CLKSEL_PCLK256	0x2
+#define KBD_KBCR_CLKSEL_PCLK512	0x3
+
+#define KBD_KBSR_INTR		(1 << 0)
+#define KBD_KBSR_WAKEUP		(1 << 1)
+
+/* USB device controller */
+
+#define USBD_BASE		(IO_VIRT + 0x12000)
+#define USBD_LENGTH		0x3C
+
+#define USBD_GCTRL		0x00
+#define USBD_EPCTRL		0x04
+#define USBD_INTMASK		0x08
+#define USBD_INTSTAT		0x0C
+#define USBD_PWR		0x10
+#define USBD_DMARXTX		0x14
+#define USBD_DEVID		0x18
+#define USBD_DEVCLASS		0x1C
+#define USBD_INTCLASS		0x20
+#define USBD_SETUP0		0x24
+#define USBD_SETUP1		0x28
+#define USBD_ENDP0RD		0x2C
+#define USBD_ENDP0WT		0x30
+#define USBD_ENDP1RD		0x34
+#define USBD_ENDP2WT		0x38
+
+/* PS/2 port */
+#define PSDATA 0x00
+#define PSSTAT 0x04
+#define PSSTAT_TXEMPTY (1<<0)
+#define PSSTAT_TXBUSY (1<<1)
+#define PSSTAT_RXFULL (1<<2)
+#define PSSTAT_RXBUSY (1<<3)
+#define PSSTAT_CLKIN (1<<4)
+#define PSSTAT_DATAIN (1<<5)
+#define PSSTAT_PARITY (1<<6)
+
+#define PSCONF 0x08
+#define PSCONF_ENABLE (1<<0)
+#define PSCONF_TXINTEN (1<<2)
+#define PSCONF_RXINTEN (1<<3)
+#define PSCONF_FORCECLKLOW (1<<4)
+#define PSCONF_FORCEDATLOW (1<<5)
+#define PSCONF_LCE (1<<6)
+
+#define PSINTR 0x0C
+#define PSINTR_TXINT (1<<0)
+#define PSINTR_RXINT (1<<1)
+#define PSINTR_PAR (1<<2)
+#define PSINTR_RXTO (1<<3)
+#define PSINTR_TXTO (1<<4)
+
+#define PSTDLO 0x10 /* clk low before start transmission */
+#define PSTPRI 0x14 /* PRI clock */
+#define PSTXMT 0x18 /* maximum transmission time */
+#define PSTREC 0x20 /* maximum receive time */
+#define PSPWDN 0x3c
+
+/* ADC converter */
+#define ADC_BASE 		(IO_VIRT + 0x29000)
+#define ADC_CR 			0x00
+#define ADC_TSCTRL 		0x04
+#define ADC_BT_CTRL 		0x08
+#define ADC_MC_CTRL		0x0C
+#define ADC_STATUS		0x10
+
+/* ADC control register bits */
+#define ADC_CR_PW_CTRL 		0x80
+#define ADC_CR_DIRECTC		0x04
+#define ADC_CR_CONTIME_NO	0x00
+#define ADC_CR_CONTIME_2	0x04
+#define ADC_CR_CONTIME_4	0x08
+#define ADC_CR_CONTIME_ADE	0x0c
+#define ADC_CR_LONGCALTIME	0x01
+
+/* ADC touch panel register bits */
+#define ADC_TSCTRL_ENABLE 	0x80
+#define ADC_TSCTRL_INTR   	0x40
+#define	ADC_TSCTRL_SWBYPSS	0x20
+#define ADC_TSCTRL_SWINVT	0x10
+#define ADC_TSCTRL_S400   	0x03
+#define ADC_TSCTRL_S200   	0x02
+#define ADC_TSCTRL_S100   	0x01
+#define ADC_TSCTRL_S50    	0x00
+
+/* ADC Interrupt Status Register bits */
+#define ADC_STATUS_TS_BIT	0x80
+#define ADC_STATUS_MBT_BIT	0x40
+#define ADC_STATUS_BBT_BIT	0x20
+#define ADC_STATUS_MIC_BIT	0x10
+
+/* Touch data registers */
+#define ADC_TS_X0X1  		0x30
+#define ADC_TS_X2X3		0x34
+#define ADC_TS_Y0Y1		0x38
+#define ADC_TS_Y2Y3  		0x3c
+#define ADC_TS_X4X5  		0x40
+#define ADC_TS_X6X7  		0x44
+#define ADC_TS_Y4Y5		0x48
+#define ADC_TS_Y6Y7		0x50
+
+/* battery data */
+#define ADC_MB_DATA		0x54
+#define ADC_BB_DATA		0x58
+
+/* Sound data register */
+#define ADC_SD_DAT0 		0x60
+#define ADC_SD_DAT1		0x64
+#define ADC_SD_DAT2		0x68
+#define ADC_SD_DAT3		0x6c
+#define ADC_SD_DAT4		0x70
+#define ADC_SD_DAT5		0x74
+#define ADC_SD_DAT6		0x78
+#define ADC_SD_DAT7		0x7c
Index: build_tree/linux/include/asm/arch-h720x/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,192 @@
+/*
+ * linux/include/asm-arm/arch-h720x/hardware.h
+ *
+ * Copyright (C) 2000 Jungjun Kim, Hynix Semiconductor Inc.
+ *           (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *           (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *
+ * This file contains the hardware definitions of the h720x processors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Do not add implementations specific defines here. This files contains
+ * only defines of the onchip peripherals. Add those defines to boards.h,
+ * which is included by this file.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#define IOCLK (3686400L)
+
+/* Onchip peripherals */
+
+#define IO_VIRT			0xf0000000	/* IO peripherals */
+#define IO_PHYS			0x80000000
+#define IO_SIZE			0x00050000
+
+#ifdef CONFIG_CPU_H7202
+#include "h7202-regs.h"
+#elif defined CONFIG_CPU_H7201
+#include "h7201-regs.h"
+#else
+#error machine definition mismatch
+#endif
+
+/* Macro to access the CPU IO */
+#define CPU_IO(x) (*(volatile u32*)(x))
+
+/* Macro to access general purpose regs (base, offset) */
+#define CPU_REG(x,y) CPU_IO(x+y)
+
+/* Macro to access irq related regs */
+#define IRQ_REG(x) CPU_REG(IRQC_VIRT,x)
+
+/* CPU registers */
+/* general purpose I/O */
+#define GPIO_VIRT(x)		(IO_VIRT + 0x23000 + ((x)<<5))
+#define GPIO_A_VIRT		(GPIO_VIRT(0))
+#define GPIO_B_VIRT		(GPIO_VIRT(1))
+#define GPIO_C_VIRT		(GPIO_VIRT(2))
+#define GPIO_D_VIRT		(GPIO_VIRT(3))
+#define GPIO_E_VIRT		(GPIO_VIRT(4))
+#define GPIO_AMULSEL		(GPIO_VIRT(0) + 0xA4)
+
+#define AMULSEL_USIN2	(1<<5)
+#define AMULSEL_USOUT2	(1<<6)
+#define AMULSEL_USIN3	(1<<13)
+#define AMULSEL_USOUT3	(1<<14)
+#define AMULSEL_IRDIN	(1<<15)
+#define AMULSEL_IRDOUT	(1<<7)
+
+/* Register offsets general purpose I/O */
+#define GPIO_DATA		0x00
+#define GPIO_DIR		0x04
+#define GPIO_MASK		0x08
+#define GPIO_STAT		0x0C
+#define GPIO_EDGE		0x10
+#define GPIO_CLR		0x14
+#define GPIO_POL		0x18
+#define GPIO_EN			0x1C
+
+/*interrupt controller */
+#define IRQC_VIRT		(IO_VIRT + 0x24000)
+/* register offset interrupt controller */
+#define IRQC_IER		0x00
+#define IRQC_ISR		0x04
+
+/* timer unit */
+#define TIMER_VIRT		(IO_VIRT + 0x25000)
+/* Register offsets timer unit */
+#define TM0_PERIOD   		0x00
+#define TM0_COUNT    		0x08
+#define TM0_CTRL     		0x10
+#define TM1_PERIOD   		0x20
+#define TM1_COUNT    		0x28
+#define TM1_CTRL     		0x30
+#define TM2_PERIOD   		0x40
+#define TM2_COUNT    		0x48
+#define TM2_CTRL     		0x50
+#define TIMER_TOPCTRL		0x60
+#define TIMER_TOPSTAT		0x64
+#define T64_COUNTL		0x80
+#define T64_COUNTH		0x84
+#define T64_CTRL		0x88
+#define T64_BASEL		0x94
+#define T64_BASEH		0x98
+/* Bitmaks timer unit TOPSTAT reg */
+#define TSTAT_T0INT		0x1
+#define TSTAT_T1INT		0x2
+#define TSTAT_T2INT		0x4
+#define TSTAT_T3INT		0x8
+/* Bit description of TMx_CTRL register */
+#define TM_START  		0x1
+#define TM_REPEAT 		0x2
+#define TM_RESET  		0x4
+/* Bit description of TIMER_CTRL register */
+#define ENABLE_TM0_INTR  	0x1
+#define ENABLE_TM1_INTR  	0x2
+#define ENABLE_TM2_INTR  	0x4
+#define TIMER_ENABLE_BIT 	0x8
+#define ENABLE_TIMER64   	0x10
+#define ENABLE_TIMER64_INT	0x20
+
+/* PMU & PLL */
+#define PMU_BASE 		(IO_VIRT + 0x1000)
+#define PMU_MODE		0x00
+#define PMU_STAT   		0x20
+#define PMU_PLL_CTRL 		0x28
+
+/* PMU Mode bits */
+#define PMU_MODE_SLOW		0x00
+#define PMU_MODE_RUN		0x01
+#define PMU_MODE_IDLE		0x02
+#define PMU_MODE_SLEEP		0x03
+#define PMU_MODE_INIT		0x04
+#define PMU_MODE_DEEPSLEEP	0x07
+#define PMU_MODE_WAKEUP		0x08
+
+/* PMU ... */
+#define PLL_2_EN		0x8000
+#define PLL_1_EN		0x4000
+#define PLL_3_MUTE		0x0080
+
+/* Control bits for PMU/ PLL */
+#define PMU_WARMRESET		0x00010000
+#define PLL_CTRL_MASK23		0x000080ff
+
+/* LCD Controller */
+#define LCD_BASE 		(IO_VIRT + 0x10000)
+#define LCD_CTRL 		0x00
+#define LCD_STATUS		0x04
+#define LCD_STATUS_M		0x08
+#define LCD_INTERRUPT		0x0C
+#define LCD_DBAR		0x10
+#define LCD_DCAR		0x14
+#define LCD_TIMING0 		0x20
+#define LCD_TIMING1 		0x24
+#define LCD_TIMING2 		0x28
+#define LCD_TEST		0x40
+
+/* LCD Control Bits */
+#define LCD_CTRL_LCD_ENABLE   	0x00000001
+/* Bits per pixel */
+#define LCD_CTRL_LCD_BPP_MASK 	0x00000006
+#define LCD_CTRL_LCD_4BPP    	0x00000000
+#define LCD_CTRL_LCD_8BPP    	0x00000002
+#define LCD_CTRL_LCD_16BPP   	0x00000004
+#define LCD_CTRL_LCD_BW		0x00000008
+#define LCD_CTRL_LCD_TFT	0x00000010
+#define LCD_CTRL_BGR		0x00001000
+#define LCD_CTRL_LCD_VCOMP	0x00080000
+#define LCD_CTRL_LCD_MONO8	0x00200000
+#define LCD_CTRL_LCD_PWR	0x00400000
+#define LCD_CTRL_LCD_BLE	0x00800000
+#define LCD_CTRL_LDBUSEN	0x01000000
+
+/* Palette */
+#define LCD_PALETTE_BASE 	(IO_VIRT + 0x10400)
+
+/* Serial ports */
+#define SERIAL0_OFS		0x20000
+#define SERIAL0_VIRT 		(IO_VIRT + SERIAL0_OFS)
+#define SERIAL0_BASE		(IO_PHYS + SERIAL0_OFS)
+
+#define SERIAL1_OFS		0x21000
+#define SERIAL1_VIRT 		(IO_VIRT + SERIAL1_OFS)
+#define SERIAL1_BASE		(IO_PHYS + SERIAL1_OFS)
+
+#define SERIAL_ENABLE		0x30
+#define SERIAL_ENABLE_EN	(1<<0)
+
+/* General defines to pacify gcc */
+#define PCIO_BASE 		(0)	/* for inb, outb and friends */
+#define PCIO_VIRT		PCIO_BASE
+
+#define __ASM_ARCH_HARDWARE_INCMACH_H
+#include "boards.h"
+#undef __ASM_ARCH_HARDWARE_INCMACH_H
+
+#endif				/* __ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-h720x/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ * linux/include/asm-arm/arch-h720x/io.h
+ *
+ * Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *
+ *  09-19-2001	JJKIM
+ *  		Created from linux/include/asm-arm/arch-l7200/io.h
+ *
+ *  03-27-2003  Robert Schwebel <r.schwebel@pengutronix.de>:
+ *  		re-unified header files for h720x
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-h720x/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,116 @@
+/*
+ * linux/include/asm-arm/arch-h720x/irqs.h
+ *
+ * Copyright (C) 2000 Jungjun Kim
+ *           (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *           (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#if defined (CONFIG_CPU_H7201)
+
+#define IRQ_PMU		0		/* 0x000001 */
+#define IRQ_DMA		1 		/* 0x000002 */
+#define IRQ_LCD		2		/* 0x000004 */
+#define IRQ_VGA		3 		/* 0x000008 */
+#define IRQ_PCMCIA1 	4 		/* 0x000010 */
+#define IRQ_PCMCIA2 	5 		/* 0x000020 */
+#define IRQ_AFE		6 		/* 0x000040 */
+#define IRQ_AIC		7 		/* 0x000080 */
+#define IRQ_KEYBOARD 	8 		/* 0x000100 */
+#define IRQ_TIMER0	9 		/* 0x000200 */
+#define IRQ_RTC		10		/* 0x000400 */
+#define IRQ_SOUND	11		/* 0x000800 */
+#define IRQ_USB		12		/* 0x001000 */
+#define IRQ_IrDA 	13		/* 0x002000 */
+#define IRQ_UART0	14		/* 0x004000 */
+#define IRQ_UART1	15		/* 0x008000 */
+#define IRQ_SPI		16		/* 0x010000 */
+#define IRQ_GPIOA 	17		/* 0x020000 */
+#define IRQ_GPIOB	18		/* 0x040000 */
+#define IRQ_GPIOC	19		/* 0x080000 */
+#define IRQ_GPIOD	20		/* 0x100000 */
+#define IRQ_CommRX	21		/* 0x200000 */
+#define IRQ_CommTX	22		/* 0x400000 */
+#define IRQ_Soft	23		/* 0x800000 */
+
+#define NR_GLBL_IRQS	24
+
+#define IRQ_CHAINED_GPIOA(x)  (NR_GLBL_IRQS + x)
+#define IRQ_CHAINED_GPIOB(x)  (IRQ_CHAINED_GPIOA(32) + x)
+#define IRQ_CHAINED_GPIOC(x)  (IRQ_CHAINED_GPIOB(32) + x)
+#define IRQ_CHAINED_GPIOD(x)  (IRQ_CHAINED_GPIOC(32) + x)
+#define NR_IRQS               IRQ_CHAINED_GPIOD(32)
+
+/* Enable mask for multiplexed interrupts */
+#define IRQ_ENA_MUX	(1<<IRQ_GPIOA) | (1<<IRQ_GPIOB) \
+			| (1<<IRQ_GPIOC) | (1<<IRQ_GPIOD)
+
+
+#elif defined (CONFIG_CPU_H7202)
+
+#define IRQ_PMU		0		/* 0x00000001 */
+#define IRQ_DMA		1		/* 0x00000002 */
+#define IRQ_LCD		2		/* 0x00000004 */
+#define IRQ_SOUND	3		/* 0x00000008 */
+#define IRQ_I2S		4		/* 0x00000010 */
+#define IRQ_USB 	5		/* 0x00000020 */
+#define IRQ_MMC 	6		/* 0x00000040 */
+#define IRQ_RTC 	7		/* 0x00000080 */
+#define IRQ_UART0 	8		/* 0x00000100 */
+#define IRQ_UART1 	9		/* 0x00000200 */
+#define IRQ_UART2 	10		/* 0x00000400 */
+#define IRQ_UART3 	11		/* 0x00000800 */
+#define IRQ_KBD 	12		/* 0x00001000 */
+#define IRQ_PS2 	13		/* 0x00002000 */
+#define IRQ_AIC 	14		/* 0x00004000 */
+#define IRQ_TIMER0 	15		/* 0x00008000 */
+#define IRQ_TIMERX 	16		/* 0x00010000 */
+#define IRQ_WDT 	17		/* 0x00020000 */
+#define IRQ_CAN0 	18		/* 0x00040000 */
+#define IRQ_CAN1 	19		/* 0x00080000 */
+#define IRQ_EXT0 	20		/* 0x00100000 */
+#define IRQ_EXT1 	21		/* 0x00200000 */
+#define IRQ_GPIOA 	22		/* 0x00400000 */
+#define IRQ_GPIOB 	23		/* 0x00800000 */
+#define IRQ_GPIOC 	24		/* 0x01000000 */
+#define IRQ_GPIOD 	25		/* 0x02000000 */
+#define IRQ_GPIOE 	26		/* 0x04000000 */
+#define IRQ_COMMRX 	27		/* 0x08000000 */
+#define IRQ_COMMTX 	28		/* 0x10000000 */
+#define IRQ_SMC 	29		/* 0x20000000 */
+#define IRQ_Soft 	30		/* 0x40000000 */
+#define IRQ_RESERVED1 	31		/* 0x80000000 */
+#define NR_GLBL_IRQS	32
+
+#define NR_TIMERX_IRQS	3
+
+#define IRQ_CHAINED_GPIOA(x)  (NR_GLBL_IRQS + x)
+#define IRQ_CHAINED_GPIOB(x)  (IRQ_CHAINED_GPIOA(32) + x)
+#define IRQ_CHAINED_GPIOC(x)  (IRQ_CHAINED_GPIOB(32) + x)
+#define IRQ_CHAINED_GPIOD(x)  (IRQ_CHAINED_GPIOC(32) + x)
+#define IRQ_CHAINED_GPIOE(x)  (IRQ_CHAINED_GPIOD(32) + x)
+#define IRQ_CHAINED_TIMERX(x) (IRQ_CHAINED_GPIOE(32) + x)
+#define IRQ_TIMER1            (IRQ_CHAINED_TIMERX(0))
+#define IRQ_TIMER2            (IRQ_CHAINED_TIMERX(1))
+#define IRQ_TIMER64B          (IRQ_CHAINED_TIMERX(2))
+
+#define NR_IRQS		(IRQ_CHAINED_TIMERX(NR_TIMERX_IRQS))
+
+/* Enable mask for multiplexed interrupts */
+#define IRQ_ENA_MUX	(1<<IRQ_TIMERX) | (1<<IRQ_GPIOA) | (1<<IRQ_GPIOB) | \
+			(1<<IRQ_GPIOC) 	| (1<<IRQ_GPIOD) | (1<<IRQ_GPIOE) | \
+			(1<<IRQ_TIMERX)
+
+#else
+#error cpu definition mismatch
+#endif
+
+/* decode irq number to register number */
+#define IRQ_TO_REGNO(irq) ((irq - NR_GLBL_IRQS) >> 5)
+#define IRQ_TO_BIT(irq) (1 << ((irq - NR_GLBL_IRQS) % 32))
+
+#endif
Index: build_tree/linux/include/asm/arch-h720x/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-arm/arch-h720x/memory.h
+ *
+ * Copyright (c) 2000 Jungjun Kim
+ *
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Page offset:
+ *    ( 0xc0000000UL )
+ */
+#define PHYS_OFFSET	UL(0x40000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ *
+ * There is something to do here later !, Mar 2000, Jungjun Kim
+ */
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-h720x/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ * linux/include/asm-arm/arch-h720x/system.h
+ *
+ * Copyright (C) 2001-2002 Jungjun Kim, Hynix Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * linux/include/asm-arm/arch-h720x/system.h
+ *
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+#include <asm/hardware.h>
+
+static void arch_idle(void)
+{
+	CPU_REG (PMU_BASE, PMU_MODE) = PMU_MODE_IDLE;
+	nop();
+	nop();
+	CPU_REG (PMU_BASE, PMU_MODE) = PMU_MODE_RUN;
+	nop();
+	nop();
+}
+
+
+static __inline__ void arch_reset(char mode)
+{
+	CPU_REG (PMU_BASE, PMU_STAT) |= PMU_WARMRESET;
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-h720x/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,15 @@
+/*
+ * linux/include/asm-arm/arch-h720x/timex.h
+ * Copyright (C) 2000 Jungjun Kim, Hynix Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_TIMEX
+#define __ASM_ARCH_TIMEX
+
+#define CLOCK_TICK_RATE		3686400
+
+#endif
Index: build_tree/linux/include/asm/arch-h720x/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * linux/include/asm-arm/arch-h720x/uncompress.h
+ *
+ * Copyright (C) 2001-2002 Jungjun Kim
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <asm/hardware.h>
+
+#define LSR 	0x14
+#define TEMPTY 	0x40
+
+static inline void putc(int c)
+{
+	volatile unsigned char *p = (volatile unsigned char *)(IO_PHYS+0x20000);
+
+	/* wait until transmit buffer is empty */
+	while((p[LSR] & TEMPTY) == 0x0)
+		barrier();
+
+	/* write next character */
+	*p = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif
Index: build_tree/linux/include/asm/arch-h720x/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-h720x/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-h720x/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,10 @@
+/*
+ * linux/include/asm-arm/arch-h720x/vmalloc.h
+ */
+
+#ifndef __ARCH_ARM_VMALLOC_H
+#define __ARCH_ARM_VMALLOC_H
+
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-imx/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,34 @@
+/* linux/include/asm-arm/arch-imx/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x00000000	@ physical
+		movne	\rx, #0xe0000000	@ virtual
+		orreq	\rx, \rx, #0x00200000	@ physical
+		orr	\rx, \rx, #0x00006000	@ UART1 offset
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0x40]	@ TXDATA
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #0x98]	@ SR2
+		tst	\rd, #1 << 3		@ TXDC
+		beq	1002b			@ wait until transmit done
+		.endm
Index: build_tree/linux/include/asm/arch-imx/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,56 @@
+/*
+ *  linux/include/asm-arm/imxads/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+typedef enum {
+	DMA_PRIO_HIGH = 0,
+	DMA_PRIO_MEDIUM = 1,
+	DMA_PRIO_LOW = 2
+} imx_dma_prio;
+
+#define DMA_REQ_UART3_T        2
+#define DMA_REQ_UART3_R        3
+#define DMA_REQ_SSI2_T         4
+#define DMA_REQ_SSI2_R         5
+#define DMA_REQ_CSI_STAT       6
+#define DMA_REQ_CSI_R          7
+#define DMA_REQ_MSHC           8
+#define DMA_REQ_DSPA_DCT_DOUT  9
+#define DMA_REQ_DSPA_DCT_DIN  10
+#define DMA_REQ_DSPA_MAC      11
+#define DMA_REQ_EXT           12
+#define DMA_REQ_SDHC          13
+#define DMA_REQ_SPI1_R        14
+#define DMA_REQ_SPI1_T        15
+#define DMA_REQ_SSI_T         16
+#define DMA_REQ_SSI_R         17
+#define DMA_REQ_ASP_DAC       18
+#define DMA_REQ_ASP_ADC       19
+#define DMA_REQ_USP_EP(x)    (20+(x))
+#define DMA_REQ_SPI2_R        26
+#define DMA_REQ_SPI2_T        27
+#define DMA_REQ_UART2_T       28
+#define DMA_REQ_UART2_R       29
+#define DMA_REQ_UART1_T       30
+#define DMA_REQ_UART1_R       31
+
+#endif				/* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-imx/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-imx/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-imx/entry-macro.S
+ *
+ * Low-level IRQ helper macros for iMX-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro	get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro	arch_ret_to_user, tmp1, tmp2
+		.endm
+
+#define AITC_NIVECSR   0x40
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =IO_ADDRESS(IMX_AITC_BASE)
+		@ Load offset & priority of the highest priority
+		@ interrupt pending.
+		ldr	\irqstat, [\base, #AITC_NIVECSR]
+		@ Shift off the priority leaving the offset or
+		@ "interrupt number", use arithmetic shift to
+		@ transform illegal source (0xffff) as -1
+		mov	\irqnr, \irqstat, asr #16
+		adds	\tmp, \irqnr, #1
+		.endm
Index: build_tree/linux/include/asm/arch-imx/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,99 @@
+/*
+ *  linux/include/asm-arm/arch-imx/hardware.h
+ *
+ *  Copyright (C) 1999 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include "imx-regs.h"
+
+#ifndef __ASSEMBLY__
+# define __REG(x)	(*((volatile u32 *)IO_ADDRESS(x)))
+
+# define __REG2(x,y)        (*(volatile u32 *)((u32)&__REG(x) + (y)))
+#endif
+
+/*
+ * Memory map
+ */
+
+#define IMX_IO_PHYS		0x00200000
+#define IMX_IO_SIZE		0x00100000
+#define IMX_IO_BASE		0xe0000000
+
+#define IMX_CS0_PHYS		0x10000000
+#define IMX_CS0_SIZE		0x02000000
+#define IMX_CS0_VIRT		0xe8000000
+
+#define IMX_CS1_PHYS		0x12000000
+#define IMX_CS1_SIZE		0x01000000
+#define IMX_CS1_VIRT		0xea000000
+
+#define IMX_CS2_PHYS		0x13000000
+#define IMX_CS2_SIZE		0x01000000
+#define IMX_CS2_VIRT		0xeb000000
+
+#define IMX_CS3_PHYS		0x14000000
+#define IMX_CS3_SIZE		0x01000000
+#define IMX_CS3_VIRT		0xec000000
+
+#define IMX_CS4_PHYS		0x15000000
+#define IMX_CS4_SIZE		0x01000000
+#define IMX_CS4_VIRT		0xed000000
+
+#define IMX_CS5_PHYS		0x16000000
+#define IMX_CS5_SIZE		0x01000000
+#define IMX_CS5_VIRT		0xee000000
+
+#define IMX_FB_VIRT		0xF1000000
+#define IMX_FB_SIZE		(256*1024)
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x) ((x) | IMX_IO_BASE)
+
+#ifndef __ASSEMBLY__
+/*
+ * Handy routine to set GPIO functions
+ */
+extern void imx_gpio_mode( int gpio_mode );
+
+/* get frequencies in Hz */
+extern unsigned int imx_get_system_clk(void);
+extern unsigned int imx_get_mcu_clk(void);
+extern unsigned int imx_get_perclk1(void); /* UART[12], Timer[12], PWM */
+extern unsigned int imx_get_perclk2(void); /* LCD, SD, SPI[12]         */
+extern unsigned int imx_get_perclk3(void); /* SSI                      */
+extern unsigned int imx_get_hclk(void);    /* SDRAM, CSI, Memory Stick,*/
+                                           /* I2C, DMA                 */
+#endif
+
+#define MAXIRQNUM                       62
+#define MAXFIQNUM                       62
+#define MAXSWINUM                       62
+
+/*
+ * Use SDRAM for memory
+ */
+#define MEM_SIZE		0x01000000
+
+#ifdef CONFIG_ARCH_MX1ADS
+#include "mx1ads.h"
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/imx-dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/imx-dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/imx-dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,94 @@
+/*
+ *  linux/include/asm-arm/imxads/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/dma.h>
+
+#ifndef __ASM_ARCH_IMX_DMA_H
+#define __ASM_ARCH_IMX_DMA_H
+
+#define IMX_DMA_CHANNELS  11
+
+/*
+ * struct imx_dma_channel - i.MX specific DMA extension
+ * @name: name specified by DMA client
+ * @irq_handler: client callback for end of transfer
+ * @err_handler: client callback for error condition
+ * @data: clients context data for callbacks
+ * @dma_mode: direction of the transfer %DMA_MODE_READ or %DMA_MODE_WRITE
+ * @sg: pointer to the actual read/written chunk for scatter-gather emulation
+ * @sgbc: counter of processed bytes in the actual read/written chunk
+ * @resbytes: total residual number of bytes to transfer
+ *            (it can be lower or same as sum of SG mapped chunk sizes)
+ * @sgcount: number of chunks to be read/written
+ *
+ * Structure is used for IMX DMA processing. It would be probably good
+ * @struct dma_struct in the future for external interfacing and use
+ * @struct imx_dma_channel only as extension to it.
+ */
+
+struct imx_dma_channel {
+	const char *name;
+	void (*irq_handler) (int, void *);
+	void (*err_handler) (int, void *, int errcode);
+	void *data;
+	dmamode_t  dma_mode;
+	struct scatterlist *sg;
+	unsigned int sgbc;
+	unsigned int sgcount;
+	unsigned int resbytes;
+	int dma_num;
+};
+
+extern struct imx_dma_channel imx_dma_channels[IMX_DMA_CHANNELS];
+
+#define IMX_DMA_ERR_BURST     1
+#define IMX_DMA_ERR_REQUEST   2
+#define IMX_DMA_ERR_TRANSFER  4
+#define IMX_DMA_ERR_BUFFER    8
+
+/* The type to distinguish channel numbers parameter from ordinal int type */
+typedef int imx_dmach_t;
+
+int
+imx_dma_setup_single(imx_dmach_t dma_ch, dma_addr_t dma_address,
+		unsigned int dma_length, unsigned int dev_addr, dmamode_t dmamode);
+
+int
+imx_dma_setup_sg(imx_dmach_t dma_ch,
+		 struct scatterlist *sg, unsigned int sgcount, unsigned int dma_length,
+		 unsigned int dev_addr, dmamode_t dmamode);
+
+int
+imx_dma_setup_handlers(imx_dmach_t dma_ch,
+		void (*irq_handler) (int, void *),
+		void (*err_handler) (int, void *, int), void *data);
+
+void imx_dma_enable(imx_dmach_t dma_ch);
+
+void imx_dma_disable(imx_dmach_t dma_ch);
+
+int imx_dma_request(imx_dmach_t dma_ch, const char *name);
+
+void imx_dma_free(imx_dmach_t dma_ch);
+
+int imx_dma_request_by_prio(imx_dmach_t *pdma_ch, const char *name, imx_dma_prio prio);
+
+
+#endif	/* _ASM_ARCH_IMX_DMA_H */
Index: build_tree/linux/include/asm/arch-imx/imx-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/imx-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/imx-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,598 @@
+#ifndef _IMX_REGS_H
+#define _IMX_REGS_H
+/* ------------------------------------------------------------------------
+ *  Motorola IMX system registers
+ * ------------------------------------------------------------------------
+ *
+ */
+
+/*
+ *  Register BASEs, based on OFFSETs
+ *
+ */
+#define IMX_AIPI1_BASE             (0x00000 + IMX_IO_BASE)
+#define IMX_WDT_BASE               (0x01000 + IMX_IO_BASE)
+#define IMX_TIM1_BASE              (0x02000 + IMX_IO_BASE)
+#define IMX_TIM2_BASE              (0x03000 + IMX_IO_BASE)
+#define IMX_RTC_BASE               (0x04000 + IMX_IO_BASE)
+#define IMX_LCDC_BASE              (0x05000 + IMX_IO_BASE)
+#define IMX_UART1_BASE             (0x06000 + IMX_IO_BASE)
+#define IMX_UART2_BASE             (0x07000 + IMX_IO_BASE)
+#define IMX_PWM_BASE               (0x08000 + IMX_IO_BASE)
+#define IMX_DMAC_BASE              (0x09000 + IMX_IO_BASE)
+#define IMX_AIPI2_BASE             (0x10000 + IMX_IO_BASE)
+#define IMX_SIM_BASE               (0x11000 + IMX_IO_BASE)
+#define IMX_USBD_BASE              (0x12000 + IMX_IO_BASE)
+#define IMX_SPI1_BASE              (0x13000 + IMX_IO_BASE)
+#define IMX_MMC_BASE               (0x14000 + IMX_IO_BASE)
+#define IMX_ASP_BASE               (0x15000 + IMX_IO_BASE)
+#define IMX_BTA_BASE               (0x16000 + IMX_IO_BASE)
+#define IMX_I2C_BASE               (0x17000 + IMX_IO_BASE)
+#define IMX_SSI_BASE               (0x18000 + IMX_IO_BASE)
+#define IMX_SPI2_BASE              (0x19000 + IMX_IO_BASE)
+#define IMX_MSHC_BASE              (0x1A000 + IMX_IO_BASE)
+#define IMX_PLL_BASE               (0x1B000 + IMX_IO_BASE)
+#define IMX_GPIO_BASE              (0x1C000 + IMX_IO_BASE)
+#define IMX_EIM_BASE               (0x20000 + IMX_IO_BASE)
+#define IMX_SDRAMC_BASE            (0x21000 + IMX_IO_BASE)
+#define IMX_MMA_BASE               (0x22000 + IMX_IO_BASE)
+#define IMX_AITC_BASE              (0x23000 + IMX_IO_BASE)
+#define IMX_CSI_BASE               (0x24000 + IMX_IO_BASE)
+
+/* PLL registers */
+#define CSCR   __REG(IMX_PLL_BASE)        /* Clock Source Control Register */
+#define CSCR_SPLL_RESTART	(1<<22)
+#define CSCR_MPLL_RESTART	(1<<21)
+#define CSCR_SYSTEM_SEL		(1<<16)
+#define CSCR_BCLK_DIV		(0xf<<10)
+#define CSCR_MPU_PRESC		(1<<15)
+#define CSCR_SPEN		(1<<1)
+#define CSCR_MPEN		(1<<0)
+
+#define MPCTL0 __REG(IMX_PLL_BASE + 0x4)  /* MCU PLL Control Register 0 */
+#define MPCTL1 __REG(IMX_PLL_BASE + 0x8)  /* MCU PLL and System Clock Register 1 */
+#define SPCTL0 __REG(IMX_PLL_BASE + 0xc)  /* System PLL Control Register 0 */
+#define SPCTL1 __REG(IMX_PLL_BASE + 0x10) /* System PLL Control Register 1 */
+#define PCDR   __REG(IMX_PLL_BASE + 0x20) /* Peripheral Clock Divider Register */
+
+/*
+ *  GPIO Module and I/O Multiplexer
+ *  x = 0..3 for reg_A, reg_B, reg_C, reg_D
+ */
+#define DDIR(x)    __REG2(IMX_GPIO_BASE + 0x00, ((x) & 3) << 8)
+#define OCR1(x)    __REG2(IMX_GPIO_BASE + 0x04, ((x) & 3) << 8)
+#define OCR2(x)    __REG2(IMX_GPIO_BASE + 0x08, ((x) & 3) << 8)
+#define ICONFA1(x) __REG2(IMX_GPIO_BASE + 0x0c, ((x) & 3) << 8)
+#define ICONFA2(x) __REG2(IMX_GPIO_BASE + 0x10, ((x) & 3) << 8)
+#define ICONFB1(x) __REG2(IMX_GPIO_BASE + 0x14, ((x) & 3) << 8)
+#define ICONFB2(x) __REG2(IMX_GPIO_BASE + 0x18, ((x) & 3) << 8)
+#define DR(x)      __REG2(IMX_GPIO_BASE + 0x1c, ((x) & 3) << 8)
+#define GIUS(x)    __REG2(IMX_GPIO_BASE + 0x20, ((x) & 3) << 8)
+#define SSR(x)     __REG2(IMX_GPIO_BASE + 0x24, ((x) & 3) << 8)
+#define ICR1(x)    __REG2(IMX_GPIO_BASE + 0x28, ((x) & 3) << 8)
+#define ICR2(x)    __REG2(IMX_GPIO_BASE + 0x2c, ((x) & 3) << 8)
+#define IMR(x)     __REG2(IMX_GPIO_BASE + 0x30, ((x) & 3) << 8)
+#define ISR(x)     __REG2(IMX_GPIO_BASE + 0x34, ((x) & 3) << 8)
+#define GPR(x)     __REG2(IMX_GPIO_BASE + 0x38, ((x) & 3) << 8)
+#define SWR(x)     __REG2(IMX_GPIO_BASE + 0x3c, ((x) & 3) << 8)
+#define PUEN(x)    __REG2(IMX_GPIO_BASE + 0x40, ((x) & 3) << 8)
+
+#define GPIO_PIN_MASK 0x1f
+#define GPIO_PORT_MASK (0x3 << 5)
+
+#define GPIO_PORT_SHIFT 5
+#define GPIO_PORTA (0<<5)
+#define GPIO_PORTB (1<<5)
+#define GPIO_PORTC (2<<5)
+#define GPIO_PORTD (3<<5)
+
+#define GPIO_OUT   (1<<7)
+#define GPIO_IN    (0<<7)
+#define GPIO_PUEN  (1<<8)
+
+#define GPIO_PF    (0<<9)
+#define GPIO_AF    (1<<9)
+
+#define GPIO_OCR_SHIFT 10
+#define GPIO_OCR_MASK (3<<10)
+#define GPIO_AIN   (0<<10)
+#define GPIO_BIN   (1<<10)
+#define GPIO_CIN   (2<<10)
+#define GPIO_DR    (3<<10)
+
+#define GPIO_AOUT_SHIFT 12
+#define GPIO_AOUT_MASK (3<<12)
+#define GPIO_AOUT     (0<<12)
+#define GPIO_AOUT_ISR (1<<12)
+#define GPIO_AOUT_0   (2<<12)
+#define GPIO_AOUT_1   (3<<12)
+
+#define GPIO_BOUT_SHIFT 14
+#define GPIO_BOUT_MASK (3<<14)
+#define GPIO_BOUT      (0<<14)
+#define GPIO_BOUT_ISR  (1<<14)
+#define GPIO_BOUT_0    (2<<14)
+#define GPIO_BOUT_1    (3<<14)
+
+#define GPIO_GIUS      (1<<16)
+
+/* assignements for GPIO alternate/primary functions */
+
+/* FIXME: This list is not completed. The correct directions are
+ * missing on some (many) pins
+ */
+#define PA0_AIN_SPI2_CLK     ( GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 0 )
+#define PA0_AF_ETMTRACESYNC  ( GPIO_PORTA | GPIO_AF | 0 )
+#define PA1_AOUT_SPI2_RXD    ( GPIO_GIUS | GPIO_PORTA | GPIO_IN | 1 )
+#define PA1_PF_TIN           ( GPIO_PORTA | GPIO_PF | 1 )
+#define PA2_PF_PWM0          ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 2 )
+#define PA3_PF_CSI_MCLK      ( GPIO_PORTA | GPIO_PF | 3 )
+#define PA4_PF_CSI_D0        ( GPIO_PORTA | GPIO_PF | 4 )
+#define PA5_PF_CSI_D1        ( GPIO_PORTA | GPIO_PF | 5 )
+#define PA6_PF_CSI_D2        ( GPIO_PORTA | GPIO_PF | 6 )
+#define PA7_PF_CSI_D3        ( GPIO_PORTA | GPIO_PF | 7 )
+#define PA8_PF_CSI_D4        ( GPIO_PORTA | GPIO_PF | 8 )
+#define PA9_PF_CSI_D5        ( GPIO_PORTA | GPIO_PF | 9 )
+#define PA10_PF_CSI_D6       ( GPIO_PORTA | GPIO_PF | 10 )
+#define PA11_PF_CSI_D7       ( GPIO_PORTA | GPIO_PF | 11 )
+#define PA12_PF_CSI_VSYNC    ( GPIO_PORTA | GPIO_PF | 12 )
+#define PA13_PF_CSI_HSYNC    ( GPIO_PORTA | GPIO_PF | 13 )
+#define PA14_PF_CSI_PIXCLK   ( GPIO_PORTA | GPIO_PF | 14 )
+#define PA15_PF_I2C_SDA      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 15 )
+#define PA16_PF_I2C_SCL      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 16 )
+#define PA17_AF_ETMTRACEPKT4 ( GPIO_PORTA | GPIO_AF | 17 )
+#define PA17_AIN_SPI2_SS     ( GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 17 )
+#define PA18_AF_ETMTRACEPKT5 ( GPIO_PORTA | GPIO_AF | 18 )
+#define PA19_AF_ETMTRACEPKT6 ( GPIO_PORTA | GPIO_AF | 19 )
+#define PA20_AF_ETMTRACEPKT7 ( GPIO_PORTA | GPIO_AF | 20 )
+#define PA21_PF_A0           ( GPIO_PORTA | GPIO_PF | 21 )
+#define PA22_PF_CS4          ( GPIO_PORTA | GPIO_PF | 22 )
+#define PA23_PF_CS5          ( GPIO_PORTA | GPIO_PF | 23 )
+#define PA24_PF_A16          ( GPIO_PORTA | GPIO_PF | 24 )
+#define PA24_AF_ETMTRACEPKT0 ( GPIO_PORTA | GPIO_AF | 24 )
+#define PA25_PF_A17          ( GPIO_PORTA | GPIO_PF | 25 )
+#define PA25_AF_ETMTRACEPKT1 ( GPIO_PORTA | GPIO_AF | 25 )
+#define PA26_PF_A18          ( GPIO_PORTA | GPIO_PF | 26 )
+#define PA26_AF_ETMTRACEPKT2 ( GPIO_PORTA | GPIO_AF | 26 )
+#define PA27_PF_A19          ( GPIO_PORTA | GPIO_PF | 27 )
+#define PA27_AF_ETMTRACEPKT3 ( GPIO_PORTA | GPIO_AF | 27 )
+#define PA28_PF_A20          ( GPIO_PORTA | GPIO_PF | 28 )
+#define PA28_AF_ETMPIPESTAT0 ( GPIO_PORTA | GPIO_AF | 28 )
+#define PA29_PF_A21          ( GPIO_PORTA | GPIO_PF | 29 )
+#define PA29_AF_ETMPIPESTAT1 ( GPIO_PORTA | GPIO_AF | 29 )
+#define PA30_PF_A22          ( GPIO_PORTA | GPIO_PF | 30 )
+#define PA30_AF_ETMPIPESTAT2 ( GPIO_PORTA | GPIO_AF | 30 )
+#define PA31_PF_A23          ( GPIO_PORTA | GPIO_PF | 31 )
+#define PA31_AF_ETMTRACECLK  ( GPIO_PORTA | GPIO_AF | 31 )
+#define PB8_PF_SD_DAT0       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 8 )
+#define PB8_AF_MS_PIO        ( GPIO_PORTB | GPIO_AF | 8 )
+#define PB9_PF_SD_DAT1       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 9 )
+#define PB9_AF_MS_PI1        ( GPIO_PORTB | GPIO_AF | 9 )
+#define PB10_PF_SD_DAT2      ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 10 )
+#define PB10_AF_MS_SCLKI     ( GPIO_PORTB | GPIO_AF | 10 )
+#define PB11_PF_SD_DAT3      ( GPIO_PORTB | GPIO_PF | 11 )
+#define PB11_AF_MS_SDIO      ( GPIO_PORTB | GPIO_AF | 11 )
+#define PB12_PF_SD_CLK       ( GPIO_PORTB | GPIO_PF | 12 )
+#define PB12_AF_MS_SCLK0     ( GPIO_PORTB | GPIO_AF | 12 )
+#define PB13_PF_SD_CMD       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 13 )
+#define PB13_AF_MS_BS        ( GPIO_PORTB | GPIO_AF | 13 )
+#define PB14_AF_SSI_RXFS     ( GPIO_PORTB | GPIO_AF | 14 )
+#define PB15_AF_SSI_RXCLK    ( GPIO_PORTB | GPIO_AF | 15 )
+#define PB16_AF_SSI_RXDAT    ( GPIO_PORTB | GPIO_IN | GPIO_AF | 16 )
+#define PB17_AF_SSI_TXDAT    ( GPIO_PORTB | GPIO_OUT | GPIO_AF | 17 )
+#define PB18_AF_SSI_TXFS     ( GPIO_PORTB | GPIO_AF | 18 )
+#define PB19_AF_SSI_TXCLK    ( GPIO_PORTB | GPIO_AF | 19 )
+#define PB20_PF_USBD_AFE     ( GPIO_PORTB | GPIO_PF | 20 )
+#define PB21_PF_USBD_OE      ( GPIO_PORTB | GPIO_PF | 21 )
+#define PB22_PFUSBD_RCV      ( GPIO_PORTB | GPIO_PF | 22 )
+#define PB23_PF_USBD_SUSPND  ( GPIO_PORTB | GPIO_PF | 23 )
+#define PB24_PF_USBD_VP      ( GPIO_PORTB | GPIO_PF | 24 )
+#define PB25_PF_USBD_VM      ( GPIO_PORTB | GPIO_PF | 25 )
+#define PB26_PF_USBD_VPO     ( GPIO_PORTB | GPIO_PF | 26 )
+#define PB27_PF_USBD_VMO     ( GPIO_PORTB | GPIO_PF | 27 )
+#define PB28_PF_UART2_CTS    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 28 )
+#define PB29_PF_UART2_RTS    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 29 )
+#define PB30_PF_UART2_TXD    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 30 )
+#define PB31_PF_UART2_RXD    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 31 )
+#define PC3_PF_SSI_RXFS      ( GPIO_PORTC | GPIO_PF | 3 )
+#define PC4_PF_SSI_RXCLK     ( GPIO_PORTC | GPIO_PF | 4 )
+#define PC5_PF_SSI_RXDAT     ( GPIO_PORTC | GPIO_IN | GPIO_PF | 5 )
+#define PC6_PF_SSI_TXDAT     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 6 )
+#define PC7_PF_SSI_TXFS      ( GPIO_PORTC | GPIO_PF | 7 )
+#define PC8_PF_SSI_TXCLK     ( GPIO_PORTC | GPIO_PF | 8 )
+#define PC9_PF_UART1_CTS     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 9 )
+#define PC10_PF_UART1_RTS    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 10 )
+#define PC11_PF_UART1_TXD    ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 11 )
+#define PC12_PF_UART1_RXD    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 12 )
+#define PC13_PF_SPI1_SPI_RDY ( GPIO_PORTC | GPIO_PF | 13 )
+#define PC14_PF_SPI1_SCLK    ( GPIO_PORTC | GPIO_PF | 14 )
+#define PC15_PF_SPI1_SS      ( GPIO_PORTC | GPIO_PF | 15 )
+#define PC16_PF_SPI1_MISO    ( GPIO_PORTC | GPIO_PF | 16 )
+#define PC17_PF_SPI1_MOSI    ( GPIO_PORTC | GPIO_PF | 17 )
+#define PC24_BIN_UART3_RI    ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 24 )
+#define PC25_BIN_UART3_DSR   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 25 )
+#define PC26_AOUT_UART3_DTR  ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 26 )
+#define PC27_BIN_UART3_DCD   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 27 )
+#define PC28_BIN_UART3_CTS   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 28 )
+#define PC29_AOUT_UART3_RTS  ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 29 )
+#define PC30_BIN_UART3_TX    ( GPIO_GIUS | GPIO_PORTC | GPIO_BIN | 30 )
+#define PC31_AOUT_UART3_RX   ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 31)
+#define PD6_PF_LSCLK         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 6 )
+#define PD7_PF_REV           ( GPIO_PORTD | GPIO_PF | 7 )
+#define PD7_AF_UART2_DTR     ( GPIO_GIUS | GPIO_PORTD | GPIO_IN | GPIO_AF | 7 )
+#define PD7_AIN_SPI2_SCLK    ( GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 7 )
+#define PD8_PF_CLS           ( GPIO_PORTD | GPIO_PF | 8 )
+#define PD8_AF_UART2_DCD     ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 8 )
+#define PD8_AIN_SPI2_SS      ( GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 8 )
+#define PD9_PF_PS            ( GPIO_PORTD | GPIO_PF | 9 )
+#define PD9_AF_UART2_RI      ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 9 )
+#define PD9_AOUT_SPI2_RXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_IN | 9 )
+#define PD10_PF_SPL_SPR      ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 10 )
+#define PD10_AF_UART2_DSR    ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 10 )
+#define PD10_AIN_SPI2_TXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_OUT | 10 )
+#define PD11_PF_CONTRAST     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 11 )
+#define PD12_PF_ACD_OE       ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 12 )
+#define PD13_PF_LP_HSYNC     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 13 )
+#define PD14_PF_FLM_VSYNC    ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 14 )
+#define PD15_PF_LD0          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 15 )
+#define PD16_PF_LD1          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 16 )
+#define PD17_PF_LD2          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 17 )
+#define PD18_PF_LD3          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 18 )
+#define PD19_PF_LD4          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 19 )
+#define PD20_PF_LD5          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 20 )
+#define PD21_PF_LD6          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 21 )
+#define PD22_PF_LD7          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 22 )
+#define PD23_PF_LD8          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 23 )
+#define PD24_PF_LD9          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 24 )
+#define PD25_PF_LD10         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 25 )
+#define PD26_PF_LD11         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 26 )
+#define PD27_PF_LD12         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 27 )
+#define PD28_PF_LD13         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 28 )
+#define PD29_PF_LD14         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 29 )
+#define PD30_PF_LD15         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 30 )
+#define PD31_PF_TMR2OUT      ( GPIO_PORTD | GPIO_PF | 31 )
+#define PD31_BIN_SPI2_TXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_BIN | 31 )
+
+/*
+ * PWM controller
+ */
+#define PWMC	__REG(IMX_PWM_BASE + 0x00)	/* PWM Control Register		*/
+#define PWMS	__REG(IMX_PWM_BASE + 0x04)	/* PWM Sample Register		*/
+#define PWMP	__REG(IMX_PWM_BASE + 0x08)	/* PWM Period Register		*/
+#define PWMCNT	__REG(IMX_PWM_BASE + 0x0C)	/* PWM Counter Register		*/
+
+#define PWMC_HCTR		(0x01<<18)		/* Halfword FIFO Data Swapping	*/
+#define PWMC_BCTR		(0x01<<17)		/* Byte FIFO Data Swapping	*/
+#define PWMC_SWR		(0x01<<16)		/* Software Reset		*/
+#define PWMC_CLKSRC		(0x01<<15)		/* Clock Source			*/
+#define PWMC_PRESCALER(x)	(((x-1) & 0x7F) << 8)	/* PRESCALER			*/
+#define PWMC_IRQ		(0x01<< 7)		/* Interrupt Request		*/
+#define PWMC_IRQEN		(0x01<< 6)		/* Interrupt Request Enable	*/
+#define PWMC_FIFOAV		(0x01<< 5)		/* FIFO Available		*/
+#define PWMC_EN			(0x01<< 4)		/* Enables/Disables the PWM	*/
+#define PWMC_REPEAT(x)		(((x) & 0x03) << 2)	/* Sample Repeats		*/
+#define PWMC_CLKSEL(x)		(((x) & 0x03) << 0)	/* Clock Selection		*/
+
+#define PWMS_SAMPLE(x)		((x) & 0xFFFF)		/* Contains a two-sample word	*/
+#define PWMP_PERIOD(x)		((x) & 0xFFFF)		/* Represents the PWM's period	*/
+#define PWMC_COUNTER(x)		((x) & 0xFFFF)		/* Represents the current count value	*/
+
+/*
+ *  DMA Controller
+ */
+#define DCR     __REG(IMX_DMAC_BASE +0x00)	/* DMA Control Register */
+#define DISR    __REG(IMX_DMAC_BASE +0x04)	/* DMA Interrupt status Register */
+#define DIMR    __REG(IMX_DMAC_BASE +0x08)	/* DMA Interrupt mask Register */
+#define DBTOSR  __REG(IMX_DMAC_BASE +0x0c)	/* DMA Burst timeout status Register */
+#define DRTOSR  __REG(IMX_DMAC_BASE +0x10)	/* DMA Request timeout Register */
+#define DSESR   __REG(IMX_DMAC_BASE +0x14)	/* DMA Transfer Error Status Register */
+#define DBOSR   __REG(IMX_DMAC_BASE +0x18)	/* DMA Buffer overflow status Register */
+#define DBTOCR  __REG(IMX_DMAC_BASE +0x1c)	/* DMA Burst timeout control Register */
+#define WSRA    __REG(IMX_DMAC_BASE +0x40)	/* W-Size Register A */
+#define XSRA    __REG(IMX_DMAC_BASE +0x44)	/* X-Size Register A */
+#define YSRA    __REG(IMX_DMAC_BASE +0x48)	/* Y-Size Register A */
+#define WSRB    __REG(IMX_DMAC_BASE +0x4c)	/* W-Size Register B */
+#define XSRB    __REG(IMX_DMAC_BASE +0x50)	/* X-Size Register B */
+#define YSRB    __REG(IMX_DMAC_BASE +0x54)	/* Y-Size Register B */
+#define SAR(x)  __REG2( IMX_DMAC_BASE + 0x80, (x) << 6)	/* Source Address Registers */
+#define DAR(x)  __REG2( IMX_DMAC_BASE + 0x84, (x) << 6)	/* Destination Address Registers */
+#define CNTR(x) __REG2( IMX_DMAC_BASE + 0x88, (x) << 6)	/* Count Registers */
+#define CCR(x)  __REG2( IMX_DMAC_BASE + 0x8c, (x) << 6)	/*Control Registers */
+#define RSSR(x) __REG2( IMX_DMAC_BASE + 0x90, (x) << 6)	/* Request source select Registers */
+#define BLR(x)  __REG2( IMX_DMAC_BASE + 0x94, (x) << 6)	/* Burst length Registers */
+#define RTOR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Request timeout Registers */
+#define BUCR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Bus Utilization Registers */
+
+#define DCR_DRST           (1<<1)
+#define DCR_DEN            (1<<0)
+#define DBTOCR_EN          (1<<15)
+#define DBTOCR_CNT(x)      ((x) & 0x7fff )
+#define CNTR_CNT(x)        ((x) & 0xffffff )
+#define CCR_DMOD_LINEAR    ( 0x0 << 12 )
+#define CCR_DMOD_2D        ( 0x1 << 12 )
+#define CCR_DMOD_FIFO      ( 0x2 << 12 )
+#define CCR_DMOD_EOBFIFO   ( 0x3 << 12 )
+#define CCR_SMOD_LINEAR    ( 0x0 << 10 )
+#define CCR_SMOD_2D        ( 0x1 << 10 )
+#define CCR_SMOD_FIFO      ( 0x2 << 10 )
+#define CCR_SMOD_EOBFIFO   ( 0x3 << 10 )
+#define CCR_MDIR_DEC       (1<<9)
+#define CCR_MSEL_B         (1<<8)
+#define CCR_DSIZ_32        ( 0x0 << 6 )
+#define CCR_DSIZ_8         ( 0x1 << 6 )
+#define CCR_DSIZ_16        ( 0x2 << 6 )
+#define CCR_SSIZ_32        ( 0x0 << 4 )
+#define CCR_SSIZ_8         ( 0x1 << 4 )
+#define CCR_SSIZ_16        ( 0x2 << 4 )
+#define CCR_REN            (1<<3)
+#define CCR_RPT            (1<<2)
+#define CCR_FRC            (1<<1)
+#define CCR_CEN            (1<<0)
+#define RTOR_EN            (1<<15)
+#define RTOR_CLK           (1<<14)
+#define RTOR_PSC           (1<<13)
+
+/*
+ *  Interrupt controller
+ */
+
+#define IMX_INTCNTL        __REG(IMX_AITC_BASE+0x00)
+#define INTCNTL_FIAD       (1<<19)
+#define INTCNTL_NIAD       (1<<20)
+
+#define IMX_NIMASK         __REG(IMX_AITC_BASE+0x04)
+#define IMX_INTENNUM       __REG(IMX_AITC_BASE+0x08)
+#define IMX_INTDISNUM      __REG(IMX_AITC_BASE+0x0c)
+#define IMX_INTENABLEH     __REG(IMX_AITC_BASE+0x10)
+#define IMX_INTENABLEL     __REG(IMX_AITC_BASE+0x14)
+
+/*
+ *  General purpose timers
+ */
+#define IMX_TCTL(x)        __REG( 0x00 + (x))
+#define TCTL_SWR           (1<<15)
+#define TCTL_FRR           (1<<8)
+#define TCTL_CAP_RIS       (1<<6)
+#define TCTL_CAP_FAL       (2<<6)
+#define TCTL_CAP_RIS_FAL   (3<<6)
+#define TCTL_OM            (1<<5)
+#define TCTL_IRQEN         (1<<4)
+#define TCTL_CLK_PCLK1     (1<<1)
+#define TCTL_CLK_PCLK1_16  (2<<1)
+#define TCTL_CLK_TIN       (3<<1)
+#define TCTL_CLK_32        (4<<1)
+#define TCTL_TEN           (1<<0)
+
+#define IMX_TPRER(x)       __REG( 0x04 + (x))
+#define IMX_TCMP(x)        __REG( 0x08 + (x))
+#define IMX_TCR(x)         __REG( 0x0C + (x))
+#define IMX_TCN(x)         __REG( 0x10 + (x))
+#define IMX_TSTAT(x)       __REG( 0x14 + (x))
+#define TSTAT_CAPT         (1<<1)
+#define TSTAT_COMP         (1<<0)
+
+/*
+ * LCD Controller
+ */
+
+#define LCDC_SSA	__REG(IMX_LCDC_BASE+0x00)
+
+#define LCDC_SIZE	__REG(IMX_LCDC_BASE+0x04)
+#define SIZE_XMAX(x)	((((x) >> 4) & 0x3f) << 20)
+#define SIZE_YMAX(y)    ( (y) & 0x1ff )
+
+#define LCDC_VPW	__REG(IMX_LCDC_BASE+0x08)
+#define VPW_VPW(x)	( (x) & 0x3ff )
+
+#define LCDC_CPOS	__REG(IMX_LCDC_BASE+0x0C)
+#define CPOS_CC1        (1<<31)
+#define CPOS_CC0        (1<<30)
+#define CPOS_OP         (1<<28)
+#define CPOS_CXP(x)     (((x) & 3ff) << 16)
+#define CPOS_CYP(y)     ((y) & 0x1ff)
+
+#define LCDC_LCWHB	__REG(IMX_LCDC_BASE+0x10)
+#define LCWHB_BK_EN     (1<<31)
+#define LCWHB_CW(w)     (((w) & 0x1f) << 24)
+#define LCWHB_CH(h)     (((h) & 0x1f) << 16)
+#define LCWHB_BD(x)     ((x) & 0xff)
+
+#define LCDC_LCHCC	__REG(IMX_LCDC_BASE+0x14)
+#define LCHCC_CUR_COL_R(r) (((r) & 0x1f) << 11)
+#define LCHCC_CUR_COL_G(g) (((g) & 0x3f) << 5)
+#define LCHCC_CUR_COL_B(b) ((b) & 0x1f)
+
+#define LCDC_PCR	__REG(IMX_LCDC_BASE+0x18)
+#define PCR_TFT         (1<<31)
+#define PCR_COLOR       (1<<30)
+#define PCR_PBSIZ_1     (0<<28)
+#define PCR_PBSIZ_2     (1<<28)
+#define PCR_PBSIZ_4     (2<<28)
+#define PCR_PBSIZ_8     (3<<28)
+#define PCR_BPIX_1      (0<<25)
+#define PCR_BPIX_2      (1<<25)
+#define PCR_BPIX_4      (2<<25)
+#define PCR_BPIX_8      (3<<25)
+#define PCR_BPIX_12     (4<<25)
+#define PCR_BPIX_16     (4<<25)
+#define PCR_PIXPOL      (1<<24)
+#define PCR_FLMPOL      (1<<23)
+#define PCR_LPPOL       (1<<22)
+#define PCR_CLKPOL      (1<<21)
+#define PCR_OEPOL       (1<<20)
+#define PCR_SCLKIDLE    (1<<19)
+#define PCR_END_SEL     (1<<18)
+#define PCR_END_BYTE_SWAP (1<<17)
+#define PCR_REV_VS      (1<<16)
+#define PCR_ACD_SEL     (1<<15)
+#define PCR_ACD(x)      (((x) & 0x7f) << 8)
+#define PCR_SCLK_SEL    (1<<7)
+#define PCR_SHARP       (1<<6)
+#define PCR_PCD(x)      ((x) & 0x3f)
+
+#define LCDC_HCR	__REG(IMX_LCDC_BASE+0x1C)
+#define HCR_H_WIDTH(x)  (((x) & 0x3f) << 26)
+#define HCR_H_WAIT_1(x) (((x) & 0xff) << 8)
+#define HCR_H_WAIT_2(x) ((x) & 0xff)
+
+#define LCDC_VCR	__REG(IMX_LCDC_BASE+0x20)
+#define VCR_V_WIDTH(x)  (((x) & 0x3f) << 26)
+#define VCR_V_WAIT_1(x) (((x) & 0xff) << 8)
+#define VCR_V_WAIT_2(x) ((x) & 0xff)
+
+#define LCDC_POS	__REG(IMX_LCDC_BASE+0x24)
+#define POS_POS(x)      ((x) & 1f)
+
+#define LCDC_LSCR1	__REG(IMX_LCDC_BASE+0x28)
+#define LSCR1_PS_RISE_DELAY(x)    (((x) & 0x7f) << 26)
+#define LSCR1_CLS_RISE_DELAY(x)   (((x) & 0x3f) << 16)
+#define LSCR1_REV_TOGGLE_DELAY(x) (((x) & 0xf) << 8)
+#define LSCR1_GRAY2(x)            (((x) & 0xf) << 4)
+#define LSCR1_GRAY1(x)            (((x) & 0xf))
+
+#define LCDC_PWMR	__REG(IMX_LCDC_BASE+0x2C)
+#define PWMR_CLS(x)     (((x) & 0x1ff) << 16)
+#define PWMR_LDMSK      (1<<15)
+#define PWMR_SCR1       (1<<10)
+#define PWMR_SCR0       (1<<9)
+#define PWMR_CC_EN      (1<<8)
+#define PWMR_PW(x)      ((x) & 0xff)
+
+#define LCDC_DMACR	__REG(IMX_LCDC_BASE+0x30)
+#define DMACR_BURST     (1<<31)
+#define DMACR_HM(x)     (((x) & 0xf) << 16)
+#define DMACR_TM(x)     ((x) &0xf)
+
+#define LCDC_RMCR	__REG(IMX_LCDC_BASE+0x34)
+#define RMCR_LCDC_EN		(1<<1)
+#define RMCR_SELF_REF		(1<<0)
+
+#define LCDC_LCDICR	__REG(IMX_LCDC_BASE+0x38)
+#define LCDICR_INT_SYN  (1<<2)
+#define LCDICR_INT_CON  (1)
+
+#define LCDC_LCDISR	__REG(IMX_LCDC_BASE+0x40)
+#define LCDISR_UDR_ERR (1<<3)
+#define LCDISR_ERR_RES (1<<2)
+#define LCDISR_EOF     (1<<1)
+#define LCDISR_BOF     (1<<0)
+
+/*
+ *  UART Module. Takes the UART base address as argument
+ */
+#define URXD0(x) __REG( 0x0 + (x)) /* Receiver Register */
+#define URTX0(x) __REG( 0x40 + (x)) /* Transmitter Register */
+#define UCR1(x)  __REG( 0x80 + (x)) /* Control Register 1 */
+#define UCR2(x)  __REG( 0x84 + (x)) /* Control Register 2 */
+#define UCR3(x)  __REG( 0x88 + (x)) /* Control Register 3 */
+#define UCR4(x)  __REG( 0x8c + (x)) /* Control Register 4 */
+#define UFCR(x)  __REG( 0x90 + (x)) /* FIFO Control Register */
+#define USR1(x)  __REG( 0x94 + (x)) /* Status Register 1 */
+#define USR2(x)  __REG( 0x98 + (x)) /* Status Register 2 */
+#define UESC(x)  __REG( 0x9c + (x)) /* Escape Character Register */
+#define UTIM(x)  __REG( 0xa0 + (x)) /* Escape Timer Register */
+#define UBIR(x)  __REG( 0xa4 + (x)) /* BRM Incremental Register */
+#define UBMR(x)  __REG( 0xa8 + (x)) /* BRM Modulator Register */
+#define UBRC(x)  __REG( 0xac + (x)) /* Baud Rate Count Register */
+#define BIPR1(x) __REG( 0xb0 + (x)) /* Incremental Preset Register 1 */
+#define BIPR2(x) __REG( 0xb4 + (x)) /* Incremental Preset Register 2 */
+#define BIPR3(x) __REG( 0xb8 + (x)) /* Incremental Preset Register 3 */
+#define BIPR4(x) __REG( 0xbc + (x)) /* Incremental Preset Register 4 */
+#define BMPR1(x) __REG( 0xc0 + (x)) /* BRM Modulator Register 1 */
+#define BMPR2(x) __REG( 0xc4 + (x)) /* BRM Modulator Register 2 */
+#define BMPR3(x) __REG( 0xc8 + (x)) /* BRM Modulator Register 3 */
+#define BMPR4(x) __REG( 0xcc + (x)) /* BRM Modulator Register 4 */
+#define UTS(x)   __REG( 0xd0 + (x)) /* UART Test Register */
+
+/* UART Control Register Bit Fields.*/
+#define  URXD_CHARRDY    (1<<15)
+#define  URXD_ERR        (1<<14)
+#define  URXD_OVRRUN     (1<<13)
+#define  URXD_FRMERR     (1<<12)
+#define  URXD_BRK        (1<<11)
+#define  URXD_PRERR      (1<<10)
+#define  UCR1_ADEN       (1<<15) /* Auto dectect interrupt */
+#define  UCR1_ADBR       (1<<14) /* Auto detect baud rate */
+#define  UCR1_TRDYEN     (1<<13) /* Transmitter ready interrupt enable */
+#define  UCR1_IDEN       (1<<12) /* Idle condition interrupt */
+#define  UCR1_RRDYEN     (1<<9)	 /* Recv ready interrupt enable */
+#define  UCR1_RDMAEN     (1<<8)	 /* Recv ready DMA enable */
+#define  UCR1_IREN       (1<<7)	 /* Infrared interface enable */
+#define  UCR1_TXMPTYEN   (1<<6)	 /* Transimitter empty interrupt enable */
+#define  UCR1_RTSDEN     (1<<5)	 /* RTS delta interrupt enable */
+#define  UCR1_SNDBRK     (1<<4)	 /* Send break */
+#define  UCR1_TDMAEN     (1<<3)	 /* Transmitter ready DMA enable */
+#define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
+#define  UCR1_DOZE       (1<<1)	 /* Doze */
+#define  UCR1_UARTEN     (1<<0)	 /* UART enabled */
+#define  UCR2_ESCI     	 (1<<15) /* Escape seq interrupt enable */
+#define  UCR2_IRTS  	 (1<<14) /* Ignore RTS pin */
+#define  UCR2_CTSC  	 (1<<13) /* CTS pin control */
+#define  UCR2_CTS        (1<<12) /* Clear to send */
+#define  UCR2_ESCEN      (1<<11) /* Escape enable */
+#define  UCR2_PREN       (1<<8)  /* Parity enable */
+#define  UCR2_PROE       (1<<7)  /* Parity odd/even */
+#define  UCR2_STPB       (1<<6)	 /* Stop */
+#define  UCR2_WS         (1<<5)	 /* Word size */
+#define  UCR2_RTSEN      (1<<4)	 /* Request to send interrupt enable */
+#define  UCR2_TXEN       (1<<2)	 /* Transmitter enabled */
+#define  UCR2_RXEN       (1<<1)	 /* Receiver enabled */
+#define  UCR2_SRST 	 (1<<0)	 /* SW reset */
+#define  UCR3_DTREN 	 (1<<13) /* DTR interrupt enable */
+#define  UCR3_PARERREN   (1<<12) /* Parity enable */
+#define  UCR3_FRAERREN   (1<<11) /* Frame error interrupt enable */
+#define  UCR3_DSR        (1<<10) /* Data set ready */
+#define  UCR3_DCD        (1<<9)  /* Data carrier detect */
+#define  UCR3_RI         (1<<8)  /* Ring indicator */
+#define  UCR3_TIMEOUTEN  (1<<7)  /* Timeout interrupt enable */
+#define  UCR3_RXDSEN	 (1<<6)  /* Receive status interrupt enable */
+#define  UCR3_AIRINTEN   (1<<5)  /* Async IR wake interrupt enable */
+#define  UCR3_AWAKEN	 (1<<4)  /* Async wake interrupt enable */
+#define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
+#define  UCR3_REF30 	 (1<<2)  /* Ref Freq 30 MHz */
+#define  UCR3_INVT  	 (1<<1)  /* Inverted Infrared transmission */
+#define  UCR3_BPEN  	 (1<<0)  /* Preset registers enable */
+#define  UCR4_CTSTL_32   (32<<10) /* CTS trigger level (32 chars) */
+#define  UCR4_INVR  	 (1<<9)  /* Inverted infrared reception */
+#define  UCR4_ENIRI 	 (1<<8)  /* Serial infrared interrupt enable */
+#define  UCR4_WKEN  	 (1<<7)  /* Wake interrupt enable */
+#define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
+#define  UCR4_IRSC  	 (1<<5)  /* IR special case */
+#define  UCR4_TCEN  	 (1<<3)  /* Transmit complete interrupt enable */
+#define  UCR4_BKEN  	 (1<<2)  /* Break condition interrupt enable */
+#define  UCR4_OREN  	 (1<<1)  /* Receiver overrun interrupt enable */
+#define  UCR4_DREN  	 (1<<0)  /* Recv data ready interrupt enable */
+#define  UFCR_RXTL_SHF   0       /* Receiver trigger level shift */
+#define  UFCR_RFDIV      (7<<7)  /* Reference freq divider mask */
+#define  UFCR_TXTL_SHF   10      /* Transmitter trigger level shift */
+#define  USR1_PARITYERR  (1<<15) /* Parity error interrupt flag */
+#define  USR1_RTSS  	 (1<<14) /* RTS pin status */
+#define  USR1_TRDY  	 (1<<13) /* Transmitter ready interrupt/dma flag */
+#define  USR1_RTSD  	 (1<<12) /* RTS delta */
+#define  USR1_ESCF  	 (1<<11) /* Escape seq interrupt flag */
+#define  USR1_FRAMERR    (1<<10) /* Frame error interrupt flag */
+#define  USR1_RRDY       (1<<9)	 /* Receiver ready interrupt/dma flag */
+#define  USR1_TIMEOUT    (1<<7)	 /* Receive timeout interrupt status */
+#define  USR1_RXDS  	 (1<<6)	 /* Receiver idle interrupt flag */
+#define  USR1_AIRINT	 (1<<5)	 /* Async IR wake interrupt flag */
+#define  USR1_AWAKE 	 (1<<4)	 /* Aysnc wake interrupt flag */
+#define  USR2_ADET  	 (1<<15) /* Auto baud rate detect complete */
+#define  USR2_TXFE  	 (1<<14) /* Transmit buffer FIFO empty */
+#define  USR2_DTRF  	 (1<<13) /* DTR edge interrupt flag */
+#define  USR2_IDLE  	 (1<<12) /* Idle condition */
+#define  USR2_IRINT 	 (1<<8)	 /* Serial infrared interrupt flag */
+#define  USR2_WAKE  	 (1<<7)	 /* Wake */
+#define  USR2_RTSF  	 (1<<4)	 /* RTS edge interrupt flag */
+#define  USR2_TXDC  	 (1<<3)	 /* Transmitter complete */
+#define  USR2_BRCD  	 (1<<2)	 /* Break condition */
+#define  USR2_ORE        (1<<1)	 /* Overrun error */
+#define  USR2_RDR        (1<<0)	 /* Recv data ready */
+#define  UTS_FRCPERR	 (1<<13) /* Force parity error */
+#define  UTS_LOOP        (1<<12) /* Loop tx and rx */
+#define  UTS_TXEMPTY	 (1<<6)	 /* TxFIFO empty */
+#define  UTS_RXEMPTY	 (1<<5)	 /* RxFIFO empty */
+#define  UTS_TXFULL 	 (1<<4)	 /* TxFIFO full */
+#define  UTS_RXFULL 	 (1<<3)	 /* RxFIFO full */
+#define  UTS_SOFTRST	 (1<<0)	 /* Software reset */
+
+#endif				// _IMX_REGS_H
Index: build_tree/linux/include/asm/arch-imx/imx-uart.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/imx-uart.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/imx-uart.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,10 @@
+#ifndef ASMARM_ARCH_UART_H
+#define ASMARM_ARCH_UART_H
+
+#define IMXUART_HAVE_RTSCTS (1<<0)
+
+struct imxuart_platform_data {
+	unsigned int flags;
+};
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/imxfb.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/imxfb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/imxfb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ * This structure describes the machine which we are running on.
+ */
+struct imxfb_mach_info {
+	u_long		pixclock;
+
+	u_short		xres;
+	u_short		yres;
+
+	u_char		bpp;
+	u_char		hsync_len;
+	u_char		left_margin;
+	u_char		right_margin;
+
+	u_char		vsync_len;
+	u_char		upper_margin;
+	u_char		lower_margin;
+	u_char		sync;
+
+	u_int		cmap_greyscale:1,
+			cmap_inverse:1,
+			cmap_static:1,
+			unused:29;
+
+	u_int		pcr;
+	u_int		pwmr;
+	u_int		lscr1;
+	u_int		dmacr;
+
+	u_char * fixed_screen_cpu;
+	dma_addr_t fixed_screen_dma;
+
+	void (*lcd_power)(int);
+	void (*backlight_power)(int);
+};
+void set_imx_fb_info(struct imxfb_mach_info *hard_imx_fb_info);
Index: build_tree/linux/include/asm/arch-imx/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-arm/arch-imxads/io.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,116 @@
+/*
+ *  linux/include/asm-arm/arch-imxads/irqs.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ARM_IRQS_H__
+#define __ARM_IRQS_H__
+
+/* Use the imx definitions */
+#include <asm/hardware.h>
+
+/*
+ *  IMX Interrupt numbers
+ *
+ */
+#define INT_SOFTINT                 0
+#define CSI_INT                     6
+#define DSPA_MAC_INT                7
+#define DSPA_INT                    8
+#define COMP_INT                    9
+#define MSHC_XINT                   10
+#define GPIO_INT_PORTA              11
+#define GPIO_INT_PORTB              12
+#define GPIO_INT_PORTC              13
+#define LCDC_INT                    14
+#define SIM_INT                     15
+#define SIM_DATA_INT                16
+#define RTC_INT                     17
+#define RTC_SAMINT                  18
+#define UART2_MINT_PFERR            19
+#define UART2_MINT_RTS              20
+#define UART2_MINT_DTR              21
+#define UART2_MINT_UARTC            22
+#define UART2_MINT_TX               23
+#define UART2_MINT_RX               24
+#define UART1_MINT_PFERR            25
+#define UART1_MINT_RTS              26
+#define UART1_MINT_DTR              27
+#define UART1_MINT_UARTC            28
+#define UART1_MINT_TX               29
+#define UART1_MINT_RX               30
+#define VOICE_DAC_INT               31
+#define VOICE_ADC_INT               32
+#define PEN_DATA_INT                33
+#define PWM_INT                     34
+#define SDHC_INT                    35
+#define I2C_INT                     39
+#define CSPI_INT                    41
+#define SSI_TX_INT                  42
+#define SSI_TX_ERR_INT              43
+#define SSI_RX_INT                  44
+#define SSI_RX_ERR_INT              45
+#define TOUCH_INT                   46
+#define USBD_INT0                   47
+#define USBD_INT1                   48
+#define USBD_INT2                   49
+#define USBD_INT3                   50
+#define USBD_INT4                   51
+#define USBD_INT5                   52
+#define USBD_INT6                   53
+#define BTSYS_INT                   55
+#define BTTIM_INT                   56
+#define BTWUI_INT                   57
+#define TIM2_INT                    58
+#define TIM1_INT                    59
+#define DMA_ERR                     60
+#define DMA_INT                     61
+#define GPIO_INT_PORTD              62
+
+#define IMX_IRQS                         (64)
+
+/* note: the IMX has four gpio ports (A-D), but only
+ *       the following pins are connected to the outside
+ *       world:
+ *
+ * PORT A: bits 0-31
+ * PORT B: bits 8-31
+ * PORT C: bits 3-17
+ * PORT D: bits 6-31
+ *
+ * We map these interrupts straight on. As a result we have
+ * several holes in the interrupt mapping. We do this for two
+ * reasons:
+ *   - mapping the interrupts without holes would get
+ *     far more complicated
+ *   - Motorola could well decide to bring some processor
+ *     with more pins connected
+ */
+
+#define IRQ_GPIOA(x)  (IMX_IRQS + x)
+#define IRQ_GPIOB(x)  (IRQ_GPIOA(32) + x)
+#define IRQ_GPIOC(x)  (IRQ_GPIOB(32) + x)
+#define IRQ_GPIOD(x)  (IRQ_GPIOC(32) + x)
+
+/* decode irq number to use with IMR(x), ISR(x) and friends */
+#define IRQ_TO_REG(irq) ((irq - IMX_IRQS) >> 5)
+
+#define NR_IRQS (IRQ_GPIOD(32) + 1)
+#define IRQ_GPIO(x)
+#endif
Index: build_tree/linux/include/asm/arch-imx/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/arch-imx/memory.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MMU_H
+#define __ASM_ARCH_MMU_H
+
+#define PHYS_OFFSET	UL(0x08000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	(x - PAGE_OFFSET + PHYS_OFFSET)
+#define __bus_to_virt(x)	(x - PHYS_OFFSET + PAGE_OFFSET)
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/mmc.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/mmc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/mmc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,12 @@
+#ifndef ASMARM_ARCH_MMC_H
+#define ASMARM_ARCH_MMC_H
+
+#include <linux/mmc/protocol.h>
+
+struct imxmmc_platform_data {
+	int (*card_present)(void);
+};
+
+extern void imx_set_mmc_info(struct imxmmc_platform_data *info);
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/mx1ads.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/mx1ads.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/mx1ads.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ * linux/include/asm-arm/arch-imx/mx1ads.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_MX1ADS_H
+#define __ASM_ARCH_MX1ADS_H
+
+/* ------------------------------------------------------------------------ */
+/* Memory Map for the M9328MX1ADS (MX1ADS) Board                            */
+/* ------------------------------------------------------------------------ */
+
+#define MX1ADS_FLASH_PHYS		0x10000000
+#define MX1ADS_FLASH_SIZE		(16*1024*1024)
+
+#define IMX_FB_PHYS			(0x0C000000 - 0x40000)
+
+#define CLK32 32000
+
+#endif /* __ASM_ARCH_MX1ADS_H */
Index: build_tree/linux/include/asm/arch-imx/spi_imx.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/spi_imx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/spi_imx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,72 @@
+/*
+ * include/asm-arm/arch-imx/spi_imx.h
+ *
+ * Copyright (C) 2006 SWAPP
+ *	Andrea Paterniani <a.paterniani@swapp-eng.it>
+ *
+ * Initial version inspired by:
+ *	linux-2.6.17-rc3-mm1/include/asm-arm/arch-pxa/pxa2xx_spi.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef SPI_IMX_H_
+#define SPI_IMX_H_
+
+
+/*-------------------------------------------------------------------------*/
+/**
+ * struct spi_imx_master - device.platform_data for SPI controller devices.
+ * @num_chipselect: chipselects are used to distinguish individual
+ *	SPI slaves, and are numbered from zero to num_chipselects - 1.
+ *	each slave has a chipselect signal, but it's common that not
+ *	every chipselect is connected to a slave.
+ * @enable_dma: if true enables DMA driven transfers.
+*/
+struct spi_imx_master {
+	u8 num_chipselect;
+	u8 enable_dma:1;
+};
+/*-------------------------------------------------------------------------*/
+
+
+/*-------------------------------------------------------------------------*/
+/**
+ * struct spi_imx_chip - spi_board_info.controller_data for SPI
+ * slave devices, copied to spi_device.controller_data.
+ * @enable_loopback : used for test purpouse to internally connect RX and TX
+ *	sections.
+ * @enable_dma : enables dma transfer (provided that controller driver has
+ *	dma enabled too).
+ * @ins_ss_pulse : enable /SS pulse insertion between SPI burst.
+ * @bclk_wait : number of bclk waits between each bits_per_word SPI burst.
+ * @cs_control : function pointer to board-specific function to assert/deassert
+ *	I/O port to control HW generation of devices chip-select.
+*/
+struct spi_imx_chip {
+	u8	enable_loopback:1;
+	u8	enable_dma:1;
+	u8	ins_ss_pulse:1;
+	u16	bclk_wait:15;
+	void (*cs_control)(u32 control);
+};
+
+/* Chip-select state */
+#define SPI_CS_ASSERT			(1 << 0)
+#define SPI_CS_DEASSERT			(1 << 1)
+/*-------------------------------------------------------------------------*/
+
+
+#endif /* SPI_IMX_H_*/
Index: build_tree/linux/include/asm/arch-imx/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-imxads/system.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+static void
+arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void
+arch_reset(char mode)
+{
+	cpu_reset(0);
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ *  linux/include/asm-arm/imx/timex.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#define CLOCK_TICK_RATE		(16000000)
+
+#endif
Index: build_tree/linux/include/asm/arch-imx/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,71 @@
+/*
+ *  linux/include/asm-arm/arch-imxads/uncompress.h
+ *
+ *
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) Shane Nay (shane@minirl.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define UART(x) (*(volatile unsigned long *)(serial_port + (x)))
+
+#define UART1_BASE 0x206000
+#define UART2_BASE 0x207000
+#define USR2 0x98
+#define USR2_TXFE (1<<14)
+#define TXR  0x40
+#define UCR1 0x80
+#define UCR1_UARTEN 1
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void putc(int c)
+{
+	unsigned long serial_port;
+
+	do {
+		serial_port = UART1_BASE;
+		if ( UART(UCR1) & UCR1_UARTEN )
+			break;
+		serial_port = UART2_BASE;
+		if ( UART(UCR1) & UCR1_UARTEN )
+			break;
+		return;
+	} while(0);
+
+	while (!(UART(USR2) & USR2_TXFE))
+		barrier();
+
+	UART(TXR) = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-imx/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-imx/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-imx/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-imx/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
Index: build_tree/linux/include/asm/arch-integrator/bits.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/bits.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/bits.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,61 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Bit field definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __bits_h
+#define __bits_h                        1
+
+#define BIT0                            0x00000001
+#define BIT1                            0x00000002
+#define BIT2                            0x00000004
+#define BIT3                            0x00000008
+#define BIT4                            0x00000010
+#define BIT5                            0x00000020
+#define BIT6                            0x00000040
+#define BIT7                            0x00000080
+#define BIT8                            0x00000100
+#define BIT9                            0x00000200
+#define BIT10                           0x00000400
+#define BIT11                           0x00000800
+#define BIT12                           0x00001000
+#define BIT13                           0x00002000
+#define BIT14                           0x00004000
+#define BIT15                           0x00008000
+#define BIT16                           0x00010000
+#define BIT17                           0x00020000
+#define BIT18                           0x00040000
+#define BIT19                           0x00080000
+#define BIT20                           0x00100000
+#define BIT21                           0x00200000
+#define BIT22                           0x00400000
+#define BIT23                           0x00800000
+#define BIT24                           0x01000000
+#define BIT25                           0x02000000
+#define BIT26                           0x04000000
+#define BIT27                           0x08000000
+#define BIT28                           0x10000000
+#define BIT29                           0x20000000
+#define BIT30                           0x40000000
+#define BIT31                           0x80000000
+
+#endif
+
+/*         END */
Index: build_tree/linux/include/asm/arch-integrator/cm.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/cm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/cm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ * update the core module control register.
+ */
+void cm_control(u32, u32);
+
+#define CM_CTRL_LED			(1 << 0)
+#define CM_CTRL_nMBDET			(1 << 1)
+#define CM_CTRL_REMAP			(1 << 2)
+#define CM_CTRL_RESET			(1 << 3)
+
+/*
+ * Integrator/AP,PP2 specific
+ */
+#define CM_CTRL_HIGHVECTORS		(1 << 4)
+#define CM_CTRL_BIGENDIAN		(1 << 5)
+#define CM_CTRL_FASTBUS			(1 << 6)
+#define CM_CTRL_SYNC			(1 << 7)
+
+/*
+ * ARM926/946/966 Integrator/CP specific
+ */
+#define CM_CTRL_LCDBIASEN		(1 << 8)
+#define CM_CTRL_LCDBIASUP		(1 << 9)
+#define CM_CTRL_LCDBIASDN		(1 << 10)
+#define CM_CTRL_LCDMUXSEL_MASK		(7 << 11)
+#define CM_CTRL_LCDMUXSEL_GENLCD	(1 << 11)
+#define CM_CTRL_LCDMUXSEL_VGA_16BPP	(2 << 11)
+#define CM_CTRL_LCDMUXSEL_SHARPLCD	(3 << 11)
+#define CM_CTRL_LCDMUXSEL_VGA_8421BPP	(4 << 11)
+#define CM_CTRL_LCDEN0			(1 << 14)
+#define CM_CTRL_LCDEN1			(1 << 15)
+#define CM_CTRL_STATIC1			(1 << 16)
+#define CM_CTRL_STATIC2			(1 << 17)
+#define CM_CTRL_STATIC			(1 << 18)
+#define CM_CTRL_n24BITEN		(1 << 19)
+#define CM_CTRL_EBIWP			(1 << 20)
Index: build_tree/linux/include/asm/arch-integrator/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/* linux/include/asm-arm/arch-integrator/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x16000000	@ physical base address
+		movne	\rx, #0xf0000000	@ virtual base
+		addne	\rx, \rx, #0x16000000 >> 4
+		.endm
+
+#include <asm/hardware/debug-pl01x.S>
Index: build_tree/linux/include/asm/arch-integrator/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
Index: build_tree/linux/include/asm/arch-integrator/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,44 @@
+/*
+ * include/asm-arm/arch-integrator/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Integrator platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/arch/irqs.h>
+
+ 		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+/* FIXME: should not be using soo many LDRs here */
+		ldr	\base, =IO_ADDRESS(INTEGRATOR_IC_BASE)
+		mov	\irqnr, #IRQ_PIC_START
+		ldr	\irqstat, [\base, #IRQ_STATUS]		@ get masked status
+		ldr	\base, =IO_ADDRESS(INTEGRATOR_HDR_BASE)
+		teq	\irqstat, #0
+		ldreq	\irqstat, [\base, #(INTEGRATOR_HDR_IC_OFFSET+IRQ_STATUS)]
+		moveq	\irqnr, #IRQ_CIC_START
+
+1001:		tst	\irqstat, #15
+		bne	1002f
+		add	\irqnr, \irqnr, #4
+		movs	\irqstat, \irqstat, lsr #4
+		bne	1001b
+1002:		tst	\irqstat, #1
+		bne	1003f
+		add	\irqnr, \irqnr, #1
+		movs	\irqstat, \irqstat, lsr #1
+		bne	1002b
+1003:		/* EQ will be set if no irqs pending */
+		.endm
+
Index: build_tree/linux/include/asm/arch-integrator/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,48 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/hardware.h
+ *
+ *  This file contains the hardware definitions of the Integrator.
+ *
+ *  Copyright (C) 1999 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <asm/arch/platform.h>
+
+/*
+ * Where in virtual memory the IO devices (timers, system controllers
+ * and so on)
+ */
+#define IO_BASE			0xF0000000                 // VA of IO 
+#define IO_SIZE			0x0B000000                 // How much?
+#define IO_START		INTEGRATOR_HDR_BASE        // PA of IO
+
+#define PCIO_BASE		PCI_IO_VADDR
+#define PCIMEM_BASE		PCI_MEMORY_VADDR
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x) (((x) >> 4) + IO_BASE) 
+
+#define pcibios_assign_all_busses()	1
+
+#define PCIBIOS_MIN_IO		0x6000
+#define PCIBIOS_MIN_MEM 	0x00100000
+
+#endif
+
Index: build_tree/linux/include/asm/arch-integrator/impd1.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/impd1.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/impd1.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+#define IMPD1_OSC1	0x00
+#define IMPD1_OSC2	0x04
+#define IMPD1_LOCK	0x08
+#define IMPD1_LEDS	0x0c
+#define IMPD1_INT	0x10
+#define IMPD1_SW	0x14
+#define IMPD1_CTRL	0x18
+
+#define IMPD1_CTRL_DISP_LCD	(0 << 0)
+#define IMPD1_CTRL_DISP_VGA	(1 << 0)
+#define IMPD1_CTRL_DISP_LCD1	(2 << 0)
+#define IMPD1_CTRL_DISP_ENABLE	(1 << 2)
+#define IMPD1_CTRL_DISP_MASK	(7 << 0)
+
+struct device;
+
+void impd1_tweak_control(struct device *dev, u32 mask, u32 val);
+
Index: build_tree/linux/include/asm/arch-integrator/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/io.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffff
+
+/*
+ * WARNING: this has to mirror definitions in platform.h
+ */
+#define PCI_MEMORY_VADDR        0xe8000000
+#define PCI_CONFIG_VADDR        0xec000000
+#define PCI_V3_VADDR            0xed000000
+#define PCI_IO_VADDR            0xee000000
+
+#define __io(a)			((void __iomem *)(PCI_IO_VADDR + (a)))
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-integrator/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,82 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/irqs.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* 
+ *  Interrupt numbers
+ */
+#define IRQ_PIC_START			0
+#define IRQ_SOFTINT			0
+#define IRQ_UARTINT0			1
+#define IRQ_UARTINT1			2
+#define IRQ_KMIINT0			3
+#define IRQ_KMIINT1			4
+#define IRQ_TIMERINT0			5
+#define IRQ_TIMERINT1			6
+#define IRQ_TIMERINT2			7
+#define IRQ_RTCINT			8
+#define IRQ_AP_EXPINT0			9
+#define IRQ_AP_EXPINT1			10
+#define IRQ_AP_EXPINT2			11
+#define IRQ_AP_EXPINT3			12
+#define IRQ_AP_PCIINT0			13
+#define IRQ_AP_PCIINT1			14
+#define IRQ_AP_PCIINT2			15
+#define IRQ_AP_PCIINT3			16
+#define IRQ_AP_V3INT			17
+#define IRQ_AP_CPINT0			18
+#define IRQ_AP_CPINT1			19
+#define IRQ_AP_LBUSTIMEOUT 		20
+#define IRQ_AP_APCINT			21
+#define IRQ_CP_CLCDCINT			22
+#define IRQ_CP_MMCIINT0			23
+#define IRQ_CP_MMCIINT1			24
+#define IRQ_CP_AACIINT			25
+#define IRQ_CP_CPPLDINT			26
+#define IRQ_CP_ETHINT			27
+#define IRQ_CP_TSPENINT			28
+#define IRQ_PIC_END			31
+
+#define IRQ_CIC_START			32
+#define IRQ_CM_SOFTINT			32
+#define IRQ_CM_COMMRX			33
+#define IRQ_CM_COMMTX			34
+#define IRQ_CIC_END			34
+
+/*
+ * IntegratorCP only
+ */
+#define IRQ_SIC_START			35
+#define IRQ_SIC_CP_SOFTINT		35
+#define IRQ_SIC_CP_RI0			36
+#define IRQ_SIC_CP_RI1			37
+#define IRQ_SIC_CP_CARDIN		38
+#define IRQ_SIC_CP_LMINT0		39
+#define IRQ_SIC_CP_LMINT1		40
+#define IRQ_SIC_CP_LMINT2		41
+#define IRQ_SIC_CP_LMINT3		42
+#define IRQ_SIC_CP_LMINT4		43
+#define IRQ_SIC_CP_LMINT5		44
+#define IRQ_SIC_CP_LMINT6		45
+#define IRQ_SIC_CP_LMINT7		46
+#define IRQ_SIC_END			46
+
+#define NR_IRQS                         47
+
Index: build_tree/linux/include/asm/arch-integrator/lm.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/lm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/lm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+
+struct lm_device {
+	struct device		dev;
+	struct resource		resource;
+	unsigned int		irq;
+	unsigned int		id;
+};
+
+struct lm_driver {
+	struct device_driver	drv;
+	int			(*probe)(struct lm_device *);
+	void			(*remove)(struct lm_device *);
+	int			(*suspend)(struct lm_device *, pm_message_t);
+	int			(*resume)(struct lm_device *);
+};
+
+int lm_driver_register(struct lm_driver *drv);
+void lm_driver_unregister(struct lm_driver *drv);
+
+int lm_device_register(struct lm_device *dev);
+
+#define lm_get_drvdata(lm)	dev_get_drvdata(&(lm)->dev)
+#define lm_set_drvdata(lm,d)	dev_set_drvdata(&(lm)->dev, d)
Index: build_tree/linux/include/asm/arch-integrator/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/memory.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+#define BUS_OFFSET	UL(0x80000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	(x - PAGE_OFFSET + BUS_OFFSET)
+#define __bus_to_virt(x)	(x - BUS_OFFSET + PAGE_OFFSET)
+
+#endif
Index: build_tree/linux/include/asm/arch-integrator/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/platform.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,469 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/**************************************************************************
+ * * Copyright  ARM Limited 1998.  All rights reserved.
+ * ***********************************************************************/
+/* ************************************************************************
+ *
+ *   Integrator address map
+ *
+ * 	NOTE: This is a multi-hosted header file for use with uHAL and
+ * 	      supported debuggers.
+ *
+ * 	$Id: platform.s,v 1.32 2000/02/18 10:51:39 asims Exp $
+ *
+ * ***********************************************************************/
+
+#ifndef __address_h
+#define __address_h                     1
+
+/* ========================================================================
+ *  Integrator definitions
+ * ========================================================================
+ * ------------------------------------------------------------------------
+ *  Memory definitions
+ * ------------------------------------------------------------------------
+ *  Integrator memory map
+ *
+ */
+#define INTEGRATOR_BOOT_ROM_LO          0x00000000
+#define INTEGRATOR_BOOT_ROM_HI          0x20000000
+#define INTEGRATOR_BOOT_ROM_BASE        INTEGRATOR_BOOT_ROM_HI	 /*  Normal position */
+#define INTEGRATOR_BOOT_ROM_SIZE        SZ_512K
+
+/*
+ *  New Core Modules have different amounts of SSRAM, the amount of SSRAM
+ *  fitted can be found in HDR_STAT.
+ *
+ *  The symbol INTEGRATOR_SSRAM_SIZE is kept, however this now refers to
+ *  the minimum amount of SSRAM fitted on any core module.
+ *
+ *  New Core Modules also alias the SSRAM.
+ *
+ */
+#define INTEGRATOR_SSRAM_BASE           0x00000000
+#define INTEGRATOR_SSRAM_ALIAS_BASE     0x10800000
+#define INTEGRATOR_SSRAM_SIZE           SZ_256K
+
+#define INTEGRATOR_FLASH_BASE           0x24000000
+#define INTEGRATOR_FLASH_SIZE           SZ_32M
+
+#define INTEGRATOR_MBRD_SSRAM_BASE      0x28000000
+#define INTEGRATOR_MBRD_SSRAM_SIZE      SZ_512K
+
+/*
+ *  SDRAM is a SIMM therefore the size is not known.
+ *
+ */
+#define INTEGRATOR_SDRAM_BASE           0x00040000
+
+#define INTEGRATOR_SDRAM_ALIAS_BASE     0x80000000
+#define INTEGRATOR_HDR0_SDRAM_BASE      0x80000000
+#define INTEGRATOR_HDR1_SDRAM_BASE      0x90000000
+#define INTEGRATOR_HDR2_SDRAM_BASE      0xA0000000
+#define INTEGRATOR_HDR3_SDRAM_BASE      0xB0000000
+
+/*
+ *  Logic expansion modules
+ *
+ */
+#define INTEGRATOR_LOGIC_MODULES_BASE   0xC0000000
+#define INTEGRATOR_LOGIC_MODULE0_BASE   0xC0000000
+#define INTEGRATOR_LOGIC_MODULE1_BASE   0xD0000000
+#define INTEGRATOR_LOGIC_MODULE2_BASE   0xE0000000
+#define INTEGRATOR_LOGIC_MODULE3_BASE   0xF0000000
+
+/* ------------------------------------------------------------------------
+ *  Integrator header card registers
+ * ------------------------------------------------------------------------
+ *
+ */
+#define INTEGRATOR_HDR_ID_OFFSET        0x00
+#define INTEGRATOR_HDR_PROC_OFFSET      0x04
+#define INTEGRATOR_HDR_OSC_OFFSET       0x08
+#define INTEGRATOR_HDR_CTRL_OFFSET      0x0C
+#define INTEGRATOR_HDR_STAT_OFFSET      0x10
+#define INTEGRATOR_HDR_LOCK_OFFSET      0x14
+#define INTEGRATOR_HDR_SDRAM_OFFSET     0x20
+#define INTEGRATOR_HDR_INIT_OFFSET      0x24	 /*  CM9x6 */
+#define INTEGRATOR_HDR_IC_OFFSET        0x40
+#define INTEGRATOR_HDR_SPDBASE_OFFSET   0x100
+#define INTEGRATOR_HDR_SPDTOP_OFFSET    0x200
+
+#define INTEGRATOR_HDR_BASE             0x10000000
+#define INTEGRATOR_HDR_ID               (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_ID_OFFSET)
+#define INTEGRATOR_HDR_PROC             (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_PROC_OFFSET)
+#define INTEGRATOR_HDR_OSC              (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_OSC_OFFSET)
+#define INTEGRATOR_HDR_CTRL             (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_CTRL_OFFSET)
+#define INTEGRATOR_HDR_STAT             (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_STAT_OFFSET)
+#define INTEGRATOR_HDR_LOCK             (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_LOCK_OFFSET)
+#define INTEGRATOR_HDR_SDRAM            (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_SDRAM_OFFSET)
+#define INTEGRATOR_HDR_INIT             (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_INIT_OFFSET)
+#define INTEGRATOR_HDR_IC               (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_IC_OFFSET)
+#define INTEGRATOR_HDR_SPDBASE          (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_SPDBASE_OFFSET)
+#define INTEGRATOR_HDR_SPDTOP           (INTEGRATOR_HDR_BASE + INTEGRATOR_HDR_SPDTOP_OFFSET)
+
+#define INTEGRATOR_HDR_CTRL_LED         0x01
+#define INTEGRATOR_HDR_CTRL_MBRD_DETECH 0x02
+#define INTEGRATOR_HDR_CTRL_REMAP       0x04
+#define INTEGRATOR_HDR_CTRL_RESET       0x08
+#define INTEGRATOR_HDR_CTRL_HIGHVECTORS 0x10
+#define INTEGRATOR_HDR_CTRL_BIG_ENDIAN  0x20
+#define INTEGRATOR_HDR_CTRL_FASTBUS     0x40
+#define INTEGRATOR_HDR_CTRL_SYNC        0x80
+
+#define INTEGRATOR_HDR_OSC_CORE_10MHz   0x102
+#define INTEGRATOR_HDR_OSC_CORE_15MHz   0x107
+#define INTEGRATOR_HDR_OSC_CORE_20MHz   0x10C
+#define INTEGRATOR_HDR_OSC_CORE_25MHz   0x111
+#define INTEGRATOR_HDR_OSC_CORE_30MHz   0x116
+#define INTEGRATOR_HDR_OSC_CORE_35MHz   0x11B
+#define INTEGRATOR_HDR_OSC_CORE_40MHz   0x120
+#define INTEGRATOR_HDR_OSC_CORE_45MHz   0x125
+#define INTEGRATOR_HDR_OSC_CORE_50MHz   0x12A
+#define INTEGRATOR_HDR_OSC_CORE_55MHz   0x12F
+#define INTEGRATOR_HDR_OSC_CORE_60MHz   0x134
+#define INTEGRATOR_HDR_OSC_CORE_65MHz   0x139
+#define INTEGRATOR_HDR_OSC_CORE_70MHz   0x13E
+#define INTEGRATOR_HDR_OSC_CORE_75MHz   0x143
+#define INTEGRATOR_HDR_OSC_CORE_80MHz   0x148
+#define INTEGRATOR_HDR_OSC_CORE_85MHz   0x14D
+#define INTEGRATOR_HDR_OSC_CORE_90MHz   0x152
+#define INTEGRATOR_HDR_OSC_CORE_95MHz   0x157
+#define INTEGRATOR_HDR_OSC_CORE_100MHz  0x15C
+#define INTEGRATOR_HDR_OSC_CORE_105MHz  0x161
+#define INTEGRATOR_HDR_OSC_CORE_110MHz  0x166
+#define INTEGRATOR_HDR_OSC_CORE_115MHz  0x16B
+#define INTEGRATOR_HDR_OSC_CORE_120MHz  0x170
+#define INTEGRATOR_HDR_OSC_CORE_125MHz  0x175
+#define INTEGRATOR_HDR_OSC_CORE_130MHz  0x17A
+#define INTEGRATOR_HDR_OSC_CORE_135MHz  0x17F
+#define INTEGRATOR_HDR_OSC_CORE_140MHz  0x184
+#define INTEGRATOR_HDR_OSC_CORE_145MHz  0x189
+#define INTEGRATOR_HDR_OSC_CORE_150MHz  0x18E
+#define INTEGRATOR_HDR_OSC_CORE_155MHz  0x193
+#define INTEGRATOR_HDR_OSC_CORE_160MHz  0x198
+#define INTEGRATOR_HDR_OSC_CORE_MASK    0x7FF
+
+#define INTEGRATOR_HDR_OSC_MEM_10MHz    0x10C000
+#define INTEGRATOR_HDR_OSC_MEM_15MHz    0x116000
+#define INTEGRATOR_HDR_OSC_MEM_20MHz    0x120000
+#define INTEGRATOR_HDR_OSC_MEM_25MHz    0x12A000
+#define INTEGRATOR_HDR_OSC_MEM_30MHz    0x134000
+#define INTEGRATOR_HDR_OSC_MEM_33MHz    0x13A000
+#define INTEGRATOR_HDR_OSC_MEM_40MHz    0x148000
+#define INTEGRATOR_HDR_OSC_MEM_50MHz    0x15C000
+#define INTEGRATOR_HDR_OSC_MEM_60MHz    0x170000
+#define INTEGRATOR_HDR_OSC_MEM_66MHz    0x17C000
+#define INTEGRATOR_HDR_OSC_MEM_MASK     0x7FF000
+
+#define INTEGRATOR_HDR_OSC_BUS_MODE_CM7x0  0x0
+#define INTEGRATOR_HDR_OSC_BUS_MODE_CM9x0  0x0800000
+#define INTEGRATOR_HDR_OSC_BUS_MODE_CM9x6  0x1000000
+#define INTEGRATOR_HDR_OSC_BUS_MODE_CM10x00  0x1800000
+#define INTEGRATOR_HDR_OSC_BUS_MODE_MASK  0x1800000
+
+#define INTEGRATOR_HDR_SDRAM_SPD_OK     (1 << 5)
+
+
+/* ------------------------------------------------------------------------
+ *  Integrator system registers
+ * ------------------------------------------------------------------------
+ *
+ */
+
+/*
+ *  System Controller
+ *
+ */
+#define INTEGRATOR_SC_ID_OFFSET         0x00
+#define INTEGRATOR_SC_OSC_OFFSET        0x04
+#define INTEGRATOR_SC_CTRLS_OFFSET      0x08
+#define INTEGRATOR_SC_CTRLC_OFFSET      0x0C
+#define INTEGRATOR_SC_DEC_OFFSET        0x10
+#define INTEGRATOR_SC_ARB_OFFSET        0x14
+#define INTEGRATOR_SC_PCIENABLE_OFFSET  0x18
+#define INTEGRATOR_SC_LOCK_OFFSET       0x1C
+
+#define INTEGRATOR_SC_BASE              0x11000000
+#define INTEGRATOR_SC_ID                (INTEGRATOR_SC_BASE + INTEGRATOR_SC_ID_OFFSET)
+#define INTEGRATOR_SC_OSC               (INTEGRATOR_SC_BASE + INTEGRATOR_SC_OSC_OFFSET)
+#define INTEGRATOR_SC_CTRLS             (INTEGRATOR_SC_BASE + INTEGRATOR_SC_CTRLS_OFFSET)
+#define INTEGRATOR_SC_CTRLC             (INTEGRATOR_SC_BASE + INTEGRATOR_SC_CTRLC_OFFSET)
+#define INTEGRATOR_SC_DEC               (INTEGRATOR_SC_BASE + INTEGRATOR_SC_DEC_OFFSET)
+#define INTEGRATOR_SC_ARB               (INTEGRATOR_SC_BASE + INTEGRATOR_SC_ARB_OFFSET)
+#define INTEGRATOR_SC_PCIENABLE         (INTEGRATOR_SC_BASE + INTEGRATOR_SC_PCIENABLE_OFFSET)
+#define INTEGRATOR_SC_LOCK              (INTEGRATOR_SC_BASE + INTEGRATOR_SC_LOCK_OFFSET)
+
+#define INTEGRATOR_SC_OSC_SYS_10MHz     0x20
+#define INTEGRATOR_SC_OSC_SYS_15MHz     0x34
+#define INTEGRATOR_SC_OSC_SYS_20MHz     0x48
+#define INTEGRATOR_SC_OSC_SYS_25MHz     0x5C
+#define INTEGRATOR_SC_OSC_SYS_33MHz     0x7C
+#define INTEGRATOR_SC_OSC_SYS_MASK      0xFF
+
+#define INTEGRATOR_SC_OSC_PCI_25MHz     0x100
+#define INTEGRATOR_SC_OSC_PCI_33MHz     0x0
+#define INTEGRATOR_SC_OSC_PCI_MASK      0x100
+
+#define INTEGRATOR_SC_CTRL_SOFTRST      (1 << 0)
+#define INTEGRATOR_SC_CTRL_nFLVPPEN     (1 << 1)
+#define INTEGRATOR_SC_CTRL_nFLWP        (1 << 2)
+#define INTEGRATOR_SC_CTRL_URTS0        (1 << 4)
+#define INTEGRATOR_SC_CTRL_UDTR0        (1 << 5)
+#define INTEGRATOR_SC_CTRL_URTS1        (1 << 6)
+#define INTEGRATOR_SC_CTRL_UDTR1        (1 << 7)
+
+/*
+ *  External Bus Interface
+ *
+ */
+#define INTEGRATOR_EBI_BASE             0x12000000
+
+#define INTEGRATOR_EBI_CSR0_OFFSET      0x00
+#define INTEGRATOR_EBI_CSR1_OFFSET      0x04
+#define INTEGRATOR_EBI_CSR2_OFFSET      0x08
+#define INTEGRATOR_EBI_CSR3_OFFSET      0x0C
+#define INTEGRATOR_EBI_LOCK_OFFSET      0x20
+
+#define INTEGRATOR_EBI_CSR0             (INTEGRATOR_EBI_BASE + INTEGRATOR_EBI_CSR0_OFFSET)
+#define INTEGRATOR_EBI_CSR1             (INTEGRATOR_EBI_BASE + INTEGRATOR_EBI_CSR1_OFFSET)
+#define INTEGRATOR_EBI_CSR2             (INTEGRATOR_EBI_BASE + INTEGRATOR_EBI_CSR2_OFFSET)
+#define INTEGRATOR_EBI_CSR3             (INTEGRATOR_EBI_BASE + INTEGRATOR_EBI_CSR3_OFFSET)
+#define INTEGRATOR_EBI_LOCK             (INTEGRATOR_EBI_BASE + INTEGRATOR_EBI_LOCK_OFFSET)
+
+#define INTEGRATOR_EBI_8_BIT            0x00
+#define INTEGRATOR_EBI_16_BIT           0x01
+#define INTEGRATOR_EBI_32_BIT           0x02
+#define INTEGRATOR_EBI_WRITE_ENABLE     0x04
+#define INTEGRATOR_EBI_SYNC             0x08
+#define INTEGRATOR_EBI_WS_2             0x00
+#define INTEGRATOR_EBI_WS_3             0x10
+#define INTEGRATOR_EBI_WS_4             0x20
+#define INTEGRATOR_EBI_WS_5             0x30
+#define INTEGRATOR_EBI_WS_6             0x40
+#define INTEGRATOR_EBI_WS_7             0x50
+#define INTEGRATOR_EBI_WS_8             0x60
+#define INTEGRATOR_EBI_WS_9             0x70
+#define INTEGRATOR_EBI_WS_10            0x80
+#define INTEGRATOR_EBI_WS_11            0x90
+#define INTEGRATOR_EBI_WS_12            0xA0
+#define INTEGRATOR_EBI_WS_13            0xB0
+#define INTEGRATOR_EBI_WS_14            0xC0
+#define INTEGRATOR_EBI_WS_15            0xD0
+#define INTEGRATOR_EBI_WS_16            0xE0
+#define INTEGRATOR_EBI_WS_17            0xF0
+
+
+#define INTEGRATOR_CT_BASE              0x13000000	 /*  Counter/Timers */
+#define INTEGRATOR_IC_BASE              0x14000000	 /*  Interrupt Controller */
+#define INTEGRATOR_RTC_BASE             0x15000000	 /*  Real Time Clock */
+#define INTEGRATOR_UART0_BASE           0x16000000	 /*  UART 0 */
+#define INTEGRATOR_UART1_BASE           0x17000000	 /*  UART 1 */
+#define INTEGRATOR_KBD_BASE             0x18000000	 /*  Keyboard */
+#define INTEGRATOR_MOUSE_BASE           0x19000000	 /*  Mouse */
+
+/*
+ *  LED's & Switches
+ *
+ */
+#define INTEGRATOR_DBG_ALPHA_OFFSET     0x00
+#define INTEGRATOR_DBG_LEDS_OFFSET      0x04
+#define INTEGRATOR_DBG_SWITCH_OFFSET    0x08
+
+#define INTEGRATOR_DBG_BASE             0x1A000000
+#define INTEGRATOR_DBG_ALPHA            (INTEGRATOR_DBG_BASE + INTEGRATOR_DBG_ALPHA_OFFSET)
+#define INTEGRATOR_DBG_LEDS             (INTEGRATOR_DBG_BASE + INTEGRATOR_DBG_LEDS_OFFSET)
+#define INTEGRATOR_DBG_SWITCH           (INTEGRATOR_DBG_BASE + INTEGRATOR_DBG_SWITCH_OFFSET)
+
+
+#if defined(CONFIG_ARCH_INTEGRATOR_AP)
+#define INTEGRATOR_GPIO_BASE            0x1B000000	 /*  GPIO */
+#elif defined(CONFIG_ARCH_INTEGRATOR_CP)
+#define INTEGRATOR_GPIO_BASE            0xC9000000	 /*  GPIO */
+#endif
+
+/* ------------------------------------------------------------------------
+ *  KMI keyboard/mouse definitions
+ * ------------------------------------------------------------------------
+ */
+/* PS2 Keyboard interface */
+#define KMI0_BASE                       INTEGRATOR_KBD_BASE
+
+/* PS2 Mouse interface */
+#define KMI1_BASE                       INTEGRATOR_MOUSE_BASE
+
+/* KMI definitions are now in include/asm-arm/hardware/amba_kmi.h -- rmk */
+
+/* ------------------------------------------------------------------------
+ *  Where in the memory map does PCI live?
+ * ------------------------------------------------------------------------
+ *  This represents a fairly liberal usage of address space.  Even though
+ *  the V3 only has two windows (therefore we need to map stuff on the fly),
+ *  we maintain the same addresses, even if they're not mapped.
+ *
+ */
+#define PHYS_PCI_MEM_BASE               0x40000000   /* 512M to xxx */
+/*  unused 256M from A0000000-AFFFFFFF might be used for I2O ???
+ */
+#define PHYS_PCI_IO_BASE                0x60000000   /* 16M to xxx */
+/*  unused (128-16)M from B1000000-B7FFFFFF
+ */
+#define PHYS_PCI_CONFIG_BASE            0x61000000   /* 16M to xxx */
+/*  unused ((128-16)M - 64K) from XXX
+ */
+#define PHYS_PCI_V3_BASE                0x62000000
+
+#define PCI_DRAMSIZE                    INTEGRATOR_SSRAM_SIZE
+
+/* 'export' these to UHAL */
+#define UHAL_PCI_IO                     PCI_IO_BASE
+#define UHAL_PCI_MEM                    PCI_MEM_BASE
+#define UHAL_PCI_ALLOC_IO_BASE          0x00004000
+#define UHAL_PCI_ALLOC_MEM_BASE         PCI_MEM_BASE
+#define UHAL_PCI_MAX_SLOT               20
+
+/* ========================================================================
+ *  Start of uHAL definitions
+ * ========================================================================
+ */
+
+/* ------------------------------------------------------------------------
+ *  Integrator Interrupt Controllers
+ * ------------------------------------------------------------------------
+ *
+ *  Offsets from interrupt controller base
+ *
+ *  System Controller interrupt controller base is
+ *
+ * 	INTEGRATOR_IC_BASE + (header_number << 6)
+ *
+ *  Core Module interrupt controller base is
+ *
+ * 	INTEGRATOR_HDR_IC
+ *
+ */
+#define IRQ_STATUS                      0
+#define IRQ_RAW_STATUS                  0x04
+#define IRQ_ENABLE                      0x08
+#define IRQ_ENABLE_SET                  0x08
+#define IRQ_ENABLE_CLEAR                0x0C
+
+#define INT_SOFT_SET                    0x10
+#define INT_SOFT_CLEAR                  0x14
+
+#define FIQ_STATUS                      0x20
+#define FIQ_RAW_STATUS                  0x24
+#define FIQ_ENABLE                      0x28
+#define FIQ_ENABLE_SET                  0x28
+#define FIQ_ENABLE_CLEAR                0x2C
+
+
+/* ------------------------------------------------------------------------
+ *  Interrupts
+ * ------------------------------------------------------------------------
+ *
+ *
+ *  Each Core Module has two interrupts controllers, one on the core module
+ *  itself and one in the system controller on the motherboard.  The
+ *  READ_INT macro in target.s reads both interrupt controllers and returns
+ *  a 32 bit bitmask, bits 0 to 23 are interrupts from the system controller
+ *  and bits 24 to 31 are from the core module.
+ *
+ *  The following definitions relate to the bitmask returned by READ_INT.
+ *
+ */
+
+/* ------------------------------------------------------------------------
+ *  LED's - The header LED is not accessible via the uHAL API
+ * ------------------------------------------------------------------------
+ *
+ */
+#define GREEN_LED                       0x01
+#define YELLOW_LED                      0x02
+#define RED_LED                         0x04
+#define GREEN_LED_2                     0x08
+#define ALL_LEDS                        0x0F
+
+#define LED_BANK                        INTEGRATOR_DBG_LEDS
+
+/*
+ *  Memory definitions - run uHAL out of SSRAM.
+ *
+ */
+#define uHAL_MEMORY_SIZE                INTEGRATOR_SSRAM_SIZE
+
+/*
+ *  Application Flash
+ *
+ */
+#define FLASH_BASE                      INTEGRATOR_FLASH_BASE
+#define FLASH_SIZE                      INTEGRATOR_FLASH_SIZE
+#define FLASH_END                       (FLASH_BASE + FLASH_SIZE - 1)
+#define FLASH_BLOCK_SIZE                SZ_128K
+
+/*
+ *  Boot Flash
+ *
+ */
+#define EPROM_BASE                      INTEGRATOR_BOOT_ROM_HI
+#define EPROM_SIZE                      INTEGRATOR_BOOT_ROM_SIZE
+#define EPROM_END                       (EPROM_BASE + EPROM_SIZE - 1)
+
+/*
+ *  Clean base - dummy
+ *
+ */
+#define CLEAN_BASE                      EPROM_BASE
+
+/*
+ *  Timer definitions
+ *
+ *  Only use timer 1 & 2
+ *  (both run at 24MHz and will need the clock divider set to 16).
+ *
+ *  Timer 0 runs at bus frequency and therefore could vary and currently
+ *  uHAL can't handle that.
+ *
+ */
+
+#define INTEGRATOR_TIMER0_BASE          INTEGRATOR_CT_BASE
+#define INTEGRATOR_TIMER1_BASE          (INTEGRATOR_CT_BASE + 0x100)
+#define INTEGRATOR_TIMER2_BASE          (INTEGRATOR_CT_BASE + 0x200)
+
+#define MAX_TIMER                       2
+#define MAX_PERIOD                      699050
+#define TICKS_PER_uSEC                  24
+
+/*
+ *  These are useconds NOT ticks.
+ *
+ */
+#define mSEC_1                          1000
+#define mSEC_5                          (mSEC_1 * 5)
+#define mSEC_10                         (mSEC_1 * 10)
+#define mSEC_25                         (mSEC_1 * 25)
+#define SEC_1                           (mSEC_1 * 1000)
+
+#define INTEGRATOR_CSR_BASE             0x10000000
+#define INTEGRATOR_CSR_SIZE             0x10000000
+
+#endif
+
+/* 	END */
Index: build_tree/linux/include/asm/arch-integrator/smp.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/smp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/smp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#define hard_smp_processor_id()				\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+extern void secondary_scan_irqs(void);
+
+#endif
Index: build_tree/linux/include/asm/arch-integrator/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/system.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/cm.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	/*
+	 * To reset, we hit the on-board reset register
+	 * in the system FPGA
+	 */
+	cm_control(CM_CTRL_RESET, CM_CTRL_RESET);
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-integrator/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/timex.h
+ *
+ *  Integrator architecture timex specifications
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * ??
+ */
+#define CLOCK_TICK_RATE		(50000000 / 16)
Index: build_tree/linux/include/asm/arch-integrator/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,50 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/uncompress.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define AMBA_UART_DR	(*(volatile unsigned char *)0x16000000)
+#define AMBA_UART_LCRH	(*(volatile unsigned char *)0x16000008)
+#define AMBA_UART_LCRM	(*(volatile unsigned char *)0x1600000c)
+#define AMBA_UART_LCRL	(*(volatile unsigned char *)0x16000010)
+#define AMBA_UART_CR	(*(volatile unsigned char *)0x16000014)
+#define AMBA_UART_FR	(*(volatile unsigned char *)0x16000018)
+
+/*
+ * This does not append a newline
+ */
+static void putc(int c)
+{
+	while (AMBA_UART_FR & (1 << 5))
+		barrier();
+
+	AMBA_UART_DR = c;
+}
+
+static inline void flush(void)
+{
+	while (AMBA_UART_FR & (1 << 3))
+		barrier();
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-integrator/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-integrator/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-integrator/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
Index: build_tree/linux/include/asm/arch-iop13xx/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-iop13xx/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * Copyright (C) 1994-1999 Russell King
+ * Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+	.macro	addruart, rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1			@ mmu enabled?
+	moveq	\rx, #0xff000000	@ physical
+	orreq	\rx, \rx, #0x00d80000
+	movne	\rx, #0xfe000000	@ virtual
+	orrne	\rx, \rx, #0x00e80000
+	orr	\rx, \rx, #0x00002300
+	orr	\rx, \rx, #0x00000040
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-iop13xx/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,3 @@
+#ifndef _IOP13XX_DMA_H
+#define _IOP13XX_DMA_H_
+#endif
Index: build_tree/linux/include/asm/arch-iop13xx/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,45 @@
+/*
+ * iop13xx low level irq macros
+ * Copyright (c) 2005-2006, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+	.macro  disable_fiq
+	.endm
+
+	.macro get_irqnr_preamble, base, tmp
+	mrc	p15, 0, \tmp, c15, c1, 0
+	orr	\tmp, \tmp, #(1 << 6)
+	mcr	p15, 0, \tmp, c15, c1, 0	@ Enable cp6 access
+	.endm
+
+	/*
+	 * Note: a 1-cycle window exists where iintvec will return the value
+	 * of iintbase, so we explicitly check for "bad zeros"
+	 */
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	mrc	p6, 0, \irqnr, c3, c2, 0  	@ Read IINTVEC
+	cmp	\irqnr, #0
+	mrceq	p6, 0, \irqnr, c3, c2, 0  	@ Re-read on potentially bad zero
+	adds	\irqstat, \irqnr, #1	  	@ Check for 0xffffffff
+	movne	\irqnr, \irqnr, lsr #2	  	@ Convert to irqnr
+	.endm
+
+	.macro arch_ret_to_user, tmp1, tmp2
+	mrc	p15, 0, \tmp1, c15, c1, 0
+	ands	\tmp2, \tmp1, #(1 << 6)
+	bicne	\tmp1, \tmp1, #(1 << 6)
+	mcrne	p15, 0, \tmp1, c15, c1, 0	@ Disable cp6 access
+	.endm
Index: build_tree/linux/include/asm/arch-iop13xx/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+#include <asm/types.h>
+
+#define pcibios_assign_all_busses() 1
+
+#ifndef __ASSEMBLY__
+extern unsigned long iop13xx_pcibios_min_io;
+extern unsigned long iop13xx_pcibios_min_mem;
+extern u16 iop13xx_dev_id(void);
+extern void iop13xx_set_atu_mmr_bases(void);
+#endif
+
+#define PCIBIOS_MIN_IO      (iop13xx_pcibios_min_io)
+#define PCIBIOS_MIN_MEM     (iop13xx_pcibios_min_mem)
+
+/*
+ * Generic chipset bits
+ *
+ */
+#include "iop13xx.h"
+
+/*
+ * Board specific bits
+ */
+#include "iq81340.h"
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-iop13xx/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ * iop13xx custom ioremap implementation
+ * Copyright (c) 2005-2006, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a) __iop13xx_io(a)
+#define __mem_pci(a) (a)
+#define __mem_isa(a) (a)
+
+extern void __iomem * __iop13xx_io(unsigned long io_addr);
+extern void __iomem * __ioremap(unsigned long, size_t, unsigned long);
+extern void __iomem *__iop13xx_ioremap(unsigned long cookie, size_t size,
+	unsigned long flags);
+extern void __iop13xx_iounmap(void __iomem *addr);
+
+extern u32 iop13xx_atue_mem_base;
+extern u32 iop13xx_atux_mem_base;
+extern size_t iop13xx_atue_mem_size;
+extern size_t iop13xx_atux_mem_size;
+
+#define __arch_ioremap(a, s, f) __iop13xx_ioremap(a, s, f)
+#define __arch_iounmap(a)	 __iop13xx_iounmap(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-iop13xx/iop13xx.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/iop13xx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/iop13xx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,454 @@
+#ifndef _IOP13XX_HW_H_
+#define _IOP13XX_HW_H_
+
+#ifndef __ASSEMBLY__
+/* The ATU offsets can change based on the strapping */
+extern u32 iop13xx_atux_pmmr_offset;
+extern u32 iop13xx_atue_pmmr_offset;
+void iop13xx_init_irq(void);
+void iop13xx_map_io(void);
+void iop13xx_platform_init(void);
+void iop13xx_init_irq(void);
+
+/* CPUID CP6 R0 Page 0 */
+static inline int iop13xx_cpu_id(void)
+{
+	int id;
+	asm volatile("mrc p6, 0, %0, c0, c0, 0":"=r" (id));
+	return id;
+}
+
+#endif
+
+/*
+ * IOP13XX I/O and Mem space regions for PCI autoconfiguration
+ */
+#define IOP13XX_MAX_RAM_SIZE    0x80000000UL  /* 2GB */
+#define IOP13XX_PCI_OFFSET	 IOP13XX_MAX_RAM_SIZE
+
+/* PCI MAP
+ * 0x0000.0000 - 0x8000.0000           1:1 mapping with Physical RAM
+ * 0x8000.0000 - 0x8800.0000           PCIX/PCIE memory window (128MB)
+*/
+#define IOP13XX_PCIX_IO_WINDOW_SIZE   0x10000UL
+#define IOP13XX_PCIX_LOWER_IO_PA      0xfffb0000UL
+#define IOP13XX_PCIX_LOWER_IO_VA      0xfec60000UL
+#define IOP13XX_PCIX_LOWER_IO_BA      0x0fff0000UL
+#define IOP13XX_PCIX_UPPER_IO_PA      (IOP13XX_PCIX_LOWER_IO_PA +\
+				       IOP13XX_PCIX_IO_WINDOW_SIZE - 1)
+#define IOP13XX_PCIX_UPPER_IO_VA      (IOP13XX_PCIX_LOWER_IO_VA +\
+				       IOP13XX_PCIX_IO_WINDOW_SIZE - 1)
+#define IOP13XX_PCIX_IO_OFFSET        (IOP13XX_PCIX_LOWER_IO_VA -\
+				       IOP13XX_PCIX_LOWER_IO_BA)
+#define IOP13XX_PCIX_IO_PHYS_TO_VIRT(addr) (u32) ((u32) addr -\
+					   (IOP13XX_PCIX_LOWER_IO_PA\
+					   - IOP13XX_PCIX_LOWER_IO_VA))
+
+#define IOP13XX_PCIX_MEM_PHYS_OFFSET  0x100000000ULL
+#define IOP13XX_PCIX_MEM_WINDOW_SIZE  0x3a000000UL
+#define IOP13XX_PCIX_LOWER_MEM_BA     (PHYS_OFFSET + IOP13XX_PCI_OFFSET)
+#define IOP13XX_PCIX_LOWER_MEM_PA     (IOP13XX_PCIX_MEM_PHYS_OFFSET +\
+				       IOP13XX_PCIX_LOWER_MEM_BA)
+#define IOP13XX_PCIX_UPPER_MEM_PA     (IOP13XX_PCIX_LOWER_MEM_PA +\
+				       IOP13XX_PCIX_MEM_WINDOW_SIZE - 1)
+#define IOP13XX_PCIX_UPPER_MEM_BA     (IOP13XX_PCIX_LOWER_MEM_BA +\
+				       IOP13XX_PCIX_MEM_WINDOW_SIZE - 1)
+
+#define IOP13XX_PCIX_MEM_COOKIE        0x80000000UL
+#define IOP13XX_PCIX_LOWER_MEM_RA      IOP13XX_PCIX_MEM_COOKIE
+#define IOP13XX_PCIX_UPPER_MEM_RA      (IOP13XX_PCIX_LOWER_MEM_RA +\
+					IOP13XX_PCIX_MEM_WINDOW_SIZE - 1)
+#define IOP13XX_PCIX_MEM_OFFSET        (IOP13XX_PCIX_MEM_COOKIE -\
+					IOP13XX_PCIX_LOWER_MEM_BA)
+
+/* PCI-E ranges */
+#define IOP13XX_PCIE_IO_WINDOW_SIZE   	 0x10000UL
+#define IOP13XX_PCIE_LOWER_IO_PA      	 0xfffd0000UL
+#define IOP13XX_PCIE_LOWER_IO_VA      	 0xfed70000UL
+#define IOP13XX_PCIE_LOWER_IO_BA      	 0x0fff0000UL
+#define IOP13XX_PCIE_UPPER_IO_PA      	 (IOP13XX_PCIE_LOWER_IO_PA +\
+					 IOP13XX_PCIE_IO_WINDOW_SIZE - 1)
+#define IOP13XX_PCIE_UPPER_IO_VA      	 (IOP13XX_PCIE_LOWER_IO_VA +\
+					 IOP13XX_PCIE_IO_WINDOW_SIZE - 1)
+#define IOP13XX_PCIE_UPPER_IO_BA      	 (IOP13XX_PCIE_LOWER_IO_BA +\
+					 IOP13XX_PCIE_IO_WINDOW_SIZE - 1)
+#define IOP13XX_PCIE_IO_OFFSET        	 (IOP13XX_PCIE_LOWER_IO_VA -\
+					 IOP13XX_PCIE_LOWER_IO_BA)
+#define IOP13XX_PCIE_IO_PHYS_TO_VIRT(addr) (u32) ((u32) addr -\
+					   (IOP13XX_PCIE_LOWER_IO_PA\
+					   - IOP13XX_PCIE_LOWER_IO_VA))
+
+#define IOP13XX_PCIE_MEM_PHYS_OFFSET  	 0x200000000ULL
+#define IOP13XX_PCIE_MEM_WINDOW_SIZE  	 0x3a000000UL
+#define IOP13XX_PCIE_LOWER_MEM_BA     	 (PHYS_OFFSET + IOP13XX_PCI_OFFSET)
+#define IOP13XX_PCIE_LOWER_MEM_PA     	 (IOP13XX_PCIE_MEM_PHYS_OFFSET +\
+					 IOP13XX_PCIE_LOWER_MEM_BA)
+#define IOP13XX_PCIE_UPPER_MEM_PA     	 (IOP13XX_PCIE_LOWER_MEM_PA +\
+					 IOP13XX_PCIE_MEM_WINDOW_SIZE - 1)
+#define IOP13XX_PCIE_UPPER_MEM_BA     	 (IOP13XX_PCIE_LOWER_MEM_BA +\
+					 IOP13XX_PCIE_MEM_WINDOW_SIZE - 1)
+
+/* All 0xc000.0000 - 0xfdff.ffff addresses belong to PCIe */
+#define IOP13XX_PCIE_MEM_COOKIE       	 0xc0000000UL
+#define IOP13XX_PCIE_LOWER_MEM_RA     	 IOP13XX_PCIE_MEM_COOKIE
+#define IOP13XX_PCIE_UPPER_MEM_RA     	 (IOP13XX_PCIE_LOWER_MEM_RA +\
+					 IOP13XX_PCIE_MEM_WINDOW_SIZE - 1)
+#define IOP13XX_PCIE_MEM_OFFSET       	 (IOP13XX_PCIE_MEM_COOKIE -\
+					 IOP13XX_PCIE_LOWER_MEM_BA)
+
+/* PBI Ranges */
+#define IOP13XX_PBI_LOWER_MEM_PA	  0xf0000000UL
+#define IOP13XX_PBI_MEM_WINDOW_SIZE	  0x04000000UL
+#define IOP13XX_PBI_MEM_COOKIE		  0xfa000000UL
+#define IOP13XX_PBI_LOWER_MEM_RA	  IOP13XX_PBI_MEM_COOKIE
+#define IOP13XX_PBI_UPPER_MEM_RA	  (IOP13XX_PBI_LOWER_MEM_RA +\
+					  IOP13XX_PBI_MEM_WINDOW_SIZE - 1)
+
+/*
+ * IOP13XX chipset registers
+ */
+#define IOP13XX_PMMR_PHYS_MEM_BASE	   0xffd80000UL  /* PMMR phys. address */
+#define IOP13XX_PMMR_VIRT_MEM_BASE	   0xfee80000UL  /* PMMR phys. address */
+#define IOP13XX_PMMR_MEM_WINDOW_SIZE	   0x80000
+#define IOP13XX_PMMR_UPPER_MEM_VA	   (IOP13XX_PMMR_VIRT_MEM_BASE +\
+					   IOP13XX_PMMR_MEM_WINDOW_SIZE - 1)
+#define IOP13XX_PMMR_UPPER_MEM_PA	   (IOP13XX_PMMR_PHYS_MEM_BASE +\
+					   IOP13XX_PMMR_MEM_WINDOW_SIZE - 1)
+#define IOP13XX_PMMR_VIRT_TO_PHYS(addr)   (u32) ((u32) addr +\
+					   (IOP13XX_PMMR_PHYS_MEM_BASE\
+					   - IOP13XX_PMMR_VIRT_MEM_BASE))
+#define IOP13XX_PMMR_PHYS_TO_VIRT(addr)   (u32) ((u32) addr -\
+					   (IOP13XX_PMMR_PHYS_MEM_BASE\
+					   - IOP13XX_PMMR_VIRT_MEM_BASE))
+#define IOP13XX_REG_ADDR32(reg)     	   (IOP13XX_PMMR_VIRT_MEM_BASE + (reg))
+#define IOP13XX_REG_ADDR16(reg)     	   (IOP13XX_PMMR_VIRT_MEM_BASE + (reg))
+#define IOP13XX_REG_ADDR8(reg)      	   (IOP13XX_PMMR_VIRT_MEM_BASE + (reg))
+#define IOP13XX_REG_ADDR32_PHYS(reg)      (IOP13XX_PMMR_PHYS_MEM_BASE + (reg))
+#define IOP13XX_REG_ADDR16_PHYS(reg)      (IOP13XX_PMMR_PHYS_MEM_BASE + (reg))
+#define IOP13XX_REG_ADDR8_PHYS(reg)       (IOP13XX_PMMR_PHYS_MEM_BASE + (reg))
+#define IOP13XX_PMMR_SIZE		   0x00080000
+
+/*=================== Defines for Platform Devices =====================*/
+#define IOP13XX_UART0_PHYS  (IOP13XX_PMMR_PHYS_MEM_BASE | 0x00002300)
+#define IOP13XX_UART1_PHYS  (IOP13XX_PMMR_PHYS_MEM_BASE | 0x00002340)
+#define IOP13XX_UART0_VIRT  (IOP13XX_PMMR_VIRT_MEM_BASE | 0x00002300)
+#define IOP13XX_UART1_VIRT  (IOP13XX_PMMR_VIRT_MEM_BASE | 0x00002340)
+
+#define IOP13XX_I2C0_PHYS   (IOP13XX_PMMR_PHYS_MEM_BASE | 0x00002500)
+#define IOP13XX_I2C1_PHYS   (IOP13XX_PMMR_PHYS_MEM_BASE | 0x00002520)
+#define IOP13XX_I2C2_PHYS   (IOP13XX_PMMR_PHYS_MEM_BASE | 0x00002540)
+#define IOP13XX_I2C0_VIRT   (IOP13XX_PMMR_VIRT_MEM_BASE | 0x00002500)
+#define IOP13XX_I2C1_VIRT   (IOP13XX_PMMR_VIRT_MEM_BASE | 0x00002520)
+#define IOP13XX_I2C2_VIRT   (IOP13XX_PMMR_VIRT_MEM_BASE | 0x00002540)
+
+/* ATU selection flags */
+/* IOP13XX_INIT_ATU_DEFAULT = Rely on CONFIG_IOP13XX_ATU* */
+#define IOP13XX_INIT_ATU_DEFAULT     (0)
+#define IOP13XX_INIT_ATU_ATUX	      (1 << 0)
+#define IOP13XX_INIT_ATU_ATUE	      (1 << 1)
+#define IOP13XX_INIT_ATU_NONE	      (1 << 2)
+
+/* UART selection flags */
+/* IOP13XX_INIT_UART_DEFAULT = Rely on CONFIG_IOP13XX_UART* */
+#define IOP13XX_INIT_UART_DEFAULT    (0)
+#define IOP13XX_INIT_UART_0	      (1 << 0)
+#define IOP13XX_INIT_UART_1	      (1 << 1)
+
+/* I2C selection flags */
+/* IOP13XX_INIT_I2C_DEFAULT = Rely on CONFIG_IOP13XX_I2C* */
+#define IOP13XX_INIT_I2C_DEFAULT     (0)
+#define IOP13XX_INIT_I2C_0	      (1 << 0)
+#define IOP13XX_INIT_I2C_1	      (1 << 1)
+#define IOP13XX_INIT_I2C_2	      (1 << 2)
+
+#define IQ81340_NUM_UART     2
+#define IQ81340_NUM_I2C      3
+#define IQ81340_NUM_PHYS_MAP_FLASH 1
+#define IQ81340_MAX_PLAT_DEVICES (IQ81340_NUM_UART +\
+				IQ81340_NUM_I2C +\
+				IQ81340_NUM_PHYS_MAP_FLASH)
+
+/*========================== PMMR offsets for key registers ============*/
+#define IOP13XX_ATU0_PMMR_OFFSET   	0x00048000
+#define IOP13XX_ATU1_PMMR_OFFSET   	0x0004c000
+#define IOP13XX_ATU2_PMMR_OFFSET   	0x0004d000
+#define IOP13XX_ADMA0_PMMR_OFFSET  	0x00000000
+#define IOP13XX_ADMA1_PMMR_OFFSET  	0x00000200
+#define IOP13XX_ADMA2_PMMR_OFFSET  	0x00000400
+#define IOP13XX_PBI_PMMR_OFFSET    	0x00001580
+#define IOP13XX_ESSR0_PMMR_OFFSET  	0x00002188
+#define IOP13XX_ESSR0			IOP13XX_REG_ADDR32(0x00002188)
+
+#define IOP13XX_ESSR0_IFACE_MASK   	0x00004000  /* Interface PCI-X / PCI-E */
+#define IOP13XX_CONTROLLER_ONLY    	(1 << 14)
+#define IOP13XX_INTERFACE_SEL_PCIX 	(1 << 15)
+
+#define IOP13XX_PMON_PMMR_OFFSET	0x0001A000
+#define IOP13XX_PMON_BASE		(IOP13XX_PMMR_VIRT_MEM_BASE +\
+					IOP13XX_PMON_PMMR_OFFSET)
+#define IOP13XX_PMON_PHYSBASE		(IOP13XX_PMMR_PHYS_MEM_BASE +\
+					IOP13XX_PMON_PMMR_OFFSET)
+
+#define IOP13XX_PMON_CMD0		(IOP13XX_PMON_BASE + 0x0)
+#define IOP13XX_PMON_EVR0		(IOP13XX_PMON_BASE + 0x4)
+#define IOP13XX_PMON_STS0		(IOP13XX_PMON_BASE + 0x8)
+#define IOP13XX_PMON_DATA0		(IOP13XX_PMON_BASE + 0xC)
+
+#define IOP13XX_PMON_CMD3		(IOP13XX_PMON_BASE + 0x30)
+#define IOP13XX_PMON_EVR3		(IOP13XX_PMON_BASE + 0x34)
+#define IOP13XX_PMON_STS3		(IOP13XX_PMON_BASE + 0x38)
+#define IOP13XX_PMON_DATA3		(IOP13XX_PMON_BASE + 0x3C)
+
+#define IOP13XX_PMON_CMD7		(IOP13XX_PMON_BASE + 0x70)
+#define IOP13XX_PMON_EVR7		(IOP13XX_PMON_BASE + 0x74)
+#define IOP13XX_PMON_STS7		(IOP13XX_PMON_BASE + 0x78)
+#define IOP13XX_PMON_DATA7		(IOP13XX_PMON_BASE + 0x7C)
+
+#define IOP13XX_PMONEN			(IOP13XX_PMMR_VIRT_MEM_BASE + 0x4E040)
+#define IOP13XX_PMONSTAT		(IOP13XX_PMMR_VIRT_MEM_BASE + 0x4E044)
+
+/*================================ATU===================================*/
+#define IOP13XX_ATUX_OFFSET(ofs)	IOP13XX_REG_ADDR32(\
+					iop13xx_atux_pmmr_offset + (ofs))
+
+#define IOP13XX_ATUX_DID		IOP13XX_REG_ADDR16(\
+					iop13xx_atux_pmmr_offset + 0x2)
+
+#define IOP13XX_ATUX_ATUCMD		IOP13XX_REG_ADDR16(\
+					iop13xx_atux_pmmr_offset + 0x4)
+#define IOP13XX_ATUX_ATUSR		IOP13XX_REG_ADDR16(\
+					iop13xx_atux_pmmr_offset + 0x6)
+
+#define IOP13XX_ATUX_IABAR0   		IOP13XX_ATUX_OFFSET(0x10)
+#define IOP13XX_ATUX_IAUBAR0  		IOP13XX_ATUX_OFFSET(0x14)
+#define IOP13XX_ATUX_IABAR1   		IOP13XX_ATUX_OFFSET(0x18)
+#define IOP13XX_ATUX_IAUBAR1  		IOP13XX_ATUX_OFFSET(0x1c)
+#define IOP13XX_ATUX_IABAR2   		IOP13XX_ATUX_OFFSET(0x20)
+#define IOP13XX_ATUX_IAUBAR2  		IOP13XX_ATUX_OFFSET(0x24)
+#define IOP13XX_ATUX_IALR0    		IOP13XX_ATUX_OFFSET(0x40)
+#define IOP13XX_ATUX_IATVR0   		IOP13XX_ATUX_OFFSET(0x44)
+#define IOP13XX_ATUX_IAUTVR0  		IOP13XX_ATUX_OFFSET(0x48)
+#define IOP13XX_ATUX_IALR1    		IOP13XX_ATUX_OFFSET(0x4c)
+#define IOP13XX_ATUX_IATVR1   		IOP13XX_ATUX_OFFSET(0x50)
+#define IOP13XX_ATUX_IAUTVR1  		IOP13XX_ATUX_OFFSET(0x54)
+#define IOP13XX_ATUX_IALR2    		IOP13XX_ATUX_OFFSET(0x58)
+#define IOP13XX_ATUX_IATVR2   		IOP13XX_ATUX_OFFSET(0x5c)
+#define IOP13XX_ATUX_IAUTVR2  		IOP13XX_ATUX_OFFSET(0x60)
+#define IOP13XX_ATUX_ATUCR    		IOP13XX_ATUX_OFFSET(0x70)
+#define IOP13XX_ATUX_PCSR     		IOP13XX_ATUX_OFFSET(0x74)
+#define IOP13XX_ATUX_ATUISR   		IOP13XX_ATUX_OFFSET(0x78)
+#define IOP13XX_ATUX_PCIXSR   		IOP13XX_ATUX_OFFSET(0xD4)
+#define IOP13XX_ATUX_IABAR3   		IOP13XX_ATUX_OFFSET(0x200)
+#define IOP13XX_ATUX_IAUBAR3  		IOP13XX_ATUX_OFFSET(0x204)
+#define IOP13XX_ATUX_IALR3    		IOP13XX_ATUX_OFFSET(0x208)
+#define IOP13XX_ATUX_IATVR3   		IOP13XX_ATUX_OFFSET(0x20c)
+#define IOP13XX_ATUX_IAUTVR3  		IOP13XX_ATUX_OFFSET(0x210)
+
+#define IOP13XX_ATUX_OIOBAR   		IOP13XX_ATUX_OFFSET(0x300)
+#define IOP13XX_ATUX_OIOWTVR  		IOP13XX_ATUX_OFFSET(0x304)
+#define IOP13XX_ATUX_OUMBAR0  		IOP13XX_ATUX_OFFSET(0x308)
+#define IOP13XX_ATUX_OUMWTVR0 		IOP13XX_ATUX_OFFSET(0x30c)
+#define IOP13XX_ATUX_OUMBAR1  		IOP13XX_ATUX_OFFSET(0x310)
+#define IOP13XX_ATUX_OUMWTVR1 		IOP13XX_ATUX_OFFSET(0x314)
+#define IOP13XX_ATUX_OUMBAR2  		IOP13XX_ATUX_OFFSET(0x318)
+#define IOP13XX_ATUX_OUMWTVR2 		IOP13XX_ATUX_OFFSET(0x31c)
+#define IOP13XX_ATUX_OUMBAR3  		IOP13XX_ATUX_OFFSET(0x320)
+#define IOP13XX_ATUX_OUMWTVR3 		IOP13XX_ATUX_OFFSET(0x324)
+#define IOP13XX_ATUX_OUDMABAR 		IOP13XX_ATUX_OFFSET(0x328)
+#define IOP13XX_ATUX_OUMSIBAR 		IOP13XX_ATUX_OFFSET(0x32c)
+#define IOP13XX_ATUX_OCCAR    		IOP13XX_ATUX_OFFSET(0x330)
+#define IOP13XX_ATUX_OCCDR    		IOP13XX_ATUX_OFFSET(0x334)
+
+#define IOP13XX_ATUX_ATUCR_OUT_EN		(1 << 1)
+#define IOP13XX_ATUX_PCSR_CENTRAL_RES		(1 << 25)
+#define IOP13XX_ATUX_PCSR_P_RSTOUT		(1 << 21)
+#define IOP13XX_ATUX_PCSR_OUT_Q_BUSY		(1 << 15)
+#define IOP13XX_ATUX_PCSR_IN_Q_BUSY		(1 << 14)
+#define IOP13XX_ATUX_PCSR_FREQ_OFFSET		(16)
+
+#define IOP13XX_ATUX_STAT_PCI_IFACE_ERR	(1 << 18)
+#define IOP13XX_ATUX_STAT_VPD_ADDR		(1 << 17)
+#define IOP13XX_ATUX_STAT_INT_PAR_ERR		(1 << 16)
+#define IOP13XX_ATUX_STAT_CFG_WRITE		(1 << 15)
+#define IOP13XX_ATUX_STAT_ERR_COR		(1 << 14)
+#define IOP13XX_ATUX_STAT_TX_SCEM		(1 << 13)
+#define IOP13XX_ATUX_STAT_REC_SCEM		(1 << 12)
+#define IOP13XX_ATUX_STAT_POWER_TRAN	 	(1 << 11)
+#define IOP13XX_ATUX_STAT_TX_SERR		(1 << 10)
+#define IOP13XX_ATUX_STAT_DET_PAR_ERR	 	(1 << 9	)
+#define IOP13XX_ATUX_STAT_BIST			(1 << 8	)
+#define IOP13XX_ATUX_STAT_INT_REC_MABORT 	(1 << 7	)
+#define IOP13XX_ATUX_STAT_REC_SERR		(1 << 4	)
+#define IOP13XX_ATUX_STAT_EXT_REC_MABORT 	(1 << 3	)
+#define IOP13XX_ATUX_STAT_EXT_REC_TABORT 	(1 << 2	)
+#define IOP13XX_ATUX_STAT_EXT_SIG_TABORT 	(1 << 1	)
+#define IOP13XX_ATUX_STAT_MASTER_DATA_PAR	(1 << 0	)
+
+#define IOP13XX_ATUX_PCIXSR_BUS_NUM	(8)
+#define IOP13XX_ATUX_PCIXSR_DEV_NUM	(3)
+#define IOP13XX_ATUX_PCIXSR_FUNC_NUM	(0)
+
+#define IOP13XX_ATUX_IALR_DISABLE  	0x00000001
+#define IOP13XX_ATUX_OUMBAR_ENABLE 	0x80000000
+
+#define IOP13XX_ATUE_OFFSET(ofs)	IOP13XX_REG_ADDR32(\
+					iop13xx_atue_pmmr_offset + (ofs))
+
+#define IOP13XX_ATUE_DID		IOP13XX_REG_ADDR16(\
+					iop13xx_atue_pmmr_offset + 0x2)
+#define IOP13XX_ATUE_ATUCMD		IOP13XX_REG_ADDR16(\
+					iop13xx_atue_pmmr_offset + 0x4)
+#define IOP13XX_ATUE_ATUSR		IOP13XX_REG_ADDR16(\
+					iop13xx_atue_pmmr_offset + 0x6)
+
+#define IOP13XX_ATUE_IABAR0		IOP13XX_ATUE_OFFSET(0x10)
+#define IOP13XX_ATUE_IAUBAR0		IOP13XX_ATUE_OFFSET(0x14)
+#define IOP13XX_ATUE_IABAR1		IOP13XX_ATUE_OFFSET(0x18)
+#define IOP13XX_ATUE_IAUBAR1		IOP13XX_ATUE_OFFSET(0x1c)
+#define IOP13XX_ATUE_IABAR2		IOP13XX_ATUE_OFFSET(0x20)
+#define IOP13XX_ATUE_IAUBAR2		IOP13XX_ATUE_OFFSET(0x24)
+#define IOP13XX_ATUE_IALR0		IOP13XX_ATUE_OFFSET(0x40)
+#define IOP13XX_ATUE_IATVR0		IOP13XX_ATUE_OFFSET(0x44)
+#define IOP13XX_ATUE_IAUTVR0		IOP13XX_ATUE_OFFSET(0x48)
+#define IOP13XX_ATUE_IALR1		IOP13XX_ATUE_OFFSET(0x4c)
+#define IOP13XX_ATUE_IATVR1		IOP13XX_ATUE_OFFSET(0x50)
+#define IOP13XX_ATUE_IAUTVR1		IOP13XX_ATUE_OFFSET(0x54)
+#define IOP13XX_ATUE_IALR2		IOP13XX_ATUE_OFFSET(0x58)
+#define IOP13XX_ATUE_IATVR2		IOP13XX_ATUE_OFFSET(0x5c)
+#define IOP13XX_ATUE_IAUTVR2		IOP13XX_ATUE_OFFSET(0x60)
+#define IOP13XX_ATUE_PE_LSTS		IOP13XX_REG_ADDR16(\
+					iop13xx_atue_pmmr_offset + 0xe2)
+#define IOP13XX_ATUE_OIOWTVR		IOP13XX_ATUE_OFFSET(0x304)
+#define IOP13XX_ATUE_OUMBAR0		IOP13XX_ATUE_OFFSET(0x308)
+#define IOP13XX_ATUE_OUMWTVR0		IOP13XX_ATUE_OFFSET(0x30c)
+#define IOP13XX_ATUE_OUMBAR1		IOP13XX_ATUE_OFFSET(0x310)
+#define IOP13XX_ATUE_OUMWTVR1		IOP13XX_ATUE_OFFSET(0x314)
+#define IOP13XX_ATUE_OUMBAR2		IOP13XX_ATUE_OFFSET(0x318)
+#define IOP13XX_ATUE_OUMWTVR2		IOP13XX_ATUE_OFFSET(0x31c)
+#define IOP13XX_ATUE_OUMBAR3		IOP13XX_ATUE_OFFSET(0x320)
+#define IOP13XX_ATUE_OUMWTVR3		IOP13XX_ATUE_OFFSET(0x324)
+
+#define IOP13XX_ATUE_ATUCR		IOP13XX_ATUE_OFFSET(0x70)
+#define IOP13XX_ATUE_PCSR		IOP13XX_ATUE_OFFSET(0x74)
+#define IOP13XX_ATUE_ATUISR		IOP13XX_ATUE_OFFSET(0x78)
+#define IOP13XX_ATUE_OIOBAR		IOP13XX_ATUE_OFFSET(0x300)
+#define IOP13XX_ATUE_OCCAR		IOP13XX_ATUE_OFFSET(0x32c)
+#define IOP13XX_ATUE_OCCDR		IOP13XX_ATUE_OFFSET(0x330)
+
+#define IOP13XX_ATUE_PIE_STS		IOP13XX_ATUE_OFFSET(0x384)
+#define IOP13XX_ATUE_PIE_MSK		IOP13XX_ATUE_OFFSET(0x388)
+
+#define IOP13XX_ATUE_ATUCR_IVM		(1 << 6)
+#define IOP13XX_ATUE_ATUCR_OUT_EN	(1 << 1)
+#define IOP13XX_ATUE_OCCAR_BUS_NUM	(24)
+#define IOP13XX_ATUE_OCCAR_DEV_NUM	(19)
+#define IOP13XX_ATUE_OCCAR_FUNC_NUM	(16)
+#define IOP13XX_ATUE_OCCAR_EXT_REG	(8)
+#define IOP13XX_ATUE_OCCAR_REG		(2)
+
+#define IOP13XX_ATUE_PCSR_BUS_NUM	(24)
+#define IOP13XX_ATUE_PCSR_DEV_NUM	(19)
+#define IOP13XX_ATUE_PCSR_FUNC_NUM	(16)
+#define IOP13XX_ATUE_PCSR_OUT_Q_BUSY	(1 << 15)
+#define IOP13XX_ATUE_PCSR_IN_Q_BUSY	(1 << 14)
+#define IOP13XX_ATUE_PCSR_END_POINT	(1 << 13)
+#define IOP13XX_ATUE_PCSR_LLRB_BUSY	(1 << 12)
+
+#define IOP13XX_ATUE_PCSR_BUS_NUM_MASK		(0xff)
+#define IOP13XX_ATUE_PCSR_DEV_NUM_MASK		(0x1f)
+#define IOP13XX_ATUE_PCSR_FUNC_NUM_MASK	(0x7)
+
+#define IOP13XX_ATUE_PCSR_CORE_RESET		(8)
+#define IOP13XX_ATUE_PCSR_FUNC_NUM		(16)
+
+#define IOP13XX_ATUE_LSTS_TRAINING		(1 << 11)
+#define IOP13XX_ATUE_STAT_SLOT_PWR_MSG		(1 << 28)
+#define IOP13XX_ATUE_STAT_PME			(1 << 27)
+#define IOP13XX_ATUE_STAT_HOT_PLUG_MSG		(1 << 26)
+#define IOP13XX_ATUE_STAT_IVM			(1 << 25)
+#define IOP13XX_ATUE_STAT_BIST			(1 << 24)
+#define IOP13XX_ATUE_STAT_CFG_WRITE		(1 << 18)
+#define IOP13XX_ATUE_STAT_VPD_ADDR		(1 << 17)
+#define IOP13XX_ATUE_STAT_POWER_TRAN		(1 << 16)
+#define IOP13XX_ATUE_STAT_HALT_ON_ERROR	(1 << 13)
+#define IOP13XX_ATUE_STAT_ROOT_SYS_ERR		(1 << 12)
+#define IOP13XX_ATUE_STAT_ROOT_ERR_MSG		(1 << 11)
+#define IOP13XX_ATUE_STAT_PCI_IFACE_ERR	(1 << 10)
+#define IOP13XX_ATUE_STAT_ERR_COR		(1 << 9	)
+#define IOP13XX_ATUE_STAT_ERR_UNCOR		(1 << 8	)
+#define IOP13XX_ATUE_STAT_CRS			(1 << 7	)
+#define IOP13XX_ATUE_STAT_LNK_DWN		(1 << 6	)
+#define IOP13XX_ATUE_STAT_INT_REC_MABORT	(1 << 5	)
+#define IOP13XX_ATUE_STAT_DET_PAR_ERR		(1 << 4	)
+#define IOP13XX_ATUE_STAT_EXT_REC_MABORT	(1 << 3	)
+#define IOP13XX_ATUE_STAT_SIG_TABORT		(1 << 2	)
+#define IOP13XX_ATUE_STAT_EXT_REC_TABORT	(1 << 1	)
+#define IOP13XX_ATUE_STAT_MASTER_DATA_PAR	(1 << 0	)
+
+#define IOP13XX_ATUE_ESTAT_REC_UNSUPPORTED_COMP_REQ	(1 << 31)
+#define IOP13XX_ATUE_ESTAT_REC_COMPLETER_ABORT		(1 << 30)
+#define IOP13XX_ATUE_ESTAT_TX_POISONED_TLP		(1 << 29)
+#define IOP13XX_ATUE_ESTAT_TX_PAR_ERR			(1 << 28)
+#define IOP13XX_ATUE_ESTAT_REC_UNSUPPORTED_REQ		(1 << 20)
+#define IOP13XX_ATUE_ESTAT_REC_ECRC_ERR		(1 << 19)
+#define IOP13XX_ATUE_ESTAT_REC_MALFORMED_TLP		(1 << 18)
+#define IOP13XX_ATUE_ESTAT_TX_RECEIVER_OVERFLOW	(1 << 17)
+#define IOP13XX_ATUE_ESTAT_REC_UNEXPECTED_COMP		(1 << 16)
+#define IOP13XX_ATUE_ESTAT_INT_COMP_ABORT		(1 << 15)
+#define IOP13XX_ATUE_ESTAT_COMP_TIMEOUT		(1 << 14)
+#define IOP13XX_ATUE_ESTAT_FLOW_CONTROL_ERR		(1 << 13)
+#define IOP13XX_ATUE_ESTAT_REC_POISONED_TLP		(1 << 12)
+#define IOP13XX_ATUE_ESTAT_DATA_LNK_ERR		(1 << 4	)
+#define IOP13XX_ATUE_ESTAT_TRAINING_ERR		(1 << 0	)
+
+#define IOP13XX_ATUE_IALR_DISABLE   		(0x00000001)
+#define IOP13XX_ATUE_OUMBAR_ENABLE  		(0x80000000)
+#define IOP13XX_ATU_OUMBAR_FUNC_NUM  		(28)
+#define IOP13XX_ATU_OUMBAR_FUNC_NUM_MASK  	(0x7)
+/*=======================================================================*/
+
+/*==============================ADMA UNITS===============================*/
+#define IOP13XX_ADMA_PHYS_BASE(chan)	IOP13XX_REG_ADDR32_PHYS((chan << 9))
+#define IOP13XX_ADMA_UPPER_PA(chan)	(IOP13XX_ADMA_PHYS_BASE(chan) + 0xc0)
+#define IOP13XX_ADMA_OFFSET(chan, ofs)	IOP13XX_REG_ADDR32((chan << 9) + (ofs))
+
+#define IOP13XX_ADMA_ACCR(chan)      IOP13XX_ADMA_OFFSET(chan, 0x0)
+#define IOP13XX_ADMA_ACSR(chan)      IOP13XX_ADMA_OFFSET(chan, 0x4)
+#define IOP13XX_ADMA_ADAR(chan)      IOP13XX_ADMA_OFFSET(chan, 0x8)
+#define IOP13XX_ADMA_IIPCR(chan)     IOP13XX_ADMA_OFFSET(chan, 0x18)
+#define IOP13XX_ADMA_IIPAR(chan)     IOP13XX_ADMA_OFFSET(chan, 0x1c)
+#define IOP13XX_ADMA_IIPUAR(chan)    IOP13XX_ADMA_OFFSET(chan, 0x20)
+#define IOP13XX_ADMA_ANDAR(chan)     IOP13XX_ADMA_OFFSET(chan, 0x24)
+#define IOP13XX_ADMA_ADCR(chan)      IOP13XX_ADMA_OFFSET(chan, 0x28)
+#define IOP13XX_ADMA_CARMD(chan)     IOP13XX_ADMA_OFFSET(chan, 0x2c)
+#define IOP13XX_ADMA_ABCR(chan)      IOP13XX_ADMA_OFFSET(chan, 0x30)
+#define IOP13XX_ADMA_DLADR(chan)     IOP13XX_ADMA_OFFSET(chan, 0x34)
+#define IOP13XX_ADMA_DUADR(chan)     IOP13XX_ADMA_OFFSET(chan, 0x38)
+#define IOP13XX_ADMA_SLAR(src, chan) IOP13XX_ADMA_OFFSET(chan, 0x3c + (src <<3))
+#define IOP13XX_ADMA_SUAR(src, chan) IOP13XX_ADMA_OFFSET(chan, 0x40 + (src <<3))
+
+/*==============================XSI BRIDGE===============================*/
+#define IOP13XX_XBG_BECSR		IOP13XX_REG_ADDR32(0x178c)
+#define IOP13XX_XBG_BERAR		IOP13XX_REG_ADDR32(0x1790)
+#define IOP13XX_XBG_BERUAR		IOP13XX_REG_ADDR32(0x1794)
+#define is_atue_occdr_error(x) 	((__raw_readl(IOP13XX_XBG_BERAR) == \
+					IOP13XX_PMMR_VIRT_TO_PHYS(\
+					IOP13XX_ATUE_OCCDR))\
+					&& (__raw_readl(IOP13XX_XBG_BECSR) & 1))
+#define is_atux_occdr_error(x) 	((__raw_readl(IOP13XX_XBG_BERAR) == \
+					IOP13XX_PMMR_VIRT_TO_PHYS(\
+					IOP13XX_ATUX_OCCDR))\
+					&& (__raw_readl(IOP13XX_XBG_BECSR) & 1))
+/*=======================================================================*/
+
+#define IOP13XX_PBI_OFFSET(ofs) IOP13XX_REG_ADDR32(IOP13XX_PBI_PMMR_OFFSET +\
+							(ofs))
+
+#define IOP13XX_PBI_CR	       		IOP13XX_PBI_OFFSET(0x0)
+#define IOP13XX_PBI_SR	       		IOP13XX_PBI_OFFSET(0x4)
+#define IOP13XX_PBI_BAR0      		IOP13XX_PBI_OFFSET(0x8)
+#define IOP13XX_PBI_LR0       		IOP13XX_PBI_OFFSET(0xc)
+#define IOP13XX_PBI_BAR1      		IOP13XX_PBI_OFFSET(0x10)
+#define IOP13XX_PBI_LR1       		IOP13XX_PBI_OFFSET(0x14)
+
+#endif /* _IOP13XX_HW_H_ */
Index: build_tree/linux/include/asm/arch-iop13xx/iq81340.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/iq81340.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/iq81340.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+#ifndef _IQ81340_H_
+#define _IQ81340_H_
+
+#define IQ81340_PCE_BAR0    IOP13XX_PBI_LOWER_MEM_RA
+#define IQ81340_PCE_BAR1    (IQ81340_PCE_BAR0 + 0x02000000)
+
+#define IQ81340_FLASHBASE   IQ81340_PCE_BAR0	/* Flash */
+
+#define IQ81340_PCE_BAR1_OFFSET(a) (IQ81340_PCE_BAR1 + (a))
+
+#define IQ81340_PRD_CODE    IQ81340_PCE_BAR1_OFFSET(0)
+#define IQ81340_BRD_STEP    IQ81340_PCE_BAR1_OFFSET(0x10000)
+#define IQ81340_CPLD_REV    IQ81340_PCE_BAR1_OFFSET(0x20000)
+#define IQ81340_LED	     IQ81340_PCE_BAR1_OFFSET(0x30000)
+#define IQ81340_LHEX	     IQ81340_PCE_BAR1_OFFSET(0x40000)
+#define IQ81340_RHEX	     IQ81340_PCE_BAR1_OFFSET(0x50000)
+#define IQ81340_BUZZER	     IQ81340_PCE_BAR1_OFFSET(0x60000)
+#define IQ81340_32K_NVRAM   IQ81340_PCE_BAR1_OFFSET(0x70000)
+#define IQ81340_256K_NVRAM  IQ81340_PCE_BAR1_OFFSET(0x80000)
+#define IQ81340_ROTARY_SW   IQ81340_PCE_BAR1_OFFSET(0xd0000)
+#define IQ81340_BATT_STAT   IQ81340_PCE_BAR1_OFFSET(0xf0000)
+#define IQ81340_CMP_FLSH    IQ81340_PCE_BAR1_OFFSET(0x1000000) /* 16MB */
+
+#define PBI_CF_IDE_BASE     (IQ81340_CMP_FLSH)
+#define PBI_CF_BAR_ADDR     (IOP13XX_PBI_BAR1)
+
+
+#endif	/* _IQ81340_H_ */
Index: build_tree/linux/include/asm/arch-iop13xx/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,190 @@
+#ifndef _IOP13XX_IRQS_H_
+#define _IOP13XX_IRQS_H_
+
+#ifndef __ASSEMBLER__
+#include <linux/types.h>
+
+/* INTPND0 CP6 R0 Page 3
+ */
+static inline u32 read_intpnd_0(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c0, c3, 0":"=r" (val));
+	return val;
+}
+
+/* INTPND1 CP6 R1 Page 3
+ */
+static inline u32 read_intpnd_1(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c1, c3, 0":"=r" (val));
+	return val;
+}
+
+/* INTPND2 CP6 R2 Page 3
+ */
+static inline u32 read_intpnd_2(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c2, c3, 0":"=r" (val));
+	return val;
+}
+
+/* INTPND3 CP6 R3 Page 3
+ */
+static inline u32 read_intpnd_3(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c3, c3, 0":"=r" (val));
+	return val;
+}
+#endif
+
+#define INTBASE 0
+#define INTSIZE_4 1
+
+/*
+ * iop34x chipset interrupts
+ */
+#define IOP13XX_IRQ(x)		(IOP13XX_IRQ_OFS + (x))
+
+/*
+ * On IRQ or FIQ register
+ */
+#define IRQ_IOP13XX_ADMA0_EOT	(0)
+#define IRQ_IOP13XX_ADMA0_EOC	(1)
+#define IRQ_IOP13XX_ADMA1_EOT	(2)
+#define IRQ_IOP13XX_ADMA1_EOC	(3)
+#define IRQ_IOP13XX_ADMA2_EOT	(4)
+#define IRQ_IOP13XX_ADMA2_EOC	(5)
+#define IRQ_IOP134_WATCHDOG	(6)
+#define IRQ_IOP13XX_RSVD_7	(7)
+#define IRQ_IOP13XX_TIMER0	(8)
+#define IRQ_IOP13XX_TIMER1	(9)
+#define IRQ_IOP13XX_I2C_0	(10)
+#define IRQ_IOP13XX_I2C_1	(11)
+#define IRQ_IOP13XX_MSG	(12)
+#define IRQ_IOP13XX_MSGIBQ	(13)
+#define IRQ_IOP13XX_ATU_IM	(14)
+#define IRQ_IOP13XX_ATU_BIST	(15)
+#define IRQ_IOP13XX_PPMU	(16)
+#define IRQ_IOP13XX_COREPMU	(17)
+#define IRQ_IOP13XX_CORECACHE	(18)
+#define IRQ_IOP13XX_RSVD_19	(19)
+#define IRQ_IOP13XX_RSVD_20	(20)
+#define IRQ_IOP13XX_RSVD_21	(21)
+#define IRQ_IOP13XX_RSVD_22	(22)
+#define IRQ_IOP13XX_RSVD_23	(23)
+#define IRQ_IOP13XX_XINT0	(24)
+#define IRQ_IOP13XX_XINT1	(25)
+#define IRQ_IOP13XX_XINT2	(26)
+#define IRQ_IOP13XX_XINT3	(27)
+#define IRQ_IOP13XX_XINT4	(28)
+#define IRQ_IOP13XX_XINT5	(29)
+#define IRQ_IOP13XX_XINT6	(30)
+#define IRQ_IOP13XX_XINT7	(31)
+				      /* IINTSRC1 bit */
+#define IRQ_IOP13XX_XINT8	(32)  /* 0  */
+#define IRQ_IOP13XX_XINT9	(33)  /* 1  */
+#define IRQ_IOP13XX_XINT10	(34)  /* 2  */
+#define IRQ_IOP13XX_XINT11	(35)  /* 3  */
+#define IRQ_IOP13XX_XINT12	(36)  /* 4  */
+#define IRQ_IOP13XX_XINT13	(37)  /* 5  */
+#define IRQ_IOP13XX_XINT14	(38)  /* 6  */
+#define IRQ_IOP13XX_XINT15	(39)  /* 7  */
+#define IRQ_IOP13XX_RSVD_40	(40)  /* 8  */
+#define IRQ_IOP13XX_RSVD_41	(41)  /* 9  */
+#define IRQ_IOP13XX_RSVD_42	(42)  /* 10 */
+#define IRQ_IOP13XX_RSVD_43	(43)  /* 11 */
+#define IRQ_IOP13XX_RSVD_44	(44)  /* 12 */
+#define IRQ_IOP13XX_RSVD_45	(45)  /* 13 */
+#define IRQ_IOP13XX_RSVD_46	(46)  /* 14 */
+#define IRQ_IOP13XX_RSVD_47	(47)  /* 15 */
+#define IRQ_IOP13XX_RSVD_48	(48)  /* 16 */
+#define IRQ_IOP13XX_RSVD_49	(49)  /* 17 */
+#define IRQ_IOP13XX_RSVD_50	(50)  /* 18 */
+#define IRQ_IOP13XX_UART0	(51)  /* 19 */
+#define IRQ_IOP13XX_UART1	(52)  /* 20 */
+#define IRQ_IOP13XX_PBIE	(53)  /* 21 */
+#define IRQ_IOP13XX_ATU_CRW	(54)  /* 22 */
+#define IRQ_IOP13XX_ATU_ERR	(55)  /* 23 */
+#define IRQ_IOP13XX_MCU_ERR	(56)  /* 24 */
+#define IRQ_IOP13XX_ADMA0_ERR	(57)  /* 25 */
+#define IRQ_IOP13XX_ADMA1_ERR	(58)  /* 26 */
+#define IRQ_IOP13XX_ADMA2_ERR	(59)  /* 27 */
+#define IRQ_IOP13XX_RSVD_60	(60)  /* 28 */
+#define IRQ_IOP13XX_RSVD_61	(61)  /* 29 */
+#define IRQ_IOP13XX_MSG_ERR	(62)  /* 30 */
+#define IRQ_IOP13XX_RSVD_63	(63)  /* 31 */
+				      /* IINTSRC2 bit */
+#define IRQ_IOP13XX_INTERPROC	(64)  /* 0  */
+#define IRQ_IOP13XX_RSVD_65	(65)  /* 1  */
+#define IRQ_IOP13XX_RSVD_66	(66)  /* 2  */
+#define IRQ_IOP13XX_RSVD_67	(67)  /* 3  */
+#define IRQ_IOP13XX_RSVD_68	(68)  /* 4  */
+#define IRQ_IOP13XX_RSVD_69	(69)  /* 5  */
+#define IRQ_IOP13XX_RSVD_70	(70)  /* 6  */
+#define IRQ_IOP13XX_RSVD_71	(71)  /* 7  */
+#define IRQ_IOP13XX_RSVD_72	(72)  /* 8  */
+#define IRQ_IOP13XX_RSVD_73	(73)  /* 9  */
+#define IRQ_IOP13XX_RSVD_74	(74)  /* 10 */
+#define IRQ_IOP13XX_RSVD_75	(75)  /* 11 */
+#define IRQ_IOP13XX_RSVD_76	(76)  /* 12 */
+#define IRQ_IOP13XX_RSVD_77	(77)  /* 13 */
+#define IRQ_IOP13XX_RSVD_78	(78)  /* 14 */
+#define IRQ_IOP13XX_RSVD_79	(79)  /* 15 */
+#define IRQ_IOP13XX_RSVD_80	(80)  /* 16 */
+#define IRQ_IOP13XX_RSVD_81	(81)  /* 17 */
+#define IRQ_IOP13XX_RSVD_82	(82)  /* 18 */
+#define IRQ_IOP13XX_RSVD_83	(83)  /* 19 */
+#define IRQ_IOP13XX_RSVD_84	(84)  /* 20 */
+#define IRQ_IOP13XX_RSVD_85	(85)  /* 21 */
+#define IRQ_IOP13XX_RSVD_86	(86)  /* 22 */
+#define IRQ_IOP13XX_RSVD_87	(87)  /* 23 */
+#define IRQ_IOP13XX_RSVD_88	(88)  /* 24 */
+#define IRQ_IOP13XX_RSVD_89	(89)  /* 25 */
+#define IRQ_IOP13XX_RSVD_90	(90)  /* 26 */
+#define IRQ_IOP13XX_RSVD_91	(91)  /* 27 */
+#define IRQ_IOP13XX_RSVD_92	(92)  /* 28 */
+#define IRQ_IOP13XX_RSVD_93	(93)  /* 29 */
+#define IRQ_IOP13XX_SIB_ERR	(94)  /* 30 */
+#define IRQ_IOP13XX_SRAM_ERR	(95)  /* 31 */
+				      /* IINTSRC3 bit */
+#define IRQ_IOP13XX_I2C_2	(96)  /* 0  */
+#define IRQ_IOP13XX_ATUE_BIST	(97)  /* 1  */
+#define IRQ_IOP13XX_ATUE_CRW	(98)  /* 2  */
+#define IRQ_IOP13XX_ATUE_ERR	(99)  /* 3  */
+#define IRQ_IOP13XX_IMU	(100) /* 4  */
+#define IRQ_IOP13XX_RSVD_101	(101) /* 5  */
+#define IRQ_IOP13XX_RSVD_102	(102) /* 6  */
+#define IRQ_IOP13XX_TPMI0_OUT	(103) /* 7  */
+#define IRQ_IOP13XX_TPMI1_OUT	(104) /* 8  */
+#define IRQ_IOP13XX_TPMI2_OUT	(105) /* 9  */
+#define IRQ_IOP13XX_TPMI3_OUT	(106) /* 10 */
+#define IRQ_IOP13XX_ATUE_IMA	(107) /* 11 */
+#define IRQ_IOP13XX_ATUE_IMB	(108) /* 12 */
+#define IRQ_IOP13XX_ATUE_IMC	(109) /* 13 */
+#define IRQ_IOP13XX_ATUE_IMD	(110) /* 14 */
+#define IRQ_IOP13XX_MU_MSI_TB	(111) /* 15 */
+#define IRQ_IOP13XX_RSVD_112	(112) /* 16 */
+#define IRQ_IOP13XX_RSVD_113	(113) /* 17 */
+#define IRQ_IOP13XX_RSVD_114	(114) /* 18 */
+#define IRQ_IOP13XX_RSVD_115	(115) /* 19 */
+#define IRQ_IOP13XX_RSVD_116	(116) /* 20 */
+#define IRQ_IOP13XX_RSVD_117	(117) /* 21 */
+#define IRQ_IOP13XX_RSVD_118	(118) /* 22 */
+#define IRQ_IOP13XX_RSVD_119	(119) /* 23 */
+#define IRQ_IOP13XX_RSVD_120	(120) /* 24 */
+#define IRQ_IOP13XX_RSVD_121	(121) /* 25 */
+#define IRQ_IOP13XX_RSVD_122	(122) /* 26 */
+#define IRQ_IOP13XX_RSVD_123	(123) /* 27 */
+#define IRQ_IOP13XX_RSVD_124	(124) /* 28 */
+#define IRQ_IOP13XX_RSVD_125	(125) /* 29 */
+#define IRQ_IOP13XX_RSVD_126	(126) /* 30 */
+#define IRQ_IOP13XX_HPI	(127) /* 31 */
+
+#define NR_IOP13XX_IRQS	(IRQ_IOP13XX_HPI + 1)
+#define NR_IRQS		NR_IOP13XX_IRQS
+
+#endif /* _IOP13XX_IRQ_H_ */
Index: build_tree/linux/include/asm/arch-iop13xx/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,64 @@
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/arch/hardware.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+#define TASK_SIZE  	UL(0x3f000000)
+#define PAGE_OFFSET	UL(0x40000000)
+#define TASK_UNMAPPED_BASE ((TASK_SIZE + 0x01000000) / 3)
+
+#ifndef __ASSEMBLY__
+
+#if defined(CONFIG_ARCH_IOP13XX)
+#define IOP13XX_PMMR_V_START (IOP13XX_PMMR_VIRT_MEM_BASE)
+#define IOP13XX_PMMR_V_END   (IOP13XX_PMMR_VIRT_MEM_BASE + IOP13XX_PMMR_SIZE)
+#define IOP13XX_PMMR_P_START (IOP13XX_PMMR_PHYS_MEM_BASE)
+#define IOP13XX_PMMR_P_END   (IOP13XX_PMMR_PHYS_MEM_BASE + IOP13XX_PMMR_SIZE)
+
+/*
+ * Virtual view <-> PCI DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+
+/* RAM has 1:1 mapping on the PCIe/x Busses */
+#define __virt_to_bus(x)	(__virt_to_phys(x))
+#define __bus_to_virt(x)    (__phys_to_virt(x))
+
+#define virt_to_lbus(x) 					   \
+(( ((void*)(x) >= (void*)IOP13XX_PMMR_V_START) &&		   \
+((void*)(x) < (void*)IOP13XX_PMMR_V_END) ) ? 			   \
+((x) - IOP13XX_PMMR_VIRT_MEM_BASE + IOP13XX_PMMR_PHYS_MEM_BASE) : \
+((x) - PAGE_OFFSET + PHYS_OFFSET))
+
+#define lbus_to_virt(x)                                            \
+(( ((x) >= IOP13XX_PMMR_P_START) && ((x) < IOP13XX_PMMR_P_END) ) ? \
+((x) - IOP13XX_PMMR_PHYS_MEM_BASE + IOP13XX_PMMR_VIRT_MEM_BASE ) : \
+((x) - PHYS_OFFSET + PAGE_OFFSET))
+
+/* Device is an lbus device if it is on the platform bus of the IOP13XX */
+#define is_lbus_device(dev) (dev &&\
+			     (strncmp(dev->bus->name, "platform", 8) == 0))
+
+#define __arch_page_to_dma(dev, page)					\
+({is_lbus_device(dev) ? (dma_addr_t)virt_to_lbus(page_address(page)) : \
+(dma_addr_t)__virt_to_bus(page_address(page));})
+
+#define __arch_dma_to_virt(dev, addr) \
+({is_lbus_device(dev) ? lbus_to_virt(addr) : __bus_to_virt(addr);})
+
+#define __arch_virt_to_dma(dev, addr) \
+({is_lbus_device(dev) ? virt_to_lbus(addr) : __virt_to_bus(addr);})
+
+#endif /* CONFIG_ARCH_IOP13XX */
+#endif /* !ASSEMBLY */
+
+#define PFN_TO_NID(addr)	(0)
+
+#endif
Index: build_tree/linux/include/asm/arch-iop13xx/pci.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/pci.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/pci.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+#ifndef _IOP13XX_PCI_H_
+#define _IOP13XX_PCI_H_
+#include <asm/arch/irqs.h>
+#include <asm/io.h>
+
+struct pci_sys_data;
+struct hw_pci;
+int iop13xx_pci_setup(int nr, struct pci_sys_data *sys);
+struct pci_bus *iop13xx_scan_bus(int nr, struct pci_sys_data *);
+void iop13xx_atu_select(struct hw_pci *plat_pci);
+void iop13xx_pci_init(void);
+void iop13xx_map_pci_memory(void);
+
+#define IOP_PCI_STATUS_ERROR (PCI_STATUS_PARITY |	     \
+			       PCI_STATUS_SIG_TARGET_ABORT | \
+			       PCI_STATUS_REC_TARGET_ABORT | \
+			       PCI_STATUS_REC_TARGET_ABORT | \
+			       PCI_STATUS_REC_MASTER_ABORT | \
+			       PCI_STATUS_SIG_SYSTEM_ERROR | \
+	 		       PCI_STATUS_DETECTED_PARITY)
+
+#define IOP13XX_ATUE_ATUISR_ERROR (IOP13XX_ATUE_STAT_HALT_ON_ERROR |  \
+				    IOP13XX_ATUE_STAT_ROOT_SYS_ERR |   \
+				    IOP13XX_ATUE_STAT_PCI_IFACE_ERR |  \
+				    IOP13XX_ATUE_STAT_ERR_COR |	       \
+				    IOP13XX_ATUE_STAT_ERR_UNCOR |      \
+				    IOP13XX_ATUE_STAT_CRS |	       \
+				    IOP13XX_ATUE_STAT_DET_PAR_ERR |    \
+				    IOP13XX_ATUE_STAT_EXT_REC_MABORT | \
+				    IOP13XX_ATUE_STAT_SIG_TABORT |     \
+				    IOP13XX_ATUE_STAT_EXT_REC_TABORT | \
+				    IOP13XX_ATUE_STAT_MASTER_DATA_PAR)
+
+#define IOP13XX_ATUX_ATUISR_ERROR (IOP13XX_ATUX_STAT_TX_SCEM |        \
+				    IOP13XX_ATUX_STAT_REC_SCEM |       \
+				    IOP13XX_ATUX_STAT_TX_SERR |	       \
+				    IOP13XX_ATUX_STAT_DET_PAR_ERR |    \
+				    IOP13XX_ATUX_STAT_INT_REC_MABORT | \
+				    IOP13XX_ATUX_STAT_REC_SERR |       \
+				    IOP13XX_ATUX_STAT_EXT_REC_MABORT | \
+				    IOP13XX_ATUX_STAT_EXT_REC_TABORT | \
+				    IOP13XX_ATUX_STAT_EXT_SIG_TABORT | \
+				    IOP13XX_ATUX_STAT_MASTER_DATA_PAR)
+
+/* PCI interrupts
+ */
+#define ATUX_INTA IRQ_IOP13XX_XINT0
+#define ATUX_INTB IRQ_IOP13XX_XINT1
+#define ATUX_INTC IRQ_IOP13XX_XINT2
+#define ATUX_INTD IRQ_IOP13XX_XINT3
+
+#define ATUE_INTA IRQ_IOP13XX_ATUE_IMA
+#define ATUE_INTB IRQ_IOP13XX_ATUE_IMB
+#define ATUE_INTC IRQ_IOP13XX_ATUE_IMC
+#define ATUE_INTD IRQ_IOP13XX_ATUE_IMD
+
+#endif /* _IOP13XX_PCI_H_ */
Index: build_tree/linux/include/asm/arch-iop13xx/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/*
+ * linux/include/asm-arm/arch-iop13xx/system.h
+ *
+ *  Copyright (C) 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm/arch/iop13xx.h>
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+/* WDTCR CP6 R7 Page 9 */
+static inline u32 read_wdtcr(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c7, c9, 0":"=r" (val));
+	return val;
+}
+static inline void write_wdtcr(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c7, c9, 0"::"r" (val));
+}
+
+/* WDTSR CP6 R8 Page 9 */
+static inline u32 read_wdtsr(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c8, c9, 0":"=r" (val));
+	return val;
+}
+static inline void write_wdtsr(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c8, c9, 0"::"r" (val));
+}
+
+#define IOP13XX_WDTCR_EN_ARM	0x1e1e1e1e
+#define IOP13XX_WDTCR_EN	0xe1e1e1e1
+#define IOP13XX_WDTCR_DIS_ARM	0x1f1f1f1f
+#define IOP13XX_WDTCR_DIS	0xf1f1f1f1
+#define IOP13XX_WDTSR_WRITE_EN	(1 << 31)
+#define IOP13XX_WDTCR_IB_RESET	(1 << 0)
+static inline void arch_reset(char mode)
+{
+	/*
+	 * Reset the internal bus (warning both cores are reset)
+	 */
+	write_wdtcr(IOP13XX_WDTCR_EN_ARM);
+	write_wdtcr(IOP13XX_WDTCR_EN);
+	write_wdtsr(IOP13XX_WDTSR_WRITE_EN | IOP13XX_WDTCR_IB_RESET);
+	write_wdtcr(0x1000);
+
+	for(;;);
+}
Index: build_tree/linux/include/asm/arch-iop13xx/time.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/time.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/time.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,51 @@
+#ifndef _IOP13XX_TIME_H_
+#define _IOP13XX_TIME_H_
+#define IRQ_IOP_TIMER0 IRQ_IOP13XX_TIMER0
+
+#define IOP_TMR_EN	    0x02
+#define IOP_TMR_RELOAD	    0x04
+#define IOP_TMR_PRIVILEGED 0x08
+#define IOP_TMR_RATIO_1_1  0x00
+
+void iop_init_time(unsigned long tickrate);
+unsigned long iop_gettimeoffset(void);
+
+static inline void write_tmr0(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c0, c9, 0" : : "r" (val));
+}
+
+static inline void write_tmr1(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c1, c9, 0" : : "r" (val));
+}
+
+static inline u32 read_tcr0(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c2, c9, 0" : "=r" (val));
+	return val;
+}
+
+static inline u32 read_tcr1(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c3, c9, 0" : "=r" (val));
+	return val;
+}
+
+static inline void write_trr0(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c4, c9, 0" : : "r" (val));
+}
+
+static inline void write_trr1(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c5, c9, 0" : : "r" (val));
+}
+
+static inline void write_tisr(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c6, c9, 0" : : "r" (val));
+}
+#endif
Index: build_tree/linux/include/asm/arch-iop13xx/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,3 @@
+#include <asm/hardware.h>
+
+#define CLOCK_TICK_RATE (100 * HZ)
Index: build_tree/linux/include/asm/arch-iop13xx/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+#include <asm/types.h>
+#include <linux/serial_reg.h>
+#include <asm/hardware.h>
+#include <asm/processor.h>
+
+#define UART_BASE ((volatile u32 *)IOP13XX_UART1_PHYS)
+#define TX_DONE (UART_LSR_TEMT | UART_LSR_THRE)
+
+static inline void putc(char c)
+{
+	while ((UART_BASE[UART_LSR] & TX_DONE) != TX_DONE)
+		cpu_relax();
+	UART_BASE[UART_TX] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-iop13xx/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop13xx/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop13xx/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,4 @@
+#ifndef _VMALLOC_H_
+#define _VMALLOC_H_
+#define VMALLOC_END 	0xfa000000UL
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-iop32x/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * Copyright (C) 1994-1999 Russell King
+ * Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+		.macro	addruart, rx
+		mov	\rx, #0xfe000000	@ physical as well as virtual
+		orr	\rx, \rx, #0x00800000	@ location of the UART
+		.endm
+
+#define UART_SHIFT	0
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-iop32x/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-iop32x/dma.h
+ *
+ * Copyright (C) 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
Index: build_tree/linux/include/asm/arch-iop32x/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ * include/asm-arm/arch-iop32x/entry-macro.S
+ *
+ * Low-level IRQ helper macros for IOP32x-based platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/arch/iop32x.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro get_irqnr_preamble, base, tmp
+	mrc	p15, 0, \tmp, c15, c1, 0
+	orr	\tmp, \tmp, #(1 << 6)
+	mcr	p15, 0, \tmp, c15, c1, 0	@ Enable cp6 access
+	mrc	p15, 0, \tmp, c15, c1, 0
+	mov	\tmp, \tmp
+	sub	pc, pc, #4			@ cp_wait
+	.endm
+
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	mrc     p6, 0, \irqstat, c8, c0, 0	@ Read IINTSRC
+	cmp     \irqstat, #0
+	clzne   \irqnr, \irqstat
+	rsbne   \irqnr, \irqnr, #31
+	.endm
+
+	.macro arch_ret_to_user, tmp1, tmp2
+	mrc	p15, 0, \tmp1, c15, c1, 0
+	ands	\tmp2, \tmp1, #(1 << 6)
+	bicne	\tmp1, \tmp1, #(1 << 6)
+	mcrne	p15, 0, \tmp1, c15, c1, 0	@ Disable cp6 access
+	.endm
Index: build_tree/linux/include/asm/arch-iop32x/glantank.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/glantank.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/glantank.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,13 @@
+/*
+ * include/asm/arch-iop32x/glantank.h
+ *
+ * IO-Data GLAN Tank board registers
+ */
+
+#ifndef __GLANTANK_H
+#define __GLANTANK_H
+
+#define GLANTANK_UART		0xfe800000	/* UART */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,44 @@
+/*
+ * include/asm-arm/arch-iop32x/hardware.h
+ */
+
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <asm/types.h>
+
+/*
+ * Note about PCI IO space mappings
+ *
+ * To make IO space accesses efficient, we store virtual addresses in
+ * the IO resources.
+ *
+ * The PCI IO space is located at virtual 0xfe000000 from physical
+ * 0x90000000. The PCI BARs must be programmed with physical addresses,
+ * but when we read them, we convert them to virtual addresses. See
+ * arch/arm/plat-iop/pci.c.
+ */
+#define pcibios_assign_all_busses() 1
+#define PCIBIOS_MIN_IO		0x00000000
+#define PCIBIOS_MIN_MEM		0x00000000
+
+#ifndef __ASSEMBLY__
+void iop32x_init_irq(void);
+#endif
+
+
+/*
+ * Generic chipset bits
+ */
+#include "iop32x.h"
+
+/*
+ * Board specific bits
+ */
+#include "glantank.h"
+#include "iq80321.h"
+#include "iq31244.h"
+#include "n2100.h"
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ * include/asm-arm/arch-iop32x/io.h
+ *
+ * Copyright (C) 2001 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __IO_H
+#define __IO_H
+
+#include <asm/hardware.h>
+
+extern void __iomem * __ioremap(unsigned long, size_t, unsigned long);
+extern void __iomem *__iop3xx_ioremap(unsigned long cookie, size_t size,
+	unsigned long flags);
+extern void __iop3xx_iounmap(void __iomem *addr);
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define __io(p)		((void __iomem *)IOP3XX_PCI_IO_PHYS_TO_VIRT(p))
+#define __mem_pci(a)		(a)
+
+#define __arch_ioremap(a, s, f) __iop3xx_ioremap(a, s, f)
+#define __arch_iounmap(a)	 __iop3xx_iounmap(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/iop32x.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/iop32x.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/iop32x.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ * include/asm-arm/arch-iop32x/iop32x.h
+ *
+ * Intel IOP32X Chip definitions
+ *
+ * Author: Rory Bolt <rorybolt@pacbell.net>
+ * Copyright (C) 2002 Rory Bolt
+ * Copyright (C) 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __IOP32X_H
+#define __IOP32X_H
+
+/*
+ * Peripherals that are shared between the iop32x and iop33x but
+ * located at different addresses.
+ */
+#define IOP3XX_GPIO_REG(reg)	(IOP3XX_PERIPHERAL_VIRT_BASE + 0x07c4 + (reg))
+#define IOP3XX_TIMER_REG(reg)	(IOP3XX_PERIPHERAL_VIRT_BASE + 0x07e0 + (reg))
+
+#include <asm/hardware/iop3xx.h>
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/iq31244.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/iq31244.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/iq31244.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,17 @@
+/*
+ * include/asm-arm/arch-iop32x/iq31244.h
+ *
+ * Intel IQ31244 evaluation board registers
+ */
+
+#ifndef __IQ31244_H
+#define __IQ31244_H
+
+#define IQ31244_UART		0xfe800000	/* UART #1 */
+#define IQ31244_7SEG_1		0xfe840000	/* 7-Segment MSB */
+#define IQ31244_7SEG_0		0xfe850000	/* 7-Segment LSB (WO) */
+#define IQ31244_ROTARY_SW	0xfe8d0000	/* Rotary Switch */
+#define IQ31244_BATT_STAT	0xfe8f0000	/* Battery Status */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/iq80321.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/iq80321.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/iq80321.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,17 @@
+/*
+ * include/asm-arm/arch-iop32x/iq80321.h
+ *
+ * Intel IQ80321 evaluation board registers
+ */
+
+#ifndef __IQ80321_H
+#define __IQ80321_H
+
+#define IQ80321_UART		0xfe800000	/* UART #1 */
+#define IQ80321_7SEG_1		0xfe840000	/* 7-Segment MSB */
+#define IQ80321_7SEG_0		0xfe850000	/* 7-Segment LSB (WO) */
+#define IQ80321_ROTARY_SW	0xfe8d0000	/* Rotary Switch */
+#define IQ80321_BATT_STAT	0xfe8f0000	/* Battery Status */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,50 @@
+/*
+ * include/asm-arm/arch-iop32x/irqs.h
+ *
+ * Author:	Rory Bolt <rorybolt@pacbell.net>
+ * Copyright:	(C) 2002 Rory Bolt
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __IRQS_H
+#define __IRQS_H
+
+/*
+ * IOP80321 chipset interrupts
+ */
+#define IRQ_IOP32X_DMA0_EOT	0
+#define IRQ_IOP32X_DMA0_EOC	1
+#define IRQ_IOP32X_DMA1_EOT	2
+#define IRQ_IOP32X_DMA1_EOC	3
+#define IRQ_IOP32X_AA_EOT	6
+#define IRQ_IOP32X_AA_EOC	7
+#define IRQ_IOP32X_CORE_PMON	8
+#define IRQ_IOP32X_TIMER0	9
+#define IRQ_IOP32X_TIMER1	10
+#define IRQ_IOP32X_I2C_0	11
+#define IRQ_IOP32X_I2C_1	12
+#define IRQ_IOP32X_MESSAGING	13
+#define IRQ_IOP32X_ATU_BIST	14
+#define IRQ_IOP32X_PERFMON	15
+#define IRQ_IOP32X_CORE_PMU	16
+#define IRQ_IOP32X_BIU_ERR	17
+#define IRQ_IOP32X_ATU_ERR	18
+#define IRQ_IOP32X_MCU_ERR	19
+#define IRQ_IOP32X_DMA0_ERR	20
+#define IRQ_IOP32X_DMA1_ERR	21
+#define IRQ_IOP32X_AA_ERR	23
+#define IRQ_IOP32X_MSG_ERR	24
+#define IRQ_IOP32X_SSP		25
+#define IRQ_IOP32X_XINT0	27
+#define IRQ_IOP32X_XINT1	28
+#define IRQ_IOP32X_XINT2	29
+#define IRQ_IOP32X_XINT3	30
+#define IRQ_IOP32X_HPI		31
+
+#define NR_IRQS			32
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-iop32x/memory.h
+ */
+
+#ifndef __MEMORY_H
+#define __MEMORY_H
+
+#include <asm/hardware.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0xa0000000)
+
+/*
+ * Virtual view <-> PCI DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	(((__virt_to_phys(x)) & ~(*IOP3XX_IATVR2)) | ((*IOP3XX_IABAR2) & 0xfffffff0))
+#define __bus_to_virt(x)	(__phys_to_virt(((x) & ~(*IOP3XX_IALR2)) | ( *IOP3XX_IATVR2)))
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/n2100.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/n2100.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/n2100.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,19 @@
+/*
+ * include/asm/arch-iop32x/n2100.h
+ *
+ * Thecus N2100 board registers
+ */
+
+#ifndef __N2100_H
+#define __N2100_H
+
+#define N2100_UART		0xfe800000	/* UART */
+
+#define N2100_COPY_BUTTON	IOP3XX_GPIO_LINE(0)
+#define N2100_PCA9532_RESET	IOP3XX_GPIO_LINE(2)
+#define N2100_RESET_BUTTON	IOP3XX_GPIO_LINE(3)
+#define N2100_HARDWARE_RESET	IOP3XX_GPIO_LINE(4)
+#define N2100_POWER_BUTTON	IOP3XX_GPIO_LINE(5)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-iop32x/system.h
+ *
+ * Copyright (C) 2001 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/mach-types.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	local_irq_disable();
+
+	if (machine_is_n2100()) {
+		gpio_line_set(N2100_HARDWARE_RESET, GPIO_LOW);
+		gpio_line_config(N2100_HARDWARE_RESET, GPIO_OUT);
+		while (1)
+			;
+	}
+
+	*IOP3XX_PCSR = 0x30;
+
+	/* Jump into ROM at address 0 */
+	cpu_reset(0);
+}
Index: build_tree/linux/include/asm/arch-iop32x/time.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/time.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/time.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,4 @@
+#ifndef _IOP32X_TIME_H_
+#define _IOP32X_TIME_H_
+#define IRQ_IOP_TIMER0 IRQ_IOP32X_TIMER0
+#endif
Index: build_tree/linux/include/asm/arch-iop32x/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-iop32x/timex.h
+ *
+ * IOP32x architecture timex specifications
+ */
+
+#include <asm/hardware.h>
+
+#define CLOCK_TICK_RATE		(100 * HZ)
Index: build_tree/linux/include/asm/arch-iop32x/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-iop32x/uncompress.h
+ */
+
+#include <asm/types.h>
+#include <asm/mach-types.h>
+#include <linux/serial_reg.h>
+#include <asm/hardware.h>
+
+static volatile u8 *uart_base;
+
+#define TX_DONE		(UART_LSR_TEMT | UART_LSR_THRE)
+
+static inline void putc(char c)
+{
+	while ((uart_base[UART_LSR] & TX_DONE) != TX_DONE)
+		barrier();
+	uart_base[UART_TX] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+static __inline__ void __arch_decomp_setup(unsigned long arch_id)
+{
+	if (machine_is_iq80321())
+		uart_base = (volatile u8 *)IQ80321_UART;
+	else if (machine_is_iq31244())
+		uart_base = (volatile u8 *)IQ31244_UART;
+	else
+		uart_base = (volatile u8 *)0xfe800000;
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()	__arch_decomp_setup(arch_id)
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-iop32x/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop32x/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop32x/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,5 @@
+/*
+ * include/asm-arm/arch-iop32x/vmalloc.h
+ */
+
+#define VMALLOC_END	0xfe000000
Index: build_tree/linux/include/asm/arch-iop33x/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ * include/asm-arm/arch-iop33x/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * Copyright (C) 1994-1999 Russell King
+ * Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+		.macro	addruart, rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ mmu enabled?
+		moveq	\rx, #0xff000000	@ physical
+		movne	\rx, #0xfe000000	@ virtual
+		orr	\rx, \rx, #0x00ff0000
+		orr	\rx, \rx, #0x0000f700
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-iop33x/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-iop33x/dma.h
+ *
+ * Copyright (C) 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
Index: build_tree/linux/include/asm/arch-iop33x/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-iop33x/entry-macro.S
+ *
+ * Low-level IRQ helper macros for IOP33x-based platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/arch/iop33x.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro get_irqnr_preamble, base, tmp
+	mrc	p15, 0, \tmp, c15, c1, 0
+	orr	\tmp, \tmp, #(1 << 6)
+	mcr	p15, 0, \tmp, c15, c1, 0	@ Enable cp6 access
+	mrc	p15, 0, \tmp, c15, c1, 0
+	mov	\tmp, \tmp
+	sub	pc, pc, #4			@ cp_wait
+	.endm
+
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	mrc     p6, 0, \irqstat, c14, c0, 0     @ Read IINTVEC
+	cmp     \irqstat, #0
+	mrceq   p6, 0, \irqstat, c14, c0, 0     @ erratum 63 workaround
+	adds    \irqnr, \irqstat, #1
+	movne   \irqnr, \irqstat, lsr #2
+	.endm
+
+	.macro arch_ret_to_user, tmp1, tmp2
+	mrc	p15, 0, \tmp1, c15, c1, 0
+	ands	\tmp2, \tmp1, #(1 << 6)
+	bicne	\tmp1, \tmp1, #(1 << 6)
+	mcrne	p15, 0, \tmp1, c15, c1, 0	@ Disable cp6 access
+	.endm
Index: build_tree/linux/include/asm/arch-iop33x/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/*
+ * include/asm-arm/arch-iop33x/hardware.h
+ */
+
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <asm/types.h>
+
+/*
+ * Note about PCI IO space mappings
+ *
+ * To make IO space accesses efficient, we store virtual addresses in
+ * the IO resources.
+ *
+ * The PCI IO space is located at virtual 0xfe000000 from physical
+ * 0x90000000.  The PCI BARs must be programmed with physical addresses,
+ * but when we read them, we convert them to virtual addresses.  See
+ * arch/arm/mach-iop3xx/iop3xx-pci.c
+ */
+#define pcibios_assign_all_busses()	1
+#define PCIBIOS_MIN_IO		0x00000000
+#define PCIBIOS_MIN_MEM		0x00000000
+
+#ifndef __ASSEMBLY__
+void iop33x_init_irq(void);
+
+extern struct platform_device iop33x_uart0_device;
+extern struct platform_device iop33x_uart1_device;
+#endif
+
+
+/*
+ * Generic chipset bits
+ *
+ */
+#include "iop33x.h"
+
+/*
+ * Board specific bits
+ */
+#include "iq80331.h"
+#include "iq80332.h"
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ * include/asm-arm/arch-iop33x/io.h
+ *
+ * Copyright (C) 2001  MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __IO_H
+#define __IO_H
+
+#include <asm/hardware.h>
+
+extern void __iomem * __ioremap(unsigned long, size_t, unsigned long);
+extern void __iomem *__iop3xx_ioremap(unsigned long cookie, size_t size,
+	unsigned long flags);
+extern void __iop3xx_iounmap(void __iomem *addr);
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define __io(p)		((void __iomem *)IOP3XX_PCI_IO_PHYS_TO_VIRT(p))
+#define __mem_pci(a)		(a)
+
+#define __arch_ioremap(a, s, f) __iop3xx_ioremap(a, s, f)
+#define __arch_iounmap(a)	 __iop3xx_iounmap(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/iop33x.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/iop33x.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/iop33x.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-iop33x/iop33x.h
+ *
+ * Intel IOP33X Chip definitions
+ *
+ * Author: Dave Jiang (dave.jiang@intel.com)
+ * Copyright (C) 2003, 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __IOP33X_H
+#define __IOP33X_H
+
+/*
+ * Peripherals that are shared between the iop32x and iop33x but
+ * located at different addresses.
+ */
+#define IOP3XX_GPIO_REG(reg)	(IOP3XX_PERIPHERAL_VIRT_BASE + 0x1780 + (reg))
+#define IOP3XX_TIMER_REG(reg)	(IOP3XX_PERIPHERAL_VIRT_BASE + 0x07d0 + (reg))
+
+#include <asm/hardware/iop3xx.h>
+
+/* UARTs  */
+#define IOP33X_UART0_PHYS	(IOP3XX_PERIPHERAL_PHYS_BASE + 0x1700)
+#define IOP33X_UART0_VIRT	(IOP3XX_PERIPHERAL_VIRT_BASE + 0x1700)
+#define IOP33X_UART1_PHYS	(IOP3XX_PERIPHERAL_PHYS_BASE + 0x1740)
+#define IOP33X_UART1_VIRT	(IOP3XX_PERIPHERAL_VIRT_BASE + 0x1740)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/iq80331.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/iq80331.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/iq80331.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+/*
+ * include/asm-arm/arch-iop33x/iq80331.h
+ *
+ * Intel IQ80331 evaluation board registers
+ */
+
+#ifndef __IQ80331_H
+#define __IQ80331_H
+
+#define IQ80331_7SEG_1		0xce840000	/* 7-Segment MSB */
+#define IQ80331_7SEG_0		0xce850000	/* 7-Segment LSB (WO) */
+#define IQ80331_ROTARY_SW	0xce8d0000	/* Rotary Switch */
+#define IQ80331_BATT_STAT	0xce8f0000	/* Battery Status */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/iq80332.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/iq80332.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/iq80332.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+/*
+ * include/asm-arm/arch-iop33x/iq80332.h
+ *
+ * Intel IQ80332 evaluation board registers
+ */
+
+#ifndef __IQ80332_H
+#define __IQ80332_H
+
+#define IQ80332_7SEG_1		0xce840000	/* 7-Segment MSB */
+#define IQ80332_7SEG_0		0xce850000	/* 7-Segment LSB (WO) */
+#define IQ80332_ROTARY_SW	0xce8d0000	/* Rotary Switch */
+#define IQ80332_BATT_STAT	0xce8f0000	/* Battery Status */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,60 @@
+/*
+ * include/asm-arm/arch-iop33x/irqs.h
+ *
+ * Author:	Dave Jiang (dave.jiang@intel.com)
+ * Copyright:	(C) 2003 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __IRQS_H
+#define __IRQS_H
+
+/*
+ * IOP80331 chipset interrupts
+ */
+#define IRQ_IOP33X_DMA0_EOT	0
+#define IRQ_IOP33X_DMA0_EOC	1
+#define IRQ_IOP33X_DMA1_EOT	2
+#define IRQ_IOP33X_DMA1_EOC	3
+#define IRQ_IOP33X_AA_EOT	6
+#define IRQ_IOP33X_AA_EOC	7
+#define IRQ_IOP33X_TIMER0	8
+#define IRQ_IOP33X_TIMER1	9
+#define IRQ_IOP33X_I2C_0	10
+#define IRQ_IOP33X_I2C_1	11
+#define IRQ_IOP33X_MSG		12
+#define IRQ_IOP33X_MSGIBQ	13
+#define IRQ_IOP33X_ATU_BIST	14
+#define IRQ_IOP33X_PERFMON	15
+#define IRQ_IOP33X_CORE_PMU	16
+#define IRQ_IOP33X_XINT0	24
+#define IRQ_IOP33X_XINT1	25
+#define IRQ_IOP33X_XINT2	26
+#define IRQ_IOP33X_XINT3	27
+#define IRQ_IOP33X_XINT8	32
+#define IRQ_IOP33X_XINT9	33
+#define IRQ_IOP33X_XINT10	34
+#define IRQ_IOP33X_XINT11	35
+#define IRQ_IOP33X_XINT12	36
+#define IRQ_IOP33X_XINT13	37
+#define IRQ_IOP33X_XINT14	38
+#define IRQ_IOP33X_XINT15	39
+#define IRQ_IOP33X_UART0	51
+#define IRQ_IOP33X_UART1	52
+#define IRQ_IOP33X_PBIE		53
+#define IRQ_IOP33X_ATU_CRW	54
+#define IRQ_IOP33X_ATU_ERR	55
+#define IRQ_IOP33X_MCU_ERR	56
+#define IRQ_IOP33X_DMA0_ERR	57
+#define IRQ_IOP33X_DMA1_ERR	58
+#define IRQ_IOP33X_AA_ERR	60
+#define IRQ_IOP33X_MSG_ERR	62
+#define IRQ_IOP33X_HPI		63
+
+#define NR_IRQS			64
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-iop33x/memory.h
+ */
+
+#ifndef __MEMORY_H
+#define __MEMORY_H
+
+#include <asm/hardware.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+
+/*
+ * Virtual view <-> PCI DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	(((__virt_to_phys(x)) & ~(*IOP3XX_IATVR2)) | ((*IOP3XX_IABAR2) & 0xfffffff0))
+#define __bus_to_virt(x)	(__phys_to_virt(((x) & ~(*IOP3XX_IALR2)) | ( *IOP3XX_IATVR2)))
+
+
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/*
+ * include/asm-arm/arch-iop33x/system.h
+ *
+ * Copyright (C) 2001 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	*IOP3XX_PCSR = 0x30;
+
+	/* Jump into ROM at address 0 */
+	cpu_reset(0);
+}
Index: build_tree/linux/include/asm/arch-iop33x/time.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/time.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/time.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,4 @@
+#ifndef _IOP33X_TIME_H_
+#define _IOP33X_TIME_H_
+#define IRQ_IOP_TIMER0 IRQ_IOP33X_TIMER0
+#endif
Index: build_tree/linux/include/asm/arch-iop33x/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-iop33x/timex.h
+ *
+ * IOP3xx architecture timex specifications
+ */
+
+#include <asm/hardware.h>
+
+#define CLOCK_TICK_RATE		(100 * HZ)
Index: build_tree/linux/include/asm/arch-iop33x/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-iop33x/uncompress.h
+ */
+
+#include <asm/types.h>
+#include <asm/mach-types.h>
+#include <linux/serial_reg.h>
+#include <asm/hardware.h>
+
+static volatile u32 *uart_base;
+
+#define TX_DONE		(UART_LSR_TEMT | UART_LSR_THRE)
+
+static inline void putc(char c)
+{
+	while ((uart_base[UART_LSR] & TX_DONE) != TX_DONE)
+		barrier();
+	uart_base[UART_TX] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+static __inline__ void __arch_decomp_setup(unsigned long arch_id)
+{
+	if (machine_is_iq80331() || machine_is_iq80332())
+		uart_base = (volatile u32 *)IOP33X_UART0_PHYS;
+	else
+		uart_base = (volatile u32 *)0xfe800000;
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()	__arch_decomp_setup(arch_id)
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-iop33x/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-iop33x/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-iop33x/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,5 @@
+/*
+ * include/asm-arm/arch-iop33x/vmalloc.h
+ */
+
+#define VMALLOC_END	0xfe000000
Index: build_tree/linux/include/asm/arch-ixp2000/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,27 @@
+/* linux/include/asm-arm/arch-ixp2000/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro  addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0xc0000000	@ Physical base
+		movne	\rx, #0xfe000000	@ virtual base
+		orrne	\rx, \rx, #0x00f00000
+		orr	\rx, \rx, #0x00030000
+#ifdef	__ARMEB__
+		orr	\rx, \rx, #0x00000003
+#endif
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-ixp2000/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,9 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/dma.h
+ *
+ * Copyright (C) 2002 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
Index: build_tree/linux/include/asm/arch-ixp2000/enp2611.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/enp2611.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/enp2611.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/*
+ * include/asm-arm/arch-ixp2000/enp2611.h
+ *
+ * Register and other defines for Radisys ENP-2611
+ *
+ * Created 2004 by Lennert Buytenhek from the ixdp2x01 code.  The
+ * original version carries the following notices:
+ *
+ * Original Author: Naeem Afzal <naeem.m.afzal@intel.com>
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002 Intel Corp.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __ENP2611_H
+#define __ENP2611_H
+
+#define ENP2611_CALEB_PHYS_BASE		0xc5000000
+#define ENP2611_CALEB_VIRT_BASE		0xfe000000
+#define ENP2611_CALEB_SIZE		0x00100000
+
+#define ENP2611_PM3386_0_PHYS_BASE	0xc6000000
+#define ENP2611_PM3386_0_VIRT_BASE	0xfe100000
+#define ENP2611_PM3386_0_SIZE		0x00100000
+
+#define ENP2611_PM3386_1_PHYS_BASE	0xc6400000
+#define ENP2611_PM3386_1_VIRT_BASE	0xfe200000
+#define ENP2611_PM3386_1_SIZE		0x00100000
+
+#define ENP2611_GPIO_SCL		7
+#define ENP2611_GPIO_SDA		6
+
+#define IRQ_ENP2611_THERMAL		IRQ_IXP2000_GPIO4
+#define IRQ_ENP2611_OPTION_BOARD	IRQ_IXP2000_GPIO3
+#define IRQ_ENP2611_CALEB		IRQ_IXP2000_GPIO2
+#define IRQ_ENP2611_PM3386_1		IRQ_IXP2000_GPIO1
+#define IRQ_ENP2611_PM3386_0		IRQ_IXP2000_GPIO0
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp2000/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,60 @@
+/*
+ * include/asm-arm/arch-ixp2000/entry-macro.S
+ *
+ * Low-level IRQ helper macros for IXP2000-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/arch/irqs.h>
+
+		.macro  disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		mov	\irqnr, #0x0              @clear out irqnr as default
+                mov	\base, #0xfe000000
+		orr	\base, \base, #0x00e00000
+		orr	\base, \base, #0x08
+		ldr	\irqstat, [\base]         @ get interrupts
+
+		cmp	\irqstat, #0
+		beq	1001f
+
+		clz     \irqnr, \irqstat
+		mov     \base, #31
+		subs    \irqnr, \base, \irqnr
+
+		/*
+		 * We handle PCIA and PCIB here so we don't have an
+		 * extra layer of code just to check these two bits.
+		 */
+		cmp	\irqnr, #IRQ_IXP2000_PCI
+		bne	1001f
+
+		mov	\base, #0xfe000000
+		orr	\base, \base, #0x00c00000
+		orr	\base, \base, #0x00000100
+		orr	\base, \base, #0x00000058
+		ldr	\irqstat, [\base]
+
+		mov	\tmp, #(1<<26)
+		tst	\irqstat, \tmp
+		movne	\irqnr, #IRQ_IXP2000_PCIA
+		bne	1001f
+
+		mov	\tmp, #(1<<27)
+		tst	\irqstat, \tmp
+		movne	\irqnr, #IRQ_IXP2000_PCIB
+
+1001:
+		.endm
+
Index: build_tree/linux/include/asm/arch-ixp2000/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,48 @@
+/*
+ * include/asm-arm/arch-ixp2000/gpio.h
+ *
+ * Copyright (C) 2002 Intel Corporation.
+ *
+ * This program is free software, you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * IXP2000 GPIO in/out, edge/level detection for IRQs:
+ * IRQs are generated on Falling-edge, Rising-Edge, Level-low, Level-High
+ * or both Falling-edge and Rising-edge.  
+ * This must be called *before* the corresponding IRQ is registerd.
+ * Use this instead of directly setting the GPIO registers.
+ * GPIOs may also be used as GPIOs (e.g. for emulating i2c/smb)
+ */
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#ifndef __ASSEMBLY__
+
+#define GPIO_IN				0
+#define GPIO_OUT			1
+
+#define IXP2000_GPIO_LOW		0
+#define IXP2000_GPIO_HIGH		1
+
+extern void gpio_line_config(int line, int direction);
+
+static inline int gpio_line_get(int line)
+{
+	return (((*IXP2000_GPIO_PLR) >> line) & 1);
+}
+
+static inline void gpio_line_set(int line, int value)
+{
+	if (value == IXP2000_GPIO_HIGH) {
+		ixp2000_reg_write(IXP2000_GPIO_POSR, 1 << line);
+	} else if (value == IXP2000_GPIO_LOW) {
+		ixp2000_reg_write(IXP2000_GPIO_POCR, 1 << line);
+	}
+}
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* ASM_ARCH_IXP2000_GPIO_H_ */
Index: build_tree/linux/include/asm/arch-ixp2000/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,44 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/hardware.h
+ *
+ * Hardware definitions for IXP2400/2800 based systems
+ *
+ * Original Author: Naeem M Afzal <naeem.m.afzal@intel.com>
+ *
+ * Maintainer: Deepak Saxena <dsaxena@mvista.com>
+ *
+ * Copyright (C) 2001-2002 Intel Corp.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#define __ASM_ARCH_HARDWARE_H__
+
+/*
+ * This needs to be platform-specific?
+ */
+#define PCIBIOS_MIN_IO          0x00000000
+#define PCIBIOS_MIN_MEM         0x00000000
+
+#include "ixp2000-regs.h"	/* Chipset Registers */
+
+#define pcibios_assign_all_busses() 0
+
+/*
+ * Platform helper functions
+ */
+#include "platform.h"
+
+/*
+ * Platform-specific bits
+ */
+#include "enp2611.h"		/* ENP-2611 */
+#include "ixdp2x00.h"		/* IXDP2400/2800 */
+#include "ixdp2x01.h"		/* IXDP2401/2801 */
+
+#endif  /* _ASM_ARCH_HARDWARE_H__ */
Index: build_tree/linux/include/asm/arch-ixp2000/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,134 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/io.h
+ *
+ * Original Author: Naeem M Afzal <naeem.m.afzal@intel.com>
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002  Intel Corp.
+ * Copyrgiht (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define __mem_pci(a)		(a)
+
+/*
+ * The A? revisions of the IXP2000s assert byte lanes for PCI I/O
+ * transactions the other way round (MEM transactions don't have this
+ * issue), so if we want to support those models, we need to override
+ * the standard I/O functions.
+ *
+ * B0 and later have a bit that can be set to 1 to get the proper
+ * behavior for I/O transactions, which then allows us to use the
+ * standard I/O functions.  This is what we do if the user does not
+ * explicitly ask for support for pre-B0.
+ */
+#ifdef CONFIG_IXP2000_SUPPORT_BROKEN_PCI_IO
+#define ___io(p)		((void __iomem *)((p)+IXP2000_PCI_IO_VIRT_BASE))
+
+#define alignb(addr)		(void __iomem *)((unsigned long)(addr) ^ 3)
+#define alignw(addr)		(void __iomem *)((unsigned long)(addr) ^ 2)
+
+#define outb(v,p)		__raw_writeb((v),alignb(___io(p)))
+#define outw(v,p)		__raw_writew((v),alignw(___io(p)))
+#define outl(v,p)		__raw_writel((v),___io(p))
+
+#define inb(p)		({ unsigned int __v = __raw_readb(alignb(___io(p))); __v; })
+#define inw(p)		\
+	({ unsigned int __v = (__raw_readw(alignw(___io(p)))); __v; })
+#define inl(p)		\
+	({ unsigned int __v = (__raw_readl(___io(p))); __v; })
+
+#define outsb(p,d,l)		__raw_writesb(alignb(___io(p)),d,l)
+#define outsw(p,d,l)		__raw_writesw(alignw(___io(p)),d,l)
+#define outsl(p,d,l)		__raw_writesl(___io(p),d,l)
+
+#define insb(p,d,l)		__raw_readsb(alignb(___io(p)),d,l)
+#define insw(p,d,l)		__raw_readsw(alignw(___io(p)),d,l)
+#define insl(p,d,l)		__raw_readsl(___io(p),d,l)
+
+#define __is_io_address(p)	((((unsigned long)(p)) & ~(IXP2000_PCI_IO_SIZE - 1)) == IXP2000_PCI_IO_VIRT_BASE)
+
+#define ioread8(p)						\
+	({							\
+		unsigned int __v;				\
+								\
+		if (__is_io_address(p)) {			\
+			__v = __raw_readb(alignb(p));		\
+		} else {					\
+			__v = __raw_readb(p);			\
+		}						\
+								\
+		__v;						\
+	})							\
+
+#define ioread16(p)						\
+	({							\
+		unsigned int __v;				\
+								\
+		if (__is_io_address(p)) {			\
+			__v = __raw_readw(alignw(p));		\
+		} else {					\
+			__v = le16_to_cpu(__raw_readw(p));	\
+		}						\
+								\
+		__v;						\
+	})
+
+#define ioread32(p)						\
+	({							\
+		unsigned int __v;				\
+								\
+		if (__is_io_address(p)) {			\
+			__v = __raw_readl(p);			\
+		} else {					\
+			__v = le32_to_cpu(__raw_readl(p));	\
+		}						\
+								\
+		 __v;						\
+	})
+
+#define iowrite8(v,p)						\
+	({							\
+		if (__is_io_address(p)) {			\
+			__raw_writeb((v), alignb(p));		\
+		} else {					\
+			__raw_writeb((v), p);			\
+		}						\
+	})
+
+#define iowrite16(v,p)						\
+	({							\
+		if (__is_io_address(p)) {			\
+			__raw_writew((v), alignw(p));		\
+		} else {					\
+			__raw_writew(cpu_to_le16(v), p);	\
+		}						\
+	})
+
+#define iowrite32(v,p)						\
+	({							\
+		if (__is_io_address(p)) {			\
+			__raw_writel((v), p);			\
+		} else {					\
+			__raw_writel(cpu_to_le32(v), p);	\
+		}						\
+	})
+
+#define ioport_map(port, nr)	___io(port)
+
+#define ioport_unmap(addr)
+#else
+#define __io(p)			((void __iomem *)((p)+IXP2000_PCI_IO_VIRT_BASE))
+#endif
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp2000/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,207 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/irqs.h
+ *
+ * Original Author: Naeem Afzal <naeem.m.afzal@intel.com>
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002 Intel Corp.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _IRQS_H
+#define _IRQS_H
+
+/*
+ * Do NOT add #ifdef MACHINE_FOO in here.
+ * Simpy add your machine IRQs here and increase NR_IRQS if needed to
+ * hold your machine's IRQ table.
+ */
+
+/*
+ * Some interrupt numbers go unused b/c the IRQ mask/ummask/status
+ * register has those bit reserved. We just mark those interrupts
+ * as invalid and this allows us to do mask/unmask with a single
+ * shift operation instead of having to map the IRQ number to
+ * a HW IRQ number.
+ */
+#define	IRQ_IXP2000_SOFT_INT		0 /* soft interrupt */
+#define	IRQ_IXP2000_ERRSUM		1 /* OR of all bits in ErrorStatus reg*/
+#define	IRQ_IXP2000_UART		2
+#define	IRQ_IXP2000_GPIO		3
+#define	IRQ_IXP2000_TIMER1     		4
+#define	IRQ_IXP2000_TIMER2     		5
+#define	IRQ_IXP2000_TIMER3     		6
+#define	IRQ_IXP2000_TIMER4     		7
+#define	IRQ_IXP2000_PMU        		8               
+#define	IRQ_IXP2000_SPF        		9  /* Slow port framer IRQ */
+#define	IRQ_IXP2000_DMA1      		10
+#define	IRQ_IXP2000_DMA2      		11
+#define	IRQ_IXP2000_DMA3      		12
+#define	IRQ_IXP2000_PCI_DOORBELL	13
+#define	IRQ_IXP2000_ME_ATTN       	14 
+#define	IRQ_IXP2000_PCI   		15 /* PCI INTA or INTB */
+#define	IRQ_IXP2000_THDA0   		16 /* thread 0-31A */
+#define	IRQ_IXP2000_THDA1  		17 /* thread 32-63A, IXP2800 only */
+#define	IRQ_IXP2000_THDA2		18 /* thread 64-95A */
+#define	IRQ_IXP2000_THDA3 		19 /* thread 96-127A, IXP2800 only */
+#define	IRQ_IXP2000_THDB0		24 /* thread 0-31B */
+#define	IRQ_IXP2000_THDB1		25 /* thread 32-63B, IXP2800 only */
+#define	IRQ_IXP2000_THDB2		26 /* thread 64-95B */
+#define	IRQ_IXP2000_THDB3		27 /* thread 96-127B, IXP2800 only */
+
+/* define generic GPIOs */
+#define IRQ_IXP2000_GPIO0		32
+#define IRQ_IXP2000_GPIO1		33
+#define IRQ_IXP2000_GPIO2		34
+#define IRQ_IXP2000_GPIO3		35
+#define IRQ_IXP2000_GPIO4		36
+#define IRQ_IXP2000_GPIO5		37
+#define IRQ_IXP2000_GPIO6		38
+#define IRQ_IXP2000_GPIO7		39
+
+/* split off the 2 PCI sources */
+#define IRQ_IXP2000_PCIA		40
+#define IRQ_IXP2000_PCIB		41
+
+/* Int sources from IRQ_ERROR_STATUS */
+#define IRQ_IXP2000_DRAM0_MIN_ERR	42
+#define IRQ_IXP2000_DRAM0_MAJ_ERR	43
+#define IRQ_IXP2000_DRAM1_MIN_ERR	44
+#define IRQ_IXP2000_DRAM1_MAJ_ERR	45
+#define IRQ_IXP2000_DRAM2_MIN_ERR	46
+#define IRQ_IXP2000_DRAM2_MAJ_ERR	47
+/* 48-57 reserved */
+#define IRQ_IXP2000_SRAM0_ERR		58
+#define IRQ_IXP2000_SRAM1_ERR		59
+#define IRQ_IXP2000_SRAM2_ERR		60
+#define IRQ_IXP2000_SRAM3_ERR		61
+/* 62-65 reserved */
+#define IRQ_IXP2000_MEDIA_ERR		66
+#define IRQ_IXP2000_PCI_ERR			67
+#define IRQ_IXP2000_SP_INT			68
+
+#define NR_IXP2000_IRQS				69
+
+#define	IXP2000_BOARD_IRQ(x)		(NR_IXP2000_IRQS + (x))
+
+#define	IXP2000_BOARD_IRQ_MASK(irq)	(1 << (irq - NR_IXP2000_IRQS))	
+
+#define IXP2000_ERR_IRQ_MASK(irq) ( 1 << (irq - IRQ_IXP2000_DRAM0_MIN_ERR))
+#define IXP2000_VALID_ERR_IRQ_MASK (\
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_DRAM0_MIN_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_DRAM0_MAJ_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_DRAM1_MIN_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_DRAM1_MAJ_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_DRAM2_MIN_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_DRAM2_MAJ_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_SRAM0_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_SRAM1_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_SRAM2_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_SRAM3_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_MEDIA_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_PCI_ERR) | \
+		IXP2000_ERR_IRQ_MASK(IRQ_IXP2000_SP_INT)	)
+
+/*
+ * This allows for all the on-chip sources plus up to 32 CPLD based
+ * IRQs. Should be more than enough.
+ */
+#define	IXP2000_BOARD_IRQS		32
+#define NR_IRQS				(NR_IXP2000_IRQS + IXP2000_BOARD_IRQS)
+
+
+/* 
+ * IXDP2400 specific IRQs
+ */
+#define	IRQ_IXDP2400_INGRESS_NPU	IXP2000_BOARD_IRQ(0) 
+#define	IRQ_IXDP2400_ENET		IXP2000_BOARD_IRQ(1) 
+#define	IRQ_IXDP2400_MEDIA_PCI		IXP2000_BOARD_IRQ(2) 
+#define	IRQ_IXDP2400_MEDIA_SP		IXP2000_BOARD_IRQ(3) 
+#define	IRQ_IXDP2400_SF_PCI		IXP2000_BOARD_IRQ(4) 
+#define	IRQ_IXDP2400_SF_SP		IXP2000_BOARD_IRQ(5) 
+#define	IRQ_IXDP2400_PMC		IXP2000_BOARD_IRQ(6) 
+#define	IRQ_IXDP2400_TVM		IXP2000_BOARD_IRQ(7) 
+
+#define	NR_IXDP2400_IRQS		((IRQ_IXDP2400_TVM)+1)  
+#define	IXDP2400_NR_IRQS		NR_IXDP2400_IRQS - NR_IXP2000_IRQS
+
+/* IXDP2800 specific IRQs */
+#define IRQ_IXDP2800_EGRESS_ENET	IXP2000_BOARD_IRQ(0)
+#define IRQ_IXDP2800_INGRESS_NPU	IXP2000_BOARD_IRQ(1)
+#define IRQ_IXDP2800_PMC		IXP2000_BOARD_IRQ(2)
+#define IRQ_IXDP2800_FABRIC_PCI		IXP2000_BOARD_IRQ(3)
+#define IRQ_IXDP2800_FABRIC		IXP2000_BOARD_IRQ(4)
+#define IRQ_IXDP2800_MEDIA		IXP2000_BOARD_IRQ(5)
+
+#define	NR_IXDP2800_IRQS		((IRQ_IXDP2800_MEDIA)+1)
+#define	IXDP2800_NR_IRQS		NR_IXDP2800_IRQS - NR_IXP2000_IRQS
+
+/* 
+ * IRQs on both IXDP2x01 boards
+ */
+#define IRQ_IXDP2X01_SPCI_DB_0		IXP2000_BOARD_IRQ(2)
+#define IRQ_IXDP2X01_SPCI_DB_1		IXP2000_BOARD_IRQ(3)
+#define IRQ_IXDP2X01_SPCI_PMC_INTA	IXP2000_BOARD_IRQ(4)
+#define IRQ_IXDP2X01_SPCI_PMC_INTB	IXP2000_BOARD_IRQ(5)
+#define IRQ_IXDP2X01_SPCI_PMC_INTC	IXP2000_BOARD_IRQ(6)
+#define IRQ_IXDP2X01_SPCI_PMC_INTD	IXP2000_BOARD_IRQ(7)
+#define IRQ_IXDP2X01_SPCI_FIC_INT	IXP2000_BOARD_IRQ(8)
+#define IRQ_IXDP2X01_IPMI_FROM		IXP2000_BOARD_IRQ(16)
+#define IRQ_IXDP2X01_125US		IXP2000_BOARD_IRQ(17)
+#define IRQ_IXDP2X01_DB_0_ADD		IXP2000_BOARD_IRQ(18)
+#define IRQ_IXDP2X01_DB_1_ADD		IXP2000_BOARD_IRQ(19)
+#define IRQ_IXDP2X01_UART1		IXP2000_BOARD_IRQ(21)
+#define IRQ_IXDP2X01_UART2		IXP2000_BOARD_IRQ(22)
+#define IRQ_IXDP2X01_FIC_ADD_INT	IXP2000_BOARD_IRQ(24)
+#define IRQ_IXDP2X01_CS8900		IXP2000_BOARD_IRQ(25)
+#define IRQ_IXDP2X01_BBSRAM		IXP2000_BOARD_IRQ(26)
+
+#define IXDP2X01_VALID_IRQ_MASK ( \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_SPCI_DB_0) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_SPCI_DB_1) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_SPCI_PMC_INTA) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_SPCI_PMC_INTB) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_SPCI_PMC_INTC) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_SPCI_PMC_INTD) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_SPCI_FIC_INT) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_IPMI_FROM) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_125US) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_DB_0_ADD) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_DB_1_ADD) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_UART1) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_UART2) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_FIC_ADD_INT) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_CS8900) | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2X01_BBSRAM) )
+
+/* 
+ * IXDP2401 specific IRQs
+ */
+#define IRQ_IXDP2401_INTA_82546		IXP2000_BOARD_IRQ(0)
+#define IRQ_IXDP2401_INTB_82546		IXP2000_BOARD_IRQ(1)
+
+#define	IXDP2401_VALID_IRQ_MASK ( \
+		IXDP2X01_VALID_IRQ_MASK | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2401_INTA_82546) |\
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2401_INTB_82546))
+
+/*
+ * IXDP2801-specific IRQs
+ */
+#define IRQ_IXDP2801_RIV		IXP2000_BOARD_IRQ(0)
+#define IRQ_IXDP2801_CNFG_MEDIA		IXP2000_BOARD_IRQ(27)
+#define IRQ_IXDP2801_CLOCK_REF		IXP2000_BOARD_IRQ(28)
+
+#define	IXDP2801_VALID_IRQ_MASK ( \
+		IXDP2X01_VALID_IRQ_MASK | \
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2801_RIV) |\
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2801_CNFG_MEDIA) |\
+		IXP2000_BOARD_IRQ_MASK(IRQ_IXDP2801_CLOCK_REF))
+
+#define	NR_IXDP2X01_IRQS		((IRQ_IXDP2801_CLOCK_REF) + 1)
+
+#endif /*_IRQS_H*/
Index: build_tree/linux/include/asm/arch-ixp2000/ixdp2x00.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/ixdp2x00.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/ixdp2x00.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,92 @@
+/*
+ * include/asm-arm/arch-ixp2000/ixdp2x00.h
+ *
+ * Register and other defines for IXDP2[48]00 platforms
+ *
+ * Original Author: Naeem Afzal <naeem.m.afzal@intel.com>
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002 Intel Corp.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+#ifndef _IXDP2X00_H_
+#define _IXDP2X00_H_
+
+/*
+ * On board CPLD memory map
+ */
+#define IXDP2X00_PHYS_CPLD_BASE		0xc7000000
+#define IXDP2X00_VIRT_CPLD_BASE		0xfe000000
+#define IXDP2X00_CPLD_SIZE		0x00100000
+
+
+#define IXDP2X00_CPLD_REG(x)  	\
+	(volatile unsigned long *)(IXDP2X00_VIRT_CPLD_BASE | x)
+
+/*
+ * IXDP2400 CPLD registers
+ */
+#define IXDP2400_CPLD_SYSLED		IXDP2X00_CPLD_REG(0x0)  
+#define IXDP2400_CPLD_DISP_DATA		IXDP2X00_CPLD_REG(0x4)
+#define IXDP2400_CPLD_CLOCK_SPEED	IXDP2X00_CPLD_REG(0x8)
+#define IXDP2400_CPLD_INT_STAT		IXDP2X00_CPLD_REG(0xc)
+#define IXDP2400_CPLD_REV		IXDP2X00_CPLD_REG(0x10)
+#define IXDP2400_CPLD_SYS_CLK_M		IXDP2X00_CPLD_REG(0x14)
+#define IXDP2400_CPLD_SYS_CLK_N		IXDP2X00_CPLD_REG(0x18)
+#define IXDP2400_CPLD_INT_MASK		IXDP2X00_CPLD_REG(0x48)
+
+/*
+ * IXDP2800 CPLD registers
+ */
+#define IXDP2800_CPLD_INT_STAT		IXDP2X00_CPLD_REG(0x0)
+#define IXDP2800_CPLD_INT_MASK		IXDP2X00_CPLD_REG(0x140)
+
+
+#define	IXDP2X00_GPIO_I2C_ENABLE	0x02
+#define	IXDP2X00_GPIO_SCL		0x07
+#define	IXDP2X00_GPIO_SDA		0x06
+
+/*
+ * PCI devfns for on-board devices. We need these to be able to
+ * properly translate IRQs and for device removal.
+ */
+#define	IXDP2400_SLAVE_ENET_DEVFN	0x18	/* Bus 1 */
+#define	IXDP2400_MASTER_ENET_DEVFN	0x20	/* Bus 1 */
+#define	IXDP2400_MEDIA_DEVFN		0x28	/* Bus 1 */
+#define	IXDP2400_SWITCH_FABRIC_DEVFN	0x30	/* Bus 1 */
+
+#define	IXDP2800_SLAVE_ENET_DEVFN	0x20	/* Bus 1 */
+#define	IXDP2800_MASTER_ENET_DEVFN	0x18	/* Bus 1 */
+#define	IXDP2800_SWITCH_FABRIC_DEVFN	0x30	/* Bus 1 */
+
+#define	IXDP2X00_P2P_DEVFN		0x20	/* Bus 0 */
+#define	IXDP2X00_21555_DEVFN		0x30	/* Bus 0 */
+#define IXDP2X00_SLAVE_NPU_DEVFN	0x28	/* Bus 1 */
+#define	IXDP2X00_PMC_DEVFN		0x38	/* Bus 1 */
+#define IXDP2X00_MASTER_NPU_DEVFN	0x38	/* Bus 1 */
+
+#ifndef __ASSEMBLY__
+/*
+ * The master NPU is always PCI master.
+ */
+static inline unsigned int ixdp2x00_master_npu(void)
+{
+	return !!ixp2000_is_pcimaster();
+}
+
+/*
+ * Helper functions used by ixdp2400 and ixdp2800 specific code
+ */
+void ixdp2x00_init_irq(volatile unsigned long*, volatile unsigned long *, unsigned long);
+void ixdp2x00_slave_pci_postinit(void);
+void ixdp2x00_init_machine(void);
+void ixdp2x00_map_io(void);
+
+#endif
+
+#endif /*_IXDP2X00_H_ */
Index: build_tree/linux/include/asm/arch-ixp2000/ixdp2x01.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/ixdp2x01.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/ixdp2x01.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/*
+ * include/asm-arm/arch-ixp2000/ixdp2x01.h
+ *
+ * Platform definitions for IXDP2X01 && IXDP2801 systems
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista Software, Inc. 
+ *
+ * Based on original code Copyright (c) 2002-2003 Intel Corporation
+ * 
+ * This file is licensed under  the terms of the GNU General Public 
+ * License version 2. This program is licensed "as is" without any 
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __IXDP2X01_H__
+#define __IXDP2X01_H__
+
+#define	IXDP2X01_PHYS_CPLD_BASE		0xc6024000
+#define	IXDP2X01_VIRT_CPLD_BASE		0xfe000000
+#define	IXDP2X01_CPLD_REGION_SIZE	0x00100000
+
+#define IXDP2X01_CPLD_VIRT_REG(reg) (volatile unsigned long*)(IXDP2X01_VIRT_CPLD_BASE | reg)
+#define IXDP2X01_CPLD_PHYS_REG(reg) (IXDP2X01_PHYS_CPLD_BASE | reg)
+
+#define IXDP2X01_UART1_VIRT_BASE	IXDP2X01_CPLD_VIRT_REG(0x40)
+#define IXDP2X01_UART1_PHYS_BASE	IXDP2X01_CPLD_PHYS_REG(0x40)
+
+#define IXDP2X01_UART2_VIRT_BASE	IXDP2X01_CPLD_VIRT_REG(0x60)
+#define IXDP2X01_UART2_PHYS_BASE	IXDP2X01_CPLD_PHYS_REG(0x60)
+
+#define IXDP2X01_CS8900_VIRT_BASE	IXDP2X01_CPLD_VIRT_REG(0x80)
+#define IXDP2X01_CS8900_VIRT_END	(IXDP2X01_CS8900_VIRT_BASE + 16)
+
+#define IXDP2X01_CPLD_RESET_REG         IXDP2X01_CPLD_VIRT_REG(0x00)
+#define IXDP2X01_INT_MASK_SET_REG	IXDP2X01_CPLD_VIRT_REG(0x08)
+#define IXDP2X01_INT_STAT_REG		IXDP2X01_CPLD_VIRT_REG(0x0C)
+#define IXDP2X01_INT_RAW_REG		IXDP2X01_CPLD_VIRT_REG(0x10) 
+#define IXDP2X01_INT_MASK_CLR_REG	IXDP2X01_INT_RAW_REG
+#define IXDP2X01_INT_SIM_REG		IXDP2X01_CPLD_VIRT_REG(0x14)
+
+#define IXDP2X01_CPLD_FLASH_REG		IXDP2X01_CPLD_VIRT_REG(0x20)
+
+#define IXDP2X01_CPLD_FLASH_INTERN 	0x8000
+#define IXDP2X01_CPLD_FLASH_BANK_MASK 	0xF
+#define IXDP2X01_FLASH_WINDOW_BITS 	25
+#define IXDP2X01_FLASH_WINDOW_SIZE 	(1 << IXDP2X01_FLASH_WINDOW_BITS)
+#define IXDP2X01_FLASH_WINDOW_MASK 	(IXDP2X01_FLASH_WINDOW_SIZE - 1)
+
+#define	IXDP2X01_UART_CLK		1843200
+
+#define	IXDP2X01_GPIO_I2C_ENABLE	0x02
+#define	IXDP2X01_GPIO_SCL		0x07
+#define	IXDP2X01_GPIO_SDA		0x06
+
+#endif /* __IXDP2x01_H__ */
Index: build_tree/linux/include/asm/arch-ixp2000/ixp2000-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/ixp2000-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/ixp2000-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,457 @@
+/*
+ * include/asm-arm/arch-ixp2000/ixp2000-regs.h
+ *
+ * Chipset register definitions for IXP2400/2800 based systems.
+ *
+ * Original Author: Naeem Afzal <naeem.m.afzal@intel.com>
+ *
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002 Intel Corp.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+#ifndef _IXP2000_REGS_H_
+#define _IXP2000_REGS_H_
+
+/*
+ * IXP2000 linux memory map:
+ *
+ * virt		phys		size
+ * fb000000	db000000	16M		PCI CFG1
+ * fc000000	da000000	16M		PCI CFG0
+ * fd000000	d8000000	16M		PCI I/O
+ * fe[0-7]00000			8M		per-platform mappings
+ * fe900000	80000000	1M		SRAM #0 (first MB)
+ * fea00000	cb400000	1M		SCRATCH ring get/put
+ * feb00000	c8000000	1M		MSF
+ * fec00000	df000000	1M		PCI CSRs
+ * fed00000	de000000	1M		PCI CREG
+ * fee00000	d6000000	1M		INTCTL
+ * fef00000	c0000000	1M		CAP
+ */
+
+/* 
+ * Static I/O regions.
+ *
+ * Most of the registers are clumped in 4K regions spread throughout
+ * the 0xc0000000 -> 0xc0100000 address range, but we just map in
+ * the whole range using a single 1 MB section instead of small
+ * 4K pages.  This has two advantages for us:
+ *
+ * 1) We use only one TLB entry for large number of on-chip I/O devices.
+ *
+ * 2) We can easily set the Section attributes to XCB=101 on the IXP2400
+ *    as required per erratum #66.  We accomplish this by using a
+ *    new MT_IXP2000_DEVICE memory type with the bits set as required.
+ *
+ * CAP stands for CSR Access Proxy.
+ *
+ * If you change the virtual address of this mapping, please propagate
+ * the change to arch/arm/kernel/debug.S, which hardcodes the virtual
+ * address of the UART located in this region.
+ */
+
+#define	IXP2000_CAP_PHYS_BASE		0xc0000000
+#define	IXP2000_CAP_VIRT_BASE		0xfef00000
+#define	IXP2000_CAP_SIZE		0x00100000
+
+/*
+ * Addresses for specific on-chip peripherals.
+ */
+#define	IXP2000_SLOWPORT_CSR_VIRT_BASE	0xfef80000
+#define	IXP2000_GLOBAL_REG_VIRT_BASE	0xfef04000
+#define	IXP2000_UART_PHYS_BASE		0xc0030000
+#define	IXP2000_UART_VIRT_BASE		0xfef30000
+#define	IXP2000_TIMER_VIRT_BASE		0xfef20000
+#define	IXP2000_UENGINE_CSR_VIRT_BASE	0xfef18000
+#define	IXP2000_GPIO_VIRT_BASE		0xfef10000
+
+/*
+ * Devices outside of the 0xc0000000 -> 0xc0100000 range.  The virtual
+ * addresses of the INTCTL and PCI_CSR mappings are hardcoded in
+ * entry-macro.S, so if you ever change these please propagate
+ * the change.
+ */
+#define IXP2000_INTCTL_PHYS_BASE	0xd6000000
+#define	IXP2000_INTCTL_VIRT_BASE	0xfee00000
+#define	IXP2000_INTCTL_SIZE		0x00100000
+
+#define IXP2000_PCI_CREG_PHYS_BASE	0xde000000
+#define	IXP2000_PCI_CREG_VIRT_BASE	0xfed00000
+#define	IXP2000_PCI_CREG_SIZE		0x00100000
+
+#define IXP2000_PCI_CSR_PHYS_BASE	0xdf000000
+#define	IXP2000_PCI_CSR_VIRT_BASE	0xfec00000
+#define	IXP2000_PCI_CSR_SIZE		0x00100000
+
+#define IXP2000_MSF_PHYS_BASE		0xc8000000
+#define IXP2000_MSF_VIRT_BASE		0xfeb00000
+#define IXP2000_MSF_SIZE		0x00100000
+
+#define IXP2000_SCRATCH_RING_PHYS_BASE	0xcb400000
+#define IXP2000_SCRATCH_RING_VIRT_BASE	0xfea00000
+#define IXP2000_SCRATCH_RING_SIZE	0x00100000
+
+#define IXP2000_SRAM0_PHYS_BASE		0x80000000
+#define IXP2000_SRAM0_VIRT_BASE		0xfe900000
+#define IXP2000_SRAM0_SIZE		0x00100000
+
+#define IXP2000_PCI_IO_PHYS_BASE	0xd8000000
+#define	IXP2000_PCI_IO_VIRT_BASE	0xfd000000
+#define IXP2000_PCI_IO_SIZE     	0x01000000
+
+#define IXP2000_PCI_CFG0_PHYS_BASE	0xda000000
+#define IXP2000_PCI_CFG0_VIRT_BASE	0xfc000000
+#define IXP2000_PCI_CFG0_SIZE   	0x01000000
+
+#define IXP2000_PCI_CFG1_PHYS_BASE	0xdb000000
+#define IXP2000_PCI_CFG1_VIRT_BASE	0xfb000000
+#define IXP2000_PCI_CFG1_SIZE		0x01000000
+
+/* 
+ * Timers
+ */
+#define	IXP2000_TIMER_REG(x)		((volatile unsigned long*)(IXP2000_TIMER_VIRT_BASE | (x)))
+/* Timer control */
+#define	IXP2000_T1_CTL			IXP2000_TIMER_REG(0x00)
+#define	IXP2000_T2_CTL			IXP2000_TIMER_REG(0x04)
+#define	IXP2000_T3_CTL			IXP2000_TIMER_REG(0x08)
+#define	IXP2000_T4_CTL			IXP2000_TIMER_REG(0x0c)
+/* Store initial value */
+#define	IXP2000_T1_CLD			IXP2000_TIMER_REG(0x10)
+#define	IXP2000_T2_CLD			IXP2000_TIMER_REG(0x14)
+#define	IXP2000_T3_CLD			IXP2000_TIMER_REG(0x18)
+#define	IXP2000_T4_CLD			IXP2000_TIMER_REG(0x1c)
+/* Read current value */
+#define	IXP2000_T1_CSR			IXP2000_TIMER_REG(0x20)
+#define	IXP2000_T2_CSR			IXP2000_TIMER_REG(0x24)
+#define	IXP2000_T3_CSR			IXP2000_TIMER_REG(0x28)
+#define	IXP2000_T4_CSR			IXP2000_TIMER_REG(0x2c)
+/* Clear associated timer interrupt */
+#define	IXP2000_T1_CLR			IXP2000_TIMER_REG(0x30)
+#define	IXP2000_T2_CLR			IXP2000_TIMER_REG(0x34)
+#define	IXP2000_T3_CLR			IXP2000_TIMER_REG(0x38)
+#define	IXP2000_T4_CLR			IXP2000_TIMER_REG(0x3c)
+/* Timer watchdog enable for T4 */
+#define	IXP2000_TWDE			IXP2000_TIMER_REG(0x40)
+
+#define	WDT_ENABLE			0x00000001
+#define	TIMER_DIVIDER_256		0x00000008
+#define	TIMER_ENABLE			0x00000080
+#define	IRQ_MASK_TIMER1         	(1 << 4)
+
+/*
+ * Interrupt controller registers
+ */
+#define IXP2000_INTCTL_REG(x)		(volatile unsigned long*)(IXP2000_INTCTL_VIRT_BASE | (x))
+#define IXP2000_IRQ_STATUS		IXP2000_INTCTL_REG(0x08)
+#define IXP2000_IRQ_ENABLE		IXP2000_INTCTL_REG(0x10)
+#define IXP2000_IRQ_ENABLE_SET		IXP2000_INTCTL_REG(0x10)
+#define IXP2000_IRQ_ENABLE_CLR		IXP2000_INTCTL_REG(0x18)
+#define IXP2000_FIQ_ENABLE_CLR		IXP2000_INTCTL_REG(0x14)
+#define IXP2000_IRQ_ERR_STATUS		IXP2000_INTCTL_REG(0x24)
+#define IXP2000_IRQ_ERR_ENABLE_SET	IXP2000_INTCTL_REG(0x2c)
+#define IXP2000_FIQ_ERR_ENABLE_CLR	IXP2000_INTCTL_REG(0x30)
+#define IXP2000_IRQ_ERR_ENABLE_CLR	IXP2000_INTCTL_REG(0x34)
+#define IXP2000_IRQ_THD_RAW_STATUS_A_0	IXP2000_INTCTL_REG(0x60)
+#define IXP2000_IRQ_THD_RAW_STATUS_A_1	IXP2000_INTCTL_REG(0x64)
+#define IXP2000_IRQ_THD_RAW_STATUS_A_2	IXP2000_INTCTL_REG(0x68)
+#define IXP2000_IRQ_THD_RAW_STATUS_A_3	IXP2000_INTCTL_REG(0x6c)
+#define IXP2000_IRQ_THD_RAW_STATUS_B_0	IXP2000_INTCTL_REG(0x80)
+#define IXP2000_IRQ_THD_RAW_STATUS_B_1	IXP2000_INTCTL_REG(0x84)
+#define IXP2000_IRQ_THD_RAW_STATUS_B_2	IXP2000_INTCTL_REG(0x88)
+#define IXP2000_IRQ_THD_RAW_STATUS_B_3	IXP2000_INTCTL_REG(0x8c)
+#define IXP2000_IRQ_THD_STATUS_A_0	IXP2000_INTCTL_REG(0xe0)
+#define IXP2000_IRQ_THD_STATUS_A_1	IXP2000_INTCTL_REG(0xe4)
+#define IXP2000_IRQ_THD_STATUS_A_2	IXP2000_INTCTL_REG(0xe8)
+#define IXP2000_IRQ_THD_STATUS_A_3	IXP2000_INTCTL_REG(0xec)
+#define IXP2000_IRQ_THD_STATUS_B_0	IXP2000_INTCTL_REG(0x100)
+#define IXP2000_IRQ_THD_STATUS_B_1	IXP2000_INTCTL_REG(0x104)
+#define IXP2000_IRQ_THD_STATUS_B_2	IXP2000_INTCTL_REG(0x108)
+#define IXP2000_IRQ_THD_STATUS_B_3	IXP2000_INTCTL_REG(0x10c)
+#define IXP2000_IRQ_THD_ENABLE_SET_A_0	IXP2000_INTCTL_REG(0x160)
+#define IXP2000_IRQ_THD_ENABLE_SET_A_1	IXP2000_INTCTL_REG(0x164)
+#define IXP2000_IRQ_THD_ENABLE_SET_A_2	IXP2000_INTCTL_REG(0x168)
+#define IXP2000_IRQ_THD_ENABLE_SET_A_3	IXP2000_INTCTL_REG(0x16c)
+#define IXP2000_IRQ_THD_ENABLE_SET_B_0	IXP2000_INTCTL_REG(0x180)
+#define IXP2000_IRQ_THD_ENABLE_SET_B_1	IXP2000_INTCTL_REG(0x184)
+#define IXP2000_IRQ_THD_ENABLE_SET_B_2	IXP2000_INTCTL_REG(0x188)
+#define IXP2000_IRQ_THD_ENABLE_SET_B_3	IXP2000_INTCTL_REG(0x18c)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_A_0	IXP2000_INTCTL_REG(0x1e0)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_A_1	IXP2000_INTCTL_REG(0x1e4)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_A_2	IXP2000_INTCTL_REG(0x1e8)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_A_3	IXP2000_INTCTL_REG(0x1ec)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_B_0	IXP2000_INTCTL_REG(0x200)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_B_1	IXP2000_INTCTL_REG(0x204)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_B_2	IXP2000_INTCTL_REG(0x208)
+#define IXP2000_IRQ_THD_ENABLE_CLEAR_B_3	IXP2000_INTCTL_REG(0x20c)
+
+/*
+ * Mask of valid IRQs in the 32-bit IRQ register. We use
+ * this to mark certain IRQs as being invalid.
+ */
+#define	IXP2000_VALID_IRQ_MASK	0x0f0fffff
+
+/*
+ * PCI config register access from core
+ */
+#define IXP2000_PCI_CREG(x)		(volatile unsigned long*)(IXP2000_PCI_CREG_VIRT_BASE | (x))
+#define IXP2000_PCI_CMDSTAT 		IXP2000_PCI_CREG(0x04)
+#define IXP2000_PCI_CSR_BAR		IXP2000_PCI_CREG(0x10)
+#define IXP2000_PCI_SRAM_BAR		IXP2000_PCI_CREG(0x14)
+#define IXP2000_PCI_SDRAM_BAR		IXP2000_PCI_CREG(0x18)
+
+/*
+ * PCI CSRs
+ */
+#define IXP2000_PCI_CSR(x)		(volatile unsigned long*)(IXP2000_PCI_CSR_VIRT_BASE | (x))
+
+/*
+ * PCI outbound interrupts
+ */
+#define IXP2000_PCI_OUT_INT_STATUS	IXP2000_PCI_CSR(0x30)
+#define IXP2000_PCI_OUT_INT_MASK	IXP2000_PCI_CSR(0x34)
+/*
+ * PCI communications
+ */
+#define IXP2000_PCI_MAILBOX0		IXP2000_PCI_CSR(0x50)
+#define IXP2000_PCI_MAILBOX1		IXP2000_PCI_CSR(0x54)
+#define IXP2000_PCI_MAILBOX2		IXP2000_PCI_CSR(0x58)
+#define IXP2000_PCI_MAILBOX3		IXP2000_PCI_CSR(0x5C)
+#define IXP2000_XSCALE_DOORBELL		IXP2000_PCI_CSR(0x60)
+#define IXP2000_XSCALE_DOORBELL_SETUP	IXP2000_PCI_CSR(0x64)
+#define IXP2000_PCI_DOORBELL		IXP2000_PCI_CSR(0x70)
+#define IXP2000_PCI_DOORBELL_SETUP	IXP2000_PCI_CSR(0x74)
+
+/*
+ * DMA engines
+ */
+#define IXP2000_PCI_CH1_BYTE_CNT	IXP2000_PCI_CSR(0x80)
+#define IXP2000_PCI_CH1_ADDR		IXP2000_PCI_CSR(0x84)
+#define IXP2000_PCI_CH1_DRAM_ADDR	IXP2000_PCI_CSR(0x88)
+#define IXP2000_PCI_CH1_DESC_PTR	IXP2000_PCI_CSR(0x8C)
+#define IXP2000_PCI_CH1_CNTRL		IXP2000_PCI_CSR(0x90)
+#define IXP2000_PCI_CH1_ME_PARAM	IXP2000_PCI_CSR(0x94)
+#define IXP2000_PCI_CH2_BYTE_CNT	IXP2000_PCI_CSR(0xA0)
+#define IXP2000_PCI_CH2_ADDR		IXP2000_PCI_CSR(0xA4)
+#define IXP2000_PCI_CH2_DRAM_ADDR	IXP2000_PCI_CSR(0xA8)
+#define IXP2000_PCI_CH2_DESC_PTR	IXP2000_PCI_CSR(0xAC)
+#define IXP2000_PCI_CH2_CNTRL		IXP2000_PCI_CSR(0xB0)
+#define IXP2000_PCI_CH2_ME_PARAM	IXP2000_PCI_CSR(0xB4)
+#define IXP2000_PCI_CH3_BYTE_CNT	IXP2000_PCI_CSR(0xC0)
+#define IXP2000_PCI_CH3_ADDR		IXP2000_PCI_CSR(0xC4)
+#define IXP2000_PCI_CH3_DRAM_ADDR	IXP2000_PCI_CSR(0xC8)
+#define IXP2000_PCI_CH3_DESC_PTR	IXP2000_PCI_CSR(0xCC)
+#define IXP2000_PCI_CH3_CNTRL		IXP2000_PCI_CSR(0xD0)
+#define IXP2000_PCI_CH3_ME_PARAM	IXP2000_PCI_CSR(0xD4)
+#define IXP2000_DMA_INF_MODE		IXP2000_PCI_CSR(0xE0)
+/*
+ * Size masks for BARs
+ */
+#define IXP2000_PCI_SRAM_BASE_ADDR_MASK	IXP2000_PCI_CSR(0xFC)
+#define IXP2000_PCI_DRAM_BASE_ADDR_MASK	IXP2000_PCI_CSR(0x100)
+/*
+ * Control and uEngine related
+ */
+#define IXP2000_PCI_CONTROL		IXP2000_PCI_CSR(0x13C)
+#define IXP2000_PCI_ADDR_EXT		IXP2000_PCI_CSR(0x140)
+#define IXP2000_PCI_ME_PUSH_STATUS	IXP2000_PCI_CSR(0x148)
+#define IXP2000_PCI_ME_PUSH_EN		IXP2000_PCI_CSR(0x14C)
+#define IXP2000_PCI_ERR_STATUS		IXP2000_PCI_CSR(0x150)
+#define IXP2000_PCI_ERR_ENABLE		IXP2000_PCI_CSR(0x154)
+/*
+ * Inbound PCI interrupt control
+ */
+#define IXP2000_PCI_XSCALE_INT_STATUS	IXP2000_PCI_CSR(0x158)
+#define IXP2000_PCI_XSCALE_INT_ENABLE	IXP2000_PCI_CSR(0x15C)
+
+#define IXP2000_PCICNTL_PNR		(1<<17)	/* PCI not Reset bit of PCI_CONTROL */
+#define IXP2000_PCICNTL_PCF		(1<<28)	/* PCI Central function bit */
+#define IXP2000_XSCALE_INT		(1<<1)	/* Interrupt from XScale to PCI */
+
+/* These are from the IRQ register in the PCI ISR register */
+#define PCI_CONTROL_BE_DEO		(1 << 22)	/* Big Endian Data Enable Out */
+#define PCI_CONTROL_BE_DEI		(1 << 21)	/* Big Endian Data Enable In  */
+#define PCI_CONTROL_BE_BEO		(1 << 20)	/* Big Endian Byte Enable Out */
+#define PCI_CONTROL_BE_BEI		(1 << 19)	/* Big Endian Byte Enable In  */
+#define PCI_CONTROL_IEE			(1 << 17)	/* I/O cycle Endian swap Enable */
+
+#define IXP2000_PCI_RST_REL		(1 << 2)
+#define CFG_RST_DIR			(*IXP2000_PCI_CONTROL & IXP2000_PCICNTL_PCF)
+#define CFG_PCI_BOOT_HOST		(1 << 2)
+#define CFG_BOOT_PROM			(1 << 1)
+
+/*
+ * SlowPort CSRs
+ *
+ * The slowport is used to access things like flash, SONET framer control
+ * ports, slave microprocessors, CPLDs, and others of chip memory mapped
+ * peripherals.
+ */
+#define	SLOWPORT_CSR(x)		(volatile unsigned long*)(IXP2000_SLOWPORT_CSR_VIRT_BASE | (x))
+
+#define	IXP2000_SLOWPORT_CCR		SLOWPORT_CSR(0x00)
+#define	IXP2000_SLOWPORT_WTC1		SLOWPORT_CSR(0x04)
+#define	IXP2000_SLOWPORT_WTC2		SLOWPORT_CSR(0x08)
+#define	IXP2000_SLOWPORT_RTC1		SLOWPORT_CSR(0x0c)
+#define	IXP2000_SLOWPORT_RTC2		SLOWPORT_CSR(0x10)
+#define	IXP2000_SLOWPORT_FSR		SLOWPORT_CSR(0x14)
+#define	IXP2000_SLOWPORT_PCR		SLOWPORT_CSR(0x18)
+#define	IXP2000_SLOWPORT_ADC		SLOWPORT_CSR(0x1C)
+#define	IXP2000_SLOWPORT_FAC		SLOWPORT_CSR(0x20)
+#define	IXP2000_SLOWPORT_FRM		SLOWPORT_CSR(0x24)
+#define	IXP2000_SLOWPORT_FIN		SLOWPORT_CSR(0x28)
+
+/*
+ * CCR values.  
+ * The CCR configures the clock division for the slowport interface.
+ */
+#define	SLOWPORT_CCR_DIV_1		0x00
+#define	SLOWPORT_CCR_DIV_2		0x01
+#define	SLOWPORT_CCR_DIV_4		0x02
+#define	SLOWPORT_CCR_DIV_6		0x03
+#define	SLOWPORT_CCR_DIV_8		0x04
+#define	SLOWPORT_CCR_DIV_10		0x05
+#define	SLOWPORT_CCR_DIV_12		0x06
+#define	SLOWPORT_CCR_DIV_14		0x07
+#define	SLOWPORT_CCR_DIV_16		0x08
+#define	SLOWPORT_CCR_DIV_18		0x09
+#define	SLOWPORT_CCR_DIV_20		0x0a
+#define	SLOWPORT_CCR_DIV_22		0x0b
+#define	SLOWPORT_CCR_DIV_24		0x0c
+#define	SLOWPORT_CCR_DIV_26		0x0d
+#define	SLOWPORT_CCR_DIV_28		0x0e
+#define	SLOWPORT_CCR_DIV_30		0x0f
+
+/*
+ * PCR values.  PCR configure the mode of the interface.
+ */
+#define	SLOWPORT_MODE_FLASH		0x00
+#define	SLOWPORT_MODE_LUCENT		0x01
+#define	SLOWPORT_MODE_PMC_SIERRA	0x02
+#define	SLOWPORT_MODE_INTEL_UP		0x03
+#define	SLOWPORT_MODE_MOTOROLA_UP	0x04
+
+/*
+ * ADC values.  Defines data and address bus widths.
+ */
+#define	SLOWPORT_ADDR_WIDTH_8		0x00
+#define	SLOWPORT_ADDR_WIDTH_16		0x01
+#define	SLOWPORT_ADDR_WIDTH_24		0x02
+#define	SLOWPORT_ADDR_WIDTH_32		0x03
+#define	SLOWPORT_DATA_WIDTH_8		0x00
+#define	SLOWPORT_DATA_WIDTH_16		0x10
+#define	SLOWPORT_DATA_WIDTH_24		0x20
+#define	SLOWPORT_DATA_WIDTH_32		0x30
+
+/*
+ * Masks and shifts for various fields in the WTC and RTC registers.
+ */
+#define	SLOWPORT_WRTC_MASK_HD		0x0003
+#define	SLOWPORT_WRTC_MASK_PW		0x003c
+#define	SLOWPORT_WRTC_MASK_SU		0x03c0
+
+#define	SLOWPORT_WRTC_SHIFT_HD		0x00
+#define	SLOWPORT_WRTC_SHIFT_SU		0x02
+#define	SLOWPORT_WRTC_SHFIT_PW		0x06
+
+
+/*
+ * GPIO registers & GPIO interface.
+ */
+#define IXP2000_GPIO_REG(x)		((volatile unsigned long*)(IXP2000_GPIO_VIRT_BASE+(x)))
+#define IXP2000_GPIO_PLR		IXP2000_GPIO_REG(0x00)
+#define IXP2000_GPIO_PDPR		IXP2000_GPIO_REG(0x04)
+#define IXP2000_GPIO_PDSR		IXP2000_GPIO_REG(0x08)
+#define IXP2000_GPIO_PDCR		IXP2000_GPIO_REG(0x0c)
+#define IXP2000_GPIO_POPR		IXP2000_GPIO_REG(0x10)
+#define IXP2000_GPIO_POSR		IXP2000_GPIO_REG(0x14)
+#define IXP2000_GPIO_POCR		IXP2000_GPIO_REG(0x18)
+#define IXP2000_GPIO_REDR		IXP2000_GPIO_REG(0x1c)
+#define IXP2000_GPIO_FEDR		IXP2000_GPIO_REG(0x20)
+#define IXP2000_GPIO_EDSR		IXP2000_GPIO_REG(0x24)
+#define IXP2000_GPIO_LSHR		IXP2000_GPIO_REG(0x28)
+#define IXP2000_GPIO_LSLR		IXP2000_GPIO_REG(0x2c)
+#define IXP2000_GPIO_LDSR		IXP2000_GPIO_REG(0x30)
+#define IXP2000_GPIO_INER		IXP2000_GPIO_REG(0x34)
+#define IXP2000_GPIO_INSR		IXP2000_GPIO_REG(0x38)
+#define IXP2000_GPIO_INCR		IXP2000_GPIO_REG(0x3c)
+#define IXP2000_GPIO_INST		IXP2000_GPIO_REG(0x40)
+
+/*
+ * "Global" registers...whatever that's supposed to mean.
+ */
+#define GLOBAL_REG_BASE			(IXP2000_GLOBAL_REG_VIRT_BASE + 0x0a00)
+#define GLOBAL_REG(x)			(volatile unsigned long*)(GLOBAL_REG_BASE | (x))
+
+#define IXP2000_MAJ_PROD_TYPE_MASK	0x001F0000
+#define IXP2000_MAJ_PROD_TYPE_IXP2000	0x00000000
+#define IXP2000_MIN_PROD_TYPE_MASK 	0x0000FF00
+#define IXP2000_MIN_PROD_TYPE_IXP2400	0x00000200
+#define IXP2000_MIN_PROD_TYPE_IXP2850	0x00000100
+#define IXP2000_MIN_PROD_TYPE_IXP2800	0x00000000
+#define IXP2000_MAJ_REV_MASK	      	0x000000F0
+#define IXP2000_MIN_REV_MASK	      	0x0000000F
+#define IXP2000_PROD_ID_MASK		0xFFFFFFFF
+
+#define IXP2000_PRODUCT_ID		GLOBAL_REG(0x00)
+#define IXP2000_MISC_CONTROL		GLOBAL_REG(0x04)
+#define IXP2000_MSF_CLK_CNTRL  		GLOBAL_REG(0x08)
+#define IXP2000_RESET0      		GLOBAL_REG(0x0c)
+#define IXP2000_RESET1      		GLOBAL_REG(0x10)
+#define IXP2000_CCR            		GLOBAL_REG(0x14)
+#define	IXP2000_STRAP_OPTIONS  		GLOBAL_REG(0x18)
+
+#define	RSTALL				(1 << 16)
+#define	WDT_RESET_ENABLE		0x01000000
+
+
+/*
+ * MSF registers.  The IXP2400 and IXP2800 have somewhat different MSF
+ * units, but the registers that differ between the two don't overlap,
+ * so we can have one register list for both.
+ */
+#define IXP2000_MSF_REG(x)			((volatile unsigned long*)(IXP2000_MSF_VIRT_BASE + (x)))
+#define IXP2000_MSF_RX_CONTROL			IXP2000_MSF_REG(0x0000)
+#define IXP2000_MSF_TX_CONTROL			IXP2000_MSF_REG(0x0004)
+#define IXP2000_MSF_INTERRUPT_STATUS		IXP2000_MSF_REG(0x0008)
+#define IXP2000_MSF_INTERRUPT_ENABLE		IXP2000_MSF_REG(0x000c)
+#define IXP2000_MSF_CSIX_TYPE_MAP		IXP2000_MSF_REG(0x0010)
+#define IXP2000_MSF_FC_EGRESS_STATUS		IXP2000_MSF_REG(0x0014)
+#define IXP2000_MSF_FC_INGRESS_STATUS		IXP2000_MSF_REG(0x0018)
+#define IXP2000_MSF_HWM_CONTROL			IXP2000_MSF_REG(0x0024)
+#define IXP2000_MSF_FC_STATUS_OVERRIDE		IXP2000_MSF_REG(0x0028)
+#define IXP2000_MSF_CLOCK_CONTROL		IXP2000_MSF_REG(0x002c)
+#define IXP2000_MSF_RX_PORT_MAP			IXP2000_MSF_REG(0x0040)
+#define IXP2000_MSF_RBUF_ELEMENT_DONE		IXP2000_MSF_REG(0x0044)
+#define IXP2000_MSF_RX_MPHY_POLL_LIMIT		IXP2000_MSF_REG(0x0048)
+#define IXP2000_MSF_RX_CALENDAR_LENGTH		IXP2000_MSF_REG(0x0048)
+#define IXP2000_MSF_RX_THREAD_FREELIST_TIMEOUT_0	IXP2000_MSF_REG(0x0050)
+#define IXP2000_MSF_RX_THREAD_FREELIST_TIMEOUT_1	IXP2000_MSF_REG(0x0054)
+#define IXP2000_MSF_RX_THREAD_FREELIST_TIMEOUT_2	IXP2000_MSF_REG(0x0058)
+#define IXP2000_MSF_TX_SEQUENCE_0		IXP2000_MSF_REG(0x0060)
+#define IXP2000_MSF_TX_SEQUENCE_1		IXP2000_MSF_REG(0x0064)
+#define IXP2000_MSF_TX_SEQUENCE_2		IXP2000_MSF_REG(0x0068)
+#define IXP2000_MSF_TX_MPHY_POLL_LIMIT		IXP2000_MSF_REG(0x0070)
+#define IXP2000_MSF_TX_CALENDAR_LENGTH		IXP2000_MSF_REG(0x0070)
+#define IXP2000_MSF_RX_UP_CONTROL_0		IXP2000_MSF_REG(0x0080)
+#define IXP2000_MSF_RX_UP_CONTROL_1		IXP2000_MSF_REG(0x0084)
+#define IXP2000_MSF_RX_UP_CONTROL_2		IXP2000_MSF_REG(0x0088)
+#define IXP2000_MSF_RX_UP_CONTROL_3		IXP2000_MSF_REG(0x008c)
+#define IXP2000_MSF_TX_UP_CONTROL_0		IXP2000_MSF_REG(0x0090)
+#define IXP2000_MSF_TX_UP_CONTROL_1		IXP2000_MSF_REG(0x0094)
+#define IXP2000_MSF_TX_UP_CONTROL_2		IXP2000_MSF_REG(0x0098)
+#define IXP2000_MSF_TX_UP_CONTROL_3		IXP2000_MSF_REG(0x009c)
+#define IXP2000_MSF_TRAIN_DATA			IXP2000_MSF_REG(0x00a0)
+#define IXP2000_MSF_TRAIN_CALENDAR		IXP2000_MSF_REG(0x00a4)
+#define IXP2000_MSF_TRAIN_FLOW_CONTROL		IXP2000_MSF_REG(0x00a8)
+#define IXP2000_MSF_TX_CALENDAR_0		IXP2000_MSF_REG(0x1000)
+#define IXP2000_MSF_RX_PORT_CALENDAR_STATUS	IXP2000_MSF_REG(0x1400)
+
+
+#endif				/* _IXP2000_H_ */
Index: build_tree/linux/include/asm/arch-ixp2000/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,34 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/memory.h
+ *
+ * Copyright (c) 2002 Intel Corp.
+ * Copyright (c) 2003-2004 MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET	UL(0x00000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#include <asm/arch/ixp2000-regs.h>
+
+#define __virt_to_bus(v) \
+	(((__virt_to_phys(v) - 0x0) + (*IXP2000_PCI_SDRAM_BAR & 0xfffffff0)))
+
+#define __bus_to_virt(b) \
+	__phys_to_virt((((b - (*IXP2000_PCI_SDRAM_BAR & 0xfffffff0)) + 0x0)))
+
+#endif
+
Index: build_tree/linux/include/asm/arch-ixp2000/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/platform.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,152 @@
+/*
+ * include/asm-arm/arch-ixp2000/platform.h
+ *
+ * Various bits of code used by platform-level code.
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista Software, Inc. 
+ * 
+ * This file is licensed under  the terms of the GNU General Public 
+ * License version 2. This program is licensed "as is" without any 
+ * warranty of any kind, whether express or implied.
+ */
+
+
+#ifndef __ASSEMBLY__
+
+static inline unsigned long ixp2000_reg_read(volatile void *reg)
+{
+	return *((volatile unsigned long *)reg);
+}
+
+static inline void ixp2000_reg_write(volatile void *reg, unsigned long val)
+{
+	*((volatile unsigned long *)reg) = val;
+}
+
+/*
+ * On the IXP2400, we can't use XCB=000 due to chip bugs.  We use
+ * XCB=101 instead, but that makes all I/O accesses bufferable.  This
+ * is not a problem in general, but we do have to be slightly more
+ * careful because I/O writes are no longer automatically flushed out
+ * of the write buffer.
+ *
+ * In cases where we want to make sure that a write has been flushed
+ * out of the write buffer before we proceed, for example when masking
+ * a device interrupt before re-enabling IRQs in CPSR, we can use this
+ * function, ixp2000_reg_wrb, which performs a write, a readback, and
+ * issues a dummy instruction dependent on the value of the readback
+ * (mov rX, rX) to make sure that the readback has completed before we
+ * continue.
+ */
+static inline void ixp2000_reg_wrb(volatile void *reg, unsigned long val)
+{
+	unsigned long dummy;
+
+	*((volatile unsigned long *)reg) = val;
+
+	dummy = *((volatile unsigned long *)reg);
+	__asm__ __volatile__("mov %0, %0" : "+r" (dummy));
+}
+
+/*
+ * Boards may multiplex different devices on the 2nd channel of 
+ * the slowport interface that each need different configuration 
+ * settings.  For example, the IXDP2400 uses channel 2 on the interface 
+ * to access the CPLD, the switch fabric card, and the media card.  Each
+ * one needs a different mode so drivers must save/restore the mode 
+ * before and after each operation.  
+ *
+ * acquire_slowport(&your_config);
+ * ...
+ * do slowport operations
+ * ...
+ * release_slowport();
+ *
+ * Note that while you have the slowport, you are holding a spinlock,
+ * so your code should be written as if you explicitly acquired a lock.
+ *
+ * The configuration only affects device 2 on the slowport, so the
+ * MTD map driver does not acquire/release the slowport.  
+ */
+struct slowport_cfg {
+	unsigned long CCR;	/* Clock divide */
+	unsigned long WTC;	/* Write Timing Control */
+	unsigned long RTC;	/* Read Timing Control */
+	unsigned long PCR;	/* Protocol Control Register */
+	unsigned long ADC;	/* Address/Data Width Control */
+};
+
+
+void ixp2000_acquire_slowport(struct slowport_cfg *, struct slowport_cfg *);
+void ixp2000_release_slowport(struct slowport_cfg *);
+
+/*
+ * IXP2400 A0/A1 and  IXP2800 A0/A1/A2 have broken slowport that requires
+ * tweaking of addresses in the MTD driver.
+ */
+static inline unsigned ixp2000_has_broken_slowport(void)
+{
+	unsigned long id = *IXP2000_PRODUCT_ID;
+	unsigned long id_prod = id & (IXP2000_MAJ_PROD_TYPE_MASK |
+				      IXP2000_MIN_PROD_TYPE_MASK);
+	return (((id_prod ==
+		  /* fixed in IXP2400-B0 */
+		  (IXP2000_MAJ_PROD_TYPE_IXP2000 |
+		   IXP2000_MIN_PROD_TYPE_IXP2400)) &&
+		 ((id & IXP2000_MAJ_REV_MASK) == 0)) ||
+		((id_prod ==
+		  /* fixed in IXP2800-B0 */
+		  (IXP2000_MAJ_PROD_TYPE_IXP2000 |
+		   IXP2000_MIN_PROD_TYPE_IXP2800)) &&
+		 ((id & IXP2000_MAJ_REV_MASK) == 0)) ||
+		((id_prod ==
+		  /* fixed in IXP2850-B0 */
+		  (IXP2000_MAJ_PROD_TYPE_IXP2000 |
+		   IXP2000_MIN_PROD_TYPE_IXP2850)) &&
+		 ((id & IXP2000_MAJ_REV_MASK) == 0)));
+}
+
+static inline unsigned int ixp2000_has_flash(void)
+{
+	return ((*IXP2000_STRAP_OPTIONS) & (CFG_BOOT_PROM));
+}
+
+static inline unsigned int ixp2000_is_pcimaster(void)
+{
+	return ((*IXP2000_STRAP_OPTIONS) & (CFG_PCI_BOOT_HOST));
+}
+
+void ixp2000_map_io(void);
+void ixp2000_uart_init(void);
+void ixp2000_init_irq(void);
+void ixp2000_init_time(unsigned long);
+unsigned long ixp2000_gettimeoffset(void);
+
+struct pci_sys_data;
+
+u32 *ixp2000_pci_config_addr(unsigned int bus, unsigned int devfn, int where);
+void ixp2000_pci_preinit(void);
+int ixp2000_pci_setup(int, struct pci_sys_data*);
+struct pci_bus* ixp2000_pci_scan_bus(int, struct pci_sys_data*);
+int ixp2000_pci_read_config(struct pci_bus*, unsigned int, int, int, u32 *);
+int ixp2000_pci_write_config(struct pci_bus*, unsigned int, int, int, u32);
+
+/*
+ * Several of the IXP2000 systems have banked flash so we need to extend the
+ * flash_platform_data structure with some private pointers
+ */
+struct ixp2000_flash_data {
+	struct flash_platform_data *platform_data;
+	int nr_banks;
+	unsigned long (*bank_setup)(unsigned long);
+};
+
+struct ixp2000_i2c_pins {
+	unsigned long sda_pin;
+	unsigned long scl_pin;
+};
+
+
+#endif /*  !__ASSEMBLY__ */
Index: build_tree/linux/include/asm/arch-ixp2000/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/system.h
+ *
+ * Copyright (C) 2002 Intel Corp.
+ * Copyricht (C) 2003-2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	local_irq_disable();
+
+	/*
+	 * Reset flash banking register so that we are pointing at
+	 * RedBoot bank.
+	 */
+	if (machine_is_ixdp2401()) {
+		ixp2000_reg_write(IXDP2X01_CPLD_FLASH_REG,
+					((0 >> IXDP2X01_FLASH_WINDOW_BITS)
+						| IXDP2X01_CPLD_FLASH_INTERN));
+		ixp2000_reg_wrb(IXDP2X01_CPLD_RESET_REG, 0xffffffff);
+	}
+
+	/*
+	 * On IXDP2801 we need to write this magic sequence to the CPLD
+	 * to cause a complete reset of the CPU and all external devices
+	 * and move the flash bank register back to 0.
+	 */
+	if (machine_is_ixdp2801() || machine_is_ixdp28x5()) {
+		unsigned long reset_reg = *IXDP2X01_CPLD_RESET_REG;
+
+		reset_reg = 0x55AA0000 | (reset_reg & 0x0000FFFF);
+		ixp2000_reg_write(IXDP2X01_CPLD_RESET_REG, reset_reg);
+		ixp2000_reg_wrb(IXDP2X01_CPLD_RESET_REG, 0x80000000);
+	}
+
+	ixp2000_reg_wrb(IXP2000_RESET0, RSTALL);
+}
Index: build_tree/linux/include/asm/arch-ixp2000/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,13 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/timex.h
+ *
+ * IXP2000 architecture timex specifications
+ */
+
+
+/*
+ * Default clock is 50MHz APB, but platform code can override this
+ */
+#define CLOCK_TICK_RATE	50000000
+
+
Index: build_tree/linux/include/asm/arch-ixp2000/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,47 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/uncompress.h
+ *
+ *
+ * Original Author: Naeem Afzal <naeem.m.afzal@intel.com>
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2002 Intel Corp.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/serial_reg.h>
+
+#define UART_BASE	0xc0030000
+
+#define PHYS(x)          ((volatile unsigned long *)(UART_BASE + x))
+
+#define UARTDR          PHYS(0x00)      /* Transmit reg dlab=0 */
+#define UARTDLL         PHYS(0x00)      /* Divisor Latch reg dlab=1*/
+#define UARTDLM         PHYS(0x04)      /* Divisor Latch reg dlab=1*/
+#define UARTIER         PHYS(0x04)      /* Interrupt enable reg */
+#define UARTFCR         PHYS(0x08)      /* FIFO control reg dlab =0*/
+#define UARTLCR         PHYS(0x0c)      /* Control reg */
+#define UARTSR          PHYS(0x14)      /* Status reg */
+
+
+static inline void putc(int c)
+{
+	int j = 0x1000;
+
+	while (--j && !(*UARTSR & UART_LSR_THRE))
+		barrier();
+
+	*UARTDR = c;
+}
+
+static inline void flush(void)
+{
+}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-ixp2000/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp2000/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp2000/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * linux/include/asm-arm/arch-ixp2000/vmalloc.h
+ *
+ * Author: Naeem Afzal <naeem.m.afzal@intel.com>
+ *
+ * Copyright 2002 Intel Corp.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_END	    0xfb000000
Index: build_tree/linux/include/asm/arch-ixp23xx/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-ixp23xx/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * Copyright (C) 1994-1999 Russell King
+ * Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm/arch/ixp23xx.h>
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1				@ mmu enabled?
+		ldreq	\rx, =IXP23XX_PERIPHERAL_PHYS 	@ physical
+		ldrne	\rx, =IXP23XX_PERIPHERAL_VIRT	@ virtual
+#ifdef __ARMEB__
+		orr	\rx, \rx, #0x00000003
+#endif
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-ixp23xx/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,3 @@
+/*
+ * include/asm-arm/arch-ixp23xx/dma.h
+ */
Index: build_tree/linux/include/asm/arch-ixp23xx/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-ixp23xx/entry-macro.S
+ */
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\irqnr, =(IXP23XX_INTC_VIRT + IXP23XX_INTR_IRQ_ENC_ST_OFFSET)
+		ldr	\irqnr, [\irqnr]	@ get interrupt number
+		cmp	\irqnr, #0x0		@ spurious interrupt ?
+		movne	\irqnr, \irqnr, lsr #2	@ skip unwanted low order bits
+		subne	\irqnr, \irqnr, #1	@ convert to 0 based
+
+#if 0
+		cmp	\irqnr, #IRQ_IXP23XX_PCI_INT_RPH
+		bne	1001f
+		mov	\irqnr, #IRQ_IXP23XX_INTA
+
+		ldr	\irqnr, =0xf5000030
+
+		mov	\tmp, #(1<<26)
+		tst	\irqnr, \tmp
+		movne	\irqnr, #IRQ_IXP23XX_INTB
+
+		mov	\tmp, #(1<<27)
+		tst	\irqnr, \tmp
+		movne	\irqnr, #IRQ_IXP23XX_INTA
+1001:
+#endif
+		.endm
Index: build_tree/linux/include/asm/arch-ixp23xx/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-ixp23xx/hardware.h
+ *
+ * Copyright (C) 2002-2004 Intel Corporation.
+ * Copyricht (C) 2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Hardware definitions for IXP23XX based systems
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/* PCI IO info */
+#define PCIO_BASE		IXP23XX_PCI_IO_VIRT
+#define PCIBIOS_MIN_IO		0x00000000
+#define PCIBIOS_MIN_MEM		0xe0000000
+
+#include "ixp23xx.h"
+
+#define pcibios_assign_all_busses()	0
+
+/*
+ * Platform helper functions
+ */
+#include "platform.h"
+
+/*
+ * Platform-specific headers
+ */
+#include "ixdp2351.h"
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,54 @@
+/*
+ * include/asm-arm/arch-ixp23xx/io.h
+ *
+ * Original Author: Naeem M Afzal <naeem.m.afzal@intel.com>
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2003-2005 Intel Corp.
+ * Copyright (C) 2005 MontaVista Software, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(p)		((void __iomem*)((p) + IXP23XX_PCI_IO_VIRT))
+#define __mem_pci(a)	(a)
+
+#include <linux/kernel.h>	/* For BUG */
+
+static inline void __iomem *
+ixp23xx_ioremap(unsigned long addr, unsigned long size, unsigned long flags)
+{
+	if (addr >= IXP23XX_PCI_MEM_START &&
+		addr <= IXP23XX_PCI_MEM_START + IXP23XX_PCI_MEM_SIZE) {
+		if (addr + size > IXP23XX_PCI_MEM_START + IXP23XX_PCI_MEM_SIZE)
+			return NULL;
+
+		return (void __iomem *)
+ 			((addr - IXP23XX_PCI_MEM_START) + IXP23XX_PCI_MEM_VIRT);
+	}
+
+	return __ioremap(addr, size, flags);
+}
+
+static inline void
+ixp23xx_iounmap(void __iomem *addr)
+{
+	if ((((u32)addr) >= IXP23XX_PCI_MEM_VIRT) &&
+	    (((u32)addr) < IXP23XX_PCI_MEM_VIRT + IXP23XX_PCI_MEM_SIZE))
+		return;
+
+	__iounmap(addr);
+}
+
+#define __arch_ioremap(a,s,f)	ixp23xx_ioremap(a,s,f)
+#define __arch_iounmap(a)	ixp23xx_iounmap(a)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,223 @@
+/*
+ * include/asm-arm/arch-ixp23xx/irqs.h
+ *
+ * IRQ definitions for IXP23XX based systems
+ *
+ * Author: Naeem Afzal <naeem.m.afzal@intel.com>
+ *
+ * Copyright (C) 2003-2004 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define NR_IXP23XX_IRQS			IRQ_IXP23XX_INTB+1
+#define IRQ_IXP23XX_EXTIRQS		NR_IXP23XX_IRQS
+
+
+#define IRQ_IXP23XX_DBG0		0	/* Debug/Execution/MBox */
+#define IRQ_IXP23XX_DBG1		1	/* Debug/Execution/MBox */
+#define IRQ_IXP23XX_NPE_TRG		2	/* npe_trigger */
+#define IRQ_IXP23XX_TIMER1		3	/* Timer[0] */
+#define IRQ_IXP23XX_TIMER2		4	/* Timer[1] */
+#define IRQ_IXP23XX_TIMESTAMP		5	/* Timer[2], Time-stamp */
+#define IRQ_IXP23XX_WDOG		6	/* Time[3], Watchdog Timer */
+#define IRQ_IXP23XX_PCI_DBELL		7	/* PCI Doorbell */
+#define IRQ_IXP23XX_PCI_DMA1		8	/* PCI DMA Channel 1 */
+#define IRQ_IXP23XX_PCI_DMA2		9	/* PCI DMA Channel 2 */
+#define IRQ_IXP23XX_PCI_DMA3		10	/* PCI DMA Channel 3 */
+#define IRQ_IXP23XX_PCI_INT_RPH		11	/* pcxg_pci_int_rph */
+#define IRQ_IXP23XX_CPP_PMU		12	/* xpxg_pm_int_rpl */
+#define IRQ_IXP23XX_SWINT0		13	/* S/W Interrupt0 */
+#define IRQ_IXP23XX_SWINT1		14	/* S/W Interrupt1 */
+#define IRQ_IXP23XX_UART2		15	/* UART1 Interrupt */
+#define IRQ_IXP23XX_UART1		16	/* UART0 Interrupt */
+#define IRQ_IXP23XX_XSI_PMU_ROLLOVER	17	/* AHB Performance M. Unit counter rollover */
+#define IRQ_IXP23XX_XSI_AHB_PM0		18	/* intr_pm_o */
+#define IRQ_IXP23XX_XSI_AHB_ECE0	19	/* intr_ece_o */
+#define IRQ_IXP23XX_XSI_AHB_GASKET	20	/* gas_intr_o */
+#define IRQ_IXP23XX_XSI_CPP		21	/* xsi2cpp_int */
+#define IRQ_IXP23XX_CPP_XSI		22	/* cpp2xsi_int */
+#define IRQ_IXP23XX_ME_ATTN0		23	/* ME_ATTN */
+#define IRQ_IXP23XX_ME_ATTN1		24	/* ME_ATTN */
+#define IRQ_IXP23XX_ME_ATTN2		25	/* ME_ATTN */
+#define IRQ_IXP23XX_ME_ATTN3		26	/* ME_ATTN */
+#define IRQ_IXP23XX_PCI_ERR_RPH		27	/* PCXG_PCI_ERR_RPH */
+#define IRQ_IXP23XX_D0XG_ECC_CORR	28	/* D0XG_DRAM_ECC_CORR */
+#define IRQ_IXP23XX_D0XG_ECC_UNCORR	29	/* D0XG_DRAM_ECC_UNCORR */
+#define IRQ_IXP23XX_SRAM_ERR1		30	/* SRAM1_ERR */
+#define IRQ_IXP23XX_SRAM_ERR0		31	/* SRAM0_ERR */
+#define IRQ_IXP23XX_MEDIA_ERR		32	/* MEDIA_ERR */
+#define IRQ_IXP23XX_STH_DRAM_ECC_MAJ	33	/* STH_DRAM0_ECC_MAJ */
+#define IRQ_IXP23XX_GPIO6		34	/* GPIO0 interrupts */
+#define IRQ_IXP23XX_GPIO7		35	/* GPIO1 interrupts */
+#define IRQ_IXP23XX_GPIO8		36	/* GPIO2 interrupts */
+#define IRQ_IXP23XX_GPIO9		37	/* GPIO3 interrupts */
+#define IRQ_IXP23XX_GPIO10		38	/* GPIO4 interrupts */
+#define IRQ_IXP23XX_GPIO11		39	/* GPIO5 interrupts */
+#define IRQ_IXP23XX_GPIO12		40	/* GPIO6 interrupts */
+#define IRQ_IXP23XX_GPIO13		41	/* GPIO7 interrupts */
+#define IRQ_IXP23XX_GPIO14		42	/* GPIO8 interrupts */
+#define IRQ_IXP23XX_GPIO15		43	/* GPIO9 interrupts */
+#define IRQ_IXP23XX_SHAC_RING0		44	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING1		45	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING2		46	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING3		47	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING4		48	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING5		49	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING6		50	/* SHAC RING Full */
+#define IRQ_IXP23XX_SHAC_RING7		51	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING8		52	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING9		53	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING10		54	/* SHAC Ring Full */
+#define IRQ_IXP23XX_SHAC_RING11		55	/* SHAC Ring Full */
+#define IRQ_IXP23XX_ME_THREAD_A0_ME0	56	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A1_ME0	57	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A2_ME0	58	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A3_ME0	59	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A4_ME0	60	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A5_ME0	61	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A6_ME0	62	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A7_ME0	63	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A8_ME1	64	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A9_ME1	65	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A10_ME1	66	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A11_ME1	67	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A12_ME1	68	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A13_ME1	69	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A14_ME1	70	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A15_ME1	71	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A16_ME2	72	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A17_ME2	73	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A18_ME2	74	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A19_ME2	75	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A20_ME2	76	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A21_ME2	77	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A22_ME2	78	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A23_ME2	79	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A24_ME3	80	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A25_ME3	81	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A26_ME3	82	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A27_ME3	83	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A28_ME3	84	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A29_ME3	85	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A30_ME3	86	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_A31_ME3	87	/* ME_THREAD_A */
+#define IRQ_IXP23XX_ME_THREAD_B0_ME0	88	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B1_ME0	89	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B2_ME0	90	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B3_ME0	91	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B4_ME0	92	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B5_ME0	93	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B6_ME0	94	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B7_ME0	95	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B8_ME1	96	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B9_ME1	97	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B10_ME1	98	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B11_ME1	99	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B12_ME1	100	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B13_ME1	101	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B14_ME1	102	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B15_ME1	103	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B16_ME2	104	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B17_ME2	105	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B18_ME2	106	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B19_ME2	107	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B20_ME2	108	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B21_ME2	109	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B22_ME2	110	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B23_ME2	111	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B24_ME3	112	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B25_ME3	113	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B26_ME3	114	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B27_ME3	115	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B28_ME3	116	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B29_ME3	117	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B30_ME3	118	/* ME_THREAD_B */
+#define IRQ_IXP23XX_ME_THREAD_B31_ME3	119	/* ME_THREAD_B */
+
+#define NUM_IXP23XX_RAW_IRQS		120
+
+#define IRQ_IXP23XX_INTA		120	/* Indirect pcxg_pci_int_rph */
+#define IRQ_IXP23XX_INTB		121	/* Indirect pcxg_pci_int_rph */
+
+#define NR_IXP23XX_IRQ			(IRQ_IXP23XX_INTB + 1)
+
+/*
+ * We default to 32 per-board IRQs. Increase this number if you need
+ * more, but keep it realistic.
+ */
+#define NR_IXP23XX_MACH_IRQS 		32
+
+#define NR_IRQS				NR_IXP23XX_IRQS + NR_IXP23XX_MACH_IRQS
+
+#define IXP23XX_MACH_IRQ(irq) 		(NR_IXP23XX_IRQ + (irq))
+
+
+/*
+ * IXDP2351-specific interrupts
+ */
+
+/*
+ * External PCI interrupts signaled through INTB
+ *
+ */
+#define IXDP2351_INTB_IRQ_BASE 		0
+#define IRQ_IXDP2351_INTA_82546		IXP23XX_MACH_IRQ(0)
+#define IRQ_IXDP2351_INTB_82546		IXP23XX_MACH_IRQ(1)
+#define IRQ_IXDP2351_SPCI_DB_0		IXP23XX_MACH_IRQ(2)
+#define IRQ_IXDP2351_SPCI_DB_1		IXP23XX_MACH_IRQ(3)
+#define IRQ_IXDP2351_SPCI_PMC_INTA	IXP23XX_MACH_IRQ(4)
+#define IRQ_IXDP2351_SPCI_PMC_INTB	IXP23XX_MACH_IRQ(5)
+#define IRQ_IXDP2351_SPCI_PMC_INTC	IXP23XX_MACH_IRQ(6)
+#define IRQ_IXDP2351_SPCI_PMC_INTD	IXP23XX_MACH_IRQ(7)
+#define IRQ_IXDP2351_SPCI_FIC		IXP23XX_MACH_IRQ(8)
+
+#define IXDP2351_INTB_IRQ_BIT(irq)	(irq - IXP23XX_MACH_IRQ(0))
+#define IXDP2351_INTB_IRQ_MASK(irq)	(1 << IXDP2351_INTB_IRQ_BIT(irq))
+#define IXDP2351_INTB_IRQ_VALID		0x01FF
+#define IXDP2351_INTB_IRQ_NUM 		16
+
+/*
+ * Other external interrupts signaled through INTA
+ */
+#define IXDP2351_INTA_IRQ_BASE 		16
+#define IRQ_IXDP2351_IPMI_FROM		IXP23XX_MACH_IRQ(16)
+#define IRQ_IXDP2351_125US		IXP23XX_MACH_IRQ(17)
+#define IRQ_IXDP2351_DB_0_ADD		IXP23XX_MACH_IRQ(18)
+#define IRQ_IXDP2351_DB_1_ADD		IXP23XX_MACH_IRQ(19)
+#define IRQ_IXDP2351_DEBUG1		IXP23XX_MACH_IRQ(20)
+#define IRQ_IXDP2351_ADD_UART		IXP23XX_MACH_IRQ(21)
+#define IRQ_IXDP2351_FIC_ADD		IXP23XX_MACH_IRQ(24)
+#define IRQ_IXDP2351_CS8900		IXP23XX_MACH_IRQ(25)
+#define IRQ_IXDP2351_BBSRAM		IXP23XX_MACH_IRQ(26)
+#define IRQ_IXDP2351_CONFIG_MEDIA	IXP23XX_MACH_IRQ(27)
+#define IRQ_IXDP2351_CLOCK_REF		IXP23XX_MACH_IRQ(28)
+#define IRQ_IXDP2351_A10_NP		IXP23XX_MACH_IRQ(29)
+#define IRQ_IXDP2351_A11_NP		IXP23XX_MACH_IRQ(30)
+#define IRQ_IXDP2351_DEBUG_NP		IXP23XX_MACH_IRQ(31)
+
+#define IXDP2351_INTA_IRQ_BIT(irq) 	(irq - IXP23XX_MACH_IRQ(16))
+#define IXDP2351_INTA_IRQ_MASK(irq) 	(1 << IXDP2351_INTA_IRQ_BIT(irq))
+#define IXDP2351_INTA_IRQ_VALID 	0xFF3F
+#define IXDP2351_INTA_IRQ_NUM 		16
+
+
+/*
+ * ADI RoadRunner IRQs
+ */
+#define IRQ_ROADRUNNER_PCI_INTA 	IRQ_IXP23XX_INTA
+#define IRQ_ROADRUNNER_PCI_INTB 	IRQ_IXP23XX_INTB
+#define IRQ_ROADRUNNER_PCI_INTC 	IRQ_IXP23XX_GPIO11
+#define IRQ_ROADRUNNER_PCI_INTD 	IRQ_IXP23XX_GPIO12
+
+/*
+ * Put new board definitions here
+ */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/ixdp2351.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/ixdp2351.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/ixdp2351.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,89 @@
+/*
+ * include/asm-arm/arch-ixp23xx/ixdp2351.h
+ *
+ * Register and other defines for IXDP2351
+ *
+ * Copyright (c) 2002-2004 Intel Corp.
+ * Copytight (c) 2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_IXDP2351_H
+#define __ASM_ARCH_IXDP2351_H
+
+/*
+ * NP module memory map
+ */
+#define IXDP2351_NP_PHYS_BASE		(IXP23XX_EXP_BUS_CS4_BASE)
+#define IXDP2351_NP_PHYS_SIZE		0x00100000
+#define IXDP2351_NP_VIRT_BASE		0xeff00000
+
+#define IXDP2351_VIRT_CS8900_BASE	(IXDP2351_NP_VIRT_BASE)
+#define IXDP2351_VIRT_CS8900_END	(IXDP2351_VIRT_CS8900_BASE + 16)
+
+#define IXDP2351_VIRT_NP_CPLD_BASE 	(IXP23XX_EXP_BUS_CS4_BASE_VIRT + 0x00010000)
+
+#define IXDP2351_NP_CPLD_REG(reg) ((volatile u16 *)(IXDP2351_VIRT_NP_CPLD_BASE + reg))
+
+#define IXDP2351_NP_CPLD_RESET1_REG	IXDP2351_NP_CPLD_REG(0x00)
+#define IXDP2351_NP_CPLD_LED_REG	IXDP2351_NP_CPLD_REG(0x02)
+#define IXDP2351_NP_CPLD_VERSION_REG	IXDP2351_NP_CPLD_REG(0x04)
+
+/*
+ * Base board module memory map
+ */
+
+#define IXDP2351_BB_BASE_PHYS		(IXP23XX_EXP_BUS_CS5_BASE)
+#define IXDP2351_BB_SIZE		0x01000000
+#define IXDP2351_BB_BASE_VIRT		(0xee000000)
+
+#define IXDP2351_BB_AREA_BASE(offset)	(IXDP2351_BB_BASE_VIRT + offset)
+
+#define IXDP2351_VIRT_NVRAM_BASE	IXDP2351_BB_AREA_BASE(0x0)
+#define IXDP2351_NVRAM_SIZE		(0x20000)
+
+#define IXDP2351_VIRT_MB_IXF1104_BASE	IXDP2351_BB_AREA_BASE(0x00020000)
+#define IXDP2351_VIRT_ADD_UART_BASE	IXDP2351_BB_AREA_BASE(0x000240C0)
+#define IXDP2351_VIRT_FIC_BASE		IXDP2351_BB_AREA_BASE(0x00200000)
+#define IXDP2351_VIRT_DB0_BASE		IXDP2351_BB_AREA_BASE(0x00400000)
+#define IXDP2351_VIRT_DB1_BASE		IXDP2351_BB_AREA_BASE(0x00600000)
+#define IXDP2351_VIRT_CPLD_BASE		IXDP2351_BB_AREA_BASE(0x00024000)
+
+/*
+ * On board CPLD registers
+ */
+#define IXDP2351_CPLD_BB_REG(reg) ((volatile u16 *)(IXDP2351_VIRT_CPLD_BASE + reg))
+
+#define IXDP2351_CPLD_RESET0_REG	IXDP2351_CPLD_BB_REG(0x00)
+#define IXDP2351_CPLD_RESET1_REG	IXDP2351_CPLD_BB_REG(0x04)
+
+#define IXDP2351_CPLD_RESET1_MAGIC 	0x55AA
+#define IXDP2351_CPLD_RESET1_ENABLE 	0x8000
+
+#define IXDP2351_CPLD_FPGA_CONFIG_REG	IXDP2351_CPLD_BB_REG(0x08)
+#define IXDP2351_CPLD_INTB_MASK_SET_REG	IXDP2351_CPLD_BB_REG(0x10)
+#define IXDP2351_CPLD_INTA_MASK_SET_REG	IXDP2351_CPLD_BB_REG(0x14)
+#define IXDP2351_CPLD_INTB_STAT_REG	IXDP2351_CPLD_BB_REG(0x18)
+#define IXDP2351_CPLD_INTA_STAT_REG	IXDP2351_CPLD_BB_REG(0x1C)
+#define IXDP2351_CPLD_INTB_RAW_REG	IXDP2351_CPLD_BB_REG(0x20)	/* read */
+#define IXDP2351_CPLD_INTA_RAW_REG	IXDP2351_CPLD_BB_REG(0x24)	/* read */
+#define IXDP2351_CPLD_INTB_MASK_CLR_REG	IXDP2351_CPLD_INTB_RAW_REG	/* write */
+#define IXDP2351_CPLD_INTA_MASK_CLR_REG	IXDP2351_CPLD_INTA_RAW_REG	/* write */
+#define IXDP2351_CPLD_INTB_SIM_REG	IXDP2351_CPLD_BB_REG(0x28)
+#define IXDP2351_CPLD_INTA_SIM_REG	IXDP2351_CPLD_BB_REG(0x2C)
+	/* Interrupt bits are defined in irqs.h */
+#define IXDP2351_CPLD_BB_GBE0_REG	IXDP2351_CPLD_BB_REG(0x30)
+#define IXDP2351_CPLD_BB_GBE1_REG	IXDP2351_CPLD_BB_REG(0x34)
+
+/* #define IXDP2351_CPLD_BB_MISC_REG	IXDP2351_CPLD_REG(0x1C) */
+/* #define IXDP2351_CPLD_BB_MISC_REV_MASK	0xFF		*/
+/* #define IXDP2351_CPLD_BB_GDXCS0_REG	IXDP2351_CPLD_REG(0x24) */
+/* #define IXDP2351_CPLD_BB_GDXCS1_REG	IXDP2351_CPLD_REG(0x28) */
+/* #define IXDP2351_CPLD_BB_CLOCK_REG	IXDP2351_CPLD_REG(0x04) */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/ixp23xx.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/ixp23xx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/ixp23xx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,298 @@
+/*
+ * include/asm-arm/arch-ixp23xx/ixp23xx.h
+ *
+ * Register definitions for IXP23XX
+ *
+ * Copyright (C) 2003-2005 Intel Corporation.
+ * Copyright (C) 2005 MontaVista Software, Inc.
+ *
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_IXP23XX_H
+#define __ASM_ARCH_IXP23XX_H
+
+/*
+ * IXP2300 linux memory map:
+ *
+ * virt		phys		size
+ * fffd0000	a0000000	64K		XSI2CPP_CSR
+ * fffc0000	c4000000	4K		EXP_CFG
+ * fff00000	c8000000	64K		PERIPHERAL
+ * fe000000	1c0000000	16M		CAP_CSR
+ * fd000000	1c8000000	16M		MSF_CSR
+ * fb000000			16M		---
+ * fa000000	1d8000000	32M		PCI_IO
+ * f8000000	1da000000	32M		PCI_CFG
+ * f6000000	1de000000	32M		PCI_CREG
+ * f4000000			32M		---
+ * f0000000	1e0000000	64M		PCI_MEM
+ * e[c-f]000000					per-platform mappings
+ */
+
+
+/****************************************************************************
+ * Static mappings.
+ ****************************************************************************/
+#define IXP23XX_XSI2CPP_CSR_PHYS	0xa0000000
+#define IXP23XX_XSI2CPP_CSR_VIRT	0xfffd0000
+#define IXP23XX_XSI2CPP_CSR_SIZE	0x00010000
+
+#define IXP23XX_EXP_CFG_PHYS		0xc4000000
+#define IXP23XX_EXP_CFG_VIRT		0xfffc0000
+#define IXP23XX_EXP_CFG_SIZE		0x00001000
+
+#define IXP23XX_PERIPHERAL_PHYS		0xc8000000
+#define IXP23XX_PERIPHERAL_VIRT		0xfff00000
+#define IXP23XX_PERIPHERAL_SIZE		0x00010000
+
+#define IXP23XX_CAP_CSR_PHYS		0x1c0000000ULL
+#define IXP23XX_CAP_CSR_VIRT		0xfe000000
+#define IXP23XX_CAP_CSR_SIZE		0x01000000
+
+#define IXP23XX_MSF_CSR_PHYS		0x1c8000000ULL
+#define IXP23XX_MSF_CSR_VIRT		0xfd000000
+#define IXP23XX_MSF_CSR_SIZE		0x01000000
+
+#define IXP23XX_PCI_IO_PHYS		0x1d8000000ULL
+#define IXP23XX_PCI_IO_VIRT		0xfa000000
+#define IXP23XX_PCI_IO_SIZE		0x02000000
+
+#define IXP23XX_PCI_CFG_PHYS		0x1da000000ULL
+#define IXP23XX_PCI_CFG_VIRT		0xf8000000
+#define IXP23XX_PCI_CFG_SIZE		0x02000000
+#define IXP23XX_PCI_CFG0_VIRT		IXP23XX_PCI_CFG_VIRT
+#define IXP23XX_PCI_CFG1_VIRT		(IXP23XX_PCI_CFG_VIRT + 0x01000000)
+
+#define IXP23XX_PCI_CREG_PHYS		0x1de000000ULL
+#define IXP23XX_PCI_CREG_VIRT		0xf6000000
+#define IXP23XX_PCI_CREG_SIZE		0x02000000
+#define IXP23XX_PCI_CSR_VIRT		(IXP23XX_PCI_CREG_VIRT + 0x01000000)
+
+#define IXP23XX_PCI_MEM_START		0xe0000000
+#define IXP23XX_PCI_MEM_PHYS		0x1e0000000ULL
+#define IXP23XX_PCI_MEM_VIRT		0xf0000000
+#define IXP23XX_PCI_MEM_SIZE		0x04000000
+
+
+/****************************************************************************
+ * XSI2CPP CSRs.
+ ****************************************************************************/
+#define IXP23XX_XSI2CPP_REG(x)		((volatile unsigned long *)(IXP23XX_XSI2CPP_CSR_VIRT + (x)))
+#define IXP23XX_CPP2XSI_CURR_XFER_REG3	IXP23XX_XSI2CPP_REG(0xf8)
+#define IXP23XX_CPP2XSI_ADDR_31		(1 << 19)
+#define IXP23XX_CPP2XSI_PSH_OFF		(1 << 20)
+#define IXP23XX_CPP2XSI_COH_OFF		(1 << 21)
+
+
+/****************************************************************************
+ * Expansion Bus Config.
+ ****************************************************************************/
+#define IXP23XX_EXP_CFG_REG(x)		((volatile unsigned long *)(IXP23XX_EXP_CFG_VIRT + (x)))
+#define IXP23XX_EXP_CS0			IXP23XX_EXP_CFG_REG(0x00)
+#define IXP23XX_EXP_CS1			IXP23XX_EXP_CFG_REG(0x04)
+#define IXP23XX_EXP_CS2			IXP23XX_EXP_CFG_REG(0x08)
+#define IXP23XX_EXP_CS3			IXP23XX_EXP_CFG_REG(0x0c)
+#define IXP23XX_EXP_CS4			IXP23XX_EXP_CFG_REG(0x10)
+#define IXP23XX_EXP_CS5			IXP23XX_EXP_CFG_REG(0x14)
+#define IXP23XX_EXP_CS6			IXP23XX_EXP_CFG_REG(0x18)
+#define IXP23XX_EXP_CS7			IXP23XX_EXP_CFG_REG(0x1c)
+#define IXP23XX_FLASH_WRITABLE		(0x2)
+#define IXP23XX_FLASH_BUS8		(0x1)
+
+#define IXP23XX_EXP_CFG0		IXP23XX_EXP_CFG_REG(0x20)
+#define IXP23XX_EXP_CFG1		IXP23XX_EXP_CFG_REG(0x24)
+#define IXP23XX_EXP_CFG0_MEM_MAP		(1 << 31)
+#define IXP23XX_EXP_CFG0_XSCALE_SPEED_SEL 	(3 << 22)
+#define IXP23XX_EXP_CFG0_XSCALE_SPEED_EN	(1 << 21)
+#define IXP23XX_EXP_CFG0_CPP_SPEED_SEL		(3 << 19)
+#define IXP23XX_EXP_CFG0_CPP_SPEED_EN		(1 << 18)
+#define IXP23XX_EXP_CFG0_PCI_SWIN		(3 << 16)
+#define IXP23XX_EXP_CFG0_PCI_DWIN		(3 << 14)
+#define IXP23XX_EXP_CFG0_PCI33_MODE		(1 << 13)
+#define IXP23XX_EXP_CFG0_QDR_SPEED_SEL		(1 << 12)
+#define IXP23XX_EXP_CFG0_CPP_DIV_SEL		(1 << 5)
+#define IXP23XX_EXP_CFG0_XSI_NOT_PRES		(1 << 4)
+#define IXP23XX_EXP_CFG0_PROM_BOOT		(1 << 3)
+#define IXP23XX_EXP_CFG0_PCI_ARB		(1 << 2)
+#define IXP23XX_EXP_CFG0_PCI_HOST		(1 << 1)
+#define IXP23XX_EXP_CFG0_FLASH_WIDTH		(1 << 0)
+
+#define IXP23XX_EXP_UNIT_FUSE		IXP23XX_EXP_CFG_REG(0x28)
+#define IXP23XX_EXP_MSF_MUX		IXP23XX_EXP_CFG_REG(0x30)
+#define IXP23XX_EXP_CFG_FUSE		IXP23XX_EXP_CFG_REG(0x34)
+
+#define IXP23XX_EXP_BUS_PHYS		0x90000000
+#define IXP23XX_EXP_BUS_WINDOW_SIZE	0x01000000
+
+#define IXP23XX_EXP_BUS_CS0_BASE	(IXP23XX_EXP_BUS_PHYS + 0x00000000)
+#define IXP23XX_EXP_BUS_CS1_BASE	(IXP23XX_EXP_BUS_PHYS + 0x01000000)
+#define IXP23XX_EXP_BUS_CS2_BASE	(IXP23XX_EXP_BUS_PHYS + 0x02000000)
+#define IXP23XX_EXP_BUS_CS3_BASE	(IXP23XX_EXP_BUS_PHYS + 0x03000000)
+#define IXP23XX_EXP_BUS_CS4_BASE	(IXP23XX_EXP_BUS_PHYS + 0x04000000)
+#define IXP23XX_EXP_BUS_CS5_BASE	(IXP23XX_EXP_BUS_PHYS + 0x05000000)
+#define IXP23XX_EXP_BUS_CS6_BASE	(IXP23XX_EXP_BUS_PHYS + 0x06000000)
+#define IXP23XX_EXP_BUS_CS7_BASE	(IXP23XX_EXP_BUS_PHYS + 0x07000000)
+
+
+/****************************************************************************
+ * Peripherals.
+ ****************************************************************************/
+#define IXP23XX_UART1_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x0000)
+#define IXP23XX_UART2_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x1000)
+#define IXP23XX_PMU_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x2000)
+#define IXP23XX_INTC_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x3000)
+#define IXP23XX_GPIO_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x4000)
+#define IXP23XX_TIMER_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x5000)
+#define IXP23XX_NPE0_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x6000)
+#define IXP23XX_DSR_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x7000)
+#define IXP23XX_NPE1_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x8000)
+#define IXP23XX_ETH0_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0x9000)
+#define IXP23XX_ETH1_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0xA000)
+#define IXP23XX_GIG0_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0xB000)
+#define IXP23XX_GIG1_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0xC000)
+#define IXP23XX_DDRS_VIRT		(IXP23XX_PERIPHERAL_VIRT + 0xD000)
+
+#define IXP23XX_UART1_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x0000)
+#define IXP23XX_UART2_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x1000)
+#define IXP23XX_PMU_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x2000)
+#define IXP23XX_INTC_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x3000)
+#define IXP23XX_GPIO_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x4000)
+#define IXP23XX_TIMER_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x5000)
+#define IXP23XX_NPE0_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x6000)
+#define IXP23XX_DSR_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x7000)
+#define IXP23XX_NPE1_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x8000)
+#define IXP23XX_ETH0_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0x9000)
+#define IXP23XX_ETH1_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0xA000)
+#define IXP23XX_GIG0_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0xB000)
+#define IXP23XX_GIG1_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0xC000)
+#define IXP23XX_DDRS_PHYS		(IXP23XX_PERIPHERAL_PHYS + 0xD000)
+
+
+/****************************************************************************
+ * Interrupt controller.
+ ****************************************************************************/
+#define IXP23XX_INTC_REG(x)		 ((volatile unsigned long *)(IXP23XX_INTC_VIRT + (x)))
+#define IXP23XX_INTR_ST1		IXP23XX_INTC_REG(0x00)
+#define IXP23XX_INTR_ST2		IXP23XX_INTC_REG(0x04)
+#define IXP23XX_INTR_ST3		IXP23XX_INTC_REG(0x08)
+#define IXP23XX_INTR_ST4		IXP23XX_INTC_REG(0x0c)
+#define IXP23XX_INTR_EN1		IXP23XX_INTC_REG(0x10)
+#define IXP23XX_INTR_EN2		IXP23XX_INTC_REG(0x14)
+#define IXP23XX_INTR_EN3		IXP23XX_INTC_REG(0x18)
+#define IXP23XX_INTR_EN4		IXP23XX_INTC_REG(0x1c)
+#define IXP23XX_INTR_SEL1		IXP23XX_INTC_REG(0x20)
+#define IXP23XX_INTR_SEL2		IXP23XX_INTC_REG(0x24)
+#define IXP23XX_INTR_SEL3		IXP23XX_INTC_REG(0x28)
+#define IXP23XX_INTR_SEL4		IXP23XX_INTC_REG(0x2c)
+#define IXP23XX_INTR_IRQ_ST1		IXP23XX_INTC_REG(0x30)
+#define IXP23XX_INTR_IRQ_ST2		IXP23XX_INTC_REG(0x34)
+#define IXP23XX_INTR_IRQ_ST3		IXP23XX_INTC_REG(0x38)
+#define IXP23XX_INTR_IRQ_ST4		IXP23XX_INTC_REG(0x3c)
+#define IXP23XX_INTR_IRQ_ENC_ST_OFFSET	0x54
+
+
+/****************************************************************************
+ * GPIO.
+ ****************************************************************************/
+#define IXP23XX_GPIO_REG(x)		((volatile unsigned long *)(IXP23XX_GPIO_VIRT + (x)))
+#define IXP23XX_GPIO_GPOUTR		IXP23XX_GPIO_REG(0x00)
+#define IXP23XX_GPIO_GPOER		IXP23XX_GPIO_REG(0x04)
+#define IXP23XX_GPIO_GPINR		IXP23XX_GPIO_REG(0x08)
+#define IXP23XX_GPIO_GPISR		IXP23XX_GPIO_REG(0x0c)
+#define IXP23XX_GPIO_GPIT1R		IXP23XX_GPIO_REG(0x10)
+#define IXP23XX_GPIO_GPIT2R		IXP23XX_GPIO_REG(0x14)
+#define IXP23XX_GPIO_GPCLKR		IXP23XX_GPIO_REG(0x18)
+#define IXP23XX_GPIO_GPDBSELR 		IXP23XX_GPIO_REG(0x1c)
+
+#define IXP23XX_GPIO_STYLE_MASK		0x7
+#define IXP23XX_GPIO_STYLE_ACTIVE_HIGH	0x0
+#define IXP23XX_GPIO_STYLE_ACTIVE_LOW	0x1
+#define IXP23XX_GPIO_STYLE_RISING_EDGE	0x2
+#define IXP23XX_GPIO_STYLE_FALLING_EDGE	0x3
+#define IXP23XX_GPIO_STYLE_TRANSITIONAL	0x4
+
+#define IXP23XX_GPIO_STYLE_SIZE		3
+
+
+/****************************************************************************
+ * Timer.
+ ****************************************************************************/
+#define IXP23XX_TIMER_REG(x)		((volatile unsigned long *)(IXP23XX_TIMER_VIRT + (x)))
+#define IXP23XX_TIMER_CONT		IXP23XX_TIMER_REG(0x00)
+#define IXP23XX_TIMER1_TIMESTAMP	IXP23XX_TIMER_REG(0x04)
+#define IXP23XX_TIMER1_RELOAD		IXP23XX_TIMER_REG(0x08)
+#define IXP23XX_TIMER2_TIMESTAMP	IXP23XX_TIMER_REG(0x0c)
+#define IXP23XX_TIMER2_RELOAD		IXP23XX_TIMER_REG(0x10)
+#define IXP23XX_TIMER_WDOG		IXP23XX_TIMER_REG(0x14)
+#define IXP23XX_TIMER_WDOG_EN		IXP23XX_TIMER_REG(0x18)
+#define IXP23XX_TIMER_WDOG_KEY		IXP23XX_TIMER_REG(0x1c)
+#define IXP23XX_TIMER_WDOG_KEY_MAGIC	0x482e
+#define IXP23XX_TIMER_STATUS		IXP23XX_TIMER_REG(0x20)
+#define IXP23XX_TIMER_SOFT_RESET	IXP23XX_TIMER_REG(0x24)
+#define IXP23XX_TIMER_SOFT_RESET_EN	IXP23XX_TIMER_REG(0x28)
+
+#define IXP23XX_TIMER_ENABLE		(1 << 0)
+#define IXP23XX_TIMER_ONE_SHOT		(1 << 1)
+/* Low order bits of reload value ignored */
+#define IXP23XX_TIMER_RELOAD_MASK	(0x3)
+#define IXP23XX_TIMER_DISABLED		(0x0)
+#define IXP23XX_TIMER1_INT_PEND		(1 << 0)
+#define IXP23XX_TIMER2_INT_PEND		(1 << 1)
+#define IXP23XX_TIMER_STATUS_TS_PEND	(1 << 2)
+#define IXP23XX_TIMER_STATUS_WDOG_PEND	(1 << 3)
+#define IXP23XX_TIMER_STATUS_WARM_RESET	(1 << 4)
+
+
+/****************************************************************************
+ * CAP CSRs.
+ ****************************************************************************/
+#define IXP23XX_GLOBAL_REG(x)		((volatile unsigned long *)(IXP23XX_CAP_CSR_VIRT + 0x4a00 + (x)))
+#define IXP23XX_PRODUCT_ID		IXP23XX_GLOBAL_REG(0x00)
+#define IXP23XX_MISC_CONTROL		IXP23XX_GLOBAL_REG(0x04)
+#define IXP23XX_MSF_CLK_CNTRL		IXP23XX_GLOBAL_REG(0x08)
+#define IXP23XX_RESET0			IXP23XX_GLOBAL_REG(0x0c)
+#define IXP23XX_RESET1			IXP23XX_GLOBAL_REG(0x10)
+#define IXP23XX_STRAP_OPTIONS		IXP23XX_GLOBAL_REG(0x18)
+
+#define IXP23XX_ENABLE_WATCHDOG		(1 << 24)
+#define IXP23XX_SHPC_INIT_COMP		(1 << 21)
+#define IXP23XX_RST_ALL			(1 << 16)
+#define IXP23XX_RESET_PCI		(1 << 2)
+#define IXP23XX_PCI_UNIT_RESET		(1 << 1)
+#define IXP23XX_XSCALE_RESET		(1 << 0)
+
+#define IXP23XX_UENGINE_CSR_VIRT_BASE	(IXP23XX_CAP_CSR_VIRT + 0x18000)
+
+
+/****************************************************************************
+ * PCI CSRs.
+ ****************************************************************************/
+#define IXP23XX_PCI_CREG(x)		((volatile unsigned long *)(IXP23XX_PCI_CREG_VIRT + (x)))
+#define IXP23XX_PCI_CMDSTAT		IXP23XX_PCI_CREG(0x04)
+#define IXP23XX_PCI_SRAM_BAR		IXP23XX_PCI_CREG(0x14)
+#define IXP23XX_PCI_SDRAM_BAR		IXP23XX_PCI_CREG(0x18)
+
+
+#define IXP23XX_PCI_CSR(x)		((volatile unsigned long *)(IXP23XX_PCI_CREG_VIRT + 0x01000000 + (x)))
+#define IXP23XX_PCI_OUT_INT_STATUS	IXP23XX_PCI_CSR(0x0030)
+#define IXP23XX_PCI_OUT_INT_MASK	IXP23XX_PCI_CSR(0x0034)
+#define IXP23XX_PCI_SRAM_BASE_ADDR_MASK IXP23XX_PCI_CSR(0x00fc)
+#define IXP23XX_PCI_DRAM_BASE_ADDR_MASK IXP23XX_PCI_CSR(0x0100)
+#define IXP23XX_PCI_CONTROL		IXP23XX_PCI_CSR(0x013c)
+#define IXP23XX_PCI_ADDR_EXT		IXP23XX_PCI_CSR(0x0140)
+#define IXP23XX_PCI_ME_PUSH_STATUS	IXP23XX_PCI_CSR(0x0148)
+#define IXP23XX_PCI_ME_PUSH_EN		IXP23XX_PCI_CSR(0x014c)
+#define IXP23XX_PCI_ERR_STATUS		IXP23XX_PCI_CSR(0x0150)
+#define IXP23XX_PCI_ERROR_STATUS	IXP23XX_PCI_CSR(0x0150)
+#define IXP23XX_PCI_ERR_ENABLE		IXP23XX_PCI_CSR(0x0154)
+#define IXP23XX_PCI_XSCALE_INT_STATUS	IXP23XX_PCI_CSR(0x0158)
+#define IXP23XX_PCI_XSCALE_INT_ENABLE	IXP23XX_PCI_CSR(0x015c)
+#define IXP23XX_PCI_CPP_ADDR_BITS	IXP23XX_PCI_CSR(0x0160)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ * include/asm-arm/arch-ixp23xx/memory.h
+ *
+ * Copyright (c) 2003-2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/hardware.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET		(0x00000000)
+
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#ifndef __ASSEMBLY__
+#include <asm/mach-types.h>
+
+#define __virt_to_bus(v)						\
+	({ unsigned int ret;						\
+	ret = ((__virt_to_phys(v) - 0x00000000) +			\
+	 (*((volatile int *)IXP23XX_PCI_SDRAM_BAR) & 0xfffffff0)); 	\
+	ret; })
+
+#define __bus_to_virt(b)						\
+	({ unsigned int data;						\
+	data = *((volatile int *)IXP23XX_PCI_SDRAM_BAR);		\
+	 __phys_to_virt((((b - (data & 0xfffffff0)) + 0x00000000))); })
+
+#define arch_is_coherent()	1
+
+#endif
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/platform.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/*
+ * include/asm-arm/arch-ixp23xx/platform.h
+ *
+ * Various bits of code used by platform-level code.
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2005 (c) MontaVista Software, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASSEMBLY__
+
+extern inline unsigned long ixp2000_reg_read(volatile void *reg)
+{
+	return *((volatile unsigned long *)reg);
+}
+
+extern inline void ixp2000_reg_write(volatile void *reg, unsigned long val)
+{
+	*((volatile unsigned long *)reg) = val;
+}
+
+extern inline void ixp2000_reg_wrb(volatile void *reg, unsigned long val)
+{
+	*((volatile unsigned long *)reg) = val;
+}
+
+struct pci_sys_data;
+
+void ixp23xx_map_io(void);
+void ixp23xx_init_irq(void);
+void ixp23xx_sys_init(void);
+int ixp23xx_pci_setup(int, struct pci_sys_data *);
+void ixp23xx_pci_preinit(void);
+struct pci_bus *ixp23xx_pci_scan_bus(int, struct pci_sys_data*);
+void ixp23xx_pci_slave_init(void);
+
+extern struct sys_timer ixp23xx_timer;
+
+#define IXP23XX_UART_XTAL		14745600
+
+#ifndef __ASSEMBLY__
+/*
+ * Is system memory on the XSI or CPP bus?
+ */
+static inline unsigned ixp23xx_cpp_boot(void)
+{
+	return (*IXP23XX_EXP_CFG0 & IXP23XX_EXP_CFG0_XSI_NOT_PRES);
+}
+#endif
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-ixp23xx/system.h
+ *
+ * Copyright (C) 2003 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+static inline void arch_idle(void)
+{
+#if 0
+	if (!hlt_counter)
+		cpu_do_idle();
+#endif
+}
+
+static inline void arch_reset(char mode)
+{
+	/* First try machine specific support */
+	if (machine_is_ixdp2351()) {
+		*IXDP2351_CPLD_RESET1_REG = IXDP2351_CPLD_RESET1_MAGIC;
+		(void) *IXDP2351_CPLD_RESET1_REG;
+		*IXDP2351_CPLD_RESET1_REG = IXDP2351_CPLD_RESET1_ENABLE;
+	}
+
+	/* Use on-chip reset capability */
+	*IXP23XX_RESET0 |= IXP23XX_RST_ALL;
+}
Index: build_tree/linux/include/asm/arch-ixp23xx/time.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/time.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/time.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,3 @@
+/*
+ * include/asm-arm/arch-ixp23xx/time.h
+ */
Index: build_tree/linux/include/asm/arch-ixp23xx/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,7 @@
+/*
+ * include/asm-arm/arch-ixp23xx/timex.h
+ *
+ * XScale architecture timex specifications
+ */
+
+#define CLOCK_TICK_RATE 75000000
Index: build_tree/linux/include/asm/arch-ixp23xx/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ * include/asm-arm/arch-ixp23xx/uncompress.h
+ *
+ * Copyright (C) 2002-2004 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <asm/arch/ixp23xx.h>
+#include <linux/serial_reg.h>
+
+#define UART_BASE	((volatile u32 *)IXP23XX_UART1_PHYS)
+
+static inline void putc(char c)
+{
+	int j;
+
+	for (j = 0; j < 0x1000; j++) {
+		if (UART_BASE[UART_LSR] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	UART_BASE[UART_TX] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp23xx/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp23xx/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp23xx/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,10 @@
+/*
+ * include/asm-arm/arch-ixp23xx/vmalloc.h
+ *
+ * Copyright (c) 2005 MontaVista Software, Inc.
+ *
+ * NPU mappings end at 0xf0000000 and we allocate 64MB for board
+ * specific static I/O.
+ */
+
+#define VMALLOC_END	(0xec000000)
Index: build_tree/linux/include/asm/arch-ixp4xx/avila.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/avila.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/avila.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-ixp4xx/avila.h
+ *
+ * Gateworks Avila platform specific definitions
+ *
+ * Author: Michael-Luke Jones <mlj28@cam.ac.uk>
+ *
+ * Based on ixdp425.h
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define	AVILA_SDA_PIN		7
+#define	AVILA_SCL_PIN		6
+
+/*
+ * AVILA PCI IRQs
+ */
+#define AVILA_PCI_MAX_DEV	4
+#define LOFT_PCI_MAX_DEV    6
+#define AVILA_PCI_IRQ_LINES	4
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define AVILA_PCI_INTA_PIN	11
+#define AVILA_PCI_INTB_PIN	10
+#define AVILA_PCI_INTC_PIN	9
+#define AVILA_PCI_INTD_PIN	8
+
+
Index: build_tree/linux/include/asm/arch-ixp4xx/coyote.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/coyote.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/coyote.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-ixp4xx/coyote.h
+ *
+ * ADI Engineering platform specific definitions
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista, Software, Inc. 
+ * 
+ * This file is licensed under  the terms of the GNU General Public 
+ * License version 2. This program is licensed "as is" without any 
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define	COYOTE_PCI_SLOT0_PIN	6
+#define	COYOTE_PCI_SLOT1_PIN	11
+
+#define	COYOTE_PCI_SLOT0_DEVID	14
+#define	COYOTE_PCI_SLOT1_DEVID	15
+
+#define	COYOTE_IDE_BASE_PHYS	IXP4XX_EXP_BUS_BASE(3)
+#define	COYOTE_IDE_BASE_VIRT	0xFFFE1000
+#define	COYOTE_IDE_REGION_SIZE	0x1000
+
+#define	COYOTE_IDE_DATA_PORT	0xFFFE10E0
+#define	COYOTE_IDE_CTRL_PORT	0xFFFE10FC
+#define	COYOTE_IDE_ERROR_PORT	0xFFFE10E2
+
Index: build_tree/linux/include/asm/arch-ixp4xx/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/debug-macro.S	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,24 @@
+/* linux/include/asm-arm/arch-ixp4xx/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+                .macro  addruart,rx
+                mrc     p15, 0, \rx, c1, c0
+                tst     \rx, #1                 @ MMU enabled?
+                moveq   \rx, #0xc8000000
+                movne   \rx, #0xff000000
+		orrne	\rx, \rx, #0x00b00000
+                add     \rx,\rx,#3              @ Uart regs are at off set of 3 if
+						@ byte writes used - Big Endian.
+                .endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-ixp4xx/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/dma.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,22 @@
+/*
+ * include/asm-arm/arch-ixp4xx/dma.h
+ *
+ * Copyright (C) 2001-2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <asm/page.h>
+#include <asm/sizes.h>
+#include <asm/hardware.h>
+
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET + SZ_64M)
+
+#endif /* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-ixp4xx/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/entry-macro.S	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,47 @@
+/*
+ * include/asm-arm/arch-ixp4xx/entry-macro.S
+ *
+ * Low-level IRQ helper macros for IXP4xx-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\irqstat, =(IXP4XX_INTC_BASE_VIRT+IXP4XX_ICIP_OFFSET)
+		ldr	\irqstat, [\irqstat]		@ get interrupts
+		cmp	\irqstat, #0
+		beq	1001f				@ upper IRQ?
+		clz     \irqnr, \irqstat
+		mov     \base, #31
+		sub     \irqnr, \base, \irqnr
+		b	1002f				@ lower IRQ being
+							@ handled
+
+1001:
+		/*
+		 * IXP465 has an upper IRQ status register
+		 */
+#if defined(CONFIG_CPU_IXP46X)
+		ldr	\irqstat, =(IXP4XX_INTC_BASE_VIRT+IXP4XX_ICIP2_OFFSET)
+		ldr	\irqstat, [\irqstat]		@ get upper interrupts
+		mov	\irqnr, #63
+		clz	\irqstat, \irqstat
+ 		cmp	\irqstat, #32
+		subne	\irqnr, \irqnr, \irqstat
+#endif
+1002:
+		.endm
+
+
Index: build_tree/linux/include/asm/arch-ixp4xx/gtwx5715.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/gtwx5715.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/gtwx5715.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,116 @@
+/*
+ * include/asm-arm/arch-ixp4xx/gtwx5715.h
+ *
+ * Gemtek GTWX5715 Gateway (Linksys WRV54G)
+ *
+ * Copyright 2004 (c) George T. Joseph
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+#include "irqs.h"
+
+#define GTWX5715_GPIO0	0
+#define GTWX5715_GPIO1	1
+#define GTWX5715_GPIO2	2
+#define GTWX5715_GPIO3	3
+#define GTWX5715_GPIO4	4
+#define GTWX5715_GPIO5	5
+#define GTWX5715_GPIO6	6
+#define GTWX5715_GPIO7	7
+#define GTWX5715_GPIO8	8
+#define GTWX5715_GPIO9	9
+#define GTWX5715_GPIO10	10
+#define GTWX5715_GPIO11	11
+#define GTWX5715_GPIO12	12
+#define GTWX5715_GPIO13	13
+#define GTWX5715_GPIO14	14
+
+#define GTWX5715_GPIO0_IRQ			IRQ_IXP4XX_GPIO0
+#define GTWX5715_GPIO1_IRQ			IRQ_IXP4XX_GPIO1
+#define GTWX5715_GPIO2_IRQ			IRQ_IXP4XX_GPIO2
+#define GTWX5715_GPIO3_IRQ			IRQ_IXP4XX_GPIO3
+#define GTWX5715_GPIO4_IRQ			IRQ_IXP4XX_GPIO4
+#define GTWX5715_GPIO5_IRQ			IRQ_IXP4XX_GPIO5
+#define GTWX5715_GPIO6_IRQ			IRQ_IXP4XX_GPIO6
+#define GTWX5715_GPIO7_IRQ			IRQ_IXP4XX_GPIO7
+#define GTWX5715_GPIO8_IRQ			IRQ_IXP4XX_GPIO8
+#define GTWX5715_GPIO9_IRQ			IRQ_IXP4XX_GPIO9
+#define GTWX5715_GPIO10_IRQ		IRQ_IXP4XX_GPIO10
+#define GTWX5715_GPIO11_IRQ		IRQ_IXP4XX_GPIO11
+#define GTWX5715_GPIO12_IRQ		IRQ_IXP4XX_GPIO12
+#define GTWX5715_GPIO13_IRQ		IRQ_IXP4XX_SW_INT1
+#define GTWX5715_GPIO14_IRQ		IRQ_IXP4XX_SW_INT2
+
+/* PCI controller GPIO to IRQ pin mappings
+
+			INTA	INTB
+SLOT 0	10		11
+SLOT 1	11		10
+
+*/
+
+#define	GTWX5715_PCI_SLOT0_DEVID	0
+#define	GTWX5715_PCI_SLOT0_INTA_GPIO	GTWX5715_GPIO10
+#define	GTWX5715_PCI_SLOT0_INTB_GPIO	GTWX5715_GPIO11
+#define	GTWX5715_PCI_SLOT0_INTA_IRQ	GTWX5715_GPIO10_IRQ
+#define	GTWX5715_PCI_SLOT0_INTB_IRQ	GTWX5715_GPIO11_IRQ
+
+#define	GTWX5715_PCI_SLOT1_DEVID	1
+#define	GTWX5715_PCI_SLOT1_INTA_GPIO	GTWX5715_GPIO11
+#define	GTWX5715_PCI_SLOT1_INTB_GPIO	GTWX5715_GPIO10
+#define	GTWX5715_PCI_SLOT1_INTA_IRQ	GTWX5715_GPIO11_IRQ
+#define	GTWX5715_PCI_SLOT1_INTB_IRQ	GTWX5715_GPIO10_IRQ
+
+#define GTWX5715_PCI_SLOT_COUNT			2
+#define GTWX5715_PCI_INT_PIN_COUNT		2
+
+/*
+ * GPIO 5,6,7 and12 are hard wired to the Kendin KS8995M Switch
+ * and operate as an SPI type interface.  The details of the interface
+ * are available on Kendin/Micrel's web site.
+ */
+
+#define GTWX5715_KSSPI_SELECT	GTWX5715_GPIO5
+#define GTWX5715_KSSPI_TXD		GTWX5715_GPIO6
+#define GTWX5715_KSSPI_CLOCK	GTWX5715_GPIO7
+#define GTWX5715_KSSPI_RXD		GTWX5715_GPIO12
+
+/*
+ * The "reset" button is wired to GPIO 3.
+ * The GPIO is brought "low" when the button is pushed.
+ */
+
+#define GTWX5715_BUTTON_GPIO	GTWX5715_GPIO3
+#define GTWX5715_BUTTON_IRQ	GTWX5715_GPIO3_IRQ
+
+/*
+ *  Board Label      Front Label
+ *  LED1             Power
+ *  LED2             Wireless-G
+ *  LED3             not populated but could be
+ *  LED4             Internet
+ *  LED5 - LED8      Controlled by KS8995M Switch
+ *  LED9             DMZ
+ */
+
+#define GTWX5715_LED1_GPIO		GTWX5715_GPIO2
+#define GTWX5715_LED2_GPIO		GTWX5715_GPIO9
+#define GTWX5715_LED3_GPIO		GTWX5715_GPIO8
+#define GTWX5715_LED4_GPIO		GTWX5715_GPIO1
+#define GTWX5715_LED9_GPIO		GTWX5715_GPIO4
Index: build_tree/linux/include/asm/arch-ixp4xx/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/hardware.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,51 @@
+/*
+ * include/asm-arm/arch-ixp4xx/hardware.h 
+ *
+ * Copyright (C) 2002 Intel Corporation.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*
+ * Hardware definitions for IXP4xx based systems
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#define __ASM_ARCH_HARDWARE_H__
+
+#define PCIBIOS_MIN_IO			0x00001000
+#define PCIBIOS_MIN_MEM			0x48000000
+
+/*
+ * We override the standard dma-mask routines for bouncing.
+ */
+#define	HAVE_ARCH_PCI_SET_DMA_MASK
+
+#define pcibios_assign_all_busses()	1
+
+#if defined(CONFIG_CPU_IXP46X) && !defined(__ASSEMBLY__)
+extern unsigned int processor_id;
+#define cpu_is_ixp465() ((processor_id & 0xffffffc0) == 0x69054200)
+#else
+#define	cpu_is_ixp465()	(0)
+#endif
+
+/* Register locations and bits */
+#include "ixp4xx-regs.h"
+
+/* Platform helper functions and definitions */
+#include "platform.h"
+
+/* Platform specific details */
+#include "ixdp425.h"
+#include "avila.h"
+#include "coyote.h"
+#include "prpmc1100.h"
+#include "nslu2.h"
+#include "nas100d.h"
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-ixp4xx/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/io.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,570 @@
+/*
+ * linux/include/asm-arm/arch-ixp4xx/io.h
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002-2005  MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffff0000
+
+#define	BIT(x)	((1)<<(x))
+
+
+extern int (*ixp4xx_pci_read)(u32 addr, u32 cmd, u32* data);
+extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
+
+
+/*
+ * IXP4xx provides two methods of accessing PCI memory space:
+ *
+ * 1) A direct mapped window from 0x48000000 to 0x4bffffff (64MB).
+ *    To access PCI via this space, we simply ioremap() the BAR
+ *    into the kernel and we can use the standard read[bwl]/write[bwl]
+ *    macros. This is the preffered method due to speed but it
+ *    limits the system to just 64MB of PCI memory. This can be 
+ *    problamatic if using video cards and other memory-heavy
+ *    targets.
+ *
+ * 2) If > 64MB of memory space is required, the IXP4xx can be configured
+ *    to use indirect registers to access PCI (as we do below for I/O
+ *    transactions). This allows for up to 128MB (0x48000000 to 0x4fffffff)
+ *    of memory on the bus. The disadvantage of this is that every 
+ *    PCI access requires three local register accesses plus a spinlock,
+ *    but in some cases the performance hit is acceptable. In addition,
+ *    you cannot mmap() PCI devices in this case.
+ *
+ */
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+
+#define __mem_pci(a)		(a)
+
+#else
+
+#include <linux/mm.h>
+
+/*
+ * In the case of using indirect PCI, we simply return the actual PCI
+ * address and our read/write implementation use that to drive the 
+ * access registers. If something outside of PCI is ioremap'd, we
+ * fallback to the default.
+ */
+static inline void __iomem *
+__ixp4xx_ioremap(unsigned long addr, size_t size, unsigned long flags)
+{
+	if((addr < 0x48000000) || (addr > 0x4fffffff))
+		return __ioremap(addr, size, flags);
+
+	return (void *)addr;
+}
+
+static inline void
+__ixp4xx_iounmap(void __iomem *addr)
+{
+	if ((u32)addr >= VMALLOC_START)
+		__iounmap(addr);
+}
+
+#define __arch_ioremap(a, s, f)		__ixp4xx_ioremap(a, s, f)
+#define	__arch_iounmap(a)		__ixp4xx_iounmap(a)
+
+#define	writeb(v, p)			__ixp4xx_writeb(v, p)
+#define	writew(v, p)			__ixp4xx_writew(v, p)
+#define	writel(v, p)			__ixp4xx_writel(v, p)
+
+#define	writesb(p, v, l)		__ixp4xx_writesb(p, v, l)
+#define	writesw(p, v, l)		__ixp4xx_writesw(p, v, l)
+#define	writesl(p, v, l)		__ixp4xx_writesl(p, v, l)
+	
+#define	readb(p)			__ixp4xx_readb(p)
+#define	readw(p)			__ixp4xx_readw(p)
+#define	readl(p)			__ixp4xx_readl(p)
+	
+#define	readsb(p, v, l)			__ixp4xx_readsb(p, v, l)
+#define	readsw(p, v, l)			__ixp4xx_readsw(p, v, l)
+#define	readsl(p, v, l)			__ixp4xx_readsl(p, v, l)
+
+static inline void 
+__ixp4xx_writeb(u8 value, volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START) {
+		__raw_writeb(value, addr);
+		return;
+	}
+
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_MEMWRITE, data);
+}
+
+static inline void
+__ixp4xx_writesb(volatile void __iomem *bus_addr, const u8 *vaddr, int count)
+{
+	while (count--)
+		writeb(*vaddr++, bus_addr);
+}
+
+static inline void 
+__ixp4xx_writew(u16 value, volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START) {
+		__raw_writew(value, addr);
+		return;
+	}
+
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_MEMWRITE, data);
+}
+
+static inline void
+__ixp4xx_writesw(volatile void __iomem *bus_addr, const u16 *vaddr, int count)
+{
+	while (count--)
+		writew(*vaddr++, bus_addr);
+}
+
+static inline void 
+__ixp4xx_writel(u32 value, volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	if (addr >= VMALLOC_START) {
+		__raw_writel(value, addr);
+		return;
+	}
+
+	ixp4xx_pci_write(addr, NP_CMD_MEMWRITE, value);
+}
+
+static inline void
+__ixp4xx_writesl(volatile void __iomem *bus_addr, const u32 *vaddr, int count)
+{
+	while (count--)
+		writel(*vaddr++, bus_addr);
+}
+
+static inline unsigned char 
+__ixp4xx_readb(const volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START)
+		return __raw_readb(addr);
+
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_MEMREAD, &data))
+		return 0xff;
+
+	return data >> (8*n);
+}
+
+static inline void
+__ixp4xx_readsb(const volatile void __iomem *bus_addr, u8 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = readb(bus_addr);
+}
+
+static inline unsigned short 
+__ixp4xx_readw(const volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START)
+		return __raw_readw(addr);
+
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_MEMREAD, &data))
+		return 0xffff;
+
+	return data>>(8*n);
+}
+
+static inline void 
+__ixp4xx_readsw(const volatile void __iomem *bus_addr, u16 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = readw(bus_addr);
+}
+
+static inline unsigned long 
+__ixp4xx_readl(const volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 data;
+
+	if (addr >= VMALLOC_START)
+		return __raw_readl(addr);
+
+	if (ixp4xx_pci_read(addr, NP_CMD_MEMREAD, &data))
+		return 0xffffffff;
+
+	return data;
+}
+
+static inline void 
+__ixp4xx_readsl(const volatile void __iomem *bus_addr, u32 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = readl(bus_addr);
+}
+
+
+/*
+ * We can use the built-in functions b/c they end up calling writeb/readb
+ */
+#define memset_io(c,v,l)		_memset_io((c),(v),(l))
+#define memcpy_fromio(a,c,l)		_memcpy_fromio((a),(c),(l))
+#define memcpy_toio(c,a,l)		_memcpy_toio((c),(a),(l))
+
+#endif
+
+#ifndef CONFIG_PCI
+
+#define	__io(v)		v
+
+#else
+
+/*
+ * IXP4xx does not have a transparent cpu -> PCI I/O translation
+ * window.  Instead, it has a set of registers that must be tweaked
+ * with the proper byte lanes, command types, and address for the
+ * transaction.  This means that we need to override the default
+ * I/O functions.
+ */
+#define	outb(p, v)			__ixp4xx_outb(p, v)
+#define	outw(p, v)			__ixp4xx_outw(p, v)
+#define	outl(p, v)			__ixp4xx_outl(p, v)
+	
+#define	outsb(p, v, l)			__ixp4xx_outsb(p, v, l)
+#define	outsw(p, v, l)			__ixp4xx_outsw(p, v, l)
+#define	outsl(p, v, l)			__ixp4xx_outsl(p, v, l)
+
+#define	inb(p)				__ixp4xx_inb(p)
+#define	inw(p)				__ixp4xx_inw(p)
+#define	inl(p)				__ixp4xx_inl(p)
+
+#define	insb(p, v, l)			__ixp4xx_insb(p, v, l)
+#define	insw(p, v, l)			__ixp4xx_insw(p, v, l)
+#define	insl(p, v, l)			__ixp4xx_insl(p, v, l)
+
+
+static inline void 
+__ixp4xx_outb(u8 value, u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
+}
+
+static inline void 
+__ixp4xx_outsb(u32 io_addr, const u8 *vaddr, u32 count)
+{
+	while (count--)
+		outb(*vaddr++, io_addr);
+}
+
+static inline void 
+__ixp4xx_outw(u16 value, u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
+}
+
+static inline void 
+__ixp4xx_outsw(u32 io_addr, const u16 *vaddr, u32 count)
+{
+	while (count--)
+		outw(cpu_to_le16(*vaddr++), io_addr);
+}
+
+static inline void 
+__ixp4xx_outl(u32 value, u32 addr)
+{
+	ixp4xx_pci_write(addr, NP_CMD_IOWRITE, value);
+}
+
+static inline void 
+__ixp4xx_outsl(u32 io_addr, const u32 *vaddr, u32 count)
+{
+	while (count--)
+		outl(*vaddr++, io_addr);
+}
+
+static inline u8 
+__ixp4xx_inb(u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_IOREAD, &data))
+		return 0xff;
+
+	return data >> (8*n);
+}
+
+static inline void 
+__ixp4xx_insb(u32 io_addr, u8 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = inb(io_addr);
+}
+
+static inline u16 
+__ixp4xx_inw(u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_IOREAD, &data))
+		return 0xffff;
+
+	return data>>(8*n);
+}
+
+static inline void 
+__ixp4xx_insw(u32 io_addr, u16 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = le16_to_cpu(inw(io_addr));
+}
+
+static inline u32 
+__ixp4xx_inl(u32 addr)
+{
+	u32 data;
+	if (ixp4xx_pci_read(addr, NP_CMD_IOREAD, &data))
+		return 0xffffffff;
+
+	return data;
+}
+
+static inline void 
+__ixp4xx_insl(u32 io_addr, u32 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = inl(io_addr);
+}
+
+#define PIO_OFFSET      0x10000UL
+#define PIO_MASK        0x0ffffUL
+
+#define	__is_io_address(p)	(((unsigned long)p >= PIO_OFFSET) && \
+					((unsigned long)p <= (PIO_MASK + PIO_OFFSET)))
+static inline unsigned int
+__ixp4xx_ioread8(const void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		return	(unsigned int)__ixp4xx_inb(port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		return (unsigned int)__raw_readb(port);
+#else
+		return (unsigned int)__ixp4xx_readb(addr);
+#endif
+}
+
+static inline void
+__ixp4xx_ioread8_rep(const void __iomem *addr, void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_insb(port & PIO_MASK, vaddr, count);
+	else
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_readsb(addr, vaddr, count);
+#else
+		__ixp4xx_readsb(addr, vaddr, count);
+#endif
+}
+
+static inline unsigned int
+__ixp4xx_ioread16(const void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		return	(unsigned int)__ixp4xx_inw(port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		return le16_to_cpu(__raw_readw((u32)port));
+#else
+		return (unsigned int)__ixp4xx_readw(addr);
+#endif
+}
+
+static inline void
+__ixp4xx_ioread16_rep(const void __iomem *addr, void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_insw(port & PIO_MASK, vaddr, count);
+	else
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_readsw(addr, vaddr, count);
+#else
+		__ixp4xx_readsw(addr, vaddr, count);
+#endif
+}
+
+static inline unsigned int
+__ixp4xx_ioread32(const void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		return	(unsigned int)__ixp4xx_inl(port & PIO_MASK);
+	else {
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		return le32_to_cpu(__raw_readl((u32)port));
+#else
+		return (unsigned int)__ixp4xx_readl(addr);
+#endif
+	}
+}
+
+static inline void
+__ixp4xx_ioread32_rep(const void __iomem *addr, void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_insl(port & PIO_MASK, vaddr, count);
+	else
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_readsl(addr, vaddr, count);
+#else
+		__ixp4xx_readsl(addr, vaddr, count);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite8(u8 value, void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outb(value, port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writeb(value, port);
+#else
+		__ixp4xx_writeb(value, addr);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite8_rep(void __iomem *addr, const void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outsb(port & PIO_MASK, vaddr, count);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writesb(addr, vaddr, count);
+#else
+		__ixp4xx_writesb(addr, vaddr, count);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite16(u16 value, void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outw(value, port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writew(cpu_to_le16(value), addr);
+#else
+		__ixp4xx_writew(value, addr);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite16_rep(void __iomem *addr, const void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outsw(port & PIO_MASK, vaddr, count);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writesw(addr, vaddr, count);
+#else
+		__ixp4xx_writesw(addr, vaddr, count);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite32(u32 value, void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outl(value, port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writel(cpu_to_le32(value), port);
+#else
+		__ixp4xx_writel(value, addr);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite32_rep(void __iomem *addr, const void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outsl(port & PIO_MASK, vaddr, count);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writesl(addr, vaddr, count);
+#else
+		__ixp4xx_writesl(addr, vaddr, count);
+#endif
+}
+
+#define	ioread8(p)			__ixp4xx_ioread8(p)
+#define	ioread16(p)			__ixp4xx_ioread16(p)
+#define	ioread32(p)			__ixp4xx_ioread32(p)
+
+#define	ioread8_rep(p, v, c)		__ixp4xx_ioread8_rep(p, v, c)
+#define	ioread16_rep(p, v, c)		__ixp4xx_ioread16_rep(p, v, c)
+#define	ioread32_rep(p, v, c)		__ixp4xx_ioread32_rep(p, v, c)
+
+#define	iowrite8(v,p)			__ixp4xx_iowrite8(v,p)
+#define	iowrite16(v,p)			__ixp4xx_iowrite16(v,p)
+#define	iowrite32(v,p)			__ixp4xx_iowrite32(v,p)
+
+#define	iowrite8_rep(p, v, c)		__ixp4xx_iowrite8_rep(p, v, c)
+#define	iowrite16_rep(p, v, c)		__ixp4xx_iowrite16_rep(p, v, c)
+#define	iowrite32_rep(p, v, c)		__ixp4xx_iowrite32_rep(p, v, c)
+
+#define	ioport_map(port, nr)		((void __iomem*)(port + PIO_OFFSET))
+#define	ioport_unmap(addr)
+#endif	// !CONFIG_PCI
+
+#endif	//  __ASM_ARM_ARCH_IO_H
+
Index: build_tree/linux/include/asm/arch-ixp4xx/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/irqs.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,121 @@
+/*
+ * include/asm-arm/arch-ixp4xx/irqs.h 
+ *
+ * IRQ definitions for IXP4XX based systems
+ *
+ * Copyright (C) 2002 Intel Corporation.
+ * Copyright (C) 2003 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ARCH_IXP4XX_IRQS_H_
+#define _ARCH_IXP4XX_IRQS_H_
+
+
+#define IRQ_IXP4XX_NPEA		0
+#define IRQ_IXP4XX_NPEB		1
+#define IRQ_IXP4XX_NPEC		2
+#define IRQ_IXP4XX_QM1		3
+#define IRQ_IXP4XX_QM2		4
+#define IRQ_IXP4XX_TIMER1	5
+#define IRQ_IXP4XX_GPIO0	6
+#define IRQ_IXP4XX_GPIO1	7
+#define IRQ_IXP4XX_PCI_INT	8
+#define IRQ_IXP4XX_PCI_DMA1	9
+#define IRQ_IXP4XX_PCI_DMA2	10
+#define IRQ_IXP4XX_TIMER2	11
+#define IRQ_IXP4XX_USB		12
+#define IRQ_IXP4XX_UART2	13
+#define IRQ_IXP4XX_TIMESTAMP	14
+#define IRQ_IXP4XX_UART1	15
+#define IRQ_IXP4XX_WDOG		16
+#define IRQ_IXP4XX_AHB_PMU	17
+#define IRQ_IXP4XX_XSCALE_PMU	18
+#define IRQ_IXP4XX_GPIO2	19
+#define IRQ_IXP4XX_GPIO3	20
+#define IRQ_IXP4XX_GPIO4	21
+#define IRQ_IXP4XX_GPIO5	22
+#define IRQ_IXP4XX_GPIO6	23
+#define IRQ_IXP4XX_GPIO7	24
+#define IRQ_IXP4XX_GPIO8	25
+#define IRQ_IXP4XX_GPIO9	26
+#define IRQ_IXP4XX_GPIO10	27
+#define IRQ_IXP4XX_GPIO11	28
+#define IRQ_IXP4XX_GPIO12	29
+#define IRQ_IXP4XX_SW_INT1	30
+#define IRQ_IXP4XX_SW_INT2	31
+#define IRQ_IXP4XX_USB_HOST	32
+#define IRQ_IXP4XX_I2C		33
+#define IRQ_IXP4XX_SSP		34
+#define IRQ_IXP4XX_TSYNC	35
+#define IRQ_IXP4XX_EAU_DONE	36
+#define IRQ_IXP4XX_SHA_DONE	37
+#define IRQ_IXP4XX_SWCP_PE	58
+#define IRQ_IXP4XX_QM_PE	60
+#define IRQ_IXP4XX_MCU_ECC	61
+#define IRQ_IXP4XX_EXP_PE	62
+
+/*
+ * Only first 32 sources are valid if running on IXP42x systems
+ */
+#ifndef	CONFIG_CPU_IXP46X
+#define NR_IRQS			32
+#else
+#define NR_IRQS			64
+#endif
+
+#define	XSCALE_PMU_IRQ		(IRQ_IXP4XX_XSCALE_PMU)
+
+/*
+ * IXDP425 board IRQs
+ */
+#define	IRQ_IXDP425_PCI_INTA	IRQ_IXP4XX_GPIO11
+#define	IRQ_IXDP425_PCI_INTB	IRQ_IXP4XX_GPIO10
+#define	IRQ_IXDP425_PCI_INTC	IRQ_IXP4XX_GPIO9
+#define	IRQ_IXDP425_PCI_INTD	IRQ_IXP4XX_GPIO8
+
+/*
+ * Gateworks Avila board IRQs
+ */
+#define	IRQ_AVILA_PCI_INTA	IRQ_IXP4XX_GPIO11
+#define	IRQ_AVILA_PCI_INTB	IRQ_IXP4XX_GPIO10
+#define	IRQ_AVILA_PCI_INTC	IRQ_IXP4XX_GPIO9
+#define	IRQ_AVILA_PCI_INTD	IRQ_IXP4XX_GPIO8
+
+
+/*
+ * PrPMC1100 Board IRQs
+ */
+#define	IRQ_PRPMC1100_PCI_INTA	IRQ_IXP4XX_GPIO11
+#define	IRQ_PRPMC1100_PCI_INTB	IRQ_IXP4XX_GPIO10
+#define	IRQ_PRPMC1100_PCI_INTC	IRQ_IXP4XX_GPIO9
+#define	IRQ_PRPMC1100_PCI_INTD	IRQ_IXP4XX_GPIO8
+
+/*
+ * ADI Coyote Board IRQs
+ */
+#define	IRQ_COYOTE_PCI_SLOT0	IRQ_IXP4XX_GPIO6
+#define	IRQ_COYOTE_PCI_SLOT1	IRQ_IXP4XX_GPIO11
+#define	IRQ_COYOTE_IDE		IRQ_IXP4XX_GPIO5
+
+/*
+ * NSLU2 board IRQs
+ */
+#define        IRQ_NSLU2_PCI_INTA      IRQ_IXP4XX_GPIO11
+#define        IRQ_NSLU2_PCI_INTB      IRQ_IXP4XX_GPIO10
+#define        IRQ_NSLU2_PCI_INTC      IRQ_IXP4XX_GPIO9
+
+/*
+ * NAS100D board IRQs
+ */
+#define        IRQ_NAS100D_PCI_INTA    IRQ_IXP4XX_GPIO11
+#define        IRQ_NAS100D_PCI_INTB    IRQ_IXP4XX_GPIO10
+#define        IRQ_NAS100D_PCI_INTC    IRQ_IXP4XX_GPIO9
+#define        IRQ_NAS100D_PCI_INTD    IRQ_IXP4XX_GPIO8
+#define        IRQ_NAS100D_PCI_INTE    IRQ_IXP4XX_GPIO7
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp4xx/ixdp425.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/ixdp425.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/ixdp425.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,35 @@
+/*
+ * include/asm-arm/arch-ixp4xx/ixdp425.h
+ *
+ * IXDP425 platform specific definitions
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista, Software, Inc. 
+ * 
+ * This file is licensed under  the terms of the GNU General Public 
+ * License version 2. This program is licensed "as is" without any 
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define	IXDP425_SDA_PIN		7
+#define	IXDP425_SCL_PIN		6
+
+/*
+ * IXDP425 PCI IRQs
+ */
+#define IXDP425_PCI_MAX_DEV	4
+#define IXDP425_PCI_IRQ_LINES	4
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define IXDP425_PCI_INTA_PIN	11
+#define IXDP425_PCI_INTB_PIN	10
+#define	IXDP425_PCI_INTC_PIN	9
+#define	IXDP425_PCI_INTD_PIN	8
+
+
Index: build_tree/linux/include/asm/arch-ixp4xx/ixp4xx-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/ixp4xx-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/ixp4xx-regs.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,625 @@
+/*
+ * include/asm-arm/arch-ixp4xx/ixp4xx-regs.h
+ *
+ * Register definitions for IXP4xx chipset. This file contains 
+ * register location and bit definitions only. Platform specific 
+ * definitions and helper function declarations are in platform.h 
+ * and machine-name.h.
+ *
+ * Copyright (C) 2002 Intel Corporation.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#ifndef _ASM_ARM_IXP4XX_H_
+#define _ASM_ARM_IXP4XX_H_
+
+/*
+ * IXP4xx Linux Memory Map:
+ *
+ * Phy		Size		Virt		Description
+ * =========================================================================
+ *
+ * 0x00000000	0x10000000(max)	PAGE_OFFSET	System RAM
+ *
+ * 0x48000000	0x04000000	ioremap'd	PCI Memory Space
+ *
+ * 0x50000000	0x10000000	ioremap'd	EXP BUS
+ *
+ * 0x6000000	0x00004000	ioremap'd	QMgr
+ *
+ * 0xC0000000	0x00001000	0xffbff000	PCI CFG
+ *
+ * 0xC4000000	0x00001000	0xffbfe000	EXP CFG
+ *
+ * 0xC8000000	0x00013000	0xffbeb000	On-Chip Peripherals
+ */
+
+/*
+ * Queue Manager
+ */
+#define IXP4XX_QMGR_BASE_PHYS		(0x60000000)
+#define IXP4XX_QMGR_REGION_SIZE		(0x00004000)
+
+/*
+ * Expansion BUS Configuration registers
+ */
+#define IXP4XX_EXP_CFG_BASE_PHYS	(0xC4000000)
+#define IXP4XX_EXP_CFG_BASE_VIRT	(0xFFBFE000)
+#define IXP4XX_EXP_CFG_REGION_SIZE	(0x00001000)
+
+/*
+ * PCI Config registers
+ */
+#define IXP4XX_PCI_CFG_BASE_PHYS	(0xC0000000)
+#define	IXP4XX_PCI_CFG_BASE_VIRT	(0xFFBFF000)
+#define IXP4XX_PCI_CFG_REGION_SIZE	(0x00001000)
+
+/*
+ * Peripheral space
+ */
+#define IXP4XX_PERIPHERAL_BASE_PHYS	(0xC8000000)
+#define IXP4XX_PERIPHERAL_BASE_VIRT	(0xFFBEB000)
+#define IXP4XX_PERIPHERAL_REGION_SIZE	(0x00013000)
+
+/*
+ * Debug UART
+ *
+ * This is basically a remap of UART1 into a region that is section
+ * aligned so that it * can be used with the low-level debug code.
+ */
+#define	IXP4XX_DEBUG_UART_BASE_PHYS	(0xC8000000)
+#define	IXP4XX_DEBUG_UART_BASE_VIRT	(0xffb00000)
+#define	IXP4XX_DEBUG_UART_REGION_SIZE	(0x00001000)
+
+#define IXP4XX_EXP_CS0_OFFSET	0x00
+#define IXP4XX_EXP_CS1_OFFSET   0x04
+#define IXP4XX_EXP_CS2_OFFSET   0x08
+#define IXP4XX_EXP_CS3_OFFSET   0x0C
+#define IXP4XX_EXP_CS4_OFFSET   0x10
+#define IXP4XX_EXP_CS5_OFFSET   0x14
+#define IXP4XX_EXP_CS6_OFFSET   0x18
+#define IXP4XX_EXP_CS7_OFFSET   0x1C
+#define IXP4XX_EXP_CFG0_OFFSET	0x20
+#define IXP4XX_EXP_CFG1_OFFSET	0x24
+#define IXP4XX_EXP_CFG2_OFFSET	0x28
+#define IXP4XX_EXP_CFG3_OFFSET	0x2C
+
+/*
+ * Expansion Bus Controller registers.
+ */
+#define IXP4XX_EXP_REG(x) ((volatile u32 *)(IXP4XX_EXP_CFG_BASE_VIRT+(x)))
+
+#define IXP4XX_EXP_CS0      IXP4XX_EXP_REG(IXP4XX_EXP_CS0_OFFSET)
+#define IXP4XX_EXP_CS1      IXP4XX_EXP_REG(IXP4XX_EXP_CS1_OFFSET)
+#define IXP4XX_EXP_CS2      IXP4XX_EXP_REG(IXP4XX_EXP_CS2_OFFSET) 
+#define IXP4XX_EXP_CS3      IXP4XX_EXP_REG(IXP4XX_EXP_CS3_OFFSET)
+#define IXP4XX_EXP_CS4      IXP4XX_EXP_REG(IXP4XX_EXP_CS4_OFFSET)
+#define IXP4XX_EXP_CS5      IXP4XX_EXP_REG(IXP4XX_EXP_CS5_OFFSET)
+#define IXP4XX_EXP_CS6      IXP4XX_EXP_REG(IXP4XX_EXP_CS6_OFFSET)     
+#define IXP4XX_EXP_CS7      IXP4XX_EXP_REG(IXP4XX_EXP_CS7_OFFSET)
+
+#define IXP4XX_EXP_CFG0     IXP4XX_EXP_REG(IXP4XX_EXP_CFG0_OFFSET) 
+#define IXP4XX_EXP_CFG1     IXP4XX_EXP_REG(IXP4XX_EXP_CFG1_OFFSET) 
+#define IXP4XX_EXP_CFG2     IXP4XX_EXP_REG(IXP4XX_EXP_CFG2_OFFSET) 
+#define IXP4XX_EXP_CFG3     IXP4XX_EXP_REG(IXP4XX_EXP_CFG3_OFFSET)
+
+
+/*
+ * Peripheral Space Register Region Base Addresses
+ */
+#define IXP4XX_UART1_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x0000)
+#define IXP4XX_UART2_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x1000)
+#define IXP4XX_PMU_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x2000)
+#define IXP4XX_INTC_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x3000)
+#define IXP4XX_GPIO_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x4000)
+#define IXP4XX_TIMER_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x5000)
+#define IXP4XX_NPEA_BASE_PHYS   	(IXP4XX_PERIPHERAL_BASE_PHYS + 0x6000)
+#define IXP4XX_NPEB_BASE_PHYS   	(IXP4XX_PERIPHERAL_BASE_PHYS + 0x7000)
+#define IXP4XX_NPEC_BASE_PHYS   	(IXP4XX_PERIPHERAL_BASE_PHYS + 0x8000)
+#define IXP4XX_EthB_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x9000)
+#define IXP4XX_EthC_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0xA000)
+#define IXP4XX_USB_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0xB000)
+/* ixp46X only */
+#define IXP4XX_EthA_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0xC000)
+#define IXP4XX_EthB1_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0xD000)
+#define IXP4XX_EthB2_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0xE000)
+#define IXP4XX_EthB3_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0xF000)
+#define IXP4XX_TIMESYNC_BASE_PHYS	(IXP4XX_PERIPHERAL_BASE_PHYS + 0x10000)
+#define IXP4XX_I2C_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x11000)
+#define IXP4XX_SSP_BASE_PHYS		(IXP4XX_PERIPHERAL_BASE_PHYS + 0x12000)
+
+
+#define IXP4XX_UART1_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x0000)
+#define IXP4XX_UART2_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x1000)
+#define IXP4XX_PMU_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x2000)
+#define IXP4XX_INTC_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x3000)
+#define IXP4XX_GPIO_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x4000)
+#define IXP4XX_TIMER_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x5000)
+#define IXP4XX_NPEA_BASE_VIRT   	(IXP4XX_PERIPHERAL_BASE_VIRT + 0x6000)
+#define IXP4XX_NPEB_BASE_VIRT   	(IXP4XX_PERIPHERAL_BASE_VIRT + 0x7000)
+#define IXP4XX_NPEC_BASE_VIRT   	(IXP4XX_PERIPHERAL_BASE_VIRT + 0x8000)
+#define IXP4XX_EthB_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x9000)
+#define IXP4XX_EthC_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0xA000)
+#define IXP4XX_USB_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0xB000)
+/* ixp46X only */
+#define IXP4XX_EthA_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0xC000)
+#define IXP4XX_EthB1_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0xD000)
+#define IXP4XX_EthB2_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0xE000)
+#define IXP4XX_EthB3_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0xF000)
+#define IXP4XX_TIMESYNC_BASE_VIRT	(IXP4XX_PERIPHERAL_BASE_VIRT + 0x10000)
+#define IXP4XX_I2C_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x11000)
+#define IXP4XX_SSP_BASE_VIRT		(IXP4XX_PERIPHERAL_BASE_VIRT + 0x12000)
+
+/*
+ * Constants to make it easy to access  Interrupt Controller registers
+ */
+#define IXP4XX_ICPR_OFFSET	0x00 /* Interrupt Status */
+#define IXP4XX_ICMR_OFFSET	0x04 /* Interrupt Enable */
+#define IXP4XX_ICLR_OFFSET	0x08 /* Interrupt IRQ/FIQ Select */
+#define IXP4XX_ICIP_OFFSET      0x0C /* IRQ Status */
+#define IXP4XX_ICFP_OFFSET	0x10 /* FIQ Status */
+#define IXP4XX_ICHR_OFFSET	0x14 /* Interrupt Priority */
+#define IXP4XX_ICIH_OFFSET	0x18 /* IRQ Highest Pri Int */
+#define IXP4XX_ICFH_OFFSET	0x1C /* FIQ Highest Pri Int */
+
+/*
+ * IXP465-only
+ */
+#define	IXP4XX_ICPR2_OFFSET	0x20 /* Interrupt Status 2 */
+#define	IXP4XX_ICMR2_OFFSET	0x24 /* Interrupt Enable 2 */
+#define	IXP4XX_ICLR2_OFFSET	0x28 /* Interrupt IRQ/FIQ Select 2 */
+#define IXP4XX_ICIP2_OFFSET     0x2C /* IRQ Status */
+#define IXP4XX_ICFP2_OFFSET	0x30 /* FIQ Status */
+#define IXP4XX_ICEEN_OFFSET	0x34 /* Error High Pri Enable */
+
+
+/*
+ * Interrupt Controller Register Definitions.
+ */
+
+#define IXP4XX_INTC_REG(x) ((volatile u32 *)(IXP4XX_INTC_BASE_VIRT+(x)))
+
+#define IXP4XX_ICPR	IXP4XX_INTC_REG(IXP4XX_ICPR_OFFSET)
+#define IXP4XX_ICMR     IXP4XX_INTC_REG(IXP4XX_ICMR_OFFSET)
+#define IXP4XX_ICLR     IXP4XX_INTC_REG(IXP4XX_ICLR_OFFSET)
+#define IXP4XX_ICIP     IXP4XX_INTC_REG(IXP4XX_ICIP_OFFSET)
+#define IXP4XX_ICFP     IXP4XX_INTC_REG(IXP4XX_ICFP_OFFSET)
+#define IXP4XX_ICHR     IXP4XX_INTC_REG(IXP4XX_ICHR_OFFSET)
+#define IXP4XX_ICIH     IXP4XX_INTC_REG(IXP4XX_ICIH_OFFSET) 
+#define IXP4XX_ICFH     IXP4XX_INTC_REG(IXP4XX_ICFH_OFFSET)
+#define IXP4XX_ICPR2	IXP4XX_INTC_REG(IXP4XX_ICPR2_OFFSET)
+#define IXP4XX_ICMR2    IXP4XX_INTC_REG(IXP4XX_ICMR2_OFFSET)
+#define IXP4XX_ICLR2    IXP4XX_INTC_REG(IXP4XX_ICLR2_OFFSET)
+#define IXP4XX_ICIP2    IXP4XX_INTC_REG(IXP4XX_ICIP2_OFFSET)
+#define IXP4XX_ICFP2    IXP4XX_INTC_REG(IXP4XX_ICFP2_OFFSET)
+#define IXP4XX_ICEEN    IXP4XX_INTC_REG(IXP4XX_ICEEN_OFFSET)
+                                                                                
+/*
+ * Constants to make it easy to access GPIO registers
+ */
+#define IXP4XX_GPIO_GPOUTR_OFFSET       0x00
+#define IXP4XX_GPIO_GPOER_OFFSET        0x04
+#define IXP4XX_GPIO_GPINR_OFFSET        0x08
+#define IXP4XX_GPIO_GPISR_OFFSET        0x0C
+#define IXP4XX_GPIO_GPIT1R_OFFSET	0x10
+#define IXP4XX_GPIO_GPIT2R_OFFSET	0x14
+#define IXP4XX_GPIO_GPCLKR_OFFSET	0x18
+#define IXP4XX_GPIO_GPDBSELR_OFFSET	0x1C
+
+/* 
+ * GPIO Register Definitions.
+ * [Only perform 32bit reads/writes]
+ */
+#define IXP4XX_GPIO_REG(x) ((volatile u32 *)(IXP4XX_GPIO_BASE_VIRT+(x)))
+
+#define IXP4XX_GPIO_GPOUTR	IXP4XX_GPIO_REG(IXP4XX_GPIO_GPOUTR_OFFSET)
+#define IXP4XX_GPIO_GPOER       IXP4XX_GPIO_REG(IXP4XX_GPIO_GPOER_OFFSET)
+#define IXP4XX_GPIO_GPINR       IXP4XX_GPIO_REG(IXP4XX_GPIO_GPINR_OFFSET)
+#define IXP4XX_GPIO_GPISR       IXP4XX_GPIO_REG(IXP4XX_GPIO_GPISR_OFFSET)
+#define IXP4XX_GPIO_GPIT1R      IXP4XX_GPIO_REG(IXP4XX_GPIO_GPIT1R_OFFSET)
+#define IXP4XX_GPIO_GPIT2R      IXP4XX_GPIO_REG(IXP4XX_GPIO_GPIT2R_OFFSET)
+#define IXP4XX_GPIO_GPCLKR      IXP4XX_GPIO_REG(IXP4XX_GPIO_GPCLKR_OFFSET)
+#define IXP4XX_GPIO_GPDBSELR    IXP4XX_GPIO_REG(IXP4XX_GPIO_GPDBSELR_OFFSET)
+
+/*
+ * GPIO register bit definitions
+ */
+
+/* Interrupt styles
+ */
+#define IXP4XX_GPIO_STYLE_ACTIVE_HIGH	0x0
+#define IXP4XX_GPIO_STYLE_ACTIVE_LOW	0x1
+#define IXP4XX_GPIO_STYLE_RISING_EDGE	0x2
+#define IXP4XX_GPIO_STYLE_FALLING_EDGE	0x3
+#define IXP4XX_GPIO_STYLE_TRANSITIONAL	0x4
+
+/* 
+ * Mask used to clear interrupt styles 
+ */
+#define IXP4XX_GPIO_STYLE_CLEAR		0x7
+#define IXP4XX_GPIO_STYLE_SIZE		3
+
+/*
+ * Constants to make it easy to access Timer Control/Status registers
+ */
+#define IXP4XX_OSTS_OFFSET	0x00  /* Continious TimeStamp */
+#define IXP4XX_OST1_OFFSET	0x04  /* Timer 1 Timestamp */
+#define IXP4XX_OSRT1_OFFSET	0x08  /* Timer 1 Reload */
+#define IXP4XX_OST2_OFFSET	0x0C  /* Timer 2 Timestamp */
+#define IXP4XX_OSRT2_OFFSET	0x10  /* Timer 2 Reload */
+#define IXP4XX_OSWT_OFFSET	0x14  /* Watchdog Timer */
+#define IXP4XX_OSWE_OFFSET	0x18  /* Watchdog Enable */
+#define IXP4XX_OSWK_OFFSET	0x1C  /* Watchdog Key */
+#define IXP4XX_OSST_OFFSET	0x20  /* Timer Status */
+
+/*
+ * Operating System Timer Register Definitions.
+ */
+
+#define IXP4XX_TIMER_REG(x) ((volatile u32 *)(IXP4XX_TIMER_BASE_VIRT+(x)))
+
+#define IXP4XX_OSTS	IXP4XX_TIMER_REG(IXP4XX_OSTS_OFFSET)
+#define IXP4XX_OST1	IXP4XX_TIMER_REG(IXP4XX_OST1_OFFSET)
+#define IXP4XX_OSRT1	IXP4XX_TIMER_REG(IXP4XX_OSRT1_OFFSET)
+#define IXP4XX_OST2	IXP4XX_TIMER_REG(IXP4XX_OST2_OFFSET)
+#define IXP4XX_OSRT2	IXP4XX_TIMER_REG(IXP4XX_OSRT2_OFFSET)
+#define IXP4XX_OSWT	IXP4XX_TIMER_REG(IXP4XX_OSWT_OFFSET)
+#define IXP4XX_OSWE	IXP4XX_TIMER_REG(IXP4XX_OSWE_OFFSET)
+#define IXP4XX_OSWK	IXP4XX_TIMER_REG(IXP4XX_OSWK_OFFSET)
+#define IXP4XX_OSST	IXP4XX_TIMER_REG(IXP4XX_OSST_OFFSET)
+
+/*
+ * Timer register values and bit definitions 
+ */
+#define IXP4XX_OST_ENABLE		0x00000001
+#define IXP4XX_OST_ONE_SHOT		0x00000002
+/* Low order bits of reload value ignored */
+#define IXP4XX_OST_RELOAD_MASK		0x00000003
+#define IXP4XX_OST_DISABLED		0x00000000
+#define IXP4XX_OSST_TIMER_1_PEND	0x00000001
+#define IXP4XX_OSST_TIMER_2_PEND	0x00000002
+#define IXP4XX_OSST_TIMER_TS_PEND	0x00000004
+#define IXP4XX_OSST_TIMER_WDOG_PEND	0x00000008
+#define IXP4XX_OSST_TIMER_WARM_RESET	0x00000010
+
+#define	IXP4XX_WDT_KEY			0x0000482E
+
+#define	IXP4XX_WDT_RESET_ENABLE		0x00000001
+#define	IXP4XX_WDT_IRQ_ENABLE		0x00000002
+#define	IXP4XX_WDT_COUNT_ENABLE		0x00000004
+
+
+/*
+ * Constants to make it easy to access PCI Control/Status registers
+ */
+#define PCI_NP_AD_OFFSET            0x00
+#define PCI_NP_CBE_OFFSET           0x04
+#define PCI_NP_WDATA_OFFSET         0x08
+#define PCI_NP_RDATA_OFFSET         0x0c
+#define PCI_CRP_AD_CBE_OFFSET       0x10
+#define PCI_CRP_WDATA_OFFSET        0x14
+#define PCI_CRP_RDATA_OFFSET        0x18
+#define PCI_CSR_OFFSET              0x1c
+#define PCI_ISR_OFFSET              0x20
+#define PCI_INTEN_OFFSET            0x24
+#define PCI_DMACTRL_OFFSET          0x28
+#define PCI_AHBMEMBASE_OFFSET       0x2c
+#define PCI_AHBIOBASE_OFFSET        0x30
+#define PCI_PCIMEMBASE_OFFSET       0x34
+#define PCI_AHBDOORBELL_OFFSET      0x38
+#define PCI_PCIDOORBELL_OFFSET      0x3C
+#define PCI_ATPDMA0_AHBADDR_OFFSET  0x40
+#define PCI_ATPDMA0_PCIADDR_OFFSET  0x44
+#define PCI_ATPDMA0_LENADDR_OFFSET  0x48
+#define PCI_ATPDMA1_AHBADDR_OFFSET  0x4C
+#define PCI_ATPDMA1_PCIADDR_OFFSET  0x50
+#define PCI_ATPDMA1_LENADDR_OFFSET	0x54
+
+/*
+ * PCI Control/Status Registers
+ */
+#define IXP4XX_PCI_CSR(x) ((volatile u32 *)(IXP4XX_PCI_CFG_BASE_VIRT+(x)))
+
+#define PCI_NP_AD               IXP4XX_PCI_CSR(PCI_NP_AD_OFFSET)
+#define PCI_NP_CBE              IXP4XX_PCI_CSR(PCI_NP_CBE_OFFSET)
+#define PCI_NP_WDATA            IXP4XX_PCI_CSR(PCI_NP_WDATA_OFFSET)
+#define PCI_NP_RDATA            IXP4XX_PCI_CSR(PCI_NP_RDATA_OFFSET)
+#define PCI_CRP_AD_CBE          IXP4XX_PCI_CSR(PCI_CRP_AD_CBE_OFFSET)
+#define PCI_CRP_WDATA           IXP4XX_PCI_CSR(PCI_CRP_WDATA_OFFSET)
+#define PCI_CRP_RDATA           IXP4XX_PCI_CSR(PCI_CRP_RDATA_OFFSET)
+#define PCI_CSR                 IXP4XX_PCI_CSR(PCI_CSR_OFFSET) 
+#define PCI_ISR                 IXP4XX_PCI_CSR(PCI_ISR_OFFSET)
+#define PCI_INTEN               IXP4XX_PCI_CSR(PCI_INTEN_OFFSET)
+#define PCI_DMACTRL             IXP4XX_PCI_CSR(PCI_DMACTRL_OFFSET)
+#define PCI_AHBMEMBASE          IXP4XX_PCI_CSR(PCI_AHBMEMBASE_OFFSET)
+#define PCI_AHBIOBASE           IXP4XX_PCI_CSR(PCI_AHBIOBASE_OFFSET)
+#define PCI_PCIMEMBASE          IXP4XX_PCI_CSR(PCI_PCIMEMBASE_OFFSET)
+#define PCI_AHBDOORBELL         IXP4XX_PCI_CSR(PCI_AHBDOORBELL_OFFSET)
+#define PCI_PCIDOORBELL         IXP4XX_PCI_CSR(PCI_PCIDOORBELL_OFFSET)
+#define PCI_ATPDMA0_AHBADDR     IXP4XX_PCI_CSR(PCI_ATPDMA0_AHBADDR_OFFSET)
+#define PCI_ATPDMA0_PCIADDR     IXP4XX_PCI_CSR(PCI_ATPDMA0_PCIADDR_OFFSET)
+#define PCI_ATPDMA0_LENADDR     IXP4XX_PCI_CSR(PCI_ATPDMA0_LENADDR_OFFSET)
+#define PCI_ATPDMA1_AHBADDR     IXP4XX_PCI_CSR(PCI_ATPDMA1_AHBADDR_OFFSET)
+#define PCI_ATPDMA1_PCIADDR     IXP4XX_PCI_CSR(PCI_ATPDMA1_PCIADDR_OFFSET)
+#define PCI_ATPDMA1_LENADDR     IXP4XX_PCI_CSR(PCI_ATPDMA1_LENADDR_OFFSET)
+
+/*
+ * PCI register values and bit definitions 
+ */
+
+/* CSR bit definitions */
+#define PCI_CSR_HOST    	0x00000001
+#define PCI_CSR_ARBEN   	0x00000002
+#define PCI_CSR_ADS     	0x00000004
+#define PCI_CSR_PDS     	0x00000008
+#define PCI_CSR_ABE     	0x00000010
+#define PCI_CSR_DBT     	0x00000020
+#define PCI_CSR_ASE     	0x00000100
+#define PCI_CSR_IC      	0x00008000
+
+/* ISR (Interrupt status) Register bit definitions */
+#define PCI_ISR_PSE     	0x00000001
+#define PCI_ISR_PFE     	0x00000002
+#define PCI_ISR_PPE     	0x00000004
+#define PCI_ISR_AHBE    	0x00000008
+#define PCI_ISR_APDC    	0x00000010
+#define PCI_ISR_PADC    	0x00000020
+#define PCI_ISR_ADB     	0x00000040
+#define PCI_ISR_PDB     	0x00000080
+
+/* INTEN (Interrupt Enable) Register bit definitions */
+#define PCI_INTEN_PSE   	0x00000001
+#define PCI_INTEN_PFE   	0x00000002
+#define PCI_INTEN_PPE   	0x00000004
+#define PCI_INTEN_AHBE  	0x00000008
+#define PCI_INTEN_APDC  	0x00000010
+#define PCI_INTEN_PADC  	0x00000020
+#define PCI_INTEN_ADB   	0x00000040
+#define PCI_INTEN_PDB   	0x00000080
+
+/*
+ * Shift value for byte enable on NP cmd/byte enable register
+ */
+#define IXP4XX_PCI_NP_CBE_BESL		4
+
+/*
+ * PCI commands supported by NP access unit
+ */
+#define NP_CMD_IOREAD			0x2
+#define NP_CMD_IOWRITE			0x3
+#define NP_CMD_CONFIGREAD		0xa
+#define NP_CMD_CONFIGWRITE		0xb
+#define NP_CMD_MEMREAD			0x6
+#define	NP_CMD_MEMWRITE			0x7
+
+/*
+ * Constants for CRP access into local config space
+ */
+#define CRP_AD_CBE_BESL         20
+#define CRP_AD_CBE_WRITE	0x00010000
+
+
+/*
+ * USB Device Controller
+ *
+ * These are used by the USB gadget driver, so they don't follow the
+ * IXP4XX_ naming convetions.
+ *
+ */
+# define IXP4XX_USB_REG(x)       (*((volatile u32 *)(x)))
+
+/* UDC Undocumented - Reserved1 */
+#define UDC_RES1	IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0004)  
+/* UDC Undocumented - Reserved2 */
+#define UDC_RES2	IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0008)  
+/* UDC Undocumented - Reserved3 */
+#define UDC_RES3	IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x000C)  
+/* UDC Control Register */
+#define UDCCR		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0000)  
+/* UDC Endpoint 0 Control/Status Register */
+#define UDCCS0		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0010)  
+/* UDC Endpoint 1 (IN) Control/Status Register */
+#define UDCCS1		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0014)  
+/* UDC Endpoint 2 (OUT) Control/Status Register */
+#define UDCCS2		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0018)  
+/* UDC Endpoint 3 (IN) Control/Status Register */
+#define UDCCS3		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x001C)  
+/* UDC Endpoint 4 (OUT) Control/Status Register */
+#define UDCCS4		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0020)  
+/* UDC Endpoint 5 (Interrupt) Control/Status Register */
+#define UDCCS5		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0024)  
+/* UDC Endpoint 6 (IN) Control/Status Register */
+#define UDCCS6		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0028)  
+/* UDC Endpoint 7 (OUT) Control/Status Register */
+#define UDCCS7		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x002C)  
+/* UDC Endpoint 8 (IN) Control/Status Register */
+#define UDCCS8		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0030)  
+/* UDC Endpoint 9 (OUT) Control/Status Register */
+#define UDCCS9		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0034)  
+/* UDC Endpoint 10 (Interrupt) Control/Status Register */
+#define UDCCS10		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0038)  
+/* UDC Endpoint 11 (IN) Control/Status Register */
+#define UDCCS11		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x003C)  
+/* UDC Endpoint 12 (OUT) Control/Status Register */
+#define UDCCS12		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0040)  
+/* UDC Endpoint 13 (IN) Control/Status Register */
+#define UDCCS13		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0044)  
+/* UDC Endpoint 14 (OUT) Control/Status Register */
+#define UDCCS14		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0048)  
+/* UDC Endpoint 15 (Interrupt) Control/Status Register */
+#define UDCCS15		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x004C)  
+/* UDC Frame Number Register High */
+#define UFNRH		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0060)  
+/* UDC Frame Number Register Low */
+#define UFNRL		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0064)  
+/* UDC Byte Count Reg 2 */
+#define UBCR2		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0068)  
+/* UDC Byte Count Reg 4 */
+#define UBCR4		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x006c)  
+/* UDC Byte Count Reg 7 */
+#define UBCR7		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0070)  
+/* UDC Byte Count Reg 9 */
+#define UBCR9		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0074)  
+/* UDC Byte Count Reg 12 */
+#define UBCR12		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0078)  
+/* UDC Byte Count Reg 14 */
+#define UBCR14		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x007c)  
+/* UDC Endpoint 0 Data Register */
+#define UDDR0		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0080)  
+/* UDC Endpoint 1 Data Register */
+#define UDDR1		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0100)  
+/* UDC Endpoint 2 Data Register */
+#define UDDR2		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0180)  
+/* UDC Endpoint 3 Data Register */
+#define UDDR3		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0200)  
+/* UDC Endpoint 4 Data Register */
+#define UDDR4		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0400)  
+/* UDC Endpoint 5 Data Register */
+#define UDDR5		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x00A0)  
+/* UDC Endpoint 6 Data Register */
+#define UDDR6		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0600)  
+/* UDC Endpoint 7 Data Register */
+#define UDDR7		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0680)  
+/* UDC Endpoint 8 Data Register */
+#define UDDR8		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0700)  
+/* UDC Endpoint 9 Data Register */
+#define UDDR9		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0900)  
+/* UDC Endpoint 10 Data Register */
+#define UDDR10		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x00C0)  
+/* UDC Endpoint 11 Data Register */
+#define UDDR11		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0B00)  
+/* UDC Endpoint 12 Data Register */
+#define UDDR12		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0B80)  
+/* UDC Endpoint 13 Data Register */
+#define UDDR13		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0C00)  
+/* UDC Endpoint 14 Data Register */
+#define UDDR14		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0E00)  
+/* UDC Endpoint 15 Data Register */
+#define UDDR15		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x00E0)  
+/* UDC Interrupt Control Register 0 */
+#define UICR0		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0050)  
+/* UDC Interrupt Control Register 1 */
+#define UICR1		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0054)  
+/* UDC Status Interrupt Register 0 */
+#define USIR0		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x0058)  
+/* UDC Status Interrupt Register 1 */
+#define USIR1		IXP4XX_USB_REG(IXP4XX_USB_BASE_VIRT+0x005C)  
+
+#define UDCCR_UDE	(1 << 0)	/* UDC enable */
+#define UDCCR_UDA	(1 << 1)	/* UDC active */
+#define UDCCR_RSM	(1 << 2)	/* Device resume */
+#define UDCCR_RESIR	(1 << 3)	/* Resume interrupt request */
+#define UDCCR_SUSIR	(1 << 4)	/* Suspend interrupt request */
+#define UDCCR_SRM	(1 << 5)	/* Suspend/resume interrupt mask */
+#define UDCCR_RSTIR	(1 << 6)	/* Reset interrupt request */
+#define UDCCR_REM	(1 << 7)	/* Reset interrupt mask */
+
+#define UDCCS0_OPR	(1 << 0)	/* OUT packet ready */
+#define UDCCS0_IPR	(1 << 1)	/* IN packet ready */
+#define UDCCS0_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS0_DRWF	(1 << 3)	/* Device remote wakeup feature */
+#define UDCCS0_SST	(1 << 4)	/* Sent stall */
+#define UDCCS0_FST	(1 << 5)	/* Force stall */
+#define UDCCS0_RNE	(1 << 6)	/* Receive FIFO no empty */
+#define UDCCS0_SA	(1 << 7)	/* Setup active */
+
+#define UDCCS_BI_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_BI_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_BI_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_BI_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_BI_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BI_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BI_TSP	(1 << 7)	/* Transmit short packet */
+
+#define UDCCS_BO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_BO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_BO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_BO_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BO_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_BO_RSP	(1 << 7)	/* Receive short packet */
+
+#define UDCCS_II_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_II_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_II_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_II_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_II_TSP	(1 << 7)	/* Transmit short packet */
+
+#define UDCCS_IO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_IO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_IO_ROF	(1 << 3)	/* Receive overflow */
+#define UDCCS_IO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_IO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_IO_RSP	(1 << 7)	/* Receive short packet */
+
+#define UDCCS_INT_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_INT_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_INT_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_INT_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_INT_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_INT_FST	(1 << 5)	/* Force stall */
+#define UDCCS_INT_TSP	(1 << 7)	/* Transmit short packet */
+
+#define UICR0_IM0	(1 << 0)	/* Interrupt mask ep 0 */
+#define UICR0_IM1	(1 << 1)	/* Interrupt mask ep 1 */
+#define UICR0_IM2	(1 << 2)	/* Interrupt mask ep 2 */
+#define UICR0_IM3	(1 << 3)	/* Interrupt mask ep 3 */
+#define UICR0_IM4	(1 << 4)	/* Interrupt mask ep 4 */
+#define UICR0_IM5	(1 << 5)	/* Interrupt mask ep 5 */
+#define UICR0_IM6	(1 << 6)	/* Interrupt mask ep 6 */
+#define UICR0_IM7	(1 << 7)	/* Interrupt mask ep 7 */
+
+#define UICR1_IM8	(1 << 0)	/* Interrupt mask ep 8 */
+#define UICR1_IM9	(1 << 1)	/* Interrupt mask ep 9 */
+#define UICR1_IM10	(1 << 2)	/* Interrupt mask ep 10 */
+#define UICR1_IM11	(1 << 3)	/* Interrupt mask ep 11 */
+#define UICR1_IM12	(1 << 4)	/* Interrupt mask ep 12 */
+#define UICR1_IM13	(1 << 5)	/* Interrupt mask ep 13 */
+#define UICR1_IM14	(1 << 6)	/* Interrupt mask ep 14 */
+#define UICR1_IM15	(1 << 7)	/* Interrupt mask ep 15 */
+
+#define USIR0_IR0	(1 << 0)	/* Interrup request ep 0 */
+#define USIR0_IR1	(1 << 1)	/* Interrup request ep 1 */
+#define USIR0_IR2	(1 << 2)	/* Interrup request ep 2 */
+#define USIR0_IR3	(1 << 3)	/* Interrup request ep 3 */
+#define USIR0_IR4	(1 << 4)	/* Interrup request ep 4 */
+#define USIR0_IR5	(1 << 5)	/* Interrup request ep 5 */
+#define USIR0_IR6	(1 << 6)	/* Interrup request ep 6 */
+#define USIR0_IR7	(1 << 7)	/* Interrup request ep 7 */
+
+#define USIR1_IR8	(1 << 0)	/* Interrup request ep 8 */
+#define USIR1_IR9	(1 << 1)	/* Interrup request ep 9 */
+#define USIR1_IR10	(1 << 2)	/* Interrup request ep 10 */
+#define USIR1_IR11	(1 << 3)	/* Interrup request ep 11 */
+#define USIR1_IR12	(1 << 4)	/* Interrup request ep 12 */
+#define USIR1_IR13	(1 << 5)	/* Interrup request ep 13 */
+#define USIR1_IR14	(1 << 6)	/* Interrup request ep 14 */
+#define USIR1_IR15	(1 << 7)	/* Interrup request ep 15 */
+
+#define DCMD_LENGTH	0x01fff		/* length mask (max = 8K - 1) */
+
+#ifndef __ASSEMBLY__
+static inline int cpu_is_ixp46x(void)
+{
+#ifdef CONFIG_CPU_IXP46X
+	unsigned int processor_id;
+
+	asm("mrc p15, 0, %0, cr0, cr0, 0;" : "=r"(processor_id) :);
+
+	if ((processor_id & 0xffffff00) == 0x69054200)
+		return 1;
+#endif
+	return 0;
+}
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp4xx/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/memory.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,40 @@
+/*
+ * linux/include/asm-arm/arch-ixp4xx/memory.h
+ *
+ * Copyright (c) 2001-2004 MontaVista Software, Inc.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/sizes.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+
+#if !defined(__ASSEMBLY__) && defined(CONFIG_PCI)
+
+void ixp4xx_adjust_zones(int node, unsigned long *size, unsigned long *holes);
+
+#define arch_adjust_zones(node, size, holes) \
+	ixp4xx_adjust_zones(node, size, holes)
+
+#define ISA_DMA_THRESHOLD (SZ_64M - 1)
+
+#endif
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ *
+ * These are dummies for now.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp4xx/nas100d.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/nas100d.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/nas100d.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,72 @@
+/*
+ * include/asm-arm/arch-ixp4xx/nas100d.h
+ *
+ * NAS100D platform specific definitions
+ *
+ * Copyright (c) 2005 Tower Technologies
+ *
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ *
+ * based on ixdp425.h:
+ *	Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define NAS100D_SDA_PIN		5
+#define NAS100D_SCL_PIN		6
+
+/*
+ * NAS100D PCI IRQs
+ */
+#define NAS100D_PCI_MAX_DEV	3
+#define NAS100D_PCI_IRQ_LINES	3
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define NAS100D_PCI_INTA_PIN	11
+#define NAS100D_PCI_INTB_PIN	10
+#define NAS100D_PCI_INTC_PIN	9
+#define NAS100D_PCI_INTD_PIN	8
+#define NAS100D_PCI_INTE_PIN	7
+
+/* GPIO */
+
+#define NAS100D_GPIO0           0
+#define NAS100D_GPIO1           1
+#define NAS100D_GPIO2           2
+#define NAS100D_GPIO3           3
+#define NAS100D_GPIO4           4
+#define NAS100D_GPIO5           5
+#define NAS100D_GPIO6           6
+#define NAS100D_GPIO7           7
+#define NAS100D_GPIO8           8
+#define NAS100D_GPIO9           9
+#define NAS100D_GPIO10          10
+#define NAS100D_GPIO11          11
+#define NAS100D_GPIO12          12
+#define NAS100D_GPIO13          13
+#define NAS100D_GPIO14          14
+#define NAS100D_GPIO15          15
+
+
+/* Buttons */
+
+#define NAS100D_PB_GPIO         NAS100D_GPIO14
+#define NAS100D_RB_GPIO         NAS100D_GPIO4
+#define NAS100D_PO_GPIO         NAS100D_GPIO12   /* power off */
+
+#define NAS100D_PB_IRQ          IRQ_IXP4XX_GPIO14
+#define NAS100D_RB_IRQ          IRQ_IXP4XX_GPIO4
+
+/*
+#define NAS100D_PB_BM           (1L << NAS100D_PB_GPIO)
+#define NAS100D_PO_BM           (1L << NAS100D_PO_GPIO)
+#define NAS100D_RB_BM           (1L << NAS100D_RB_GPIO)
+*/
Index: build_tree/linux/include/asm/arch-ixp4xx/nslu2.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/nslu2.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/nslu2.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,94 @@
+/*
+ * include/asm-arm/arch-ixp4xx/nslu2.h
+ *
+ * NSLU2 platform specific definitions
+ *
+ * Author: Mark Rakes <mrakes AT mac.com>
+ * Maintainers: http://www.nslu2-linux.org
+ *
+ * based on ixdp425.h:
+ *	Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define NSLU2_SDA_PIN		7
+#define NSLU2_SCL_PIN		6
+
+/*
+ * NSLU2 PCI IRQs
+ */
+#define NSLU2_PCI_MAX_DEV	3
+#define NSLU2_PCI_IRQ_LINES	3
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define NSLU2_PCI_INTA_PIN	11
+#define NSLU2_PCI_INTB_PIN	10
+#define NSLU2_PCI_INTC_PIN	9
+#define NSLU2_PCI_INTD_PIN	8
+
+
+/* NSLU2 Timer */
+#define NSLU2_FREQ 66000000
+#define NSLU2_CLOCK_TICK_RATE (((NSLU2_FREQ / HZ & ~IXP4XX_OST_RELOAD_MASK) + 1) * HZ)
+#define NSLU2_CLOCK_TICKS_PER_USEC ((NSLU2_CLOCK_TICK_RATE + USEC_PER_SEC/2) / USEC_PER_SEC)
+
+/* GPIO */
+
+#define NSLU2_GPIO0		0
+#define NSLU2_GPIO1		1
+#define NSLU2_GPIO2		2
+#define NSLU2_GPIO3		3
+#define NSLU2_GPIO4		4
+#define NSLU2_GPIO5		5
+#define NSLU2_GPIO6		6
+#define NSLU2_GPIO7		7
+#define NSLU2_GPIO8		8
+#define NSLU2_GPIO9		9
+#define NSLU2_GPIO10		10
+#define NSLU2_GPIO11		11
+#define NSLU2_GPIO12		12
+#define NSLU2_GPIO13		13
+#define NSLU2_GPIO14		14
+#define NSLU2_GPIO15		15
+
+/* Buttons */
+
+#define NSLU2_PB_GPIO		NSLU2_GPIO5
+#define NSLU2_PO_GPIO		NSLU2_GPIO8	/* power off */
+#define NSLU2_RB_GPIO		NSLU2_GPIO12
+
+#define NSLU2_PB_IRQ		IRQ_IXP4XX_GPIO5
+#define NSLU2_RB_IRQ		IRQ_IXP4XX_GPIO12
+
+#define NSLU2_PB_BM		(1L << NSLU2_PB_GPIO)
+#define NSLU2_PO_BM		(1L << NSLU2_PO_GPIO)
+#define NSLU2_RB_BM		(1L << NSLU2_RB_GPIO)
+
+/* Buzzer */
+
+#define NSLU2_GPIO_BUZZ		4
+#define NSLU2_BZ_BM		(1L << NSLU2_GPIO_BUZZ)
+
+/* LEDs */
+
+#define NSLU2_LED_RED		NSLU2_GPIO0
+#define NSLU2_LED_GRN		NSLU2_GPIO1
+
+#define NSLU2_LED_RED_BM	(1L << NSLU2_LED_RED)
+#define NSLU2_LED_GRN_BM	(1L << NSLU2_LED_GRN)
+
+#define NSLU2_LED_DISK1		NSLU2_GPIO3
+#define NSLU2_LED_DISK2		NSLU2_GPIO2
+
+#define NSLU2_LED_DISK1_BM	(1L << NSLU2_GPIO2)
+#define NSLU2_LED_DISK2_BM	(1L << NSLU2_GPIO3)
+
+
Index: build_tree/linux/include/asm/arch-ixp4xx/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/platform.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,162 @@
+/*
+ * include/asm-arm/arch-ixp4xx/platform.h
+ *
+ * Constants and functions that are useful to IXP4xx platform-specific code
+ * and device drivers.
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#ifndef __ASSEMBLY__
+
+#include <asm/types.h>
+
+#ifndef	__ARMEB__
+#define	REG_OFFSET	0
+#else
+#define	REG_OFFSET	3
+#endif
+
+/*
+ * Expansion bus memory regions
+ */
+#define IXP4XX_EXP_BUS_BASE_PHYS	(0x50000000)
+
+/*
+ * The expansion bus on the IXP4xx can be configured for either 16 or
+ * 32MB windows and the CS offset for each region changes based on the
+ * current configuration. This means that we cannot simply hardcode
+ * each offset. ixp4xx_sys_init() looks at the expansion bus configuration
+ * as setup by the bootloader to determine our window size.
+ */
+extern unsigned long ixp4xx_exp_bus_size;
+
+#define	IXP4XX_EXP_BUS_BASE(region)\
+		(IXP4XX_EXP_BUS_BASE_PHYS + ((region) * ixp4xx_exp_bus_size))
+
+#define IXP4XX_EXP_BUS_END(region)\
+		(IXP4XX_EXP_BUS_BASE(region) + ixp4xx_exp_bus_size - 1)
+
+/* Those macros can be used to adjust timing and configure
+ * other features for each region.
+ */
+
+#define IXP4XX_EXP_BUS_RECOVERY_T(x)	(((x) & 0x0f) << 16)
+#define IXP4XX_EXP_BUS_HOLD_T(x)	(((x) & 0x03) << 20)
+#define IXP4XX_EXP_BUS_STROBE_T(x)	(((x) & 0x0f) << 22)
+#define IXP4XX_EXP_BUS_SETUP_T(x)	(((x) & 0x03) << 26)
+#define IXP4XX_EXP_BUS_ADDR_T(x)	(((x) & 0x03) << 28)
+#define IXP4XX_EXP_BUS_SIZE(x)		(((x) & 0x0f) << 10)
+#define IXP4XX_EXP_BUS_CYCLES(x)	(((x) & 0x03) << 14)
+
+#define IXP4XX_EXP_BUS_CS_EN		(1L << 31)
+#define IXP4XX_EXP_BUS_BYTE_RD16	(1L << 6)
+#define IXP4XX_EXP_BUS_HRDY_POL		(1L << 5)
+#define IXP4XX_EXP_BUS_MUX_EN		(1L << 4)
+#define IXP4XX_EXP_BUS_SPLT_EN		(1L << 3)
+#define IXP4XX_EXP_BUS_WR_EN		(1L << 1)
+#define IXP4XX_EXP_BUS_BYTE_EN		(1L << 0)
+
+#define IXP4XX_EXP_BUS_CYCLES_INTEL	0x00
+#define IXP4XX_EXP_BUS_CYCLES_MOTOROLA	0x01
+#define IXP4XX_EXP_BUS_CYCLES_HPI	0x02
+
+#define IXP4XX_FLASH_WRITABLE	(0x2)
+#define IXP4XX_FLASH_DEFAULT	(0xbcd23c40)
+#define IXP4XX_FLASH_WRITE	(0xbcd23c42)
+
+/*
+ * Clock Speed Definitions.
+ */
+#define IXP4XX_PERIPHERAL_BUS_CLOCK 	(66) /* 66Mhzi APB BUS   */ 
+#define IXP4XX_UART_XTAL        	14745600
+
+/*
+ * The IXP4xx chips do not have an I2C unit, so GPIO lines are just
+ * used to 
+ * Used as platform_data to provide GPIO pin information to the ixp42x
+ * I2C driver.
+ */
+struct ixp4xx_i2c_pins {
+	unsigned long sda_pin;
+	unsigned long scl_pin;
+};
+
+/*
+ * This structure provide a means for the board setup code
+ * to give information to th pata_ixp4xx driver. It is
+ * passed as platform_data.
+ */
+struct ixp4xx_pata_data {
+	volatile u32	*cs0_cfg;
+	volatile u32	*cs1_cfg;
+	unsigned long	cs0_bits;
+	unsigned long	cs1_bits;
+	void __iomem	*cs0;
+	void __iomem	*cs1;
+};
+
+struct sys_timer;
+
+/*
+ * Frequency of clock used for primary clocksource
+ */
+extern unsigned long ixp4xx_timer_freq;
+
+/*
+ * Functions used by platform-level setup code
+ */
+extern void ixp4xx_map_io(void);
+extern void ixp4xx_init_irq(void);
+extern void ixp4xx_sys_init(void);
+extern struct sys_timer ixp4xx_timer;
+extern void ixp4xx_pci_preinit(void);
+struct pci_sys_data;
+extern int ixp4xx_setup(int nr, struct pci_sys_data *sys);
+extern struct pci_bus *ixp4xx_scan_bus(int nr, struct pci_sys_data *sys);
+
+/*
+ * GPIO-functions
+ */
+/*
+ * The following converted to the real HW bits the gpio_line_config
+ */
+/* GPIO pin types */
+#define IXP4XX_GPIO_OUT 		0x1
+#define IXP4XX_GPIO_IN  		0x2
+
+/* GPIO signal types */
+#define IXP4XX_GPIO_LOW			0
+#define IXP4XX_GPIO_HIGH		1
+
+/* GPIO Clocks */
+#define IXP4XX_GPIO_CLK_0		14
+#define IXP4XX_GPIO_CLK_1		15
+
+static inline void gpio_line_config(u8 line, u32 direction)
+{
+	if (direction == IXP4XX_GPIO_IN)
+		*IXP4XX_GPIO_GPOER |= (1 << line);
+	else
+		*IXP4XX_GPIO_GPOER &= ~(1 << line);
+}
+
+static inline void gpio_line_get(u8 line, int *value)
+{
+	*value = (*IXP4XX_GPIO_GPINR >> line) & 0x1;
+}
+
+static inline void gpio_line_set(u8 line, int value)
+{
+	if (value == IXP4XX_GPIO_HIGH)
+	    *IXP4XX_GPIO_GPOUTR |= (1 << line);
+	else if (value == IXP4XX_GPIO_LOW)
+	    *IXP4XX_GPIO_GPOUTR &= ~(1 << line);
+}
+
+#endif // __ASSEMBLY__
+
Index: build_tree/linux/include/asm/arch-ixp4xx/prpmc1100.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/prpmc1100.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/prpmc1100.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-ixp4xx/prpmc1100.h
+ *
+ * Motorolla PrPMC1100 platform specific definitions
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista, Software, Inc. 
+ * 
+ * This file is licensed under  the terms of the GNU General Public 
+ * License version 2. This program is licensed "as is" without any 
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define	PRPMC1100_FLASH_BASE	IXP4XX_EXP_BUS_CS0_BASE_PHYS
+#define	PRPMC1100_FLASH_SIZE	IXP4XX_EXP_BUS_CSX_REGION_SIZE
+
+#define	PRPMC1100_PCI_MIN_DEVID	10
+#define	PRPMC1100_PCI_MAX_DEVID	16
+#define	PRPMC1100_PCI_IRQ_LINES	4
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define PRPMC1100_PCI_INTA_PIN	11
+#define PRPMC1100_PCI_INTB_PIN	10
+#define	PRPMC1100_PCI_INTC_PIN	9
+#define	PRPMC1100_PCI_INTD_PIN	8
+
+
Index: build_tree/linux/include/asm/arch-ixp4xx/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/system.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,42 @@
+/*
+ * include/asm-arm/arch-ixp4xx/system.h
+ *
+ * Copyright (C) 2002 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <asm/hardware.h>
+
+static inline void arch_idle(void)
+{
+#if 0
+	if (!hlt_counter)
+		cpu_do_idle(0);
+#endif
+}
+
+
+static inline void arch_reset(char mode)
+{
+	if ( 1 && mode == 's') {
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+	} else {
+		/* Use on-chip reset capability */
+
+		/* set the "key" register to enable access to
+		 * "timer" and "enable" registers
+		 */
+		*IXP4XX_OSWK = IXP4XX_WDT_KEY;
+
+		/* write 0 to the timer register for an immediate reset */
+		*IXP4XX_OSWT = 0;
+
+		*IXP4XX_OSWE = IXP4XX_WDT_RESET_ENABLE | IXP4XX_WDT_COUNT_ENABLE;
+	}
+}
+
Index: build_tree/linux/include/asm/arch-ixp4xx/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/timex.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,15 @@
+/*
+ * linux/include/asm-arm/arch-ixp4xx/timex.h
+ * 
+ */
+
+#include <asm/hardware.h>
+
+/*
+ * We use IXP425 General purpose timer for our timer needs, it runs at 
+ * 66.66... MHz. We do a convulted calculation of CLOCK_TICK_RATE b/c the
+ * timer register ignores the bottom 2 bits of the LATCH value.
+ */
+#define FREQ 66666666
+#define CLOCK_TICK_RATE (((FREQ / HZ & ~IXP4XX_OST_RELOAD_MASK) + 1) * HZ)
+
Index: build_tree/linux/include/asm/arch-ixp4xx/udc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/udc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/udc.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-arm/arch-ixp4xx/udc.h
+ *
+ */
+#include <asm/mach/udc_pxa2xx.h>
+
+extern void ixp4xx_set_udc_info(struct pxa2xx_udc_mach_info *info);
+
+static inline int udc_gpio_to_irq(unsigned gpio)
+{
+	return 0;
+}
+
+static inline void udc_gpio_init_vbus(unsigned gpio)
+{
+}
+
+static inline void udc_gpio_init_pullup(unsigned gpio)
+{
+}
+
+static inline int udc_gpio_get(unsigned gpio)
+{
+	return 0;
+}
+
+static inline void udc_gpio_set(unsigned gpio, int is_on)
+{
+}
+
Index: build_tree/linux/include/asm/arch-ixp4xx/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/uncompress.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,56 @@
+/*
+ * include/asm-arm/arch-ixp4xx/uncompress.h 
+ *
+ * Copyright (C) 2002 Intel Corporation.
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ARCH_UNCOMPRESS_H_
+#define _ARCH_UNCOMPRESS_H_
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <linux/serial_reg.h>
+
+#define TX_DONE (UART_LSR_TEMT|UART_LSR_THRE)
+
+static volatile u32* uart_base;
+
+static inline void putc(int c)
+{
+	/* Check THRE and TEMT bits before we transmit the character.
+	 */
+	while ((uart_base[UART_LSR] & TX_DONE) != TX_DONE)
+		barrier();
+
+	*uart_base = c;
+}
+
+static void flush(void)
+{
+}
+
+static __inline__ void __arch_decomp_setup(unsigned long arch_id)
+{
+	/*
+	 * Coyote and gtwx5715 only have UART2 connected
+	 */
+	if (machine_is_adi_coyote() || machine_is_gtwx5715())
+		uart_base = (volatile u32*) IXP4XX_UART2_BASE_PHYS;
+	else
+		uart_base = (volatile u32*) IXP4XX_UART1_BASE_PHYS;
+}
+
+/*
+ * arch_id is a variable in decompress_kernel()
+ */
+#define arch_decomp_setup()	__arch_decomp_setup(arch_id)
+
+#define arch_decomp_wdog()
+
+#endif
Index: build_tree/linux/include/asm/arch-ixp4xx/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ixp4xx/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ixp4xx/vmalloc.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,5 @@
+/*
+ * linux/include/asm-arm/arch-ixp4xx/vmalloc.h
+ */
+#define VMALLOC_END       (0xFF000000)
+
Index: build_tree/linux/include/asm/arch-l7200/aux_reg.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/aux_reg.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/aux_reg.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ * linux/include/asm-arm/arch-l7200/aux_reg.h
+ *
+ * Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *   08-02-2000	SJH	Created file
+ */
+#ifndef _ASM_ARCH_AUXREG_H
+#define _ASM_ARCH_AUXREG_H
+
+#include <asm/hardware.h>
+
+#define l7200aux_reg	*((volatile unsigned int *) (AUX_BASE))
+
+/*
+ * Auxillary register values
+ */
+#define AUX_CLEAR		0x00000000
+#define AUX_DIAG_LED_ON		0x00000002
+#define AUX_RTS_UART1		0x00000004
+#define AUX_DTR_UART1		0x00000008
+#define AUX_KBD_COLUMN_12_HIGH	0x00000010
+#define AUX_KBD_COLUMN_12_OFF	0x00000020
+#define AUX_KBD_COLUMN_13_HIGH	0x00000040
+#define AUX_KBD_COLUMN_13_OFF	0x00000080
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/* linux/include/asm-arm/arch-l7200/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.equ	io_virt, IO_BASE
+		.equ	io_phys, IO_START
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #io_phys		@ physical base address
+		movne	\rx, #io_virt		@ virtual address
+		add	\rx, \rx, #0x00044000	@ UART1
+@		add	\rx, \rx, #0x00045000	@ UART2
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0x0]	@ UARTDR
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldr	\rd, [\rx, #0x18]	@ UARTFLG
+		tst	\rd, #1 << 5		@ UARTFLGUTXFF - 1 when full
+		bne	1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+1001:		ldr	\rd, [\rx, #0x18]	@ UARTFLG
+		tst	\rd, #1 << 3		@ UARTFLGUBUSY - 1 when busy
+		bne	1001b
+		.endm
Index: build_tree/linux/include/asm/arch-l7200/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/*
+ * linux/include/asm-arm/arch-l7200/dma.h
+ *
+ * Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *  08-29-2000	SJH	Created
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/* DMA is not yet implemented! It should be the same as acorn, copy over.. */
+
+/*
+ * This is the maximum DMA address that can be DMAd to.
+ * There should not be more than (0xd0000000 - 0xc0000000)
+ * bytes of RAM.
+ */
+#define MAX_DMA_ADDRESS         0xd0000000
+
+#define DMA_S0                  0
+
+#endif /* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-l7200/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,35 @@
+/*
+ * include/asm-arm/arch-l7200/entry-macro.S
+ *
+ * Low-level IRQ helper macros for L7200-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+
+		.equ	irq_base_addr,	IO_BASE_2
+
+		.macro  disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov     \irqstat, #irq_base_addr		@ Virt addr IRQ regs
+		add	\irqstat, \irqstat, #0x00001000		@ Status reg
+		ldr     \irqstat, [\irqstat, #0]		@ get interrupts
+		mov     \irqnr, #0
+1001:		tst     \irqstat, #1
+		addeq   \irqnr, \irqnr, #1
+		moveq   \irqstat, \irqstat, lsr #1
+		tsteq   \irqnr, #32
+		beq     1001b
+		teq     \irqnr, #32
+		.endm
+
Index: build_tree/linux/include/asm/arch-l7200/gp_timers.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/gp_timers.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/gp_timers.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ * linux/include/asm-arm/arch-l7200/gp_timers.h
+ *
+ * Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *   07-28-2000	SJH	Created file
+ *   08-02-2000	SJH	Used structure for registers
+ */
+#ifndef _ASM_ARCH_GPTIMERS_H
+#define _ASM_ARCH_GPTIMERS_H
+
+#include <asm/hardware.h>
+
+/*
+ * Layout of L7200 general purpose timer registers
+ */
+struct GPT_Regs {
+	unsigned int TIMERLOAD;
+	unsigned int TIMERVALUE;
+	unsigned int TIMERCONTROL;
+	unsigned int TIMERCLEAR;
+};
+
+#define GPT_BASE		(IO_BASE_2 + 0x3000)
+#define l7200_timer1_regs	((volatile struct GPT_Regs *) (GPT_BASE))
+#define l7200_timer2_regs	((volatile struct GPT_Regs *) (GPT_BASE + 0x20))
+
+/*
+ * General register values
+ */
+#define	GPT_PRESCALE_1		0x00000000
+#define	GPT_PRESCALE_16		0x00000004
+#define	GPT_PRESCALE_256	0x00000008
+#define GPT_MODE_FREERUN	0x00000000
+#define GPT_MODE_PERIODIC	0x00000040
+#define GPT_ENABLE		0x00000080
+#define GPT_BZTOG		0x00000100
+#define GPT_BZMOD		0x00000200
+#define GPT_LOAD_MASK 		0x0000ffff
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,105 @@
+/****************************************************************************/
+/*
+ *      linux/include/asm-arm/arch-l7200/gpio.h
+ *
+ *      Registers and  helper functions for the L7200 Link-Up Systems
+ *      GPIO.
+ *
+ *      (C) Copyright 2000, S A McConnell  (samcconn@cotw.com)
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+/****************************************************************************/
+
+#define GPIO_OFF   0x00005000  /* Offset from IO_START to the GPIO reg's. */
+
+/* IO_START and IO_BASE are defined in hardware.h */
+
+#define GPIO_START (IO_START_2 + GPIO_OFF) /* Physical addr of the GPIO reg. */
+#define GPIO_BASE  (IO_BASE_2  + GPIO_OFF) /* Virtual addr of the GPIO reg. */
+
+/* Offsets from the start of the GPIO for all the registers. */
+#define PADR_OFF     0x000
+#define PADDR_OFF    0x004
+#define PASBSR_OFF   0x008
+#define PAEENR_OFF   0x00c
+#define PAESNR_OFF   0x010
+#define PAESTR_OFF   0x014
+#define PAIMR_OFF    0x018
+#define PAINT_OFF    0x01c
+
+#define PBDR_OFF     0x020
+#define PBDDR_OFF    0x024
+#define PBSBSR_OFF   0x028
+#define PBIMR_OFF    0x038
+#define PBINT_OFF    0x03c
+
+#define PCDR_OFF     0x040
+#define PCDDR_OFF    0x044
+#define PCSBSR_OFF   0x048
+#define PCIMR_OFF    0x058
+#define PCINT_OFF    0x05c
+
+#define PDDR_OFF     0x060
+#define PDDDR_OFF    0x064
+#define PDSBSR_OFF   0x068
+#define PDEENR_OFF   0x06c
+#define PDESNR_OFF   0x070
+#define PDESTR_OFF   0x074
+#define PDIMR_OFF    0x078
+#define PDINT_OFF    0x07c
+
+#define PEDR_OFF     0x080
+#define PEDDR_OFF    0x084
+#define PESBSR_OFF   0x088
+#define PEEENR_OFF   0x08c
+#define PEESNR_OFF   0x090
+#define PEESTR_OFF   0x094
+#define PEIMR_OFF    0x098
+#define PEINT_OFF    0x09c
+
+/* Define the GPIO registers for use by device drivers and the kernel. */
+#define PADR   (*(volatile unsigned long *)(GPIO_BASE+PADR_OFF))
+#define PADDR  (*(volatile unsigned long *)(GPIO_BASE+PADDR_OFF))
+#define PASBSR (*(volatile unsigned long *)(GPIO_BASE+PASBSR_OFF))
+#define PAEENR (*(volatile unsigned long *)(GPIO_BASE+PAEENR_OFF))
+#define PAESNR (*(volatile unsigned long *)(GPIO_BASE+PAESNR_OFF))
+#define PAESTR (*(volatile unsigned long *)(GPIO_BASE+PAESTR_OFF))
+#define PAIMR  (*(volatile unsigned long *)(GPIO_BASE+PAIMR_OFF))
+#define PAINT  (*(volatile unsigned long *)(GPIO_BASE+PAINT_OFF))
+
+#define PBDR   (*(volatile unsigned long *)(GPIO_BASE+PBDR_OFF))
+#define PBDDR  (*(volatile unsigned long *)(GPIO_BASE+PBDDR_OFF))
+#define PBSBSR (*(volatile unsigned long *)(GPIO_BASE+PBSBSR_OFF))
+#define PBIMR  (*(volatile unsigned long *)(GPIO_BASE+PBIMR_OFF))
+#define PBINT  (*(volatile unsigned long *)(GPIO_BASE+PBINT_OFF))
+
+#define PCDR   (*(volatile unsigned long *)(GPIO_BASE+PCDR_OFF))
+#define PCDDR  (*(volatile unsigned long *)(GPIO_BASE+PCDDR_OFF))
+#define PCSBSR (*(volatile unsigned long *)(GPIO_BASE+PCSBSR_OFF))
+#define PCIMR  (*(volatile unsigned long *)(GPIO_BASE+PCIMR_OFF))
+#define PCINT  (*(volatile unsigned long *)(GPIO_BASE+PCINT_OFF))
+
+#define PDDR   (*(volatile unsigned long *)(GPIO_BASE+PDDR_OFF))
+#define PDDDR  (*(volatile unsigned long *)(GPIO_BASE+PDDDR_OFF))
+#define PDSBSR (*(volatile unsigned long *)(GPIO_BASE+PDSBSR_OFF))
+#define PDEENR (*(volatile unsigned long *)(GPIO_BASE+PDEENR_OFF))
+#define PDESNR (*(volatile unsigned long *)(GPIO_BASE+PDESNR_OFF))
+#define PDESTR (*(volatile unsigned long *)(GPIO_BASE+PDESTR_OFF))
+#define PDIMR  (*(volatile unsigned long *)(GPIO_BASE+PDIMR_OFF))
+#define PDINT  (*(volatile unsigned long *)(GPIO_BASE+PDINT_OFF))
+
+#define PEDR   (*(volatile unsigned long *)(GPIO_BASE+PEDR_OFF))
+#define PEDDR  (*(volatile unsigned long *)(GPIO_BASE+PEDDR_OFF))
+#define PESBSR (*(volatile unsigned long *)(GPIO_BASE+PESBSR_OFF))
+#define PEEENR (*(volatile unsigned long *)(GPIO_BASE+PEEENR_OFF))
+#define PEESNR (*(volatile unsigned long *)(GPIO_BASE+PEESNR_OFF))
+#define PEESTR (*(volatile unsigned long *)(GPIO_BASE+PEESTR_OFF))
+#define PEIMR  (*(volatile unsigned long *)(GPIO_BASE+PEIMR_OFF))
+#define PEINT  (*(volatile unsigned long *)(GPIO_BASE+PEINT_OFF))
+
+#define VEE_EN         0x02
+#define BACKLIGHT_EN   0x04
Index: build_tree/linux/include/asm/arch-l7200/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/*
+ * linux/include/asm-arm/arch-l7200/hardware.h
+ *
+ * Copyright (C) 2000 Rob Scott (rscott@mtrob.fdns.net)
+ *                    Steve Hill (sjhill@cotw.com)
+ *
+ * This file contains the hardware definitions for the 
+ * LinkUp Systems L7200 SOC development board.
+ *
+ * Changelog:
+ *   02-01-2000	 RS	Created L7200 version, derived from rpc code
+ *   03-21-2000	SJH	Cleaned up file
+ *   04-21-2000	 RS 	Changed mapping of I/O in virtual space
+ *   04-25-2000	SJH	Removed unused symbols and such
+ *   05-05-2000	SJH	Complete rewrite
+ *   07-31-2000	SJH	Added undocumented debug auxillary port to
+ *			get at last two columns for keyboard driver
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/* Hardware addresses of major areas.
+ *  *_START is the physical address
+ *  *_SIZE  is the size of the region
+ *  *_BASE  is the virtual address
+ */
+#define RAM_START		0xf0000000
+#define RAM_SIZE		0x02000000
+#define RAM_BASE		0xc0000000
+
+#define IO_START		0x80000000      /* I/O */
+#define IO_SIZE			0x01000000
+#define IO_BASE			0xd0000000
+
+#define IO_START_2		0x90000000      /* I/O */
+#define IO_SIZE_2		0x01000000
+#define IO_BASE_2		0xd1000000
+
+#define AUX_START		0x1a000000      /* AUX PORT */
+#define AUX_SIZE 		0x01000000
+#define AUX_BASE		0xd2000000
+
+#define FLASH1_START		0x00000000      /* FLASH BANK 1 */
+#define FLASH1_SIZE 		0x01000000
+#define FLASH1_BASE		0xd3000000
+
+#define FLASH2_START		0x10000000      /* FLASH BANK 2 */
+#define FLASH2_SIZE 		0x01000000
+#define FLASH2_BASE		0xd4000000
+
+#define ISA_START		0x20000000	/* ISA */
+#define ISA_SIZE		0x20000000
+#define ISA_BASE		0xe0000000
+
+#define PCIO_BASE		IO_BASE
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,27 @@
+/*
+ * linux/include/asm-arm/arch-l7200/io.h
+ *
+ * Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *  03-21-2000	SJH	Created from linux/include/asm-arm/arch-nexuspci/io.h
+ *  08-31-2000	SJH	Added in IO functions necessary for new drivers
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * There are not real ISA nor PCI buses, so we fake it.
+ */
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+#define __io(a)	__io(a)
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,56 @@
+/*
+ * include/asm-arm/arch-l7200/irqs.h
+ *
+ * Copyright (C) 2000 Rob Scott (rscott@mtrob.fdns.net)
+ *                    Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *   01-02-2000 RS	Create l7200 version
+ *   03-28-2000 SJH	Removed unused interrupt
+ *   07-28-2000 SJH	Added pseudo-keyboard interrupt
+ */
+
+/*
+ * NOTE: The second timer (Timer 2) is used as the keyboard
+ *       interrupt when the keyboard driver is enabled.
+ */
+
+#define NR_IRQS          32
+
+#define IRQ_STWDOG        0   /* Watchdog timer */
+#define IRQ_PROG          1   /* Programmable interrupt */
+#define IRQ_DEBUG_RX      2   /* Comm Rx debug */
+#define IRQ_DEBUG_TX      3   /* Comm Tx debug */
+#define IRQ_GCTC1         4   /* Timer 1 */
+#define IRQ_GCTC2         5   /* Timer 2 / Keyboard */
+#define IRQ_DMA           6   /* DMA controller */
+#define IRQ_CLCD          7   /* Color LCD controller */
+#define IRQ_SM_RX         8   /* Smart card */
+#define IRQ_SM_TX         9   /* Smart cart */
+#define IRQ_SM_RST       10   /* Smart card */
+#define IRQ_SIB          11   /* Serial Interface Bus */
+#define IRQ_MMC          12   /* MultiMediaCard */
+#define IRQ_SSP1         13   /* Synchronous Serial Port 1 */
+#define IRQ_SSP2         14   /* Synchronous Serial Port 1 */
+#define IRQ_SPI          15   /* SPI slave */
+#define IRQ_UART_1       16   /* UART 1 */
+#define IRQ_UART_2       17   /* UART 2 */
+#define IRQ_IRDA         18   /* IRDA */
+#define IRQ_RTC_TICK     19   /* Real Time Clock tick */
+#define IRQ_RTC_ALARM    20   /* Real Time Clock alarm */
+#define IRQ_GPIO         21   /* General Purpose IO */
+#define IRQ_GPIO_DMA     22   /* General Purpose IO, DMA */
+#define IRQ_M2M          23   /* Memory to memory DMA  */
+#define IRQ_RESERVED     24   /* RESERVED, don't use */
+#define IRQ_INTF         25   /* External active low interrupt */
+#define IRQ_INT0         26   /* External active low interrupt */
+#define IRQ_INT1         27   /* External active low interrupt */
+#define IRQ_INT2         28   /* External active low interrupt */
+#define IRQ_UCB1200      29   /* Interrupt generated by UCB1200*/
+#define IRQ_BAT_LO       30   /* Low batery or external power */
+#define IRQ_MEDIA_CHG    31   /* Media change interrupt */
+
+/*
+ * This is the offset of the FIQ "IRQ" numbers
+ */
+#define FIQ_START	64
Index: build_tree/linux/include/asm/arch-l7200/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-arm/arch-l7200/memory.h
+ *
+ * Copyright (c) 2000 Steve Hill (sjhill@cotw.com)
+ * Copyright (c) 2000 Rob Scott (rscott@mtrob.fdns.net)
+ *
+ * Changelog:
+ *  03-13-2000	SJH	Created
+ *  04-13-2000  RS      Changed bus macros for new addr
+ *  05-03-2000  SJH     Removed bus macros and fixed virt_to_phys macro
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset on the L7200 SDB.
+ */
+#define PHYS_OFFSET     UL(0xf0000000)
+
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+/*
+ * Cache flushing area - ROM
+ */
+#define FLUSH_BASE_PHYS		0x40000000
+#define FLUSH_BASE		0xdf000000
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/pmpcon.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/pmpcon.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/pmpcon.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/****************************************************************************/
+/*
+ *  linux/include/asm-arm/arch-l7200/pmpcon.h
+ *
+ *   Registers and  helper functions for the L7200 Link-Up Systems
+ *   DC/DC converter register.
+ *
+ *   (C) Copyright 2000, S A McConnell  (samcconn@cotw.com)
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+/****************************************************************************/
+
+#define PMPCON_OFF 0x00006000  /* Offset from IO_START_2. */
+
+/* IO_START_2 and IO_BASE_2 are defined in hardware.h */
+
+#define PMPCON_START (IO_START_2 + PMPCON_OFF)  /* Physical address of reg. */
+#define PMPCON_BASE  (IO_BASE_2  + PMPCON_OFF)  /* Virtual address of reg. */
+
+
+#define PMPCON (*(volatile unsigned int *)(PMPCON_BASE))
+
+#define PWM2_50CYCLE 0x800
+#define CONTRAST     0x9
+
+#define PWM1H (CONTRAST)
+#define PWM1L (CONTRAST << 4)
+
+#define PMPCON_VALUE  (PWM2_50CYCLE | PWM1L | PWM1H) 
+	
+/* PMPCON = 0x811;   // too light and fuzzy
+ * PMPCON = 0x844;   
+ * PMPCON = 0x866;   // better color poor depth
+ * PMPCON = 0x888;   // Darker but better depth 
+ * PMPCON = 0x899;   // Darker even better depth
+ * PMPCON = 0x8aa;   // too dark even better depth
+ * PMPCON = 0X8cc;   // Way too dark
+ */
+
+/* As CONTRAST value increases the greater the depth perception and
+ * the darker the colors.
+ */
Index: build_tree/linux/include/asm/arch-l7200/pmu.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/pmu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/pmu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,125 @@
+/****************************************************************************/
+/*
+ *  linux/include/asm-arm/arch-l7200/pmu.h
+ *
+ *   Registers and  helper functions for the L7200 Link-Up Systems
+ *   Power Management Unit (PMU).
+ *
+ *   (C) Copyright 2000, S A McConnell  (samcconn@cotw.com)
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+/****************************************************************************/
+
+#define PMU_OFF   0x00050000  /* Offset from IO_START to the PMU registers. */
+
+/* IO_START and IO_BASE are defined in hardware.h */
+
+#define PMU_START (IO_START + PMU_OFF)  /* Physical addr. of the PMU reg. */
+#define PMU_BASE  (IO_BASE  + PMU_OFF)  /* Virtual addr. of the PMU reg. */
+
+
+/* Define the PMU registers for use by device drivers and the kernel. */
+
+typedef struct {
+     unsigned int CURRENT;  /* Current configuration register */
+     unsigned int NEXT;     /* Next configuration register */
+     unsigned int reserved;
+     unsigned int RUN;      /* Run configuration register */
+     unsigned int COMM;     /* Configuration command register */
+     unsigned int SDRAM;    /* SDRAM configuration bypass register */
+} pmu_interface;
+
+#define PMU ((volatile pmu_interface *)(PMU_BASE))
+
+
+/* Macro's for reading the common register fields. */
+
+#define GET_TRANSOP(reg)  ((reg >> 25) & 0x03) /* Bits 26-25 */
+#define GET_OSCEN(reg)    ((reg >> 16) & 0x01)
+#define GET_OSCMUX(reg)   ((reg >> 15) & 0x01)
+#define GET_PLLMUL(reg)   ((reg >>  9) & 0x3f) /* Bits 14-9 */
+#define GET_PLLEN(reg)    ((reg >>  8) & 0x01)
+#define GET_PLLMUX(reg)   ((reg >>  7) & 0x01)
+#define GET_BCLK_DIV(reg) ((reg >>  3) & 0x03) /* Bits 4-3 */
+#define GET_SDRB_SEL(reg) ((reg >>  2) & 0x01)
+#define GET_SDRF_SEL(reg) ((reg >>  1) & 0x01)
+#define GET_FASTBUS(reg)  (reg & 0x1)
+
+/* CFG_NEXT register */
+
+#define CFG_NEXT_CLOCKRECOVERY ((PMU->NEXT >> 18) & 0x7f)   /* Bits 24-18 */
+#define CFG_NEXT_INTRET        ((PMU->NEXT >> 17) & 0x01)
+#define CFG_NEXT_SDR_STOP      ((PMU->NEXT >>  6) & 0x01)
+#define CFG_NEXT_SYSCLKEN      ((PMU->NEXT >>  5) & 0x01)
+
+/* Useful field values that can be used to construct the
+ * CFG_NEXT and CFG_RUN registers.
+ */
+
+#define TRANSOP_NOP      0<<25  /* NOCHANGE_NOSTALL */
+#define NOCHANGE_STALL   1<<25
+#define CHANGE_NOSTALL   2<<25
+#define CHANGE_STALL     3<<25
+
+#define INTRET           1<<17
+#define OSCEN            1<<16
+#define OSCMUX           1<<15
+
+/* PLL frequencies */
+
+#define PLLMUL_0         0<<9         /*  3.6864 MHz */
+#define PLLMUL_1         1<<9         /*  ?????? MHz */
+#define PLLMUL_5         5<<9         /*  18.432 MHz */
+#define PLLMUL_10       10<<9         /*  36.864 MHz */
+#define PLLMUL_18       18<<9         /*  ?????? MHz */
+#define PLLMUL_20       20<<9         /*  73.728 MHz */
+#define PLLMUL_32       32<<9         /*  ?????? MHz */
+#define PLLMUL_35       35<<9         /* 129.024 MHz */
+#define PLLMUL_36       36<<9         /*  ?????? MHz */
+#define PLLMUL_39       39<<9         /*  ?????? MHz */
+#define PLLMUL_40       40<<9         /* 147.456 MHz */
+
+/* Clock recovery times */
+
+#define CRCLOCK_1        1<<18
+#define CRCLOCK_2        2<<18
+#define CRCLOCK_4        4<<18
+#define CRCLOCK_8        8<<18
+#define CRCLOCK_16      16<<18
+#define CRCLOCK_32      32<<18
+#define CRCLOCK_63      63<<18
+#define CRCLOCK_127    127<<18
+
+#define PLLEN            1<<8
+#define PLLMUX           1<<7
+#define SDR_STOP         1<<6
+#define SYSCLKEN         1<<5
+
+#define BCLK_DIV_4       2<<3
+#define BCLK_DIV_2       1<<3
+#define BCLK_DIV_1       0<<3
+
+#define SDRB_SEL         1<<2
+#define SDRF_SEL         1<<1
+#define FASTBUS          1<<0
+
+
+/* CFG_SDRAM */
+
+#define SDRREFFQ         1<<0  /* Only if SDRSTOPRQ is not set. */
+#define SDRREFACK        1<<1  /* Read-only */
+#define SDRSTOPRQ        1<<2  /* Only if SDRREFFQ is not set. */
+#define SDRSTOPACK       1<<3  /* Read-only */
+#define PICEN            1<<4  /* Enable Co-procesor */
+#define PICTEST          1<<5
+
+#define GET_SDRREFFQ    ((PMU->SDRAM >> 0) & 0x01)
+#define GET_SDRREFACK   ((PMU->SDRAM >> 1) & 0x01) /* Read-only */
+#define GET_SDRSTOPRQ   ((PMU->SDRAM >> 2) & 0x01)
+#define GET_SDRSTOPACK  ((PMU->SDRAM >> 3) & 0x01) /* Read-only */
+#define GET_PICEN       ((PMU->SDRAM >> 4) & 0x01)
+#define GET_PICTEST     ((PMU->SDRAM >> 5) & 0x01)
Index: build_tree/linux/include/asm/arch-l7200/serial.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/serial.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/serial.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * linux/include/asm-arm/arch-l7200/serial.h
+ *
+ * Copyright (c) 2000 Rob Scott (rscott@mtrob.fdns.net)
+ *                    Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *  03-20-2000  SJH     Created
+ *  03-26-2000  SJH     Added flags for serial ports
+ *  03-27-2000  SJH     Corrected BASE_BAUD value
+ *  04-14-2000  RS      Made register addr dependent on IO_BASE
+ *  05-03-2000  SJH     Complete rewrite
+ *  05-09-2000	SJH	Stripped out architecture specific serial stuff
+ *                      and placed it in a separate file
+ *  07-28-2000	SJH	Moved base baud rate variable
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+/*
+ * This assumes you have a 3.6864 MHz clock for your UART.
+ */
+#define BASE_BAUD	3686400
+
+/*
+ * Standard COM flags
+ */
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+
+#define STD_SERIAL_PORT_DEFNS		\
+	/* MAGIC UART CLK   PORT       IRQ     FLAGS */			\
+	{ 0, BASE_BAUD, UART1_BASE, IRQ_UART_1, STD_COM_FLAGS },  /* ttyLU0 */ \
+	{ 0, BASE_BAUD, UART2_BASE, IRQ_UART_2, STD_COM_FLAGS },  /* ttyLU1 */ \
+
+#define EXTRA_SERIAL_PORT_DEFNS
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/serial_l7200.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/serial_l7200.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/serial_l7200.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,101 @@
+/*
+ * linux/include/asm-arm/arch-l7200/serial_l7200.h
+ *
+ * Copyright (c) 2000 Steven Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *  05-09-2000	SJH	Created
+ */
+#ifndef __ASM_ARCH_SERIAL_L7200_H
+#define __ASM_ARCH_SERIAL_L7200_H
+
+#include <asm/arch/memory.h>
+
+/*
+ * This assumes you have a 3.6864 MHz clock for your UART.
+ */
+#define BASE_BAUD 3686400
+
+/*
+ * UART base register addresses
+ */
+#define UART1_BASE	(IO_BASE + 0x00044000)
+#define UART2_BASE	(IO_BASE + 0x00045000)
+
+/*
+ * UART register offsets
+ */
+#define UARTDR			0x00	/* Tx/Rx data */
+#define RXSTAT			0x04	/* Rx status */
+#define H_UBRLCR		0x08	/* mode register high */
+#define M_UBRLCR		0x0C	/* mode reg mid (MSB of baud)*/
+#define L_UBRLCR		0x10	/* mode reg low (LSB of baud)*/
+#define UARTCON			0x14	/* control register */
+#define UARTFLG			0x18	/* flag register */
+#define UARTINTSTAT		0x1C	/* FIFO IRQ status register */
+#define UARTINTMASK		0x20	/* FIFO IRQ mask register */
+
+/*
+ * UART baud rate register values
+ */
+#define BR_110			0x827
+#define BR_1200			0x06e
+#define BR_2400			0x05f
+#define BR_4800			0x02f
+#define BR_9600			0x017
+#define BR_14400		0x00f
+#define BR_19200		0x00b
+#define BR_38400		0x005
+#define BR_57600		0x003
+#define BR_76800 		0x002
+#define BR_115200		0x001
+
+/*
+ * Receiver status register (RXSTAT) mask values
+ */
+#define RXSTAT_NO_ERR		0x00	/* No error */
+#define RXSTAT_FRM_ERR		0x01	/* Framing error */
+#define RXSTAT_PAR_ERR		0x02	/* Parity error */
+#define RXSTAT_OVR_ERR		0x04	/* Overrun error */
+
+/*
+ * High byte of UART bit rate and line control register (H_UBRLCR) values
+ */
+#define UBRLCR_BRK		0x01	/* generate break on tx */
+#define UBRLCR_PEN		0x02	/* enable parity */
+#define UBRLCR_PDIS		0x00	/* disable parity */
+#define UBRLCR_EVEN		0x04	/* 1= even parity,0 = odd parity */
+#define UBRLCR_STP2		0x08	/* transmit 2 stop bits */
+#define UBRLCR_FIFO		0x10	/* enable FIFO */
+#define UBRLCR_LEN5		0x60	/* word length5 */
+#define UBRLCR_LEN6		0x40	/* word length6 */
+#define UBRLCR_LEN7		0x20	/* word length7 */
+#define UBRLCR_LEN8		0x00	/* word length8 */
+
+/*
+ * UART control register (UARTCON) values
+ */
+#define UARTCON_UARTEN		0x01	/* Enable UART */
+#define UARTCON_DMAONERR	0x08	/* Mask RxDmaRq when errors occur */
+
+/*
+ * UART flag register (UARTFLG) mask values
+ */
+#define UARTFLG_UTXFF		0x20	/* Transmit FIFO full */
+#define UARTFLG_URXFE		0x10	/* Receiver FIFO empty */
+#define UARTFLG_UBUSY		0x08	/* Transmitter busy */
+#define UARTFLG_DCD		0x04	/* Data carrier detect */
+#define UARTFLG_DSR		0x02	/* Data set ready */
+#define UARTFLG_CTS		0x01	/* Clear to send */
+
+/*
+ * UART interrupt status/clear registers (UARTINTSTAT/CLR) values
+ */
+#define UART_TXINT		0x01	/* TX interrupt */
+#define UART_RXINT		0x02	/* RX interrupt */
+#define UART_RXERRINT		0x04	/* RX error interrupt */
+#define UART_MSINT		0x08	/* Modem Status interrupt */
+#define UART_UDINT		0x10	/* UART Disabled interrupt */
+#define UART_ALLIRQS		0x1f	/* All interrupts */
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/sib.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/sib.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/sib.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,119 @@
+/****************************************************************************/
+/*
+ *  linux/include/asm-arm/arch-l7200/sib.h
+ *
+ *  Registers and helper functions for the Serial Interface Bus.
+ *
+ *  (C) Copyright 2000, S A McConnell  (samcconn@cotw.com)
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+/****************************************************************************/
+
+#define SIB_OFF   0x00040000  /* Offset from IO_START to the SIB reg's. */
+
+/* IO_START and IO_BASE are defined in hardware.h */
+
+#define SIB_START (IO_START + SIB_OFF) /* Physical addr of the SIB reg. */
+#define SIB_BASE  (IO_BASE  + SIB_OFF) /* Virtual addr of the SIB reg.  */
+
+/* Offsets from the start of the SIB for all the registers. */
+
+/* Define the SIB registers for use by device drivers and the kernel. */
+
+typedef struct
+{
+     unsigned int MCCR;    /* SIB Control Register           Offset: 0x00 */
+     unsigned int RES1;    /* Reserved                       Offset: 0x04 */
+     unsigned int MCDR0;   /* SIB Data Register 0            Offset: 0x08 */
+     unsigned int MCDR1;   /* SIB Data Register 1            Offset: 0x0c */
+     unsigned int MCDR2;   /* SIB Data Register 2 (UCB1x00)  Offset: 0x10 */
+     unsigned int RES2;    /* Reserved                       Offset: 0x14 */
+     unsigned int MCSR;    /* SIB Status Register            Offset: 0x18 */
+} SIB_Interface;
+
+#define SIB ((volatile SIB_Interface *) (SIB_BASE))
+
+/* MCCR */
+
+#define INTERNAL_FREQ   9216000  /* Hertz */
+#define AUDIO_FREQ         5000  /* Hertz */
+#define TELECOM_FREQ       5000  /* Hertz */
+
+#define AUDIO_DIVIDE    (INTERNAL_FREQ / (32 * AUDIO_FREQ))
+#define TELECOM_DIVIDE  (INTERNAL_FREQ / (32 * TELECOM_FREQ))
+
+#define MCCR_ASD57      AUDIO_DIVIDE
+#define MCCR_TSD57      (TELECOM_DIVIDE << 8)
+#define MCCR_MCE        (1 << 16)             /* SIB enable */
+#define MCCR_ECS        (1 << 17)             /* External Clock Select */
+#define MCCR_ADM        (1 << 18)             /* A/D Data Sampling */
+#define MCCR_PMC        (1 << 26)             /* PIN Multiplexer Control */
+
+
+#define GET_ASD ((SIB->MCCR >>  0) & 0x3f) /* Audio Sample Rate Div. */
+#define GET_TSD ((SIB->MCCR >>  8) & 0x3f) /* Telcom Sample Rate Div. */
+#define GET_MCE ((SIB->MCCR >> 16) & 0x01) /* SIB Enable */
+#define GET_ECS ((SIB->MCCR >> 17) & 0x01) /* External Clock Select */
+#define GET_ADM ((SIB->MCCR >> 18) & 0x01) /* A/D Data Sampling Mode */
+#define GET_TTM ((SIB->MCCR >> 19) & 0x01) /* Telco Trans. FIFO I mask */ 
+#define GET_TRM ((SIB->MCCR >> 20) & 0x01) /* Telco Recv. FIFO I mask */
+#define GET_ATM ((SIB->MCCR >> 21) & 0x01) /* Audio Trans. FIFO I mask */ 
+#define GET_ARM ((SIB->MCCR >> 22) & 0x01) /* Audio Recv. FIFO I mask */
+#define GET_LBM ((SIB->MCCR >> 23) & 0x01) /* Loop Back Mode */
+#define GET_ECP ((SIB->MCCR >> 24) & 0x03) /* Extern. Clck Prescale sel */
+#define GET_PMC ((SIB->MCCR >> 26) & 0x01) /* PIN Multiplexer Control */
+#define GET_ERI ((SIB->MCCR >> 27) & 0x01) /* External Read Interrupt */
+#define GET_EWI ((SIB->MCCR >> 28) & 0x01) /* External Write Interrupt */
+
+/* MCDR0 */
+
+#define AUDIO_RECV     ((SIB->MCDR0 >> 4) & 0xfff)
+#define AUDIO_WRITE(v) ((SIB->MCDR0 = (v & 0xfff) << 4))
+
+/* MCDR1 */
+
+#define TELECOM_RECV     ((SIB->MCDR1 >> 2) & 032fff)
+#define TELECOM_WRITE(v) ((SIB->MCDR1 = (v & 0x3fff) << 2))
+
+
+/* MCSR */
+
+#define MCSR_ATU (1 << 4)  /* Audio Transmit FIFO Underrun */
+#define MCSR_ARO (1 << 5)  /* Audio Receive  FIFO Underrun */
+#define MCSR_TTU (1 << 6)  /* TELECOM Transmit FIFO Underrun */
+#define MCSR_TRO (1 << 7)  /* TELECOM Receive  FIFO Underrun */
+
+#define MCSR_CLEAR_UNDERUN_BITS (MCSR_ATU | MCSR_ARO | MCSR_TTU | MCSR_TRO)
+
+
+#define GET_ATS ((SIB->MCSR >>  0) & 0x01) /* Audio Transmit FIFO Service Req*/
+#define GET_ARS ((SIB->MCSR >>  1) & 0x01) /* Audio Recv FIFO Service Request*/
+#define GET_TTS ((SIB->MCSR >>  2) & 0x01) /* TELECOM Transmit FIFO  Flag */
+#define GET_TRS ((SIB->MCSR >>  3) & 0x01) /* TELECOM Recv FIFO Service Req. */
+#define GET_ATU ((SIB->MCSR >>  4) & 0x01) /* Audio Transmit FIFO Underrun */
+#define GET_ARO ((SIB->MCSR >>  5) & 0x01) /* Audio Receive  FIFO Underrun */
+#define GET_TTU ((SIB->MCSR >>  6) & 0x01) /* TELECOM Transmit FIFO Underrun */
+#define GET_TRO ((SIB->MCSR >>  7) & 0x01) /* TELECOM Receive  FIFO Underrun */
+#define GET_ANF ((SIB->MCSR >>  8) & 0x01) /* Audio Transmit FIFO not full */
+#define GET_ANE ((SIB->MCSR >>  9) & 0x01) /* Audio Receive FIFO not empty */
+#define GET_TNF ((SIB->MCSR >> 10) & 0x01) /* Telecom Transmit FIFO not full */
+#define GET_TNE ((SIB->MCSR >> 11) & 0x01) /* Telecom Receive FIFO not empty */
+#define GET_CWC ((SIB->MCSR >> 12) & 0x01) /* Codec Write Complete */
+#define GET_CRC ((SIB->MCSR >> 13) & 0x01) /* Codec Read Complete */
+#define GET_ACE ((SIB->MCSR >> 14) & 0x01) /* Audio Codec Enabled */
+#define GET_TCE ((SIB->MCSR >> 15) & 0x01) /* Telecom Codec Enabled */
+
+/* MCDR2 */
+
+#define MCDR2_rW               (1 << 16)
+
+#define WRITE_MCDR2(reg, data) (SIB->MCDR2 =((reg<<17)|MCDR2_rW|(data&0xffff)))
+#define MCDR2_WRITE_COMPLETE   GET_CWC
+
+#define INITIATE_MCDR2_READ(reg) (SIB->MCDR2 = (reg << 17))
+#define MCDR2_READ_COMPLETE      GET_CRC
+#define MCDR2_READ               (SIB->MCDR2 & 0xffff)
Index: build_tree/linux/include/asm/arch-l7200/sys-clock.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/sys-clock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/sys-clock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,67 @@
+/****************************************************************************/
+/*
+ *  linux/include/asm-arm/arch-l7200/sys-clock.h
+ *
+ *   Registers and  helper functions for the L7200 Link-Up Systems
+ *   System clocks.
+ *
+ *   (C) Copyright 2000, S A McConnell  (samcconn@cotw.com)
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+/****************************************************************************/
+
+#define SYS_CLOCK_OFF   0x00050030  /* Offset from IO_START. */
+
+/* IO_START and IO_BASE are defined in hardware.h */
+
+#define SYS_CLOCK_START (IO_START + SYS_CLCOK_OFF)  /* Physical address */
+#define SYS_CLOCK_BASE  (IO_BASE  + SYS_CLOCK_OFF)  /* Virtual address  */
+
+/* Define the interface to the SYS_CLOCK */
+
+typedef struct
+{
+     unsigned int ENABLE;
+     unsigned int ESYNC;
+     unsigned int SELECT;
+} sys_clock_interface;
+
+#define SYS_CLOCK   ((volatile sys_clock_interface *)(SYS_CLOCK_BASE))
+
+//#define CLOCK_EN    (*(volatile unsigned long *)(PMU_BASE+CLOCK_EN_OFF))
+//#define CLOCK_ESYNC (*(volatile unsigned long *)(PMU_BASE+CLOCK_ESYNC_OFF))
+//#define CLOCK_SEL   (*(volatile unsigned long *)(PMU_BASE+CLOCK_SEL_OFF))
+
+/* SYS_CLOCK -> ENABLE */
+
+#define SYN_EN          1<<0
+#define B18M_EN         1<<1
+#define CLK3M6_EN       1<<2
+#define BUART_EN        1<<3
+#define CLK18MU_EN      1<<4
+#define FIR_EN          1<<5
+#define MIRN_EN         1<<6
+#define UARTM_EN        1<<7
+#define SIBADC_EN       1<<8
+#define ALTD_EN         1<<9
+#define CLCLK_EN        1<<10
+
+/* SYS_CLOCK -> SELECT */
+
+#define CLK18M_DIV      1<<0
+#define MIR_SEL         1<<1
+#define SSP_SEL         1<<4
+#define MM_DIV          1<<5
+#define MM_SEL          1<<6
+#define ADC_SEL_2       0<<7
+#define ADC_SEL_4       1<<7
+#define ADC_SEL_8       3<<7
+#define ADC_SEL_16      7<<7
+#define ADC_SEL_32      0x0f<<7
+#define ADC_SEL_64      0x1f<<7
+#define ADC_SEL_128     0x3f<<7
+#define ALTD_SEL        1<<13
Index: build_tree/linux/include/asm/arch-l7200/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-arm/arch-l7200/system.h
+ *
+ * Copyright (c) 2000 Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog
+ *  03-21-2000  SJH	Created
+ *  04-26-2000  SJH	Fixed functions
+ *  05-03-2000  SJH	Removed usage of obsolete 'iomd.h'
+ *  05-31-2000  SJH	Properly implemented 'arch_idle'
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+
+static inline void arch_idle(void)
+{
+	*(unsigned long *)(IO_BASE + 0x50004) = 1;	/* idle mode */
+}
+
+static inline void arch_reset(char mode)
+{
+	if (mode == 's') {
+		cpu_reset(0);
+	}
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/time.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/time.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/time.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,73 @@
+/*
+ * linux/include/asm-arm/arch-l7200/time.h
+ *
+ * Copyright (C) 2000 Rob Scott (rscott@mtrob.fdns.net)
+ *                    Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *   01-02-2000	RS	Created l7200 version, derived from rpc code
+ *   05-03-2000	SJH	Complete rewrite
+ */
+#ifndef _ASM_ARCH_TIME_H
+#define _ASM_ARCH_TIME_H
+
+#include <asm/arch/irqs.h>
+
+/*
+ * RTC base register address
+ */
+#define RTC_BASE	(IO_BASE_2 + 0x2000)
+
+/*
+ * RTC registers
+ */
+#define RTC_RTCDR	(*(volatile unsigned char *) (RTC_BASE + 0x000))
+#define RTC_RTCMR	(*(volatile unsigned char *) (RTC_BASE + 0x004))
+#define RTC_RTCS	(*(volatile unsigned char *) (RTC_BASE + 0x008))
+#define RTC_RTCC	(*(volatile unsigned char *) (RTC_BASE + 0x008))
+#define RTC_RTCDV	(*(volatile unsigned char *) (RTC_BASE + 0x00c))
+#define RTC_RTCCR	(*(volatile unsigned char *) (RTC_BASE + 0x010))
+
+/*
+ * RTCCR register values
+ */
+#define RTC_RATE_32	0x00      /* 32 Hz tick */
+#define RTC_RATE_64	0x10      /* 64 Hz tick */
+#define RTC_RATE_128	0x20      /* 128 Hz tick */
+#define RTC_RATE_256	0x30      /* 256 Hz tick */
+#define RTC_EN_ALARM	0x01      /* Enable alarm */
+#define RTC_EN_TIC	0x04      /* Enable counter */
+#define RTC_EN_STWDOG	0x08      /* Enable watchdog */
+
+/*
+ * Handler for RTC timer interrupt
+ */
+static irqreturn_t
+timer_interrupt(int irq, void *dev_id)
+{
+	struct pt_regs *regs = get_irq_regs();
+	do_timer(1);
+#ifndef CONFIG_SMP
+	update_process_times(user_mode(regs));
+#endif
+	do_profile(regs);
+	RTC_RTCC = 0;				/* Clear interrupt */
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Set up RTC timer interrupt, and return the current time in seconds.
+ */
+void __init time_init(void)
+{
+	RTC_RTCC = 0;				/* Clear interrupt */
+
+	timer_irq.handler = timer_interrupt;
+
+	setup_irq(IRQ_RTC_TICK, &timer_irq);
+
+	RTC_RTCCR = RTC_RATE_128 | RTC_EN_TIC;	/* Set rate and enable timer */
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-l7200/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * linux/include/asm-arm/arch-l7200/timex.h
+ *
+ * Copyright (C) 2000 Rob Scott (rscott@mtrob.fdns.net)
+ *                    Steve Hill (sjhill@cotw.com)
+ *
+ * 04-21-2000  RS Created file
+ * 05-03-2000 SJH Tick rate was wrong
+ *
+ */
+
+/*
+ * On the ARM720T, clock ticks are set to 128 Hz.
+ *
+ * NOTE: The actual RTC value is set in 'time.h' which
+ *       must be changed when choosing a different tick
+ *       rate. The value of HZ in 'param.h' must also
+ *       be changed to match below.
+ */
+#define CLOCK_TICK_RATE		128
Index: build_tree/linux/include/asm/arch-l7200/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * linux/include/asm-arm/arch-l7200/uncompress.h
+ *
+ * Copyright (C) 2000 Steve Hill (sjhill@cotw.com)
+ *
+ * Changelog:
+ *  05-01-2000	SJH	Created
+ *  05-13-2000	SJH	Filled in function bodies
+ *  07-26-2000	SJH	Removed hard coded baud rate
+ */
+
+#include <asm/hardware.h>
+
+#define IO_UART  IO_START + 0x00044000
+
+#define __raw_writeb(v,p)	(*(volatile unsigned char *)(p) = (v))
+#define __raw_readb(p)		(*(volatile unsigned char *)(p))
+
+static inline void putc(int c)
+{
+	while(__raw_readb(IO_UART + 0x18) & 0x20 ||
+	      __raw_readb(IO_UART + 0x18) & 0x08)
+		barrier();
+
+	__raw_writeb(c, IO_UART + 0x00);
+}
+
+static inline void flush(void)
+{
+}
+
+static __inline__ void arch_decomp_setup(void)
+{
+	__raw_writeb(0x00, IO_UART + 0x08);	/* Set HSB */
+	__raw_writeb(0x00, IO_UART + 0x20);	/* Disable IRQs */
+	__raw_writeb(0x01, IO_UART + 0x14);	/* Enable UART */
+}
+
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-l7200/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-l7200/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-l7200/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,4 @@
+/*
+ * linux/include/asm-arm/arch-l7200/vmalloc.h
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
Index: build_tree/linux/include/asm/arch-lh7a40x/clocks.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/clocks.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/clocks.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/* include/asm-arm/arch-lh7a40x/clocks.h
+ *
+ *  Copyright (C) 2004 Marc Singer
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_CLOCKS_H
+#define __ASM_ARCH_CLOCKS_H
+
+unsigned int fclkfreq_get (void);
+unsigned int hclkfreq_get (void);
+unsigned int pclkfreq_get (void);
+
+#endif  /* _ASM_ARCH_CLOCKS_H */
Index: build_tree/linux/include/asm/arch-lh7a40x/constants.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/constants.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/constants.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,91 @@
+/* include/asm-arm/arch-lh7a40x/constants.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *  Copyright (C) 2004 Logic Product Development
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_CONSTANTS_H
+#define __ASM_ARCH_CONSTANTS_H
+
+
+/* Addressing constants */
+
+	/* SoC CPU IO addressing */
+#define IO_PHYS			(0x80000000)
+#define IO_VIRT			(0xf8000000)
+#define IO_SIZE			(0x0000B000)
+
+#ifdef CONFIG_MACH_KEV7A400
+# define CPLD_PHYS		(0x20000000)
+# define CPLD_VIRT		(0xf2000000)
+# define CPLD_SIZE		PAGE_SIZE
+#endif
+
+#if defined (CONFIG_MACH_LPD7A400) || defined (CONFIG_MACH_LPD7A404)
+
+# define IOBARRIER_PHYS		0x10000000 /* Second bank, fastest timing */
+# define IOBARRIER_VIRT		0xf0000000
+# define IOBARRIER_SIZE		PAGE_SIZE
+
+# define CF_PHYS		0x60200000
+# define CF_VIRT		0xf6020000
+# define CF_SIZE		(8*1024)
+
+	/* The IO mappings for the LPD CPLD are, unfortunately, sparse.  */
+# define CPLDX_PHYS(x)		(0x70000000 | ((x) << 20))
+# define CPLDX_VIRT(x)		(0xf7000000 | ((x) << 16))
+# define CPLD00_PHYS		CPLDX_PHYS (0x00) /* Wired LAN */
+# define CPLD00_VIRT		CPLDX_VIRT (0x00)
+# define CPLD00_SIZE		PAGE_SIZE
+# define CPLD02_PHYS		CPLDX_PHYS (0x02)
+# define CPLD02_VIRT		CPLDX_VIRT (0x02)
+# define CPLD02_SIZE		PAGE_SIZE
+# define CPLD06_PHYS		CPLDX_PHYS (0x06)
+# define CPLD06_VIRT		CPLDX_VIRT (0x06)
+# define CPLD06_SIZE		PAGE_SIZE
+# define CPLD08_PHYS		CPLDX_PHYS (0x08)
+# define CPLD08_VIRT		CPLDX_VIRT (0x08)
+# define CPLD08_SIZE		PAGE_SIZE
+# define CPLD0A_PHYS		CPLDX_PHYS (0x0a)
+# define CPLD0A_VIRT		CPLDX_VIRT (0x0a)
+# define CPLD0A_SIZE		PAGE_SIZE
+# define CPLD0C_PHYS		CPLDX_PHYS (0x0c)
+# define CPLD0C_VIRT		CPLDX_VIRT (0x0c)
+# define CPLD0C_SIZE		PAGE_SIZE
+# define CPLD0E_PHYS		CPLDX_PHYS (0x0e)
+# define CPLD0E_VIRT		CPLDX_VIRT (0x0e)
+# define CPLD0E_SIZE		PAGE_SIZE
+# define CPLD10_PHYS		CPLDX_PHYS (0x10)
+# define CPLD10_VIRT		CPLDX_VIRT (0x10)
+# define CPLD10_SIZE		PAGE_SIZE
+# define CPLD12_PHYS		CPLDX_PHYS (0x12)
+# define CPLD12_VIRT		CPLDX_VIRT (0x12)
+# define CPLD12_SIZE		PAGE_SIZE
+# define CPLD14_PHYS		CPLDX_PHYS (0x14)
+# define CPLD14_VIRT		CPLDX_VIRT (0x14)
+# define CPLD14_SIZE		PAGE_SIZE
+# define CPLD16_PHYS		CPLDX_PHYS (0x16)
+# define CPLD16_VIRT		CPLDX_VIRT (0x16)
+# define CPLD16_SIZE		PAGE_SIZE
+# define CPLD18_PHYS		CPLDX_PHYS (0x18)
+# define CPLD18_VIRT		CPLDX_VIRT (0x18)
+# define CPLD18_SIZE		PAGE_SIZE
+# define CPLD1A_PHYS		CPLDX_PHYS (0x1a)
+# define CPLD1A_VIRT		CPLDX_VIRT (0x1a)
+# define CPLD1A_SIZE		PAGE_SIZE
+#endif
+
+	/* Timing constants */
+
+#define	XTAL_IN			14745600	/* 14.7456 MHz crystal */
+#define PLL_CLOCK		(XTAL_IN * 21)	/* 309 MHz PLL clock */
+#define MAX_HCLK_KHZ		100000		/* HCLK max limit ~100MHz */
+#define HCLK			(99993600)
+//#define HCLK			(119808000)
+
+#endif /* __ASM_ARCH_CONSTANTS_H */
Index: build_tree/linux/include/asm/arch-lh7a40x/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/* linux/include/asm-arm/arch-lh7a40x/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+	@ It is not known if this will be appropriate for every 40x
+	@ board.
+
+		.macro  addruart,rx
+		mrc     p15, 0, \rx, c1, c0
+		tst     \rx, #1                 @ MMU enabled?
+		mov     \rx, #0x00000700        @ offset from base
+		orreq   \rx, \rx, #0x80000000   @ physical base
+		orrne   \rx, \rx, #0xf8000000   @ virtual base
+		.endm
+
+		.macro  senduart,rd,rx
+		strb    \rd, [\rx]              @ DATA
+		.endm
+
+		.macro  busyuart,rd,rx          @ spin while busy
+1001:		ldr     \rd, [\rx, #0x10]       @ STATUS
+		tst     \rd, #1 << 3            @ BUSY (TX FIFO not empty)
+		bne     1001b                   @ yes, spin
+		.endm
+
+		.macro  waituart,rd,rx          @ wait for Tx FIFO room
+1001:		ldrb    \rd, [\rx, #0x10]       @ STATUS
+		tst     \rd, #1 << 5            @ TXFF (TX FIFO full)
+		bne     1001b                   @ yes, spin
+		.endm
Index: build_tree/linux/include/asm/arch-lh7a40x/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,86 @@
+/* include/asm-arm/arch-lh7a40x/dma.h
+ *
+ *  Copyright (C) 2005 Marc Singer
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+typedef enum {
+	DMA_M2M0	= 0,
+	DMA_M2M1	= 1,
+	DMA_M2P0	= 2,	/* Tx */
+	DMA_M2P1	= 3,	/* Rx */
+	DMA_M2P2	= 4,	/* Tx */
+	DMA_M2P3	= 5,	/* Rx */
+	DMA_M2P4	= 6,	/* Tx - AC97 */
+	DMA_M2P5	= 7,	/* Rx - AC97 */
+	DMA_M2P6	= 8,	/* Tx */
+	DMA_M2P7	= 9,	/* Rx */
+} dma_device_t;
+
+#define DMA_LENGTH_MAX		((64*1024) - 4) /* bytes */
+
+#define DMAC_GCA		__REG(DMAC_PHYS + 0x2b80)
+#define DMAC_GIR		__REG(DMAC_PHYS + 0x2bc0)
+
+#define DMAC_GIR_MMI1		(1<<11)
+#define DMAC_GIR_MMI0		(1<<10)
+#define DMAC_GIR_MPI8		(1<<9)
+#define DMAC_GIR_MPI9		(1<<8)
+#define DMAC_GIR_MPI6		(1<<7)
+#define DMAC_GIR_MPI7		(1<<6)
+#define DMAC_GIR_MPI4		(1<<5)
+#define DMAC_GIR_MPI5		(1<<4)
+#define DMAC_GIR_MPI2		(1<<3)
+#define DMAC_GIR_MPI3		(1<<2)
+#define DMAC_GIR_MPI0		(1<<1)
+#define DMAC_GIR_MPI1		(1<<0)
+
+#define DMAC_M2P0		0x0000
+#define DMAC_M2P1		0x0040
+#define DMAC_M2P2		0x0080
+#define DMAC_M2P3		0x00c0
+#define DMAC_M2P4		0x0240
+#define DMAC_M2P5		0x0200
+#define DMAC_M2P6		0x02c0
+#define DMAC_M2P7		0x0280
+#define DMAC_M2P8		0x0340
+#define DMAC_M2P9		0x0300
+#define DMAC_M2M0		0x0100
+#define DMAC_M2M1		0x0140
+
+#define DMAC_P_PCONTROL(c)	__REG(DMAC_PHYS + (c) + 0x00)
+#define DMAC_P_PINTERRUPT(c)	__REG(DMAC_PHYS + (c) + 0x04)
+#define DMAC_P_PPALLOC(c)	__REG(DMAC_PHYS + (c) + 0x08)
+#define DMAC_P_PSTATUS(c)	__REG(DMAC_PHYS + (c) + 0x0c)
+#define DMAC_P_REMAIN(c)	__REG(DMAC_PHYS + (c) + 0x14)
+#define DMAC_P_MAXCNT0(c)	__REG(DMAC_PHYS + (c) + 0x20)
+#define DMAC_P_BASE0(c)		__REG(DMAC_PHYS + (c) + 0x24)
+#define DMAC_P_CURRENT0(c)	__REG(DMAC_PHYS + (c) + 0x28)
+#define DMAC_P_MAXCNT1(c)	__REG(DMAC_PHYS + (c) + 0x30)
+#define DMAC_P_BASE1(c)		__REG(DMAC_PHYS + (c) + 0x34)
+#define DMAC_P_CURRENT1(c)	__REG(DMAC_PHYS + (c) + 0x38)
+
+#define DMAC_PCONTROL_ENABLE	(1<<4)
+
+#define DMAC_PORT_USB		0
+#define DMAC_PORT_SDMMC		1
+#define DMAC_PORT_AC97_1	2
+#define DMAC_PORT_AC97_2	3
+#define DMAC_PORT_AC97_3	4
+#define DMAC_PORT_UART1		6
+#define DMAC_PORT_UART2		7
+#define DMAC_PORT_UART3		8
+
+#define DMAC_PSTATUS_CURRSTATE_SHIFT	4
+#define DMAC_PSTATUS_CURRSTATE_MASK	0x3
+
+#define DMAC_PSTATUS_NEXTBUF	 (1<<6)
+#define DMAC_PSTATUS_STALLRINT	 (1<<0)
+
+#define DMAC_INT_CHE		 (1<<3)
+#define DMAC_INT_NFB		 (1<<1)
+#define DMAC_INT_STALL		 (1<<0)
Index: build_tree/linux/include/asm/arch-lh7a40x/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,149 @@
+/*
+ * include/asm-arm/arch-lh7a40x/entry-macro.S
+ *
+ * Low-level IRQ helper macros for LH7A40x platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/arch/irqs.h>
+
+/* In order to allow there to be support for both of the processor
+   classes at the same time, we make a hack here that isn't very
+   pretty.  At startup, the link pointed to with the
+   branch_irq_lh7a400 symbol is replaced with a NOP when the CPU is
+   detected as a lh7a404.
+
+   *** FIXME: we should clean this up so that there is only one
+	      implementation for each CPU's design.
+
+*/
+
+#if defined (CONFIG_ARCH_LH7A400) && defined (CONFIG_ARCH_LH7A404)
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+branch_irq_lh7a400: b 1000f
+
+@ Implementation of the LH7A404 get_irqnr_and_base.
+
+		mov	\irqnr, #0			@ VIC1 irq base
+		mov	\base, #io_p2v(0x80000000)	@ APB registers
+		add	\base, \base, #0x8000
+		ldr	\tmp, [\base, #0x0030]		@ VIC1_VECTADDR
+		tst	\tmp, #VA_VECTORED		@ Direct vectored
+		bne	1002f
+		tst	\tmp, #VA_VIC1DEFAULT		@ Default vectored VIC1
+		ldrne	\irqstat, [\base, #0]		@ VIC1_IRQSTATUS
+		bne	1001f
+		add	\base, \base, #(0xa000 - 0x8000)
+		ldr	\tmp, [\base, #0x0030]		@ VIC2_VECTADDR
+		tst	\tmp, #VA_VECTORED		@ Direct vectored
+		bne	1002f
+		ldr	\irqstat, [\base, #0]		@ VIC2_IRQSTATUS
+		mov	\irqnr, #32			@ VIC2 irq base
+
+1001:		movs	\irqstat, \irqstat, lsr #1	@ Shift into carry
+		bcs	1008f				@ Bit set; irq found
+		add	\irqnr, \irqnr, #1
+		bne	1001b				@ Until no bits
+		b	1009f				@ Nothing?  Hmm.
+1002:		and	\irqnr, \tmp, #0x3f		@ Mask for valid bits
+1008:		movs	\irqstat, #1			@ Force !Z
+		str	\tmp, [\base, #0x0030]		@ Clear vector
+		b	1009f
+
+@ Implementation of the LH7A400 get_irqnr_and_base.
+
+1000:		mov	\irqnr, #0
+		mov	\base, #io_p2v(0x80000000)	@ APB registers
+		ldr	\irqstat, [\base, #0x500]	@ PIC INTSR
+
+1001:		movs	\irqstat, \irqstat, lsr #1	@ Shift into carry
+		bcs	1008f				@ Bit set; irq found
+		add	\irqnr, \irqnr, #1
+		bne	1001b				@ Until no bits
+		b	1009f				@ Nothing?  Hmm.
+1008:		movs	\irqstat, #1			@ Force !Z
+
+1009:
+               .endm
+
+
+
+#elif defined (CONFIG_ARCH_LH7A400)
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	\irqnr, #0
+		mov	\base, #io_p2v(0x80000000)	@ APB registers
+		ldr	\irqstat, [\base, #0x500]	@ PIC INTSR
+
+1001:		movs	\irqstat, \irqstat, lsr #1	@ Shift into carry
+		bcs	1008f				@ Bit set; irq found
+		add	\irqnr, \irqnr, #1
+		bne	1001b				@ Until no bits
+		b	1009f				@ Nothing?  Hmm.
+1008:		movs	\irqstat, #1			@ Force !Z
+1009:
+               .endm
+
+#elif defined(CONFIG_ARCH_LH7A404)
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	\irqnr, #0			@ VIC1 irq base
+		mov	\base, #io_p2v(0x80000000)	@ APB registers
+		add	\base, \base, #0x8000
+		ldr	\tmp, [\base, #0x0030]		@ VIC1_VECTADDR
+		tst	\tmp, #VA_VECTORED		@ Direct vectored
+		bne	1002f
+		tst	\tmp, #VA_VIC1DEFAULT		@ Default vectored VIC1
+		ldrne	\irqstat, [\base, #0]		@ VIC1_IRQSTATUS
+		bne	1001f
+		add	\base, \base, #(0xa000 - 0x8000)
+		ldr	\tmp, [\base, #0x0030]		@ VIC2_VECTADDR
+		tst	\tmp, #VA_VECTORED		@ Direct vectored
+		bne	1002f
+		ldr	\irqstat, [\base, #0]		@ VIC2_IRQSTATUS
+		mov	\irqnr, #32			@ VIC2 irq base
+
+1001:		movs	\irqstat, \irqstat, lsr #1	@ Shift into carry
+		bcs	1008f				@ Bit set; irq found
+		add	\irqnr, \irqnr, #1
+		bne	1001b				@ Until no bits
+		b	1009f				@ Nothing?  Hmm.
+1002:		and	\irqnr, \tmp, #0x3f		@ Mask for valid bits
+1008:		movs	\irqstat, #1			@ Force !Z
+		str	\tmp, [\base, #0x0030]		@ Clear vector
+1009:
+               .endm
+#endif
+
+
Index: build_tree/linux/include/asm/arch-lh7a40x/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,62 @@
+/* include/asm-arm/arch-lh7a40x/hardware.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *
+ *  [ Substantially cribbed from include/asm-arm/arch-pxa/hardware.h ]
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>		/* Added for the sake of amba-clcd driver */
+
+#define io_p2v(x) (0xf0000000 | (((x) & 0xfff00000) >> 4) | ((x) & 0x0000ffff))
+#define io_v2p(x) (             (((x) & 0x0fff0000) << 4) | ((x) & 0x0000ffff))
+
+#ifdef __ASSEMBLY__
+
+# define __REG(x)	io_p2v(x)
+# define __PREG(x)	io_v2p(x)
+
+#else
+
+# if 0
+#  define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+# else
+/*
+ * This __REG() version gives the same results as the one above,  except
+ * that we are fooling gcc somehow so it generates far better and smaller
+ * assembly code for access to contigous registers.  It's a shame that gcc
+ * doesn't guess this by itself.
+ */
+#include <asm/types.h>
+typedef struct { volatile u32 offset[4096]; } __regbase;
+# define __REGP(x)	((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
+# define __REG(x)	__REGP(io_p2v(x))
+typedef struct { volatile u16 offset[4096]; } __regbase16;
+# define __REGP16(x)	((__regbase16 *)((x)&~4095))->offset[((x)&4095)>>1]
+# define __REG16(x)	__REGP16(io_p2v(x))
+typedef struct { volatile u8 offset[4096]; } __regbase8;
+# define __REGP8(x)	((__regbase8 *)((x)&~4095))->offset[(x)&4095]
+# define __REG8(x)	__REGP8(io_p2v(x))
+#endif
+
+/* Let's kick gcc's ass again... */
+# define __REG2(x,y)	\
+	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+				  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+
+# define __PREG(x)	(io_v2p((u32)&(x)))
+
+#endif
+
+#define MASK_AND_SET(v,m,s)	(v) = ((v)&~(m))|(s)
+
+#include "registers.h"
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-lh7a40x/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/* include/asm-arm/arch-lh7a40x/io.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/* No ISA or PCI bus on this machine. */
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+#endif /* __ASM_ARCH_IO_H */
Index: build_tree/linux/include/asm/arch-lh7a40x/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,200 @@
+/* include/asm-arm/arch-lh7a40x/irqs.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *  Copyright (C) 2004 Logic Product Development
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+/* It is to be seen whether or not we can build a kernel for more than
+ * one board.  For the time being, these macros assume that we cannot.
+ * Thus, it is OK to ifdef machine/board specific IRQ assignments.
+ */
+
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+
+#define FIQ_START	80
+
+#if defined (CONFIG_ARCH_LH7A400)
+
+  /* FIQs */
+
+# define IRQ_GPIO0FIQ	0	/* GPIO External FIQ Interrupt on F0 */
+# define IRQ_BLINT	1	/* Battery Low */
+# define IRQ_WEINT	2	/* Watchdog Timer, WDT overflow	*/
+# define IRQ_MCINT	3	/* Media Change, MEDCHG pin rising */
+
+  /* IRQs */
+
+# define IRQ_CSINT	4	/* Audio Codec (ACI) */
+# define IRQ_GPIO1INTR	5	/* GPIO External IRQ Interrupt on F1 */
+# define IRQ_GPIO2INTR	6	/* GPIO External IRQ Interrupt on F2 */
+# define IRQ_GPIO3INTR	7	/* GPIO External IRQ Interrupt on F3 */
+# define IRQ_T1UI	8	/* Timer 1 underflow */
+# define IRQ_T2UI	9	/* Timer 2 underflow */
+# define IRQ_RTCMI	10
+# define IRQ_TINTR	11	/* Clock State Controller 64 Hz tick (CSC) */
+# define IRQ_UART1INTR	12
+# define IRQ_UART2INTR	13
+# define IRQ_LCDINTR	14
+# define IRQ_SSIEOT	15	/* Synchronous Serial Interface (SSI) */
+# define IRQ_UART3INTR	16
+# define IRQ_SCIINTR	17	/* Smart Card Interface (SCI) */
+# define IRQ_AACINTR	18	/* Advanced Audio Codec (AAC) */
+# define IRQ_MMCINTR	19	/* Multimedia Card (MMC) */
+# define IRQ_USBINTR	20
+# define IRQ_DMAINTR	21
+# define IRQ_T3UI	22	/* Timer 3 underflow */
+# define IRQ_GPIO4INTR	23	/* GPIO External IRQ Interrupt on F4 */
+# define IRQ_GPIO5INTR	24	/* GPIO External IRQ Interrupt on F5 */
+# define IRQ_GPIO6INTR	25	/* GPIO External IRQ Interrupt on F6 */
+# define IRQ_GPIO7INTR	26	/* GPIO External IRQ Interrupt on F7 */
+# define IRQ_BMIINTR	27	/* Battery Monitor Interface (BMI) */
+
+# define NR_IRQ_CPU	28	/* IRQs directly recognized by CPU */
+
+	/* Given IRQ, return GPIO interrupt number 0-7 */
+# define IRQ_TO_GPIO(i)  ((i) \
+	- (((i) > IRQ_GPIO3INTR) ? IRQ_GPIO4INTR - IRQ_GPIO3INTR - 1 : 0)\
+	- (((i) > IRQ_GPIO0INTR) ? IRQ_GPIO1INTR - IRQ_GPIO0INTR - 1 : 0))
+
+#endif
+
+#if defined (CONFIG_ARCH_LH7A404)
+
+# define IRQ_BROWN	0	/* Brownout */
+# define IRQ_WDTINTR	1	/* Watchdog Timer */
+# define IRQ_COMMRX	2	/* ARM Comm Rx for Debug */
+# define IRQ_COMMTX	3	/* ARM Comm Tx for Debug */
+# define IRQ_T1UI	4	/* Timer 1 underflow */
+# define IRQ_T2UI	5	/* Timer 2 underflow */
+# define IRQ_CSINT	6	/* Codec Interrupt (shared by AAC on 404) */
+# define IRQ_DMAM2P0	7	/* -- DMA Memory to Peripheral */
+# define IRQ_DMAM2P1	8
+# define IRQ_DMAM2P2	9
+# define IRQ_DMAM2P3	10
+# define IRQ_DMAM2P4	11
+# define IRQ_DMAM2P5	12
+# define IRQ_DMAM2P6	13
+# define IRQ_DMAM2P7	14
+# define IRQ_DMAM2P8	15
+# define IRQ_DMAM2P9	16
+# define IRQ_DMAM2M0	17	/* -- DMA Memory to Memory */
+# define IRQ_DMAM2M1	18
+# define IRQ_GPIO0INTR	19	/* -- GPIOF Interrupt */
+# define IRQ_GPIO1INTR	20
+# define IRQ_GPIO2INTR	21
+# define IRQ_GPIO3INTR	22
+# define IRQ_SOFT_V1_23	23	/* -- Unassigned */
+# define IRQ_SOFT_V1_24	24
+# define IRQ_SOFT_V1_25	25
+# define IRQ_SOFT_V1_26	26
+# define IRQ_SOFT_V1_27	27
+# define IRQ_SOFT_V1_28	28
+# define IRQ_SOFT_V1_29	29
+# define IRQ_SOFT_V1_30	30
+# define IRQ_SOFT_V1_31	31
+
+# define IRQ_BLINT	32	/* Battery Low */
+# define IRQ_BMIINTR	33	/* Battery Monitor */
+# define IRQ_MCINTR	34	/* Media Change */
+# define IRQ_TINTR	35	/* 64Hz Tick */
+# define IRQ_WEINT	36	/* Watchdog Expired */
+# define IRQ_RTCMI	37	/* Real-time Clock Match */
+# define IRQ_UART1INTR	38	/* UART1 Interrupt (including error) */
+# define IRQ_UART1ERR	39	/* UART1 Error */
+# define IRQ_UART2INTR	40	/* UART2 Interrupt (including error) */
+# define IRQ_UART2ERR	41	/* UART2 Error */
+# define IRQ_UART3INTR	42	/* UART3 Interrupt (including error) */
+# define IRQ_UART3ERR	43	/* UART3 Error */
+# define IRQ_SCIINTR	44	/* Smart Card */
+# define IRQ_TSCINTR	45	/* Touchscreen */
+# define IRQ_KMIINTR	46	/* Keyboard/Mouse (PS/2) */
+# define IRQ_GPIO4INTR	47	/* -- GPIOF Interrupt */
+# define IRQ_GPIO5INTR	48
+# define IRQ_GPIO6INTR	49
+# define IRQ_GPIO7INTR	50
+# define IRQ_T3UI	51	/* Timer 3 underflow */
+# define IRQ_LCDINTR	52	/* LCD Controller */
+# define IRQ_SSPINTR	53	/* Synchronous Serial Port */
+# define IRQ_SDINTR	54	/* Secure Digital Port (MMC) */
+# define IRQ_USBINTR	55	/* USB Device Port */
+# define IRQ_USHINTR	56	/* USB Host Port */
+# define IRQ_SOFT_V2_25	57	/* -- Unassigned */
+# define IRQ_SOFT_V2_26	58
+# define IRQ_SOFT_V2_27	59
+# define IRQ_SOFT_V2_28	60
+# define IRQ_SOFT_V2_29	61
+# define IRQ_SOFT_V2_30	62
+# define IRQ_SOFT_V2_31	63
+
+# define NR_IRQ_CPU	64	/* IRQs directly recognized by CPU */
+
+	/* Given IRQ, return GPIO interrupt number 0-7 */
+# define IRQ_TO_GPIO(i)  ((i) \
+	- (((i) > IRQ_GPIO3INTR) ? IRQ_GPIO4INTR - IRQ_GPIO3INTR - 1 : 0)\
+	- IRQ_GPIO0INTR)
+
+			/* Vector Address constants */
+# define VA_VECTORED	0x100	/* Set for vectored interrupt */
+# define VA_VIC1DEFAULT	0x200	/* Set as default VECTADDR for VIC1 */
+# define VA_VIC2DEFAULT	0x400	/* Set as default VECTADDR for VIC2 */
+
+#endif
+
+  /* IRQ aliases */
+
+#if !defined (IRQ_GPIO0INTR)
+# define IRQ_GPIO0INTR	IRQ_GPIO0FIQ
+#endif
+#define IRQ_TICK	IRQ_TINTR
+#define IRQ_PCC1_RDY	IRQ_GPIO6INTR	/* PCCard 1 ready */
+#define IRQ_PCC2_RDY	IRQ_GPIO7INTR	/* PCCard 2 ready */
+#define IRQ_USB		IRQ_USBINTR	/* USB device */
+
+#ifdef CONFIG_MACH_KEV7A400
+# define IRQ_TS		IRQ_GPIOFIQ	/* Touchscreen */
+# define IRQ_CPLD	IRQ_GPIO1INTR	/* CPLD cascade */
+# define IRQ_PCC1_CD	IRQ_GPIO_F2	/* PCCard 1 card detect */
+# define IRQ_PCC2_CD	IRQ_GPIO_F3	/* PCCard 2 card detect */
+#endif
+
+#if defined (CONFIG_MACH_LPD7A400) || defined (CONFIG_MACH_LPD7A404)
+# define IRQ_CPLD_V28	IRQ_GPIO7INTR	/* CPLD cascade through GPIO_PF7 */
+# define IRQ_CPLD_V34	IRQ_GPIO3INTR	/* CPLD cascade through GPIO_PF3 */
+#endif
+
+  /* System specific IRQs */
+
+#define IRQ_BOARD_START NR_IRQ_CPU
+
+#ifdef CONFIG_MACH_KEV7A400
+# define IRQ_KEV7A400_CPLD	IRQ_BOARD_START
+# define NR_IRQ_BOARD		5
+# define IRQ_KEV7A400_MMC_CD	IRQ_KEV7A400_CPLD + 0	/* MMC Card Detect */
+# define IRQ_KEV7A400_RI2	IRQ_KEV7A400_CPLD + 1	/* Ring Indicator 2 */
+# define IRQ_KEV7A400_IDE_CF	IRQ_KEV7A400_CPLD + 2	/* Compact Flash (?) */
+# define IRQ_KEV7A400_ETH_INT	IRQ_KEV7A400_CPLD + 3	/* Ethernet chip */
+# define IRQ_KEV7A400_INT	IRQ_KEV7A400_CPLD + 4
+#endif
+
+#if defined (CONFIG_MACH_LPD7A400) || defined (CONFIG_MACH_LPD7A404)
+# define IRQ_LPD7A40X_CPLD	IRQ_BOARD_START
+# define NR_IRQ_BOARD		2
+# define IRQ_LPD7A40X_ETH_INT	IRQ_LPD7A40X_CPLD + 0	/* Ethernet chip */
+# define IRQ_LPD7A400_TS	IRQ_LPD7A40X_CPLD + 1	/* Touch screen */
+#endif
+
+#if defined (CONFIG_MACH_LPD7A400)
+# define IRQ_TOUCH		IRQ_LPD7A400_TS
+#endif
+
+#define NR_IRQS		(NR_IRQ_CPU + NR_IRQ_BOARD)
+
+#endif
Index: build_tree/linux/include/asm/arch-lh7a40x/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,76 @@
+/* include/asm-arm/arch-lh7a40x/memory.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ *
+ *  Refer to <file:Documentation/arm/Sharp-LH/SDRAM> for more information.
+ *
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0xc0000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+#ifdef CONFIG_DISCONTIGMEM
+
+/*
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+
+# ifdef CONFIG_LH7A40X_ONE_BANK_PER_NODE
+#  define KVADDR_TO_NID(addr) \
+  (  ((((unsigned long) (addr) - PAGE_OFFSET) >> 24) &  1)\
+   | ((((unsigned long) (addr) - PAGE_OFFSET) >> 25) & ~1))
+# else  /* 2 banks per node */
+#  define KVADDR_TO_NID(addr) \
+      (((unsigned long) (addr) - PAGE_OFFSET) >> 26)
+# endif
+
+/*
+ * Given a page frame number, convert it to a node id.
+ */
+
+# ifdef CONFIG_LH7A40X_ONE_BANK_PER_NODE
+#  define PFN_TO_NID(pfn) \
+  (((((pfn) - PHYS_PFN_OFFSET) >> (24 - PAGE_SHIFT)) &  1)\
+ | ((((pfn) - PHYS_PFN_OFFSET) >> (25 - PAGE_SHIFT)) & ~1))
+# else  /* 2 banks per node */
+#  define PFN_TO_NID(pfn) \
+    (((pfn) - PHYS_PFN_OFFSET) >> (26 - PAGE_SHIFT))
+#endif
+
+/*
+ * Given a kaddr, LOCAL_MEM_MAP finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+
+# ifdef CONFIG_LH7A40X_ONE_BANK_PER_NODE
+#  define LOCAL_MAP_NR(addr) \
+       (((unsigned long)(addr) & 0x003fffff) >> PAGE_SHIFT)
+# else  /* 2 banks per node */
+#  define LOCAL_MAP_NR(addr) \
+       (((unsigned long)(addr) & 0x01ffffff) >> PAGE_SHIFT)
+# endif
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-lh7a40x/registers.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/registers.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/registers.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,224 @@
+/* include/asm-arm/arch-lh7a40x/registers.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *  Copyright (C) 2004 Logic Product Development
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#include <asm/arch/constants.h>
+
+#ifndef __ASM_ARCH_REGISTERS_H
+#define __ASM_ARCH_REGISTERS_H
+
+
+	/* Physical register base addresses */
+
+#define AC97C_PHYS	(0x80000000)	/* AC97 Controller */
+#define MMC_PHYS	(0x80000100)	/* Multimedia Card Controller */
+#define USB_PHYS	(0x80000200)	/* USB Client */
+#define SCI_PHYS	(0x80000300)	/* Secure Card Interface */
+#define CSC_PHYS	(0x80000400)	/* Clock/State Controller  */
+#define INTC_PHYS	(0x80000500)	/* Interrupt Controller */
+#define UART1_PHYS	(0x80000600)	/* UART1 Controller */
+#define SIR_PHYS	(0x80000600)	/* IR Controller, same are UART1 */
+#define UART2_PHYS	(0x80000700)	/* UART2 Controller */
+#define UART3_PHYS	(0x80000800)	/* UART3 Controller */
+#define DCDC_PHYS	(0x80000900)	/* DC to DC Controller */
+#define ACI_PHYS	(0x80000a00)	/* Audio Codec Interface */
+#define SSP_PHYS	(0x80000b00)	/* Synchronous ... */
+#define TIMER_PHYS	(0x80000c00)	/* Timer Controller */
+#define RTC_PHYS	(0x80000d00)	/* Real-time Clock */
+#define GPIO_PHYS	(0x80000e00)	/* General Purpose IO */
+#define BMI_PHYS	(0x80000f00)	/* Battery Monitor Interface */
+#define HRTFTC_PHYS	(0x80001000)	/* High-res TFT Controller (LH7A400) */
+#define ALI_PHYS	(0x80001000)	/* Advanced LCD Interface (LH7A404) */
+#define WDT_PHYS	(0x80001400)	/* Watchdog Timer */
+#define SMC_PHYS	(0x80002000)	/* Static Memory Controller */
+#define SDRC_PHYS	(0x80002400)	/* SDRAM Controller */
+#define DMAC_PHYS	(0x80002800)	/* DMA Controller */
+#define CLCDC_PHYS	(0x80003000)	/* Color LCD Controller */
+
+	/* Physical registers of the LH7A404 */
+
+#define ADC_PHYS	(0x80001300)	/* A/D & Touchscreen Controller */
+#define VIC1_PHYS	(0x80008000)	/* Vectored Interrupt Controller 1 */
+#define USBH_PHYS	(0x80009000)	/* USB OHCI host controller */
+#define VIC2_PHYS	(0x8000a000)	/* Vectored Interrupt Controller 2 */
+
+/*#define KBD_PHYS	(0x80000e00) */
+/*#define LCDICP_PHYS	(0x80001000) */
+
+
+	/* Clock/State Controller register */
+
+#define CSC_PWRSR	__REG(CSC_PHYS + 0x00) /* Reset register & ID */
+#define CSC_PWRCNT	__REG(CSC_PHYS + 0x04) /* Power control */
+#define CSC_CLKSET	__REG(CSC_PHYS + 0x20) /* Clock speed control */
+#define CSC_USBDRESET	__REG(CSC_PHYS + 0x4c) /* USB Device resets */
+
+#define CSC_PWRCNT_USBH_EN	(1<<28)	/* USB Host power enable */
+#define CSC_PWRCNT_DMAC_M2M1_EN	(1<<27)
+#define CSC_PWRCNT_DMAC_M2M0_EN	(1<<26)
+#define CSC_PWRCNT_DMAC_M2P8_EN	(1<<25)
+#define CSC_PWRCNT_DMAC_M2P9_EN	(1<<24)
+#define CSC_PWRCNT_DMAC_M2P6_EN	(1<<23)
+#define CSC_PWRCNT_DMAC_M2P7_EN	(1<<22)
+#define CSC_PWRCNT_DMAC_M2P4_EN	(1<<21)
+#define CSC_PWRCNT_DMAC_M2P5_EN	(1<<20)
+#define CSC_PWRCNT_DMAC_M2P2_EN	(1<<19)
+#define CSC_PWRCNT_DMAC_M2P3_EN	(1<<18)
+#define CSC_PWRCNT_DMAC_M2P0_EN	(1<<17)
+#define CSC_PWRCNT_DMAC_M2P1_EN	(1<<16)
+
+#define CSC_PWRSR_CHIPMAN_SHIFT	(24)
+#define CSC_PWRSR_CHIPMAN_MASK	(0xff)
+#define CSC_PWRSR_CHIPID_SHIFT	(16)
+#define CSC_PWRSR_CHIPID_MASK	(0xff)
+
+#define CSC_USBDRESET_APBRESETREG	(1<<1)
+#define CSC_USBDRESET_IORESETREG	(1<<0)
+
+	/* Interrupt Controller registers */
+
+#define INTC_INTSR	__REG(INTC_PHYS + 0x00)	/* Status */
+#define INTC_INTRSR	__REG(INTC_PHYS + 0x04)	/* Raw Status */
+#define INTC_INTENS	__REG(INTC_PHYS + 0x08)	/* Enable Set */
+#define INTC_INTENC	__REG(INTC_PHYS + 0x0c)	/* Enable Clear */
+
+
+	/* Vectored Interrupted Controller registers */
+
+#define VIC1_IRQSTATUS	__REG(VIC1_PHYS + 0x00)
+#define VIC1_FIQSTATUS	__REG(VIC1_PHYS + 0x04)
+#define VIC1_RAWINTR	__REG(VIC1_PHYS + 0x08)
+#define VIC1_INTSEL	__REG(VIC1_PHYS + 0x0c)
+#define VIC1_INTEN	__REG(VIC1_PHYS + 0x10)
+#define VIC1_INTENCLR	__REG(VIC1_PHYS + 0x14)
+#define VIC1_SOFTINT	__REG(VIC1_PHYS + 0x18)
+#define VIC1_SOFTINTCLR	__REG(VIC1_PHYS + 0x1c)
+#define VIC1_PROTECT	__REG(VIC1_PHYS + 0x20)
+#define VIC1_VECTADDR	__REG(VIC1_PHYS + 0x30)
+#define VIC1_NVADDR	__REG(VIC1_PHYS + 0x34)
+#define VIC1_VAD0	__REG(VIC1_PHYS + 0x100)
+#define VIC1_VECTCNTL0	__REG(VIC1_PHYS + 0x200)
+#define VIC2_IRQSTATUS	__REG(VIC2_PHYS + 0x00)
+#define VIC2_FIQSTATUS	__REG(VIC2_PHYS + 0x04)
+#define VIC2_RAWINTR	__REG(VIC2_PHYS + 0x08)
+#define VIC2_INTSEL	__REG(VIC2_PHYS + 0x0c)
+#define VIC2_INTEN	__REG(VIC2_PHYS + 0x10)
+#define VIC2_INTENCLR	__REG(VIC2_PHYS + 0x14)
+#define VIC2_SOFTINT	__REG(VIC2_PHYS + 0x18)
+#define VIC2_SOFTINTCLR	__REG(VIC2_PHYS + 0x1c)
+#define VIC2_PROTECT	__REG(VIC2_PHYS + 0x20)
+#define VIC2_VECTADDR	__REG(VIC2_PHYS + 0x30)
+#define VIC2_NVADDR	__REG(VIC2_PHYS + 0x34)
+#define VIC2_VAD0	__REG(VIC2_PHYS + 0x100)
+#define VIC2_VECTCNTL0	__REG(VIC2_PHYS + 0x200)
+
+#define VIC_CNTL_ENABLE	(0x20)
+
+	/* USB Host registers (Open HCI compatible) */
+
+#define USBH_CMDSTATUS	__REG(USBH_PHYS + 0x08)
+
+
+	/* GPIO registers */
+
+#define GPIO_INTTYPE1	__REG(GPIO_PHYS + 0x4c)	/* Interrupt Type 1 (Edge) */
+#define GPIO_INTTYPE2	__REG(GPIO_PHYS + 0x50)	/* Interrupt Type 2 */
+#define GPIO_GPIOFEOI	__REG(GPIO_PHYS + 0x54)	/* GPIO End-of-Interrupt */
+#define GPIO_GPIOINTEN	__REG(GPIO_PHYS + 0x58)	/* GPIO Interrupt Enable */
+#define GPIO_INTSTATUS	__REG(GPIO_PHYS + 0x5c)	/* GPIO Interrupt Status */
+#define GPIO_PINMUX	__REG(GPIO_PHYS + 0x2c)
+#define GPIO_PADD	__REG(GPIO_PHYS + 0x10)
+#define GPIO_PAD	__REG(GPIO_PHYS + 0x00)
+#define GPIO_PCD	__REG(GPIO_PHYS + 0x08)
+#define GPIO_PCDD	__REG(GPIO_PHYS + 0x18)
+#define GPIO_PEDD	__REG(GPIO_PHYS + 0x24)
+#define GPIO_PED	__REG(GPIO_PHYS + 0x20)
+
+
+	/* Static Memory Controller registers */
+
+#define SMC_BCR0	__REG(SMC_PHYS + 0x00)	/* Bank 0 Configuration */
+#define SMC_BCR1	__REG(SMC_PHYS + 0x04)	/* Bank 1 Configuration */
+#define SMC_BCR2	__REG(SMC_PHYS + 0x08)	/* Bank 2 Configuration */
+#define SMC_BCR3	__REG(SMC_PHYS + 0x0C)	/* Bank 3 Configuration */
+#define SMC_BCR6	__REG(SMC_PHYS + 0x18)	/* Bank 6 Configuration */
+#define SMC_BCR7	__REG(SMC_PHYS + 0x1c)	/* Bank 7 Configuration */
+
+
+#ifdef CONFIG_MACH_KEV7A400
+# define CPLD_RD_OPT_DIP_SW	__REG16(CPLD_PHYS + 0x00) /* Read Option SW */
+# define CPLD_WR_IO_BRD_CTL	__REG16(CPLD_PHYS + 0x00) /* Write Control */
+# define CPLD_RD_PB_KEYS	__REG16(CPLD_PHYS + 0x02) /* Read Btn Keys */
+# define CPLD_LATCHED_INTS	__REG16(CPLD_PHYS + 0x04) /* Read INTR stat. */
+# define CPLD_CL_INT		__REG16(CPLD_PHYS + 0x04) /* Clear INTR stat */
+# define CPLD_BOOT_MMC_STATUS	__REG16(CPLD_PHYS + 0x06) /* R/O */
+# define CPLD_RD_KPD_ROW_SENSE	__REG16(CPLD_PHYS + 0x08)
+# define CPLD_WR_PB_INT_MASK	__REG16(CPLD_PHYS + 0x08)
+# define CPLD_RD_BRD_DISP_SW	__REG16(CPLD_PHYS + 0x0a)
+# define CPLD_WR_EXT_INT_MASK	__REG16(CPLD_PHYS + 0x0a)
+# define CPLD_LCD_PWR_CNTL	__REG16(CPLD_PHYS + 0x0c)
+# define CPLD_SEVEN_SEG		__REG16(CPLD_PHYS + 0x0e) /* 7 seg. LED mask */
+
+#endif
+
+#if defined (CONFIG_MACH_LPD7A400) || defined (CONFIG_MACH_LPD7A404)
+
+# define CPLD_CONTROL		__REG16(CPLD02_PHYS)
+# define CPLD_SPI_DATA		__REG16(CPLD06_PHYS)
+# define CPLD_SPI_CONTROL	__REG16(CPLD08_PHYS)
+# define CPLD_SPI_EEPROM	__REG16(CPLD0A_PHYS)
+# define CPLD_INTERRUPTS	__REG16(CPLD0C_PHYS) /* IRQ mask/status */
+# define CPLD_BOOT_MODE		__REG16(CPLD0E_PHYS)
+# define CPLD_FLASH		__REG16(CPLD10_PHYS)
+# define CPLD_POWER_MGMT	__REG16(CPLD12_PHYS)
+# define CPLD_REVISION		__REG16(CPLD14_PHYS)
+# define CPLD_GPIO_EXT		__REG16(CPLD16_PHYS)
+# define CPLD_GPIO_DATA		__REG16(CPLD18_PHYS)
+# define CPLD_GPIO_DIR		__REG16(CPLD1A_PHYS)
+
+#endif
+
+	/* Timer registers */
+
+#define TIMER_LOAD1	__REG(TIMER_PHYS + 0x00) /* Timer 1 initial value */
+#define TIMER_VALUE1	__REG(TIMER_PHYS + 0x04) /* Timer 1 current value */
+#define TIMER_CONTROL1	__REG(TIMER_PHYS + 0x08) /* Timer 1 control word */
+#define TIMER_EOI1	__REG(TIMER_PHYS + 0x0c) /* Timer 1 interrupt clear */
+
+#define TIMER_LOAD2	__REG(TIMER_PHYS + 0x20) /* Timer 2 initial value */
+#define TIMER_VALUE2	__REG(TIMER_PHYS + 0x24) /* Timer 2 current value */
+#define TIMER_CONTROL2	__REG(TIMER_PHYS + 0x28) /* Timer 2 control word */
+#define TIMER_EOI2	__REG(TIMER_PHYS + 0x2c) /* Timer 2 interrupt clear */
+
+#define TIMER_BUZZCON	__REG(TIMER_PHYS + 0x40) /* Buzzer configuration */
+
+#define TIMER_LOAD3	__REG(TIMER_PHYS + 0x80) /* Timer 3 initial value */
+#define TIMER_VALUE3	__REG(TIMER_PHYS + 0x84) /* Timer 3 current value */
+#define TIMER_CONTROL3	__REG(TIMER_PHYS + 0x88) /* Timer 3 control word */
+#define TIMER_EOI3	__REG(TIMER_PHYS + 0x8c) /* Timer 3 interrupt clear */
+
+#define TIMER_C_ENABLE		(1<<7)
+#define TIMER_C_PERIODIC	(1<<6)
+#define TIMER_C_FREERUNNING	(0)
+#define TIMER_C_2KHZ		(0x00)		/* 1.986 kHz */
+#define TIMER_C_508KHZ		(0x08)
+
+	/* GPIO registers */
+
+#define GPIO_PFDD		__REG(GPIO_PHYS + 0x34)	/* PF direction */
+#define GPIO_INTTYPE1		__REG(GPIO_PHYS + 0x4c)	/* IRQ edge or lvl  */
+#define GPIO_INTTYPE2		__REG(GPIO_PHYS + 0x50)	/* IRQ activ hi/lo */
+#define GPIO_GPIOFEOI		__REG(GPIO_PHYS + 0x54)	/* GPIOF end of IRQ */
+#define GPIO_GPIOFINTEN		__REG(GPIO_PHYS + 0x58)	/* GPIOF IRQ enable */
+#define GPIO_INTSTATUS		__REG(GPIO_PHYS + 0x5c)	/* GPIOF IRQ latch */
+#define GPIO_RAWINTSTATUS	__REG(GPIO_PHYS + 0x60)	/* GPIOF IRQ raw */
+
+
+#endif  /* _ASM_ARCH_REGISTERS_H */
Index: build_tree/linux/include/asm/arch-lh7a40x/ssp.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/ssp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/ssp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,71 @@
+/* ssp.h
+     $Id$
+
+   written by Marc Singer
+   6 Dec 2004
+
+   Copyright (C) 2004 Marc Singer
+
+   -----------
+   DESCRIPTION
+   -----------
+
+   This SSP header is available throughout the kernel, for this
+   machine/architecture, because drivers that use it may be dispersed.
+
+   This file was cloned from the 7952x implementation.  It would be
+   better to share them, but we're taking an easier approach for the
+   time being.
+
+*/
+
+#if !defined (__SSP_H__)
+#    define   __SSP_H__
+
+/* ----- Includes */
+
+/* ----- Types */
+
+struct ssp_driver {
+	int  (*init)		(void);
+	void (*exit)		(void);
+	void (*acquire)		(void);
+	void (*release)		(void);
+	int  (*configure)	(int device, int mode, int speed,
+				 int frame_size_write, int frame_size_read);
+	void (*chip_select)	(int enable);
+	void (*set_callbacks)   (void* handle,
+				 irqreturn_t (*callback_tx)(void*),
+				 irqreturn_t (*callback_rx)(void*));
+	void (*enable)		(void);
+	void (*disable)		(void);
+//	int  (*save_state)	(void*);
+//	void (*restore_state)	(void*);
+	int  (*read)		(void);
+	int  (*write)		(u16 data);
+	int  (*write_read)	(u16 data);
+	void (*flush)		(void);
+	void (*write_async)	(void* pv, size_t cb);
+	size_t (*write_pos)	(void);
+};
+
+	/* These modes are only available on the LH79524 */
+#define SSP_MODE_SPI		(1)
+#define SSP_MODE_SSI		(2)
+#define SSP_MODE_MICROWIRE	(3)
+#define SSP_MODE_I2S		(4)
+
+	/* CPLD SPI devices */
+#define DEVICE_EEPROM	0	/* Configuration eeprom */
+#define DEVICE_MAC	1	/* MAC eeprom (LPD79524) */
+#define DEVICE_CODEC	2	/* Audio codec */
+#define DEVICE_TOUCH	3	/* Touch screen (LPD79520) */
+
+/* ----- Globals */
+
+/* ----- Prototypes */
+
+//extern struct ssp_driver lh79520_i2s_driver;
+extern struct ssp_driver lh7a400_cpld_ssp_driver;
+
+#endif  /* __SSP_H__ */
Index: build_tree/linux/include/asm/arch-lh7a40x/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,19 @@
+/* include/asm-arm/arch-lh7a40x/system.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle ();
+}
+
+static inline void arch_reset(char mode)
+{
+	cpu_reset (0);
+}
Index: build_tree/linux/include/asm/arch-lh7a40x/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,17 @@
+/* include/asm-arm/arch-lh7a40x/timex.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#include <asm/arch/constants.h>
+
+#define CLOCK_TICK_RATE		(PLL_CLOCK/6/16)
+
+/*
+#define CLOCK_TICK_RATE		3686400
+*/
Index: build_tree/linux/include/asm/arch-lh7a40x/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/* include/asm-arm/arch-lh7a40x/uncompress.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#include <asm/arch/registers.h>
+
+#ifndef UART_R_DATA
+# define UART_R_DATA	(0x00)
+#endif
+#ifndef UART_R_STATUS
+# define UART_R_STATUS	(0x10)
+#endif
+#define nTxRdy		(0x20)	/* Not TxReady (literally Tx FIFO full) */
+
+	/* Access UART with physical addresses before MMU is setup */
+#define UART_STATUS (*(volatile unsigned long*) (UART2_PHYS + UART_R_STATUS))
+#define UART_DATA   (*(volatile unsigned long*) (UART2_PHYS + UART_R_DATA))
+
+static inline void putc(int ch)
+{
+	while (UART_STATUS & nTxRdy)
+		barrier();
+	UART_DATA = ch;
+}
+
+static inline void flush(void)
+{
+}
+
+	/* NULL functions; we don't presently need them */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-lh7a40x/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-lh7a40x/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-lh7a40x/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,10 @@
+/* include/asm-arm/arch-lh7a40x/vmalloc.h
+ *
+ *  Copyright (C) 2004 Coastal Environmental Systems
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  version 2 as published by the Free Software Foundation.
+ *
+ */
+#define VMALLOC_END       (0xe8000000)
Index: build_tree/linux/include/asm/arch-netx/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-netx/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/* linux/include/asm-arm/arch-netx/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include "hardware.h"
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x00100000		@ physical
+		movne	\rx, #io_p2v(0x00100000)	@ virtual
+		orr	\rx, \rx, #0x00000a00
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0]
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #0x18]
+		tst	\rd, #(1 << 3)
+		bne	1002b
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldr	\rd, [\rx, #0x18]
+		tst	\rd, #(1 << 3)
+		bne	1001b
+		.endm
Index: build_tree/linux/include/asm/arch-netx/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/arch-netx/dma.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define MAX_DMA_CHANNELS 0
+#define MAX_DMA_ADDRESS ~0
Index: build_tree/linux/include/asm/arch-netx/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-netx/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/*
+ * include/asm-arm/arch-netx/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Hilscher netX based platforms
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/hardware.h>
+
+		.macro  disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	\base, #io_p2v(0x00100000)
+		add	\base, \base, #0x000ff000
+
+		ldr	\irqstat, [\base, #0]
+		clz	\irqnr, \irqstat
+		rsb     \irqnr, \irqnr, #31
+		cmp	\irqstat, #0
+		.endm
+
Index: build_tree/linux/include/asm/arch-netx/eth.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/eth.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/eth.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,27 @@
+/*
+ * include/asm-arm/arch-netx/eth.h
+ *
+ * Copyright (c) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef ASMARM_ARCH_ETH_H
+#define ASMARM_ARCH_ETH_H
+
+struct netxeth_platform_data {
+	unsigned int xcno;	/* number of xmac/xpec engine this eth uses */
+};
+
+#endif
Index: build_tree/linux/include/asm/arch-netx/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-netx/hardware.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#define NETX_IO_PHYS	0x00100000
+#define NETX_IO_VIRT	0xe0000000
+#define NETX_IO_SIZE	0x00100000
+
+#define SRAM_INTERNAL_PHYS_0 0x00000
+#define SRAM_INTERNAL_PHYS_1 0x08000
+#define SRAM_INTERNAL_PHYS_2 0x10000
+#define SRAM_INTERNAL_PHYS_3 0x18000
+#define SRAM_INTERNAL_PHYS(no) ((no) * 0x8000)
+
+#define XPEC_MEM_SIZE 0x4000
+#define XMAC_MEM_SIZE 0x1000
+#define SRAM_MEM_SIZE 0x8000
+
+#define io_p2v(x) ((x) - NETX_IO_PHYS + NETX_IO_VIRT)
+#define io_v2p(x) ((x) - NETX_IO_VIRT + NETX_IO_PHYS)
+
+#endif
Index: build_tree/linux/include/asm/arch-netx/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ *  linux/include/asm-arm/arch-netx/io.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)         ((void __iomem *)(a))
+#define __mem_pci(a)            (a)
+
+#endif
Index: build_tree/linux/include/asm/arch-netx/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,70 @@
+/*
+ * include/asm-arm/arch-netx/irqs.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define NETX_IRQ_VIC_START   0
+#define NETX_IRQ_SOFTINT     0
+#define NETX_IRQ_TIMER0      1
+#define NETX_IRQ_TIMER1      2
+#define NETX_IRQ_TIMER2      3
+#define NETX_IRQ_SYSTIME_NS  4
+#define NETX_IRQ_SYSTIME_S   5
+#define NETX_IRQ_GPIO_15     6
+#define NETX_IRQ_WATCHDOG    7
+#define NETX_IRQ_UART0       8
+#define NETX_IRQ_UART1       9
+#define NETX_IRQ_UART2      10
+#define NETX_IRQ_USB        11
+#define NETX_IRQ_SPI        12
+#define NETX_IRQ_I2C        13
+#define NETX_IRQ_LCD        14
+#define NETX_IRQ_HIF        15
+#define NETX_IRQ_GPIO_0_14  16
+#define NETX_IRQ_XPEC0      17
+#define NETX_IRQ_XPEC1      18
+#define NETX_IRQ_XPEC2      19
+#define NETX_IRQ_XPEC3      20
+#define NETX_IRQ_XPEC(no)   (17 + (no))
+#define NETX_IRQ_MSYNC0     21
+#define NETX_IRQ_MSYNC1     22
+#define NETX_IRQ_MSYNC2     23
+#define NETX_IRQ_MSYNC3     24
+#define NETX_IRQ_IRQ_PHY    25
+#define NETX_IRQ_ISO_AREA   26
+/* int 27 is reserved */
+/* int 28 is reserved */
+#define NETX_IRQ_TIMER3     29
+#define NETX_IRQ_TIMER4     30
+/* int 31 is reserved */
+
+#define NETX_IRQS 32
+
+/* for multiplexed irqs on gpio 0..14 */
+#define NETX_IRQ_GPIO(x) (NETX_IRQS + (x))
+#define NETX_IRQ_GPIO_LAST NETX_IRQ_GPIO(14)
+
+/* Host interface interrupts */
+#define NETX_IRQ_HIF_CHAINED(x)    (NETX_IRQ_GPIO_LAST + 1 + (x))
+#define NETX_IRQ_HIF_PIO35         NETX_IRQ_HIF_CHAINED(0)
+#define NETX_IRQ_HIF_PIO36         NETX_IRQ_HIF_CHAINED(1)
+#define NETX_IRQ_HIF_PIO40         NETX_IRQ_HIF_CHAINED(2)
+#define NETX_IRQ_HIF_PIO47         NETX_IRQ_HIF_CHAINED(3)
+#define NETX_IRQ_HIF_PIO72         NETX_IRQ_HIF_CHAINED(4)
+#define NETX_IRQ_HIF_LAST          NETX_IRQ_HIF_CHAINED(4)
+
+#define NR_IRQS (NETX_IRQ_HIF_LAST + 1)
Index: build_tree/linux/include/asm/arch-netx/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/arch-netx/memory.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET UL(0x80000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)         __virt_to_phys(x)
+#define __bus_to_virt(x)         __phys_to_virt(x)
+
+#endif
+
Index: build_tree/linux/include/asm/arch-netx/netx-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/netx-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/netx-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,410 @@
+/*
+ * include/asm-arm/arch-netx/netx-regs.h
+ *
+ * Copyright (c) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_NETX_REGS_H
+#define __ASM_ARCH_NETX_REGS_H
+
+/* offsets relative to the beginning of the io space */
+#define NETX_OFS_SYSTEM  0x00000
+#define NETX_OFS_MEMCR   0x00100
+#define NETX_OFS_DPMAS   0x03000
+#define NETX_OFS_GPIO    0x00800
+#define NETX_OFS_PIO     0x00900
+#define NETX_OFS_UART0   0x00a00
+#define NETX_OFS_UART1   0x00a40
+#define NETX_OFS_UART2   0x00a80
+#define NETX_OF_MIIMU    0x00b00
+#define NETX_OFS_SPI     0x00c00
+#define NETX_OFS_I2C     0x00d00
+#define NETX_OFS_SYSTIME 0x01100
+#define NETX_OFS_RTC     0x01200
+#define NETX_OFS_EXTBUS  0x03600
+#define NETX_OFS_LCD     0x04000
+#define NETX_OFS_USB     0x20000
+#define NETX_OFS_XMAC0   0x60000
+#define NETX_OFS_XMAC1   0x61000
+#define NETX_OFS_XMAC2   0x62000
+#define NETX_OFS_XMAC3   0x63000
+#define NETX_OFS_XMAC(no) (0x60000 + (no) * 0x1000)
+#define NETX_OFS_PFIFO   0x64000
+#define NETX_OFS_XPEC0   0x70000
+#define NETX_OFS_XPEC1   0x74000
+#define NETX_OFS_XPEC2   0x78000
+#define NETX_OFS_XPEC3   0x7c000
+#define NETX_OFS_XPEC(no) (0x70000 + (no) * 0x4000)
+#define NETX_OFS_VIC     0xff000
+
+/* physical addresses */
+#define NETX_PA_SYSTEM   (NETX_IO_PHYS + NETX_OFS_SYSTEM)
+#define NETX_PA_MEMCR    (NETX_IO_PHYS + NETX_OFS_MEMCR)
+#define NETX_PA_DPMAS    (NETX_IO_PHYS + NETX_OFS_DPMAS)
+#define NETX_PA_GPIO     (NETX_IO_PHYS + NETX_OFS_GPIO)
+#define NETX_PA_PIO      (NETX_IO_PHYS + NETX_OFS_PIO)
+#define NETX_PA_UART0    (NETX_IO_PHYS + NETX_OFS_UART0)
+#define NETX_PA_UART1    (NETX_IO_PHYS + NETX_OFS_UART1)
+#define NETX_PA_UART2    (NETX_IO_PHYS + NETX_OFS_UART2)
+#define NETX_PA_MIIMU    (NETX_IO_PHYS + NETX_OF_MIIMU)
+#define NETX_PA_SPI      (NETX_IO_PHYS + NETX_OFS_SPI)
+#define NETX_PA_I2C      (NETX_IO_PHYS + NETX_OFS_I2C)
+#define NETX_PA_SYSTIME  (NETX_IO_PHYS + NETX_OFS_SYSTIME)
+#define NETX_PA_RTC      (NETX_IO_PHYS + NETX_OFS_RTC)
+#define NETX_PA_EXTBUS   (NETX_IO_PHYS + NETX_OFS_EXTBUS)
+#define NETX_PA_LCD      (NETX_IO_PHYS + NETX_OFS_LCD)
+#define NETX_PA_USB      (NETX_IO_PHYS + NETX_OFS_USB)
+#define NETX_PA_XMAC0    (NETX_IO_PHYS + NETX_OFS_XMAC0)
+#define NETX_PA_XMAC1    (NETX_IO_PHYS + NETX_OFS_XMAC1)
+#define NETX_PA_XMAC2    (NETX_IO_PHYS + NETX_OFS_XMAC2)
+#define NETX_PA_XMAC3    (NETX_IO_PHYS + NETX_OFS_XMAC3)
+#define NETX_PA_XMAC(no) (NETX_IO_PHYS + NETX_OFS_XMAC(no))
+#define NETX_PA_PFIFO    (NETX_IO_PHYS + NETX_OFS_PFIFO)
+#define NETX_PA_XPEC0    (NETX_IO_PHYS + NETX_OFS_XPEC0)
+#define NETX_PA_XPEC1    (NETX_IO_PHYS + NETX_OFS_XPEC1)
+#define NETX_PA_XPEC2    (NETX_IO_PHYS + NETX_OFS_XPEC2)
+#define NETX_PA_XPEC3    (NETX_IO_PHYS + NETX_OFS_XPEC3)
+#define NETX_PA_XPEC(no) (NETX_IO_PHYS + NETX_OFS_XPEC(no))
+#define NETX_PA_VIC      (NETX_IO_PHYS + NETX_OFS_VIC)
+
+/* virual addresses */
+#define NETX_VA_SYSTEM   (NETX_IO_VIRT + NETX_OFS_SYSTEM)
+#define NETX_VA_MEMCR    (NETX_IO_VIRT + NETX_OFS_MEMCR)
+#define NETX_VA_DPMAS    (NETX_IO_VIRT + NETX_OFS_DPMAS)
+#define NETX_VA_GPIO     (NETX_IO_VIRT + NETX_OFS_GPIO)
+#define NETX_VA_PIO      (NETX_IO_VIRT + NETX_OFS_PIO)
+#define NETX_VA_UART0    (NETX_IO_VIRT + NETX_OFS_UART0)
+#define NETX_VA_UART1    (NETX_IO_VIRT + NETX_OFS_UART1)
+#define NETX_VA_UART2    (NETX_IO_VIRT + NETX_OFS_UART2)
+#define NETX_VA_MIIMU    (NETX_IO_VIRT + NETX_OF_MIIMU)
+#define NETX_VA_SPI      (NETX_IO_VIRT + NETX_OFS_SPI)
+#define NETX_VA_I2C      (NETX_IO_VIRT + NETX_OFS_I2C)
+#define NETX_VA_SYSTIME  (NETX_IO_VIRT + NETX_OFS_SYSTIME)
+#define NETX_VA_RTC      (NETX_IO_VIRT + NETX_OFS_RTC)
+#define NETX_VA_EXTBUS   (NETX_IO_VIRT + NETX_OFS_EXTBUS)
+#define NETX_VA_LCD      (NETX_IO_VIRT + NETX_OFS_LCD)
+#define NETX_VA_USB      (NETX_IO_VIRT + NETX_OFS_USB)
+#define NETX_VA_XMAC0    (NETX_IO_VIRT + NETX_OFS_XMAC0)
+#define NETX_VA_XMAC1    (NETX_IO_VIRT + NETX_OFS_XMAC1)
+#define NETX_VA_XMAC2    (NETX_IO_VIRT + NETX_OFS_XMAC2)
+#define NETX_VA_XMAC3    (NETX_IO_VIRT + NETX_OFS_XMAC3)
+#define NETX_VA_XMAC(no) (NETX_IO_VIRT + NETX_OFS_XMAC(no))
+#define NETX_VA_PFIFO    (NETX_IO_VIRT + NETX_OFS_PFIFO)
+#define NETX_VA_XPEC0    (NETX_IO_VIRT + NETX_OFS_XPEC0)
+#define NETX_VA_XPEC1    (NETX_IO_VIRT + NETX_OFS_XPEC1)
+#define NETX_VA_XPEC2    (NETX_IO_VIRT + NETX_OFS_XPEC2)
+#define NETX_VA_XPEC3    (NETX_IO_VIRT + NETX_OFS_XPEC3)
+#define NETX_VA_XPEC(no) (NETX_IO_VIRT + NETX_OFS_XPEC(no))
+#define NETX_VA_VIC      (NETX_IO_VIRT + NETX_OFS_VIC)
+
+/*********************************
+ * System functions              *
+ *********************************/
+
+/* Registers */
+#define NETX_SYSTEM_REG(ofs)            __io(NETX_VA_SYSTEM + (ofs))
+#define NETX_SYSTEM_BOO_SR          NETX_SYSTEM_REG(0x00)
+#define NETX_SYSTEM_IOC_CR          NETX_SYSTEM_REG(0x04)
+#define NETX_SYSTEM_IOC_MR          NETX_SYSTEM_REG(0x08)
+
+/* FIXME: Docs are not consistent */
+#define NETX_SYSTEM_RES_CR          NETX_SYSTEM_REG(0x08)
+/* #define NETX_SYSTEM_RES_CR          NETX_SYSTEM_REG(0x0c) */
+
+#define NETX_SYSTEM_PHY_CONTROL     NETX_SYSTEM_REG(0x10)
+#define NETX_SYSTEM_REV             NETX_SYSTEM_REG(0x34)
+#define NETX_SYSTEM_IOC_ACCESS_KEY  NETX_SYSTEM_REG(0x70)
+#define NETX_SYSTEM_WDG_TR          NETX_SYSTEM_REG(0x200)
+#define NETX_SYSTEM_WDG_CTR         NETX_SYSTEM_REG(0x204)
+#define NETX_SYSTEM_WDG_IRQ_TIMEOUT NETX_SYSTEM_REG(0x208)
+#define NETX_SYSTEM_WDG_RES_TIMEOUT NETX_SYSTEM_REG(0x20c)
+
+/* Bits */
+#define NETX_SYSTEM_RES_CR_RSTIN         (1<<0)
+#define NETX_SYSTEM_RES_CR_WDG_RES       (1<<1)
+#define NETX_SYSTEM_RES_CR_HOST_RES      (1<<2)
+#define NETX_SYSTEM_RES_CR_FIRMW_RES     (1<<3)
+#define NETX_SYSTEM_RES_CR_XPEC0_RES     (1<<4)
+#define NETX_SYSTEM_RES_CR_XPEC1_RES     (1<<5)
+#define NETX_SYSTEM_RES_CR_XPEC2_RES     (1<<6)
+#define NETX_SYSTEM_RES_CR_XPEC3_RES     (1<<7)
+#define NETX_SYSTEM_RES_CR_DIS_XPEC0_RES (1<<16)
+#define NETX_SYSTEM_RES_CR_DIS_XPEC1_RES (1<<17)
+#define NETX_SYSTEM_RES_CR_DIS_XPEC2_RES (1<<18)
+#define NETX_SYSTEM_RES_CR_DIS_XPEC3_RES (1<<19)
+#define NETX_SYSTEM_RES_CR_FIRMW_FLG0    (1<<20)
+#define NETX_SYSTEM_RES_CR_FIRMW_FLG1    (1<<21)
+#define NETX_SYSTEM_RES_CR_FIRMW_FLG2    (1<<22)
+#define NETX_SYSTEM_RES_CR_FIRMW_FLG3    (1<<23)
+#define NETX_SYSTEM_RES_CR_FIRMW_RES_EN  (1<<24)
+#define NETX_SYSTEM_RES_CR_RSTOUT        (1<<25)
+#define NETX_SYSTEM_RES_CR_EN_RSTOUT     (1<<26)
+
+#define PHY_CONTROL_RESET            (1<<31)
+#define PHY_CONTROL_SIM_BYP          (1<<30)
+#define PHY_CONTROL_CLK_XLATIN       (1<<29)
+#define PHY_CONTROL_PHY1_EN          (1<<21)
+#define PHY_CONTROL_PHY1_NP_MSG_CODE
+#define PHY_CONTROL_PHY1_AUTOMDIX    (1<<17)
+#define PHY_CONTROL_PHY1_FIXMODE     (1<<16)
+#define PHY_CONTROL_PHY1_MODE(mode)  (((mode) & 0x7) << 13)
+#define PHY_CONTROL_PHY0_EN          (1<<12)
+#define PHY_CONTROL_PHY0_NP_MSG_CODE
+#define PHY_CONTROL_PHY0_AUTOMDIX    (1<<8)
+#define PHY_CONTROL_PHY0_FIXMODE     (1<<7)
+#define PHY_CONTROL_PHY0_MODE(mode)  (((mode) & 0x7) << 4)
+#define PHY_CONTROL_PHY_ADDRESS(adr) ((adr) & 0xf)
+
+#define PHY_MODE_10BASE_T_HALF      0
+#define PHY_MODE_10BASE_T_FULL      1
+#define PHY_MODE_100BASE_TX_FX_FULL 2
+#define PHY_MODE_100BASE_TX_FX_HALF 3
+#define PHY_MODE_100BASE_TX_HALF    4
+#define PHY_MODE_REPEATER           5
+#define PHY_MODE_POWER_DOWN         6
+#define PHY_MODE_ALL                7
+
+/* Bits */
+#define VECT_CNTL_ENABLE               (1 << 5)
+
+/*******************************
+ * GPIO and timer module       *
+ *******************************/
+
+/* Registers */
+#define NETX_GPIO_REG(ofs)                     __io(NETX_VA_GPIO + (ofs))
+#define NETX_GPIO_CFG(gpio)                NETX_GPIO_REG(0x0  + ((gpio)<<2))
+#define NETX_GPIO_THRESHOLD_CAPTURE(gpio)  NETX_GPIO_REG(0x40 + ((gpio)<<2))
+#define NETX_GPIO_COUNTER_CTRL(counter)    NETX_GPIO_REG(0x80 + ((counter)<<2))
+#define NETX_GPIO_COUNTER_MAX(counter)     NETX_GPIO_REG(0x94 + ((counter)<<2))
+#define NETX_GPIO_COUNTER_CURRENT(counter) NETX_GPIO_REG(0xa8 + ((counter)<<2))
+#define NETX_GPIO_IRQ_ENABLE               NETX_GPIO_REG(0xbc)
+#define NETX_GPIO_IRQ_DISABLE              NETX_GPIO_REG(0xc0)
+#define NETX_GPIO_SYSTIME_NS_CMP           NETX_GPIO_REG(0xc4)
+#define NETX_GPIO_LINE                     NETX_GPIO_REG(0xc8)
+#define NETX_GPIO_IRQ                      NETX_GPIO_REG(0xd0)
+
+/* Bits */
+#define NETX_GPIO_CFG_IOCFG_GP_INPUT                 (0x0)
+#define NETX_GPIO_CFG_IOCFG_GP_OUTPUT                (0x1)
+#define NETX_GPIO_CFG_IOCFG_GP_UART                  (0x2)
+#define NETX_GPIO_CFG_INV                            (1<<2)
+#define NETX_GPIO_CFG_MODE_INPUT_READ                (0<<3)
+#define NETX_GPIO_CFG_MODE_INPUT_CAPTURE_CONT_RISING (1<<3)
+#define NETX_GPIO_CFG_MODE_INPUT_CAPTURE_ONCE_RISING (2<<3)
+#define NETX_GPIO_CFG_MODE_INPUT_CAPTURE_HIGH_LEVEL  (3<<3)
+#define NETX_GPIO_CFG_COUNT_REF_COUNTER0             (0<<5)
+#define NETX_GPIO_CFG_COUNT_REF_COUNTER1             (1<<5)
+#define NETX_GPIO_CFG_COUNT_REF_COUNTER2             (2<<5)
+#define NETX_GPIO_CFG_COUNT_REF_COUNTER3             (3<<5)
+#define NETX_GPIO_CFG_COUNT_REF_COUNTER4             (4<<5)
+#define NETX_GPIO_CFG_COUNT_REF_SYSTIME              (7<<5)
+
+#define NETX_GPIO_COUNTER_CTRL_RUN                   (1<<0)
+#define NETX_GPIO_COUNTER_CTRL_SYM                   (1<<1)
+#define NETX_GPIO_COUNTER_CTRL_ONCE                  (1<<2)
+#define NETX_GPIO_COUNTER_CTRL_IRQ_EN                (1<<3)
+#define NETX_GPIO_COUNTER_CTRL_CNT_EVENT             (1<<4)
+#define NETX_GPIO_COUNTER_CTRL_RST_EN                (1<<5)
+#define NETX_GPIO_COUNTER_CTRL_SEL_EVENT             (1<<6)
+#define NETX_GPIO_COUNTER_CTRL_GPIO_REF /* FIXME */
+
+#define GPIO_BIT(gpio)                     (1<<(gpio))
+#define COUNTER_BIT(counter)               ((1<<16)<<(counter))
+
+/*******************************
+ * PIO                         *
+ *******************************/
+
+/* Registers */
+#define NETX_PIO_REG(ofs)        __io(NETX_VA_PIO + (ofs))
+#define NETX_PIO_INPIO       NETX_PIO_REG(0x0)
+#define NETX_PIO_OUTPIO      NETX_PIO_REG(0x4)
+#define NETX_PIO_OEPIO       NETX_PIO_REG(0x8)
+
+/*******************************
+ * MII Unit                    *
+ *******************************/
+
+/* Registers */
+#define NETX_MIIMU           __io(NETX_VA_MIIMU)
+
+/* Bits */
+#define MIIMU_SNRDY        (1<<0)
+#define MIIMU_PREAMBLE     (1<<1)
+#define MIIMU_OPMODE_WRITE (1<<2)
+#define MIIMU_MDC_PERIOD   (1<<3)
+#define MIIMU_PHY_NRES     (1<<4)
+#define MIIMU_RTA          (1<<5)
+#define MIIMU_REGADDR(adr) (((adr) & 0x1f) << 6)
+#define MIIMU_PHYADDR(adr) (((adr) & 0x1f) << 11)
+#define MIIMU_DATA(data)   (((data) & 0xffff) << 16)
+
+/*******************************
+ * xmac / xpec                 *
+ *******************************/
+
+/* XPEC register offsets relative to NETX_VA_XPEC(no) */
+#define NETX_XPEC_R0_OFS           0x00
+#define NETX_XPEC_R1_OFS           0x04
+#define NETX_XPEC_R2_OFS           0x08
+#define NETX_XPEC_R3_OFS           0x0c
+#define NETX_XPEC_R4_OFS           0x10
+#define NETX_XPEC_R5_OFS           0x14
+#define NETX_XPEC_R6_OFS           0x18
+#define NETX_XPEC_R7_OFS           0x1c
+#define NETX_XPEC_RANGE01_OFS      0x20
+#define NETX_XPEC_RANGE23_OFS      0x24
+#define NETX_XPEC_RANGE45_OFS      0x28
+#define NETX_XPEC_RANGE67_OFS      0x2c
+#define NETX_XPEC_PC_OFS           0x48
+#define NETX_XPEC_TIMER_OFS(timer) (0x30 + ((timer)<<2))
+#define NETX_XPEC_IRQ_OFS          0x8c
+#define NETX_XPEC_SYSTIME_NS_OFS   0x90
+#define NETX_XPEC_FIFO_DATA_OFS    0x94
+#define NETX_XPEC_SYSTIME_S_OFS    0x98
+#define NETX_XPEC_ADC_OFS          0x9c
+#define NETX_XPEC_URX_COUNT_OFS    0x40
+#define NETX_XPEC_UTX_COUNT_OFS    0x44
+#define NETX_XPEC_PC_OFS           0x48
+#define NETX_XPEC_ZERO_OFS         0x4c
+#define NETX_XPEC_STATCFG_OFS      0x50
+#define NETX_XPEC_EC_MASKA_OFS     0x54
+#define NETX_XPEC_EC_MASKB_OFS     0x58
+#define NETX_XPEC_EC_MASK0_OFS     0x5c
+#define NETX_XPEC_EC_MASK8_OFS     0x7c
+#define NETX_XPEC_EC_MASK9_OFS     0x80
+#define NETX_XPEC_XPU_HOLD_PC_OFS  0x100
+#define NETX_XPEC_RAM_START_OFS    0x2000
+
+/* Bits */
+#define XPU_HOLD_PC (1<<0)
+
+/* XMAC register offsets relative to NETX_VA_XMAC(no) */
+#define NETX_XMAC_RPU_PROGRAM_START_OFS       0x000
+#define NETX_XMAC_RPU_PROGRAM_END_OFS         0x3ff
+#define NETX_XMAC_TPU_PROGRAM_START_OFS       0x400
+#define NETX_XMAC_TPU_PROGRAM_END_OFS         0x7ff
+#define NETX_XMAC_RPU_HOLD_PC_OFS             0xa00
+#define NETX_XMAC_TPU_HOLD_PC_OFS             0xa04
+#define NETX_XMAC_STATUS_SHARED0_OFS          0x840
+#define NETX_XMAC_CONFIG_SHARED0_OFS          0x844
+#define NETX_XMAC_STATUS_SHARED1_OFS          0x848
+#define NETX_XMAC_CONFIG_SHARED1_OFS          0x84c
+#define NETX_XMAC_STATUS_SHARED2_OFS          0x850
+#define NETX_XMAC_CONFIG_SHARED2_OFS          0x854
+#define NETX_XMAC_STATUS_SHARED3_OFS          0x858
+#define NETX_XMAC_CONFIG_SHARED3_OFS          0x85c
+
+#define RPU_HOLD_PC            (1<<15)
+#define TPU_HOLD_PC            (1<<15)
+
+/*******************************
+ * Pointer FIFO                *
+ *******************************/
+
+/* Registers */
+#define NETX_PFIFO_REG(ofs)               __io(NETX_VA_PFIFO + (ofs))
+#define NETX_PFIFO_BASE(pfifo)        NETX_PFIFO_REG(0x00 + ((pfifo)<<2))
+#define NETX_PFIFO_BORDER_BASE(pfifo) NETX_PFIFO_REG(0x80 + ((pfifo)<<2))
+#define NETX_PFIFO_RESET              NETX_PFIFO_REG(0x100)
+#define NETX_PFIFO_FULL               NETX_PFIFO_REG(0x104)
+#define NETX_PFIFO_EMPTY              NETX_PFIFO_REG(0x108)
+#define NETX_PFIFO_OVEFLOW            NETX_PFIFO_REG(0x10c)
+#define NETX_PFIFO_UNDERRUN           NETX_PFIFO_REG(0x110)
+#define NETX_PFIFO_FILL_LEVEL(pfifo)  NETX_PFIFO_REG(0x180 + ((pfifo)<<2))
+#define NETX_PFIFO_XPEC_ISR(xpec)     NETX_PFIFO_REG(0x400 + ((xpec) << 2))
+
+/*******************************
+ * Dual Port Memory            *
+ *******************************/
+
+/* Registers */
+#define NETX_DPMAS_REG(ofs)               __io(NETX_VA_DPMAS + (ofs))
+#define NETX_DPMAS_SYS_STAT           NETX_DPMAS_REG(0x4d8)
+#define NETX_DPMAS_INT_STAT           NETX_DPMAS_REG(0x4e0)
+#define NETX_DPMAS_INT_EN             NETX_DPMAS_REG(0x4f0)
+#define NETX_DPMAS_IF_CONF0           NETX_DPMAS_REG(0x608)
+#define NETX_DPMAS_IF_CONF1           NETX_DPMAS_REG(0x60c)
+#define NETX_DPMAS_EXT_CONFIG(cs)     NETX_DPMAS_REG(0x610 + 4 * (cs))
+#define NETX_DPMAS_IO_MODE0           NETX_DPMAS_REG(0x620) /* I/O 32..63 */
+#define NETX_DPMAS_DRV_EN0            NETX_DPMAS_REG(0x624)
+#define NETX_DPMAS_DATA0              NETX_DPMAS_REG(0x628)
+#define NETX_DPMAS_IO_MODE1           NETX_DPMAS_REG(0x630) /* I/O 64..84 */
+#define NETX_DPMAS_DRV_EN1            NETX_DPMAS_REG(0x634)
+#define NETX_DPMAS_DATA1              NETX_DPMAS_REG(0x638)
+
+/* Bits */
+#define NETX_DPMAS_INT_EN_GLB_EN         (1<<31)
+#define NETX_DPMAS_INT_EN_MEM_LCK        (1<<30)
+#define NETX_DPMAS_INT_EN_WDG            (1<<29)
+#define NETX_DPMAS_INT_EN_PIO72          (1<<28)
+#define NETX_DPMAS_INT_EN_PIO47          (1<<27)
+#define NETX_DPMAS_INT_EN_PIO40          (1<<26)
+#define NETX_DPMAS_INT_EN_PIO36          (1<<25)
+#define NETX_DPMAS_INT_EN_PIO35          (1<<24)
+
+#define NETX_DPMAS_IF_CONF0_HIF_DISABLED (0<<28)
+#define NETX_DPMAS_IF_CONF0_HIF_EXT_BUS  (1<<28)
+#define NETX_DPMAS_IF_CONF0_HIF_UP_8BIT  (2<<28)
+#define NETX_DPMAS_IF_CONF0_HIF_UP_16BIT (3<<28)
+#define NETX_DPMAS_IF_CONF0_HIF_IO       (4<<28)
+#define NETX_DPMAS_IF_CONF0_WAIT_DRV_PP  (1<<14)
+#define NETX_DPMAS_IF_CONF0_WAIT_DRV_OD  (2<<14)
+#define NETX_DPMAS_IF_CONF0_WAIT_DRV_TRI (3<<14)
+
+#define NETX_DPMAS_IF_CONF1_IRQ_POL_PIO35 (1<<26)
+#define NETX_DPMAS_IF_CONF1_IRQ_POL_PIO36 (1<<27)
+#define NETX_DPMAS_IF_CONF1_IRQ_POL_PIO40 (1<<28)
+#define NETX_DPMAS_IF_CONF1_IRQ_POL_PIO47 (1<<29)
+#define NETX_DPMAS_IF_CONF1_IRQ_POL_PIO72 (1<<30)
+
+#define NETX_EXT_CONFIG_TALEWIDTH(x) (((x) & 0x7) << 29)
+#define NETX_EXT_CONFIG_TADRHOLD(x)  (((x) & 0x7) << 26)
+#define NETX_EXT_CONFIG_TCSON(x)     (((x) & 0x7) << 23)
+#define NETX_EXT_CONFIG_TRDON(x)     (((x) & 0x7) << 20)
+#define NETX_EXT_CONFIG_TWRON(x)     (((x) & 0x7)  << 17)
+#define NETX_EXT_CONFIG_TWROFF(x)    (((x) & 0x1f) << 12)
+#define NETX_EXT_CONFIG_TRDWRCYC(x)  (((x) & 0x1f) << 7)
+#define NETX_EXT_CONFIG_WAIT_POL     (1<<6)
+#define NETX_EXT_CONFIG_WAIT_EN      (1<<5)
+#define NETX_EXT_CONFIG_NRD_MODE     (1<<4)
+#define NETX_EXT_CONFIG_DS_MODE      (1<<3)
+#define NETX_EXT_CONFIG_NWR_MODE     (1<<2)
+#define NETX_EXT_CONFIG_16BIT        (1<<1)
+#define NETX_EXT_CONFIG_CS_ENABLE    (1<<0)
+
+#define NETX_DPMAS_IO_MODE0_WRL   (1<<13)
+#define NETX_DPMAS_IO_MODE0_WAIT  (1<<14)
+#define NETX_DPMAS_IO_MODE0_READY (1<<15)
+#define NETX_DPMAS_IO_MODE0_CS0   (1<<19)
+#define NETX_DPMAS_IO_MODE0_EXTRD (1<<20)
+
+#define NETX_DPMAS_IO_MODE1_CS2           (1<<15)
+#define NETX_DPMAS_IO_MODE1_CS1           (1<<16)
+#define NETX_DPMAS_IO_MODE1_SAMPLE_NPOR   (0<<30)
+#define NETX_DPMAS_IO_MODE1_SAMPLE_100MHZ (1<<30)
+#define NETX_DPMAS_IO_MODE1_SAMPLE_NPIO36 (2<<30)
+#define NETX_DPMAS_IO_MODE1_SAMPLE_PIO36  (3<<30)
+
+/*******************************
+ * I2C                         *
+ *******************************/
+#define NETX_I2C_REG(ofs)	__io(NETX_VA_I2C, (ofs))
+#define NETX_I2C_CTRL	NETX_I2C_REG(0x0)
+#define NETX_I2C_DATA	NETX_I2C_REG(0x4)
+
+#endif /* __ASM_ARCH_NETX_REGS_H */
Index: build_tree/linux/include/asm/arch-netx/param.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/param.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/param.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/arch-netx/param.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
Index: build_tree/linux/include/asm/arch-netx/pfifo.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/pfifo.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/pfifo.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,54 @@
+/*
+ * include/asm-arm/arch-netx/pfifo.h
+ *
+ * Copyright (c) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef ASM_ARCH_PFIFO_H
+#define ASM_ARCH_PFIFO_H
+
+static inline int pfifo_push(int no, unsigned int pointer)
+{
+	writel(pointer, NETX_PFIFO_BASE(no));
+	return 0;
+}
+
+static inline unsigned int pfifo_pop(int no)
+{
+	return readl(NETX_PFIFO_BASE(no));
+}
+
+static inline int pfifo_fill_level(int no)
+{
+
+	return readl(NETX_PFIFO_FILL_LEVEL(no));
+}
+
+static inline int pfifo_full(int no)
+{
+	return readl(NETX_PFIFO_FULL) & (1<<no) ? 1 : 0;
+}
+
+static inline int pfifo_empty(int no)
+{
+	return readl(NETX_PFIFO_EMPTY) & (1<<no) ? 1 : 0;
+}
+
+int pfifo_request(unsigned int pfifo_mask);
+void pfifo_free(unsigned int pfifo_mask);
+
+#endif /* ASM_ARCH_PFIFO_H */
Index: build_tree/linux/include/asm/arch-netx/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-netx/system.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include "netx-regs.h"
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	writel(NETX_SYSTEM_RES_CR_FIRMW_RES_EN | NETX_SYSTEM_RES_CR_FIRMW_RES,
+	       NETX_SYSTEM_RES_CR);
+}
+
+#endif
+
Index: build_tree/linux/include/asm/arch-netx/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-netx/timex.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE 100000000
Index: build_tree/linux/include/asm/arch-netx/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,76 @@
+/*
+ * include/asm-arm/arch-netx/uncompress.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+
+#define REG(x) (*(volatile unsigned long *)(x))
+
+#define UART1_BASE 0x100a00
+#define UART2_BASE 0x100a80
+
+#define UART_DR 0x0
+
+#define UART_CR 0x14
+#define CR_UART_EN (1<<0)
+
+#define UART_FR 0x18
+#define FR_BUSY (1<<3)
+#define FR_TXFF (1<<5)
+
+static void putc(char c)
+{
+	unsigned long base;
+
+	if (REG(UART1_BASE + UART_CR) & CR_UART_EN)
+		base = UART1_BASE;
+	else if (REG(UART2_BASE + UART_CR) & CR_UART_EN)
+		base = UART2_BASE;
+	else
+		return;
+
+	while (REG(base + UART_FR) & FR_TXFF);
+	REG(base + UART_DR) = c;
+}
+
+static inline void flush(void)
+{
+	unsigned long base;
+
+	if (REG(UART1_BASE + UART_CR) & CR_UART_EN)
+		base = UART1_BASE;
+	else if (REG(UART2_BASE + UART_CR) & CR_UART_EN)
+		base = UART2_BASE;
+	else
+		return;
+
+	while (REG(base + UART_FR) & FR_BUSY);
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-netx/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/arch-netx/vmalloc.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
Index: build_tree/linux/include/asm/arch-netx/xc.h
diff -u /dev/null build_tree/linux/include/asm/arch-netx/xc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-netx/xc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-arm/arch-netx/xc.h
+ *
+ * Copyright (C) 2005 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_XC_H
+#define __ASM_ARCH_XC_H
+
+struct xc {
+	int no;
+	unsigned int type;
+	unsigned int version;
+	void __iomem *xpec_base;
+	void __iomem *xmac_base;
+	void __iomem *sram_base;
+	int irq;
+	struct device *dev;
+};
+
+int xc_reset(struct xc *x);
+int xc_stop(struct xc* x);
+int xc_start(struct xc *x);
+int xc_running(struct xc *x);
+int xc_request_firmware(struct xc* x);
+struct xc* request_xc(int xcno, struct device *dev);
+void free_xc(struct xc *x);
+
+#endif /* __ASM_ARCH_XC_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/board.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/board.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/board.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/*
+ * include/asm-arm/arch-ns9xxx/board.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+#include <asm/mach-types.h>
+
+#define board_is_a9m9750dev()	(machine_is_cc9p9360dev())
+
+#endif /* ifndef __ASM_ARCH_BOARD_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/clock.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/clock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/clock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/*
+ * include/asm-arm/arch-ns9xxx/clock.h
+ *
+ * Copyright (C) 2007 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_CLOCK_H
+#define __ASM_ARCH_CLOCK_H
+
+static inline u32 ns9xxx_systemclock(void) __attribute__((const));
+static inline u32 ns9xxx_systemclock(void)
+{
+	/*
+	 * This should be a multiple of HZ * TIMERCLOCKSELECT (in time.c)
+	 */
+	return 353894400;
+}
+
+static inline u32 ns9xxx_cpuclock(void) __attribute__((const));
+static inline u32 ns9xxx_cpuclock(void)
+{
+	return ns9xxx_systemclock() / 2;
+}
+
+static inline u32 ns9xxx_ahbclock(void) __attribute__((const));
+static inline u32 ns9xxx_ahbclock(void)
+{
+	return ns9xxx_systemclock() / 4;
+}
+
+static inline u32 ns9xxx_bbusclock(void) __attribute__((const));
+static inline u32 ns9xxx_bbusclock(void)
+{
+	return ns9xxx_systemclock() / 8;
+}
+
+#endif /* ifndef __ASM_ARCH_CLOCK_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/*
+ * include/asm-arm/arch-ns9xxx/debug-macro.S
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#include <asm/hardware.h>
+
+#include <asm/arch-ns9xxx/regs-board-a9m9750dev.h>
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1
+		ldreq	\rx, =NS9XXX_CSxSTAT_PHYS(0)
+		ldrne	\rx, =io_p2v(NS9XXX_CSxSTAT_PHYS(0))
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-ns9xxx/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,14 @@
+/*
+ * include/asm-arm/arch-ns9xxx/dma.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#endif /* ifndef __ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ * include/asm-arm/arch-ns9xxx/entry-macro.S
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#include <asm/hardware.h>
+#include <asm/arch-ns9xxx/regs-sys.h>
+
+		.macro	get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro	arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =SYS_ISRADDR
+		ldr	\irqstat, [\base, #(SYS_ISA - SYS_ISRADDR)]
+		cmp	\irqstat, #0
+		ldrne	\irqnr, [\base]
+		.endm
+
+		.macro	disable_fiq
+		.endm
Index: build_tree/linux/include/asm/arch-ns9xxx/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,67 @@
+/*
+ * include/asm-arm/arch-ns9xxx/hardware.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/memory.h>
+
+/*
+ * NetSilicon NS9xxx internal mapping:
+ *
+ * physical                <--> virtual
+ * 0x90000000 - 0x906fffff <--> 0xf9000000 - 0xf96fffff
+ * 0xa0100000 - 0xa0afffff <--> 0xfa100000 - 0xfaafffff
+ */
+#define io_p2v(x)	(0xf0000000 \
+			 + (((x) & 0xf0000000) >> 4) \
+			 + ((x) & 0x00ffffff))
+
+#define io_v2p(x)	((((x) & 0x0f000000) << 4) \
+			 + ((x) & 0x00ffffff))
+
+#define __REGBIT(bit)		((u32)1 << (bit))
+#define __REGBITS(hbit, lbit)	((((u32)1 << ((hbit) - (lbit) + 1)) - 1) << (lbit))
+#define __REGVAL(mask, value)	(((value) * ((mask) & (-(mask))) & (mask)))
+
+#ifndef __ASSEMBLY__
+
+#  define __REG(x)	(*((volatile u32 *)io_p2v((x))))
+#  define __REG2(x, y)	(*((volatile u32 *)io_p2v((x)) + (y)))
+
+#  define __REGB(x)	(*((volatile u8 *)io_p2v((x))))
+#  define __REGB2(x)	(*((volatile u8 *)io_p2v((x)) + (y)))
+
+#  define REGSET(var, reg, field, value)				\
+	((var) = (((var)						\
+		   & ~(reg ## _ ## field & 				\
+		       ~ reg ## _ ## field ## _ ## value))		\
+		  | (reg ## _ ## field ## _ ## value)))
+
+#  define REGSETIM(var, reg, field, value)				\
+	((var) = (((var)						\
+		   & ~(reg ## _ ## field & 				\
+		       ~(__REGVAL(reg ## _ ## field, value))))		\
+		  | (__REGVAL(reg ## _ ## field, value))))
+
+#  define REGGET(reg, field)						\
+	((reg & (reg ## _ ## field)) / (field & (-field)))
+
+#else
+
+#  define __REG(x)	io_p2v(x)
+#  define __REG2(x, y)	io_p2v((x) + (y))
+
+#  define __REGB(x)	__REG((x))
+#  define __REGB2(x, y)	__REG2((x), (y))
+
+#endif
+
+#endif /* ifndef __ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-ns9xxx/io.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT  0xffffffff /* XXX */
+
+#define __io(a)         ((void __iomem *)(a))
+#define __mem_pci(a)    (a)
+#define __mem_isa(a)    (IO_BASE + (a))
+
+#endif /* ifndef __ASM_ARCH_IO_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,85 @@
+/*
+ * include/asm-arm/arch-ns9xxx/irqs.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define IRQ_WATCHDOG	0
+#define IRQ_AHBBUSERR	1
+#define IRQ_BBUSAGG	2
+/* irq 3 is reserved for NS9360 */
+#define IRQ_ETHRX	4
+#define IRQ_ETHTX	5
+#define IRQ_ETHPHY	6
+#define IRQ_LCD		7
+#define IRQ_SERBRX	8
+#define IRQ_SERBTX	9
+#define IRQ_SERARX	10
+#define IRQ_SERATX	11
+#define IRQ_SERCRX	12
+#define IRQ_SERCTX	13
+#define IRQ_I2C		14
+#define IRQ_BBUSDMA	15
+#define IRQ_TIMER0	16
+#define IRQ_TIMER1	17
+#define IRQ_TIMER2	18
+#define IRQ_TIMER3	19
+#define IRQ_TIMER4	20
+#define IRQ_TIMER5	21
+#define IRQ_TIMER6	22
+#define IRQ_TIMER7	23
+#define IRQ_RTC		24
+#define IRQ_USBHOST	25
+#define IRQ_USBDEVICE	26
+#define IRQ_IEEE1284	27
+#define IRQ_EXT0	28
+#define IRQ_EXT1	29
+#define IRQ_EXT2	30
+#define IRQ_EXT3	31
+
+#define BBUS_IRQ(irq)	(32 + irq)
+
+#define IRQ_BBUS_DMA		BBUS_IRQ(0)
+#define IRQ_BBUS_SERBRX		BBUS_IRQ(2)
+#define IRQ_BBUS_SERBTX		BBUS_IRQ(3)
+#define IRQ_BBUS_SERARX		BBUS_IRQ(4)
+#define IRQ_BBUS_SERATX		BBUS_IRQ(5)
+#define IRQ_BBUS_SERCRX		BBUS_IRQ(6)
+#define IRQ_BBUS_SERCTX		BBUS_IRQ(7)
+#define IRQ_BBUS_SERDRX		BBUS_IRQ(8)
+#define IRQ_BBUS_SERDTX		BBUS_IRQ(9)
+#define IRQ_BBUS_I2C		BBUS_IRQ(10)
+#define IRQ_BBUS_1284		BBUS_IRQ(11)
+#define IRQ_BBUS_UTIL		BBUS_IRQ(12)
+#define IRQ_BBUS_RTC		BBUS_IRQ(13)
+#define IRQ_BBUS_USBHST		BBUS_IRQ(14)
+#define IRQ_BBUS_USBDEV		BBUS_IRQ(15)
+#define IRQ_BBUS_AHBDMA1	BBUS_IRQ(24)
+#define IRQ_BBUS_AHBDMA2	BBUS_IRQ(25)
+
+/*
+ * these Interrupts are specific for the a9m9750dev board.
+ * They are generated by an FPGA that interrupts the CPU on
+ * IRQ_EXT2
+ */
+#define FPGA_IRQ(irq)	(64 + irq)
+
+#define IRQ_FPGA_UARTA		FPGA_IRQ(0)
+#define IRQ_FPGA_UARTB		FPGA_IRQ(1)
+#define IRQ_FPGA_UARTC		FPGA_IRQ(2)
+#define IRQ_FPGA_UARTD		FPGA_IRQ(3)
+#define IRQ_FPGA_TOUCH		FPGA_IRQ(4)
+#define IRQ_FPGA_CF		FPGA_IRQ(5)
+#define IRQ_FPGA_CAN0		FPGA_IRQ(6)
+#define IRQ_FPGA_CAN1		FPGA_IRQ(7)
+
+#define NR_IRQS	72
+
+#endif /* __ASM_ARCH_IRQS_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,27 @@
+/*
+ * include/asm-arm/arch-ns9xxx/memory.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+*/
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/* x in [0..3] */
+#define NS9XXX_CSxSTAT_PHYS(x)	UL(((x) + 4) << 28)
+
+#define NS9XXX_CS0STAT_LENGTH	UL(0x1000)
+#define NS9XXX_CS1STAT_LENGTH	UL(0x1000)
+#define NS9XXX_CS2STAT_LENGTH	UL(0x1000)
+#define NS9XXX_CS3STAT_LENGTH	UL(0x1000)
+
+#define PHYS_OFFSET	UL(0x00000000)
+
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-ns9xxx/processor.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/processor.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/processor.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/*
+ * include/asm-arm/arch-ns9xxx/processor.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_PROCESSOR_H
+#define __ASM_ARCH_PROCESSOR_H
+
+#include <asm/mach-types.h>
+
+#define processor_is_ns9360()	(machine_is_cc9p9360dev())
+
+#endif /* ifndef __ASM_ARCH_PROCESSOR_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/regs-bbu.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/regs-bbu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/regs-bbu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ * include/asm-arm/arch-ns9xxx/regs-bbu.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_REGSBBU_H
+#define __ASM_ARCH_REGSBBU_H
+
+#include <asm/hardware.h>
+
+/* BBus Utility */
+
+/* GPIO Configuration Register */
+#define BBU_GC(x)	__REG2(0x9060000c, (x))
+
+#endif /* ifndef __ASM_ARCH_REGSBBU_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/regs-board-a9m9750dev.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/regs-board-a9m9750dev.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/regs-board-a9m9750dev.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ * include/asm-arm/arch-ns9xxx/regs-board-a9m9750dev.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_REGSBOARDA9M9750_H
+#define __ASM_ARCH_REGSBOARDA9M9750_H
+
+#include <asm/hardware.h>
+
+#define FPGA_UARTA_BASE	io_p2v(NS9XXX_CSxSTAT_PHYS(0))
+#define FPGA_UARTB_BASE	io_p2v(NS9XXX_CSxSTAT_PHYS(0) + 0x08)
+#define FPGA_UARTC_BASE	io_p2v(NS9XXX_CSxSTAT_PHYS(0) + 0x10)
+#define FPGA_UARTD_BASE	io_p2v(NS9XXX_CSxSTAT_PHYS(0) + 0x18)
+
+#define FPGA_IER	__REGB(NS9XXX_CSxSTAT_PHYS(0) + 0x50)
+#define FPGA_ISR	__REGB(NS9XXX_CSxSTAT_PHYS(0) + 0x60)
+
+#endif /* ifndef __ASM_ARCH_REGSBOARDA9M9750_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/regs-mem.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/regs-mem.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/regs-mem.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,135 @@
+/*
+ * include/asm-arm/arch-ns9xxx/regs-mem.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_REGSMEM_H
+#define __ASM_ARCH_REGSMEM_H
+
+#include <asm/hardware.h>
+
+/* Memory Module */
+
+/* Control register */
+#define MEM_CTRL	__REG(0xa0700000)
+
+/* Status register */
+#define MEM_STAT	__REG(0xa0700004)
+
+/* Configuration register */
+#define MEM_CONF	__REG(0xa0700008)
+
+/* Dynamic Memory Control register */
+#define MEM_DMCTRL	__REG(0xa0700020)
+
+/* Dynamic Memory Refresh Timer */
+#define MEM_DMRT	__REG(0xa0700024)
+
+/* Dynamic Memory Read Configuration register */
+#define MEM_DMRC	__REG(0xa0700028)
+
+/* Dynamic Memory Precharge Command Period (tRP) */
+#define MEM_DMPCP	__REG(0xa0700030)
+
+/* Dynamic Memory Active to Precharge Command Period (tRAS) */
+#define MEM_DMAPCP	__REG(0xa0700034)
+
+/* Dynamic Memory Self-Refresh Exit Time (tSREX) */
+#define MEM_DMSRET	__REG(0xa0700038)
+
+/* Dynamic Memory Last Data Out to Active Time (tAPR) */
+#define MEM_DMLDOAT	__REG(0xa070003c)
+
+/* Dynamic Memory Data-in to Active Command Time (tDAL or TAPW) */
+#define MEM_DMDIACT	__REG(0xa0700040)
+
+/* Dynamic Memory Write Recovery Time (tWR, tDPL, tRWL, tRDL) */
+#define MEM_DMWRT	__REG(0xa0700044)
+
+/* Dynamic Memory Active to Active Command Period (tRC) */
+#define MEM_DMAACP	__REG(0xa0700048)
+
+/* Dynamic Memory Auto Refresh Period, and Auto Refresh to Active Command Period (tRFC) */
+#define MEM_DMARP	__REG(0xa070004c)
+
+/* Dynamic Memory Exit Self-Refresh to Active Command (tXSR) */
+#define MEM_DMESRAC	__REG(0xa0700050)
+
+/* Dynamic Memory Active Bank A to Active B Time (tRRD) */
+#define MEM_DMABAABT	__REG(0xa0700054)
+
+/* Dynamic Memory Load Mode register to Active Command Time (tMRD) */
+#define MEM_DMLMACT	__REG(0xa0700058)
+
+/* Static Memory Extended Wait */
+#define MEM_SMEW	__REG(0xa0700080)
+
+/* Dynamic Memory Configuration Register x */
+#define MEM_DMCONF(x) 	__REG2(0xa0700100, (x) << 3)
+
+/* Dynamic Memory RAS and CAS Delay x */
+#define MEM_DMRCD(x)	__REG2(0xa0700104, (x) << 3)
+
+/* Static Memory Configuration Register x */
+#define MEM_SMC(x)	__REG2(0xa0700200, (x) << 3)
+
+/* Static Memory Configuration Register x: Write protect */
+#define MEM_SMC_WSMC		__REGBIT(20)
+#define MEM_SMC_WSMC_OFF		__REGVAL(MEM_SMC_WSMC, 0)
+#define MEM_SMC_WSMC_ON			__REGVAL(MEM_SMC_WSMC, 1)
+
+/* Static Memory Configuration Register x: Buffer enable */
+#define MEM_SMC_BSMC		__REGBIT(19)
+#define MEM_SMC_BSMC_OFF		__REGVAL(MEM_SMC_BSMC, 0)
+#define MEM_SMC_BSMC_ON			__REGVAL(MEM_SMC_BSMC, 1)
+
+/* Static Memory Configuration Register x: Extended Wait */
+#define MEM_SMC_EW		__REGBIT(8)
+#define MEM_SMC_EW_OFF			__REGVAL(MEM_SMC_EW, 0)
+#define MEM_SMC_EW_ON			__REGVAL(MEM_SMC_EW, 1)
+
+/* Static Memory Configuration Register x: Byte lane state */
+#define MEM_SMC_PB		__REGBIT(7)
+#define MEM_SMC_PB_0			__REGVAL(MEM_SMC_PB, 0)
+#define MEM_SMC_PB_1			__REGVAL(MEM_SMC_PB, 1)
+
+/* Static Memory Configuration Register x: Chip select polarity */
+#define MEM_SMC_PC		__REGBIT(6)
+#define MEM_SMC_PC_AL			__REGVAL(MEM_SMC_PC, 0)
+#define MEM_SMC_PC_AH			__REGVAL(MEM_SMC_PC, 1)
+
+/* static memory configuration register x: page mode*/
+#define MEM_SMC_PM		__REGBIT(3)
+#define MEM_SMC_PM_DIS			__REGVAL(MEM_SMC_PM, 0)
+#define MEM_SMC_PM_ASYNC		__REGVAL(MEM_SMC_PM, 1)
+
+/* static memory configuration register x: Memory width */
+#define MEM_SMC_MW		__REGBITS(1, 0)
+#define MEM_SMC_MW_8			__REGVAL(MEM_SMC_MW, 0)
+#define MEM_SMC_MW_16			__REGVAL(MEM_SMC_MW, 1)
+#define MEM_SMC_MW_32			__REGVAL(MEM_SMC_MW, 2)
+
+/* Static Memory Write Enable Delay x */
+#define MEM_SMWED(x)	__REG2(0xa0700204, (x) << 3)
+
+/* Static Memory Output Enable Delay x */
+#define MEM_SMOED(x)	__REG2(0xa0700208, (x) << 3)
+
+/* Static Memory Read Delay x */
+#define MEM_SMRD(x)	__REG2(0xa070020c, (x) << 3)
+
+/* Static Memory Page Mode Read Delay 0 */
+#define MEM_SMPMRD(x)	__REG2(0xa0700210, (x) << 3)
+
+/* Static Memory Write Delay */
+#define MEM_SMWD(x)	__REG2(0xa0700214, (x) << 3)
+
+/* Static Memory Turn Round Delay x */
+#define MEM_SWT(x)	__REG2(0xa0700218, (x) << 3)
+
+#endif /* ifndef __ASM_ARCH_REGSMEM_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/regs-sys.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/regs-sys.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/regs-sys.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,157 @@
+/*
+ * include/asm-arm/arch-ns9xxx/regs-sys.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_REGSSYS_H
+#define __ASM_ARCH_REGSSYS_H
+
+#include <asm/hardware.h>
+
+/* System Control Module */
+
+/* AHB Arbiter Gen Configuration */
+#define SYS_AHBAGENCONF	__REG(0xa0900000)
+
+/* BRC */
+#define SYS_BRC(x)	__REG2(0xa0900004, (x))
+
+/* Timer x Reload Count register */
+#define SYS_TRC(x)	__REG2(0xa0900044, (x))
+
+/* Timer x Read register */
+#define SYS_TR(x)	__REG2(0xa0900084, (x))
+
+/* Interrupt Vector Address Register Level x */
+#define SYS_IVA(x)	__REG2(0xa09000c4, (x))
+
+/* Interrupt Configuration registers */
+#define SYS_IC(x)	__REG2(0xa0900144, (x))
+
+/* ISRADDR */
+#define SYS_ISRADDR	__REG(0xa0900164)
+
+/* Interrupt Status Active */
+#define SYS_ISA		__REG(0xa0900168)
+
+/* Interrupt Status Raw */
+#define SYS_ISR		__REG(0xa090016c)
+
+/* Timer Interrupt Status register */
+#define SYS_TIS		__REG(0xa0900170)
+
+/* PLL Configuration register */
+#define SYS_PLL		__REG(0xa0900188)
+
+/* PLL Configuration register: PLL SW change */
+#define SYS_PLL_SWC		__REGBIT(15)
+#define SYS_PLL_SWC_NO			__REGVAL(SYS_PLL_SWC, 0)
+#define SYS_PLL_SWC_YES			__REGVAL(SYS_PLL_SWC, 1)
+
+/* Timer x Control register */
+#define SYS_TC(x)	__REG2(0xa0900190, (x))
+
+/* Timer x Control register: Timer enable */
+#define SYS_TCx_TEN		__REGBIT(15)
+#define SYS_TCx_TEN_DIS			__REGVAL(SYS_TCx_TEN, 1)
+#define SYS_TCx_TEN_EN			__REGVAL(SYS_TCx_TEN, 1)
+
+/* Timer x Control register: CPU debug mode */
+#define SYS_TCx_TDBG		__REGBIT(10)
+#define SYS_TCx_TDBG_CONT		__REGVAL(SYS_TCx_TDBG, 0)
+#define SYS_TCx_TDBG_STOP		__REGVAL(SYS_TCx_TDBG, 1)
+
+/* Timer x Control register: Interrupt clear */
+#define SYS_TCx_INTC		__REGBIT(9)
+#define SYS_TCx_INTC_UNSET		__REGVAL(SYS_TCx_INTC, 0)
+#define SYS_TCx_INTC_SET		__REGVAL(SYS_TCx_INTC, 1)
+
+/* Timer x Control register: Timer clock select */
+#define SYS_TCx_TLCS		__REGBITS(8, 6)
+#define SYS_TCx_TLCS_CPU		__REGVAL(SYS_TCx_TLCS, 0)	/* CPU clock */
+#define SYS_TCx_TLCS_DIV2		__REGVAL(SYS_TCx_TLCS, 1)	/* CPU clock / 2 */
+#define SYS_TCx_TLCS_DIV4		__REGVAL(SYS_TCx_TLCS, 2)	/* CPU clock / 4 */
+#define SYS_TCx_TLCS_DIV8		__REGVAL(SYS_TCx_TLCS, 3)	/* CPU clock / 8 */
+#define SYS_TCx_TLCS_DIV16		__REGVAL(SYS_TCx_TLCS, 4)	/* CPU clock / 16 */
+#define SYS_TCx_TLCS_DIV32		__REGVAL(SYS_TCx_TLCS, 5)	/* CPU clock / 32 */
+#define SYS_TCx_TLCS_DIV64		__REGVAL(SYS_TCx_TLCS, 6)	/* CPU clock / 64 */
+#define SYS_TCx_TLCS_EXT		__REGVAL(SYS_TCx_TLCS, 7)
+
+/* Timer x Control register: Timer mode */
+#define SYS_TCx_TM		__REGBITS(5, 4)
+#define SYS_TCx_TM_IEE			__REGVAL(SYS_TCx_TM, 0)		/* Internal timer or external event */
+#define SYS_TCx_TM_ELL			__REGVAL(SYS_TCx_TM, 1)		/* External low-level, gated timer */
+#define SYS_TCx_TM_EHL			__REGVAL(SYS_TCx_TM, 2)		/* External high-level, gated timer */
+#define SYS_TCx_TM_CONCAT		__REGVAL(SYS_TCx_TM, 3)		/* Concatenate the lower timer. */
+
+/* Timer x Control register: Interrupt select */
+#define SYS_TCx_INTS		__REGBIT(3)
+#define SYS_TCx_INTS_DIS		__REGVAL(SYS_TCx_INTS, 0)
+#define SYS_TCx_INTS_EN			__REGVAL(SYS_TCx_INTS, 1)
+
+/* Timer x Control register: Up/down select */
+#define SYS_TCx_UDS		__REGBIT(2)
+#define SYS_TCx_UDS_UP			__REGVAL(SYS_TCx_UDS, 0)
+#define SYS_TCx_UDS_DOWN		__REGVAL(SYS_TCx_UDS, 1)
+
+/* Timer x Control register: 32- or 16-bit timer */
+#define SYS_TCx_TSZ		__REGBIT(1)
+#define SYS_TCx_TSZ_16			__REGVAL(SYS_TCx_TSZ, 0)
+#define SYS_TCx_TSZ_32			__REGVAL(SYS_TCx_TSZ, 1)
+
+/* Timer x Control register: Reload enable */
+#define SYS_TCx_REN		__REGBIT(0)
+#define SYS_TCx_REN_DIS			__REGVAL(SYS_TCx_REN, 0)
+#define SYS_TCx_REN_EN			__REGVAL(SYS_TCx_REN, 1)
+
+/* System Memory Chip Select x Dynamic Memory Base */
+#define SYS_SMCSDMB(x)	__REG2(0xa09001d0, (x) << 1)
+
+/* System Memory Chip Select x Dynamic Memory Mask */
+#define SYS_SMCSDMM(x)	__REG2(0xa09001d4, (x) << 1)
+
+/* System Memory Chip Select x Static Memory Base */
+#define SYS_SMCSSMB(x)	__REG2(0xa09001f0, (x) << 1)
+
+/* System Memory Chip Select x Static Memory Base: Chip select x base */
+#define SYS_SMCSSMB_CSxB	__REGBITS(31, 12)
+
+/* System Memory Chip Select x Static Memory Mask */
+#define SYS_SMCSSMM(x)	__REG2(0xa09001f4, (x) << 1)
+
+/* System Memory Chip Select x Static Memory Mask: Chip select x mask */
+#define SYS_SMCSSMM_CSxM	__REGBITS(31, 12)
+
+/* System Memory Chip Select x Static Memory Mask: Chip select x enable */
+#define SYS_SMCSSMM_CSEx	__REGBIT(0)
+#define SYS_SMCSSMM_CSEx_DIS		__REGVAL(SYS_SMCSSMM_CSEx, 0)
+#define SYS_SMCSSMM_CSEx_EN		__REGVAL(SYS_SMCSSMM_CSEx, 1)
+
+/* General purpose, user-defined ID register */
+#define SYS_GENID	__REG(0xa0900210)
+
+/* External Interrupt x Control register */
+#define SYS_EIC(x)	__REG2(0xa0900214, (x))
+
+/* External Interrupt x Control register: Status */
+#define SYS_EIC_STS		__REGBIT(3)
+
+/* External Interrupt x Control register: Clear */
+#define SYS_EIC_CLR		__REGBIT(2)
+
+/* External Interrupt x Control register: Polarity */
+#define SYS_EIC_PLTY		__REGBIT(1)
+#define SYS_EIC_PLTY_AH			__REGVAL(SYS_EIC_PLTY, 0)
+#define SYS_EIC_PLTY_AL			__REGVAL(SYS_EIC_PLTY, 1)
+
+/* External Interrupt x Control register: Level edge */
+#define SYS_EIC_LVEDG		__REGBIT(0)
+#define SYS_EIC_LVEDG_LEVEL		__REGVAL(SYS_EIC_LVEDG, 0)
+#define SYS_EIC_LVEDG_EDGE		__REGVAL(SYS_EIC_LVEDG, 1)
+
+#endif /* ifndef __ASM_ARCH_REGSSYS_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,34 @@
+/*
+ * include/asm-arm/arch-ns9xxx/system.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/proc-fns.h>
+#include <asm/arch-ns9xxx/regs-sys.h>
+#include <asm/mach-types.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	u32 reg;
+
+	reg = SYS_PLL >> 16;
+	REGSET(reg, SYS_PLL, SWC, YES);
+	SYS_PLL = reg;
+
+	BUG();
+}
+
+#endif /* ifndef __ASM_ARCH_SYSTEM_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-ns9xxx/timex.h
+ *
+ * Copyright (C) 2005-2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+/*
+ * value for CLOCK_TICK_RATE stolen from include/asm-arm/arch-s3c2410/timex.h.
+ * See there for an explanation.
+ */
+#define CLOCK_TICK_RATE         12000000
+
+#endif /* ifndef __ASM_ARCH_TIMEX_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,35 @@
+/*
+ * include/asm-arm/arch-ns9xxx/uncompress.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+static void putc(char c)
+{
+	volatile u8 *base = (volatile u8 *)0x40000000;
+	int t = 0x10000;
+
+	do {
+		if (base[5] & 0x20) {
+			base[0] = c;
+			break;
+		}
+	} while (--t);
+}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+static void flush(void)
+{
+	/* nothing */
+}
+
+#endif /* ifndef __ASM_ARCH_UNCOMPRESS_H */
Index: build_tree/linux/include/asm/arch-ns9xxx/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-ns9xxx/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-ns9xxx/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+/*
+ * include/asm-arm/arch-ns9xxx/vmalloc.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END     (0xf0000000)
+
+#endif /* ifndef __ASM_ARCH_VMALLOC_H */
Index: build_tree/linux/include/asm/arch-omap/aic23.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/aic23.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/aic23.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,116 @@
+/*
+ * linux/include/asm-arm/arch-omap/aic23.h
+ *
+ * Hardware definitions for TI TLV320AIC23 audio codec
+ *
+ * Copyright (C) 2002 RidgeRun, Inc.
+ * Author: Steve Johnson
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_AIC23_H
+#define __ASM_ARCH_AIC23_H
+
+// Codec TLV320AIC23
+#define LEFT_LINE_VOLUME_ADDR		0x00
+#define RIGHT_LINE_VOLUME_ADDR		0x01
+#define LEFT_CHANNEL_VOLUME_ADDR	0x02
+#define RIGHT_CHANNEL_VOLUME_ADDR	0x03
+#define ANALOG_AUDIO_CONTROL_ADDR	0x04
+#define DIGITAL_AUDIO_CONTROL_ADDR	0x05
+#define POWER_DOWN_CONTROL_ADDR		0x06
+#define DIGITAL_AUDIO_FORMAT_ADDR	0x07
+#define SAMPLE_RATE_CONTROL_ADDR	0x08
+#define DIGITAL_INTERFACE_ACT_ADDR	0x09
+#define RESET_CONTROL_ADDR		0x0F
+
+// Left (right) line input volume control register
+#define LRS_ENABLED			0x0100
+#define LIM_MUTED			0x0080
+#define LIV_DEFAULT			0x0017
+#define LIV_MAX				0x001f
+#define LIV_MIN				0x0000
+
+// Left (right) channel headphone volume control register
+#define LZC_ON				0x0080
+#define LHV_DEFAULT			0x0079
+#define LHV_MAX				0x007f
+#define LHV_MIN				0x0000
+
+// Analog audio path control register
+#define STA_REG(x)			((x)<<6)
+#define STE_ENABLED			0x0020
+#define DAC_SELECTED			0x0010
+#define BYPASS_ON			0x0008
+#define INSEL_MIC			0x0004
+#define MICM_MUTED			0x0002
+#define MICB_20DB			0x0001
+
+// Digital audio path control register
+#define DACM_MUTE			0x0008
+#define DEEMP_32K			0x0002
+#define DEEMP_44K			0x0004
+#define DEEMP_48K			0x0006
+#define ADCHP_ON			0x0001
+
+// Power control down register
+#define DEVICE_POWER_OFF	  	0x0080
+#define CLK_OFF				0x0040
+#define OSC_OFF				0x0020
+#define OUT_OFF				0x0010
+#define DAC_OFF				0x0008
+#define ADC_OFF				0x0004
+#define MIC_OFF				0x0002
+#define LINE_OFF			0x0001
+
+// Digital audio interface register
+#define MS_MASTER			0x0040
+#define LRSWAP_ON			0x0020
+#define LRP_ON				0x0010
+#define IWL_16				0x0000
+#define IWL_20				0x0004
+#define IWL_24				0x0008
+#define IWL_32				0x000C
+#define FOR_I2S				0x0002
+#define FOR_DSP				0x0003
+
+// Sample rate control register
+#define CLKOUT_HALF			0x0080
+#define CLKIN_HALF			0x0040
+#define BOSR_384fs			0x0002 // BOSR_272fs when in USB mode
+#define USB_CLK_ON			0x0001
+#define SR_MASK                         0xf
+#define CLKOUT_SHIFT                    7
+#define CLKIN_SHIFT                     6
+#define SR_SHIFT                        2
+#define BOSR_SHIFT                      1
+
+// Digital interface register
+#define ACT_ON				0x0001
+
+#define TLV320AIC23ID1                  (0x1a)	// cs low
+#define TLV320AIC23ID2                  (0x1b)	// cs high
+
+void tlv320aic23_power_up(void);
+void tlv320aic23_power_down(void);
+
+#endif /* __ASM_ARCH_AIC23_H */
Index: build_tree/linux/include/asm/arch-omap/board-ams-delta.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-ams-delta.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-ams-delta.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,76 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-ams-delta.h
+ *
+ * Copyright (C) 2006 Jonathan McDowell <noodles@earth.li>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef __ASM_ARCH_OMAP_AMS_DELTA_H
+#define __ASM_ARCH_OMAP_AMS_DELTA_H
+
+#if defined (CONFIG_MACH_AMS_DELTA)
+
+#define AMS_DELTA_LATCH1_PHYS		0x01000000
+#define AMS_DELTA_LATCH1_VIRT		0xEA000000
+#define AMS_DELTA_MODEM_PHYS		0x04000000
+#define AMS_DELTA_MODEM_VIRT		0xEB000000
+#define AMS_DELTA_LATCH2_PHYS		0x08000000
+#define AMS_DELTA_LATCH2_VIRT		0xEC000000
+
+#define AMS_DELTA_LATCH1_LED_CAMERA	0x01
+#define AMS_DELTA_LATCH1_LED_ADVERT	0x02
+#define AMS_DELTA_LATCH1_LED_EMAIL	0x04
+#define AMS_DELTA_LATCH1_LED_HANDSFREE	0x08
+#define AMS_DELTA_LATCH1_LED_VOICEMAIL	0x10
+#define AMS_DELTA_LATCH1_LED_VOICE	0x20
+
+#define AMS_DELTA_LATCH2_LCD_VBLEN	0x0001
+#define AMS_DELTA_LATCH2_LCD_NDISP	0x0002
+#define AMS_DELTA_LATCH2_NAND_NCE	0x0004
+#define AMS_DELTA_LATCH2_NAND_NRE	0x0008
+#define AMS_DELTA_LATCH2_NAND_NWP	0x0010
+#define AMS_DELTA_LATCH2_NAND_NWE	0x0020
+#define AMS_DELTA_LATCH2_NAND_ALE	0x0040
+#define AMS_DELTA_LATCH2_NAND_CLE	0x0080
+#define AMD_DELTA_LATCH2_KEYBRD_PWR	0x0100
+#define AMD_DELTA_LATCH2_KEYBRD_DATA	0x0200
+#define AMD_DELTA_LATCH2_SCARD_RSTIN	0x0400
+#define AMD_DELTA_LATCH2_SCARD_CMDVCC	0x0800
+#define AMS_DELTA_LATCH2_MODEM_NRESET	0x1000
+#define AMS_DELTA_LATCH2_MODEM_CODEC	0x2000
+
+#define AMS_DELTA_GPIO_PIN_KEYBRD_DATA	0
+#define AMS_DELTA_GPIO_PIN_KEYBRD_CLK	1
+#define AMS_DELTA_GPIO_PIN_MODEM_IRQ	2
+#define AMS_DELTA_GPIO_PIN_HOOK_SWITCH	4
+#define AMS_DELTA_GPIO_PIN_SCARD_NOFF	6
+#define AMS_DELTA_GPIO_PIN_SCARD_IO	7
+#define AMS_DELTA_GPIO_PIN_CONFIG	11
+#define AMS_DELTA_GPIO_PIN_NAND_RB	12
+
+#ifndef __ASSEMBLY__
+void ams_delta_latch1_write(u8 mask, u8 value);
+void ams_delta_latch2_write(u16 mask, u16 value);
+#endif
+
+#endif /* CONFIG_MACH_AMS_DELTA */
+
+#endif /* __ASM_ARCH_OMAP_AMS_DELTA_H */
Index: build_tree/linux/include/asm/arch-omap/board-apollon.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-apollon.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-apollon.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,45 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-apollon.h
+ *
+ * Hardware definitions for Samsung OMAP24XX Apollon board.
+ *
+ * Initial creation by Kyungmin Park <kyungmin.park@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_APOLLON_H
+#define __ASM_ARCH_OMAP_APOLLON_H
+
+/* Placeholder for APOLLON specific defines */
+/* GPMC CS0 */
+#define APOLLON_CS0_BASE		0x00000000
+/* GPMC CS1 */
+#define APOLLON_CS1_BASE		0x08000000
+#define APOLLON_ETHR_START		(APOLLON_CS1_BASE + 0x300)
+#define APOLLON_ETHR_GPIO_IRQ		74
+/* GPMC CS2 - reserved for OneNAND */
+#define APOLLON_CS2_BASE		0x10000000
+/* GPMC CS3 - reserved for NOR or NAND */
+#define APOLLON_CS3_BASE		0x18000000
+
+#endif /*  __ASM_ARCH_OMAP_APOLLON_H */
+
Index: build_tree/linux/include/asm/arch-omap/board-fsample.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-fsample.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-fsample.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,51 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-fsample.h
+ *
+ * Board-specific goodies for TI F-Sample.
+ *
+ * Copyright (C) 2006 Google, Inc.
+ * Author: Brian Swetland <swetland@google.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_OMAP_FSAMPLE_H
+#define __ASM_ARCH_OMAP_FSAMPLE_H
+
+/* fsample is pretty close to p2-sample */
+#include <asm/arch/board-perseus2.h>
+
+#define fsample_cpld_read(reg) __raw_readb(reg)
+#define fsample_cpld_write(val, reg) __raw_writeb(val, reg)
+
+#define FSAMPLE_CPLD_BASE    0xE8100000
+#define FSAMPLE_CPLD_SIZE    SZ_4K
+#define FSAMPLE_CPLD_START   0x05080000
+
+#define FSAMPLE_CPLD_REG_A   (FSAMPLE_CPLD_BASE + 0x00)
+#define FSAMPLE_CPLD_SWITCH  (FSAMPLE_CPLD_BASE + 0x02)
+#define FSAMPLE_CPLD_UART    (FSAMPLE_CPLD_BASE + 0x02)
+#define FSAMPLE_CPLD_REG_B   (FSAMPLE_CPLD_BASE + 0x04)
+#define FSAMPLE_CPLD_VERSION (FSAMPLE_CPLD_BASE + 0x06)
+#define FSAMPLE_CPLD_SET_CLR (FSAMPLE_CPLD_BASE + 0x06)
+
+#define FSAMPLE_CPLD_BIT_BT_RESET         0
+#define FSAMPLE_CPLD_BIT_LCD_RESET        1
+#define FSAMPLE_CPLD_BIT_CAM_PWDN         2
+#define FSAMPLE_CPLD_BIT_CHARGER_ENABLE   3
+#define FSAMPLE_CPLD_BIT_SD_MMC_EN        4
+#define FSAMPLE_CPLD_BIT_aGPS_PWREN       5
+#define FSAMPLE_CPLD_BIT_BACKLIGHT        6
+#define FSAMPLE_CPLD_BIT_aGPS_EN_RESET    7
+#define FSAMPLE_CPLD_BIT_aGPS_SLEEPx_N    8
+#define FSAMPLE_CPLD_BIT_OTG_RESET        9
+
+#define fsample_cpld_set(bit) \
+    fsample_cpld_write((((bit) & 15) << 4) | 0x0f, FSAMPLE_CPLD_SET_CLR)
+
+#define fsample_cpld_clear(bit) \
+    fsample_cpld_write(0xf0 | ((bit) & 15), FSAMPLE_CPLD_SET_CLR)
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/board-h2.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-h2.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-h2.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-h2.h
+ *
+ * Hardware definitions for TI OMAP1610 H2 board.
+ *
+ * Cleanup for Linux-2.6 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_H2_H
+#define __ASM_ARCH_OMAP_H2_H
+
+/* Placeholder for H2 specific defines */
+
+/* At OMAP1610 Innovator the Ethernet is directly connected to CS1 */
+#define OMAP1610_ETHR_START		0x04000300
+
+#endif /*  __ASM_ARCH_OMAP_H2_H */
+
Index: build_tree/linux/include/asm/arch-omap/board-h3.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-h3.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-h3.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-h3.h
+ *
+ * Copyright (C) 2001 RidgeRun, Inc.
+ * Copyright (C) 2004 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef __ASM_ARCH_OMAP_H3_H
+#define __ASM_ARCH_OMAP_H3_H
+
+/* In OMAP1710 H3 the Ethernet is directly connected to CS1 */
+#define OMAP1710_ETHR_START		0x04000300
+
+#define MAXIRQNUM			(IH_BOARD_BASE)
+#define MAXFIQNUM			MAXIRQNUM
+#define MAXSWINUM			MAXIRQNUM
+
+#define NR_IRQS				(MAXIRQNUM + 1)
+
+
+#endif /*  __ASM_ARCH_OMAP_H3_H */
Index: build_tree/linux/include/asm/arch-omap/board-h4.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-h4.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-h4.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-h4.h
+ *
+ * Hardware definitions for TI OMAP1610 H4 board.
+ *
+ * Initial creation by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_H4_H
+#define __ASM_ARCH_OMAP_H4_H
+
+/* Placeholder for H4 specific defines */
+/* GPMC CS1 */
+#define OMAP24XX_ETHR_START             0x08000300
+#define OMAP24XX_ETHR_GPIO_IRQ		92
+#define H4_CS0_BASE			0x04000000
+#endif /*  __ASM_ARCH_OMAP_H4_H */
+
Index: build_tree/linux/include/asm/arch-omap/board-innovator.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-innovator.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-innovator.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,55 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-innovator.h
+ *
+ * Copyright (C) 2001 RidgeRun, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef __ASM_ARCH_OMAP_INNOVATOR_H
+#define __ASM_ARCH_OMAP_INNOVATOR_H
+
+#if defined (CONFIG_ARCH_OMAP15XX)
+
+#ifndef OMAP_SDRAM_DEVICE
+#define OMAP_SDRAM_DEVICE			D256M_1X16_4B
+#endif
+
+#define OMAP1510P1_IMIF_PRI_VALUE		0x00
+#define OMAP1510P1_EMIFS_PRI_VALUE		0x00
+#define OMAP1510P1_EMIFF_PRI_VALUE		0x00
+
+#define NR_FPGA_IRQS		24
+#define NR_IRQS                 IH_BOARD_BASE + NR_FPGA_IRQS
+
+#ifndef __ASSEMBLY__
+void fpga_write(unsigned char val, int reg);
+unsigned char fpga_read(int reg);
+#endif
+
+#endif /* CONFIG_ARCH_OMAP15XX */
+
+#if defined (CONFIG_ARCH_OMAP16XX)
+
+/* At OMAP1610 Innovator the Ethernet is directly connected to CS1 */
+#define INNOVATOR1610_ETHR_START	0x04000300
+
+#endif /* CONFIG_ARCH_OMAP1610 */
+#endif /* __ASM_ARCH_OMAP_INNOVATOR_H */
Index: build_tree/linux/include/asm/arch-omap/board-nokia.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-nokia.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-nokia.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,54 @@
+/*
+ *  linux/include/asm-arm/arch-omap/board-nokia.h
+ *
+ *  Information structures for Nokia-specific board config data
+ *
+ *  Copyright (C) 2005	Nokia Corporation
+ */
+
+#ifndef _OMAP_BOARD_NOKIA_H
+#define _OMAP_BOARD_NOKIA_H
+
+#include <linux/types.h>
+
+#define OMAP_TAG_NOKIA_BT	0x4e01
+#define OMAP_TAG_WLAN_CX3110X	0x4e02
+#define OMAP_TAG_CBUS		0x4e03
+#define OMAP_TAG_EM_ASIC_BB5	0x4e04
+
+
+#define BT_CHIP_CSR		1
+#define BT_CHIP_TI		2
+
+#define BT_SYSCLK_12		1
+#define BT_SYSCLK_38_4		2
+
+struct omap_bluetooth_config {
+	u8    chip_type;
+	u8    bt_wakeup_gpio;
+	u8    host_wakeup_gpio;
+	u8    reset_gpio;
+	u8    bt_uart;
+	u8    bd_addr[6];
+	u8    bt_sysclk;
+};
+
+struct omap_wlan_cx3110x_config {
+	u8  chip_type;
+	s16 power_gpio;
+	s16 irq_gpio;
+	s16 spi_cs_gpio;
+};
+
+struct omap_cbus_config {
+	s16 clk_gpio;
+	s16 dat_gpio;
+	s16 sel_gpio;
+};
+
+struct omap_em_asic_bb5_config {
+	s16 retu_irq_gpio;
+	s16 tahvo_irq_gpio;
+};
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/board-osk.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-osk.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-osk.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-osk.h
+ *
+ * Hardware definitions for TI OMAP5912 OSK board.
+ *
+ * Written by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_OSK_H
+#define __ASM_ARCH_OMAP_OSK_H
+
+/* At OMAP5912 OSK the Ethernet is directly connected to CS1 */
+#define OMAP_OSK_ETHR_START		0x04800300
+
+#endif /*  __ASM_ARCH_OMAP_OSK_H */
+
Index: build_tree/linux/include/asm/arch-omap/board-perseus2.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-perseus2.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-perseus2.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,45 @@
+/*
+ *  linux/include/asm-arm/arch-omap/board-perseus2.h
+ *
+ *  Copyright 2003 by Texas Instruments Incorporated
+ *    OMAP730 / Perseus2 support by Jean Pihet
+ *
+ * Copyright (C) 2001 RidgeRun, Inc. (http://www.ridgerun.com)
+ * Author: RidgeRun, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef __ASM_ARCH_OMAP_PERSEUS2_H
+#define __ASM_ARCH_OMAP_PERSEUS2_H
+
+#include <asm/arch/fpga.h>
+
+#ifndef OMAP_SDRAM_DEVICE
+#define OMAP_SDRAM_DEVICE		D256M_1X16_4B
+#endif
+
+#define MAXIRQNUM		IH_BOARD_BASE
+#define MAXFIQNUM		MAXIRQNUM
+#define MAXSWINUM		MAXIRQNUM
+
+#define NR_IRQS			(MAXIRQNUM + 1)
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/board-voiceblue.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board-voiceblue.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board-voiceblue.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2004 2N Telekomunikace, Ladislav Michl <michl@2n.cz>
+ *
+ * Hardware definitions for OMAP5910 based VoiceBlue board.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_VOICEBLUE_H
+#define __ASM_ARCH_VOICEBLUE_H
+
+extern void voiceblue_wdt_enable(void);
+extern void voiceblue_wdt_disable(void);
+extern void voiceblue_wdt_ping(void);
+extern void voiceblue_reset(void);
+
+#endif /*  __ASM_ARCH_VOICEBLUE_H */
+
Index: build_tree/linux/include/asm/arch-omap/board.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/board.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/board.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,175 @@
+/*
+ *  linux/include/asm-arm/arch-omap/board.h
+ *
+ *  Information structures for board-specific data
+ *
+ *  Copyright (C) 2004	Nokia Corporation
+ *  Written by Juha Yrjl <juha.yrjola@nokia.com>
+ */
+
+#ifndef _OMAP_BOARD_H
+#define _OMAP_BOARD_H
+
+#include <linux/types.h>
+
+/* Different peripheral ids */
+#define OMAP_TAG_CLOCK		0x4f01
+#define OMAP_TAG_MMC		0x4f02
+#define OMAP_TAG_SERIAL_CONSOLE 0x4f03
+#define OMAP_TAG_USB		0x4f04
+#define OMAP_TAG_LCD		0x4f05
+#define OMAP_TAG_GPIO_SWITCH	0x4f06
+#define OMAP_TAG_UART		0x4f07
+#define OMAP_TAG_FBMEM		0x4f08
+#define OMAP_TAG_STI_CONSOLE	0x4f09
+#define OMAP_TAG_CAMERA_SENSOR	0x4f0a
+
+#define OMAP_TAG_BOOT_REASON    0x4f80
+#define OMAP_TAG_FLASH_PART	0x4f81
+#define OMAP_TAG_VERSION_STR	0x4f82
+
+struct omap_clock_config {
+	/* 0 for 12 MHz, 1 for 13 MHz and 2 for 19.2 MHz */
+	u8 system_clock_type;
+};
+
+struct omap_mmc_conf {
+	unsigned enabled:1;
+	/* nomux means "standard" muxing is wrong on this board, and that
+	 * board-specific code handled it before common init logic.
+	 */
+	unsigned nomux:1;
+	/* switch pin can be for card detect (default) or card cover */
+	unsigned cover:1;
+	/* 4 wire signaling is optional, and is only used for SD/SDIO */
+	unsigned wire4:1;
+	s16 power_pin;
+	s16 switch_pin;
+	s16 wp_pin;
+};
+
+struct omap_mmc_config {
+	struct omap_mmc_conf mmc[2];
+};
+
+struct omap_serial_console_config {
+	u8 console_uart;
+	u32 console_speed;
+};
+
+struct omap_sti_console_config {
+	unsigned enable:1;
+	u8 channel;
+};
+
+struct omap_camera_sensor_config {
+	u16 reset_gpio;
+	int (*power_on)(void * data);
+	int (*power_off)(void * data);
+};
+
+struct omap_usb_config {
+	/* Configure drivers according to the connectors on your board:
+	 *  - "A" connector (rectagular)
+	 *	... for host/OHCI use, set "register_host".
+	 *  - "B" connector (squarish) or "Mini-B"
+	 *	... for device/gadget use, set "register_dev".
+	 *  - "Mini-AB" connector (very similar to Mini-B)
+	 *	... for OTG use as device OR host, initialize "otg"
+	 */
+	unsigned	register_host:1;
+	unsigned	register_dev:1;
+	u8		otg;	/* port number, 1-based:  usb1 == 2 */
+
+	u8		hmc_mode;
+
+	/* implicitly true if otg:  host supports remote wakeup? */
+	u8		rwc;
+
+	/* signaling pins used to talk to transceiver on usbN:
+	 *  0 == usbN unused
+	 *  2 == usb0-only, using internal transceiver
+	 *  3 == 3 wire bidirectional
+	 *  4 == 4 wire bidirectional
+	 *  6 == 6 wire unidirectional (or TLL)
+	 */
+	u8		pins[3];
+};
+
+struct omap_lcd_config {
+	char panel_name[16];
+	char ctrl_name[16];
+};
+
+struct omap_fbmem_config {
+	u32 fb_sram_start;
+	u32 fb_sram_size;
+	u32 fb_sdram_start;
+	u32 fb_sdram_size;
+};
+
+/* Cover:
+ *      high -> closed
+ *      low  -> open
+ * Connection:
+ *      high -> connected
+ *      low  -> disconnected
+ */
+#define OMAP_GPIO_SWITCH_TYPE_COVER		0x0000
+#define OMAP_GPIO_SWITCH_TYPE_CONNECTION	0x0001
+#define OMAP_GPIO_SWITCH_FLAG_INVERTED		0x0001
+#define OMAP_GPIO_SWITCH_FLAG_OUTPUT		0x0002
+struct omap_gpio_switch_config {
+	char name[12];
+	u16 gpio;
+	int flags:4;
+	int type:4;
+	int key_code:24; /* Linux key code */
+};
+
+struct omap_uart_config {
+	/* Bit field of UARTs present; bit 0 --> UART1 */
+	unsigned int enabled_uarts;
+};
+
+
+struct omap_flash_part_config {
+	char part_table[0];
+};
+
+struct omap_boot_reason_config {
+	char reason_str[12];
+};
+
+struct omap_version_config {
+	char component[12];
+	char version[12];
+};
+
+
+#include <asm-arm/arch-omap/board-nokia.h>
+
+struct omap_board_config_entry {
+	u16 tag;
+	u16 len;
+	u8  data[0];
+};
+
+struct omap_board_config_kernel {
+	u16 tag;
+	const void *data;
+};
+
+extern const void *__omap_get_config(u16 tag, size_t len, int nr);
+
+#define omap_get_config(tag, type) \
+	((const type *) __omap_get_config((tag), sizeof(type), 0))
+#define omap_get_nr_config(tag, type, nr) \
+	((const type *) __omap_get_config((tag), sizeof(type), (nr)))
+
+extern const void *omap_get_var_config(u16 tag, size_t *len);
+
+extern struct omap_board_config_kernel *omap_board_config;
+extern int omap_board_config_size;
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/clock.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/clock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/clock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,91 @@
+/*
+ *  linux/include/asm-arm/arch-omap/clock.h
+ *
+ *  Copyright (C) 2004 - 2005 Nokia corporation
+ *  Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *  Based on clocks.h by Tony Lindgren, Gordon McNutt and RidgeRun, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ARCH_ARM_OMAP_CLOCK_H
+#define __ARCH_ARM_OMAP_CLOCK_H
+
+struct module;
+
+struct clk {
+	struct list_head	node;
+	struct module		*owner;
+	const char		*name;
+	int			id;
+	struct clk		*parent;
+	unsigned long		rate;
+	__u32			flags;
+	void __iomem		*enable_reg;
+	__u8			enable_bit;
+	__u8			rate_offset;
+	__u8			src_offset;
+	__s8			usecount;
+	void			(*recalc)(struct clk *);
+	int			(*set_rate)(struct clk *, unsigned long);
+	long			(*round_rate)(struct clk *, unsigned long);
+	void			(*init)(struct clk *);
+	int			(*enable)(struct clk *);
+	void			(*disable)(struct clk *);
+};
+
+struct clk_functions {
+	int		(*clk_enable)(struct clk *clk);
+	void		(*clk_disable)(struct clk *clk);
+	long		(*clk_round_rate)(struct clk *clk, unsigned long rate);
+	int		(*clk_set_rate)(struct clk *clk, unsigned long rate);
+	int		(*clk_set_parent)(struct clk *clk, struct clk *parent);
+	struct clk *	(*clk_get_parent)(struct clk *clk);
+	void		(*clk_allow_idle)(struct clk *clk);
+	void		(*clk_deny_idle)(struct clk *clk);
+	void		(*clk_disable_unused)(struct clk *clk);
+};
+
+extern unsigned int mpurate;
+
+extern int clk_init(struct clk_functions * custom_clocks);
+extern int clk_register(struct clk *clk);
+extern void clk_unregister(struct clk *clk);
+extern void propagate_rate(struct clk *clk);
+extern void followparent_recalc(struct clk * clk);
+extern void clk_allow_idle(struct clk *clk);
+extern void clk_deny_idle(struct clk *clk);
+extern int clk_get_usecount(struct clk *clk);
+
+/* Clock flags */
+#define RATE_CKCTL		(1 << 0)	/* Main fixed ratio clocks */
+#define RATE_FIXED		(1 << 1)	/* Fixed clock rate */
+#define RATE_PROPAGATES		(1 << 2)	/* Program children too */
+#define VIRTUAL_CLOCK		(1 << 3)	/* Composite clock from table */
+#define ALWAYS_ENABLED		(1 << 4)	/* Clock cannot be disabled */
+#define ENABLE_REG_32BIT	(1 << 5)	/* Use 32-bit access */
+#define VIRTUAL_IO_ADDRESS	(1 << 6)	/* Clock in virtual address */
+#define CLOCK_IDLE_CONTROL	(1 << 7)
+#define CLOCK_NO_IDLE_PARENT	(1 << 8)
+#define DELAYED_APP		(1 << 9)	/* Delay application of clock */
+#define CONFIG_PARTICIPANT	(1 << 10)	/* Fundamental clock */
+#define CM_MPU_SEL1		(1 << 11)	/* Domain divider/source */
+#define CM_DSP_SEL1		(1 << 12)
+#define CM_GFX_SEL1		(1 << 13)
+#define CM_MODEM_SEL1		(1 << 14)
+#define CM_CORE_SEL1		(1 << 15)	/* Sets divider for many */
+#define CM_CORE_SEL2		(1 << 16)	/* sets parent for GPT */
+#define CM_WKUP_SEL1		(1 << 17)
+#define CM_PLL_SEL1		(1 << 18)
+#define CM_PLL_SEL2		(1 << 19)
+#define CM_SYSCLKOUT_SEL1	(1 << 20)
+#define CLOCK_IN_OMAP310	(1 << 21)
+#define CLOCK_IN_OMAP730	(1 << 22)
+#define CLOCK_IN_OMAP1510	(1 << 23)
+#define CLOCK_IN_OMAP16XX	(1 << 24)
+#define CLOCK_IN_OMAP242X	(1 << 25)
+#define CLOCK_IN_OMAP243X	(1 << 26)
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/common.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/common.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/common.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ * linux/include/asm-arm/arch-omap/common.h
+ *
+ * Header for code common to all OMAP machines.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ARCH_ARM_MACH_OMAP_COMMON_H
+#define __ARCH_ARM_MACH_OMAP_COMMON_H
+
+struct sys_timer;
+
+extern void omap_map_common_io(void);
+extern struct sys_timer omap_timer;
+extern void omap_serial_init(void);
+
+#endif /* __ARCH_ARM_MACH_OMAP_COMMON_H */
Index: build_tree/linux/include/asm/arch-omap/cpu.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/cpu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/cpu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,252 @@
+/*
+ * linux/include/asm-arm/arch-omap/cpu.h
+ *
+ * OMAP cpu type detection
+ *
+ * Copyright (C) 2004 Nokia Corporation
+ *
+ * Written by Tony Lindgren <tony.lindgren@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __ASM_ARCH_OMAP_CPU_H
+#define __ASM_ARCH_OMAP_CPU_H
+
+extern unsigned int system_rev;
+
+#define omap2_cpu_rev()		((system_rev >> 8) & 0x0f)
+
+/*
+ * Test if multicore OMAP support is needed
+ */
+#undef MULTI_OMAP1
+#undef MULTI_OMAP2
+#undef OMAP_NAME
+
+#ifdef CONFIG_ARCH_OMAP730
+# ifdef OMAP_NAME
+#  undef  MULTI_OMAP1
+#  define MULTI_OMAP1
+# else
+#  define OMAP_NAME omap730
+# endif
+#endif
+#ifdef CONFIG_ARCH_OMAP15XX
+# ifdef OMAP_NAME
+#  undef  MULTI_OMAP1
+#  define MULTI_OMAP1
+# else
+#  define OMAP_NAME omap1510
+# endif
+#endif
+#ifdef CONFIG_ARCH_OMAP16XX
+# ifdef OMAP_NAME
+#  undef  MULTI_OMAP1
+#  define MULTI_OMAP1
+# else
+#  define OMAP_NAME omap16xx
+# endif
+#endif
+#ifdef CONFIG_ARCH_OMAP24XX
+# if (defined(OMAP_NAME) || defined(MULTI_OMAP1))
+#  error "OMAP1 and OMAP2 can't be selected at the same time"
+# else
+#  undef  MULTI_OMAP2
+#  define OMAP_NAME omap24xx
+# endif
+#endif
+
+/*
+ * Macros to group OMAP into cpu classes.
+ * These can be used in most places.
+ * cpu_is_omap7xx():	True for OMAP730
+ * cpu_is_omap15xx():	True for OMAP1510, OMAP5910 and OMAP310
+ * cpu_is_omap16xx():	True for OMAP1610, OMAP5912 and OMAP1710
+ * cpu_is_omap24xx():	True for OMAP2420, OMAP2422, OMAP2423, OMAP2430
+ * cpu_is_omap242x():	True for OMAP2420, OMAP2422, OMAP2423
+ * cpu_is_omap243x():	True for OMAP2430
+ */
+#define GET_OMAP_CLASS	(system_rev & 0xff)
+
+#define IS_OMAP_CLASS(class, id)			\
+static inline int is_omap ##class (void)		\
+{							\
+	return (GET_OMAP_CLASS == (id)) ? 1 : 0;	\
+}
+
+#define GET_OMAP_SUBCLASS	((system_rev >> 20) & 0x0fff)
+
+#define IS_OMAP_SUBCLASS(subclass, id)			\
+static inline int is_omap ##subclass (void)		\
+{							\
+	return (GET_OMAP_SUBCLASS == (id)) ? 1 : 0;	\
+}
+
+IS_OMAP_CLASS(7xx, 0x07)
+IS_OMAP_CLASS(15xx, 0x15)
+IS_OMAP_CLASS(16xx, 0x16)
+IS_OMAP_CLASS(24xx, 0x24)
+
+IS_OMAP_SUBCLASS(242x, 0x242)
+IS_OMAP_SUBCLASS(243x, 0x243)
+
+#define cpu_is_omap7xx()		0
+#define cpu_is_omap15xx()		0
+#define cpu_is_omap16xx()		0
+#define cpu_is_omap24xx()		0
+#define cpu_is_omap242x()		0
+#define cpu_is_omap243x()		0
+
+#if defined(MULTI_OMAP1)
+# if defined(CONFIG_ARCH_OMAP730)
+#  undef  cpu_is_omap7xx
+#  define cpu_is_omap7xx()		is_omap7xx()
+# endif
+# if defined(CONFIG_ARCH_OMAP15XX)
+#  undef  cpu_is_omap15xx
+#  define cpu_is_omap15xx()		is_omap15xx()
+# endif
+# if defined(CONFIG_ARCH_OMAP16XX)
+#  undef  cpu_is_omap16xx
+#  define cpu_is_omap16xx()		is_omap16xx()
+# endif
+#else
+# if defined(CONFIG_ARCH_OMAP730)
+#  undef  cpu_is_omap7xx
+#  define cpu_is_omap7xx()		1
+# endif
+# if defined(CONFIG_ARCH_OMAP15XX)
+#  undef  cpu_is_omap15xx
+#  define cpu_is_omap15xx()		1
+# endif
+# if defined(CONFIG_ARCH_OMAP16XX)
+#  undef  cpu_is_omap16xx
+#  define cpu_is_omap16xx()		1
+# endif
+# if defined(CONFIG_ARCH_OMAP24XX)
+#  undef  cpu_is_omap24xx
+#  undef  cpu_is_omap242x
+#  undef  cpu_is_omap243x
+#  define cpu_is_omap24xx()		1
+#  define cpu_is_omap242x()		is_omap242x()
+#  define cpu_is_omap243x()		is_omap243x()
+# endif
+#endif
+
+/*
+ * Macros to detect individual cpu types.
+ * These are only rarely needed.
+ * cpu_is_omap330():	True for OMAP330
+ * cpu_is_omap730():	True for OMAP730
+ * cpu_is_omap1510():	True for OMAP1510
+ * cpu_is_omap1610():	True for OMAP1610
+ * cpu_is_omap1611():	True for OMAP1611
+ * cpu_is_omap5912():	True for OMAP5912
+ * cpu_is_omap1621():	True for OMAP1621
+ * cpu_is_omap1710():	True for OMAP1710
+ * cpu_is_omap2420():	True for OMAP2420
+ * cpu_is_omap2422():	True for OMAP2422
+ * cpu_is_omap2423():	True for OMAP2423
+ * cpu_is_omap2430():	True for OMAP2430
+ */
+#define GET_OMAP_TYPE	((system_rev >> 16) & 0xffff)
+
+#define IS_OMAP_TYPE(type, id)				\
+static inline int is_omap ##type (void)			\
+{							\
+	return (GET_OMAP_TYPE == (id)) ? 1 : 0;		\
+}
+
+IS_OMAP_TYPE(310, 0x0310)
+IS_OMAP_TYPE(730, 0x0730)
+IS_OMAP_TYPE(1510, 0x1510)
+IS_OMAP_TYPE(1610, 0x1610)
+IS_OMAP_TYPE(1611, 0x1611)
+IS_OMAP_TYPE(5912, 0x1611)
+IS_OMAP_TYPE(1621, 0x1621)
+IS_OMAP_TYPE(1710, 0x1710)
+IS_OMAP_TYPE(2420, 0x2420)
+IS_OMAP_TYPE(2422, 0x2422)
+IS_OMAP_TYPE(2423, 0x2423)
+IS_OMAP_TYPE(2430, 0x2430)
+
+#define cpu_is_omap310()		0
+#define cpu_is_omap730()		0
+#define cpu_is_omap1510()		0
+#define cpu_is_omap1610()		0
+#define cpu_is_omap5912()		0
+#define cpu_is_omap1611()		0
+#define cpu_is_omap1621()		0
+#define cpu_is_omap1710()		0
+#define cpu_is_omap2420()		0
+#define cpu_is_omap2422()		0
+#define cpu_is_omap2423()		0
+#define cpu_is_omap2430()		0
+
+#if defined(MULTI_OMAP1)
+# if defined(CONFIG_ARCH_OMAP730)
+#  undef  cpu_is_omap730
+#  define cpu_is_omap730()		is_omap730()
+# endif
+#else
+# if defined(CONFIG_ARCH_OMAP730)
+#  undef  cpu_is_omap730
+#  define cpu_is_omap730()		1
+# endif
+#endif
+
+/*
+ * Whether we have MULTI_OMAP1 or not, we still need to distinguish
+ * between 330 vs. 1510 and 1611B/5912 vs. 1710.
+ */
+#if defined(CONFIG_ARCH_OMAP15XX)
+# undef  cpu_is_omap310
+# undef  cpu_is_omap1510
+# define cpu_is_omap310()		is_omap310()
+# define cpu_is_omap1510()		is_omap1510()
+#endif
+
+#if defined(CONFIG_ARCH_OMAP16XX)
+# undef  cpu_is_omap1610
+# undef  cpu_is_omap1611
+# undef  cpu_is_omap5912
+# undef  cpu_is_omap1621
+# undef  cpu_is_omap1710
+# define cpu_is_omap1610()		is_omap1610()
+# define cpu_is_omap1611()		is_omap1611()
+# define cpu_is_omap5912()		is_omap5912()
+# define cpu_is_omap1621()		is_omap1621()
+# define cpu_is_omap1710()		is_omap1710()
+#endif
+
+#if defined(CONFIG_ARCH_OMAP24XX)
+# undef  cpu_is_omap2420
+# undef  cpu_is_omap2422
+# undef  cpu_is_omap2423
+# undef  cpu_is_omap2430
+# define cpu_is_omap2420()		is_omap2420()
+# define cpu_is_omap2422()		is_omap2422()
+# define cpu_is_omap2423()		is_omap2423()
+# define cpu_is_omap2430()		is_omap2430()
+#endif
+
+/* Macros to detect if we have OMAP1 or OMAP2 */
+#define cpu_class_is_omap1()	(cpu_is_omap730() || cpu_is_omap15xx() || \
+				cpu_is_omap16xx())
+#define cpu_class_is_omap2()	cpu_is_omap24xx()
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-omap/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,58 @@
+/* linux/include/asm-arm/arch-omap/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+#ifdef CONFIG_ARCH_OMAP1
+		moveq	\rx, #0xff000000	@ physical base address
+		movne	\rx, #0xfe000000	@ virtual base
+		orr	\rx, \rx, #0x00fb0000
+#ifdef CONFIG_OMAP_LL_DEBUG_UART3
+		orr	\rx, \rx, #0x00009000	@ UART 3
+#endif
+#if defined(CONFIG_OMAP_LL_DEBUG_UART2) || defined(CONFIG_OMAP_LL_DEBUG_UART3)
+		orr	\rx, \rx, #0x00000800	@ UART 2 & 3
+#endif
+
+#elif  CONFIG_ARCH_OMAP2
+		moveq	\rx, #0x48000000	@ physical base address
+		movne	\rx, #0xd8000000	@ virtual base
+		orr	\rx, \rx, #0x0006a000
+#ifdef CONFIG_OMAP_LL_DEBUG_UART2
+		add	\rx, \rx, #0x00002000	@ UART 2
+#endif
+#ifdef CONFIG_OMAP_LL_DEBUG_UART3
+		add	\rx, \rx, #0x00004000	@ UART 3
+#endif
+#endif
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx]
+		.endm
+
+		.macro	busyuart,rd,rx
+1001:		ldrb	\rd, [\rx, #(0x5 << 2)]	@ OMAP-1510 and friends
+		and	\rd, \rd, #0x60
+		teq	\rd, #0x60
+		beq	1002f
+		ldrb	\rd, [\rx, #(0x5 << 0)]	@ OMAP-730 only
+		and	\rd, \rd, #0x60
+		teq	\rd, #0x60
+		bne	1001b
+1002:
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
Index: build_tree/linux/include/asm/arch-omap/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,430 @@
+/*
+ *  linux/include/asm-arm/arch-omap/dma.h
+ *
+ *  Copyright (C) 2003 Nokia Corporation
+ *  Author: Juha Yrjl <juha.yrjola@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/* Hardware registers for omap1 */
+#define OMAP_DMA_BASE			(0xfffed800)
+#define OMAP_DMA_GCR			(OMAP_DMA_BASE + 0x400)
+#define OMAP_DMA_GSCR			(OMAP_DMA_BASE + 0x404)
+#define OMAP_DMA_GRST			(OMAP_DMA_BASE + 0x408)
+#define OMAP_DMA_HW_ID			(OMAP_DMA_BASE + 0x442)
+#define OMAP_DMA_PCH2_ID		(OMAP_DMA_BASE + 0x444)
+#define OMAP_DMA_PCH0_ID		(OMAP_DMA_BASE + 0x446)
+#define OMAP_DMA_PCH1_ID		(OMAP_DMA_BASE + 0x448)
+#define OMAP_DMA_PCHG_ID		(OMAP_DMA_BASE + 0x44a)
+#define OMAP_DMA_PCHD_ID		(OMAP_DMA_BASE + 0x44c)
+#define OMAP_DMA_CAPS_0_U		(OMAP_DMA_BASE + 0x44e)
+#define OMAP_DMA_CAPS_0_L		(OMAP_DMA_BASE + 0x450)
+#define OMAP_DMA_CAPS_1_U		(OMAP_DMA_BASE + 0x452)
+#define OMAP_DMA_CAPS_1_L		(OMAP_DMA_BASE + 0x454)
+#define OMAP_DMA_CAPS_2			(OMAP_DMA_BASE + 0x456)
+#define OMAP_DMA_CAPS_3			(OMAP_DMA_BASE + 0x458)
+#define OMAP_DMA_CAPS_4			(OMAP_DMA_BASE + 0x45a)
+#define OMAP_DMA_PCH2_SR		(OMAP_DMA_BASE + 0x460)
+#define OMAP_DMA_PCH0_SR		(OMAP_DMA_BASE + 0x480)
+#define OMAP_DMA_PCH1_SR		(OMAP_DMA_BASE + 0x482)
+#define OMAP_DMA_PCHD_SR		(OMAP_DMA_BASE + 0x4c0)
+
+/* Hardware registers for omap2 */
+#define OMAP24XX_DMA_BASE		(L4_24XX_BASE + 0x56000)
+#define OMAP_DMA4_REVISION		(OMAP24XX_DMA_BASE + 0x00)
+#define OMAP_DMA4_GCR_REG		(OMAP24XX_DMA_BASE + 0x78)
+#define OMAP_DMA4_IRQSTATUS_L0		(OMAP24XX_DMA_BASE + 0x08)
+#define OMAP_DMA4_IRQSTATUS_L1		(OMAP24XX_DMA_BASE + 0x0c)
+#define OMAP_DMA4_IRQSTATUS_L2		(OMAP24XX_DMA_BASE + 0x10)
+#define OMAP_DMA4_IRQSTATUS_L3		(OMAP24XX_DMA_BASE + 0x14)
+#define OMAP_DMA4_IRQENABLE_L0		(OMAP24XX_DMA_BASE + 0x18)
+#define OMAP_DMA4_IRQENABLE_L1		(OMAP24XX_DMA_BASE + 0x1c)
+#define OMAP_DMA4_IRQENABLE_L2		(OMAP24XX_DMA_BASE + 0x20)
+#define OMAP_DMA4_IRQENABLE_L3		(OMAP24XX_DMA_BASE + 0x24)
+#define OMAP_DMA4_SYSSTATUS		(OMAP24XX_DMA_BASE + 0x28)
+#define OMAP_DMA4_CAPS_0		(OMAP24XX_DMA_BASE + 0x64)
+#define OMAP_DMA4_CAPS_2		(OMAP24XX_DMA_BASE + 0x6c)
+#define OMAP_DMA4_CAPS_3		(OMAP24XX_DMA_BASE + 0x70)
+#define OMAP_DMA4_CAPS_4		(OMAP24XX_DMA_BASE + 0x74)
+
+#ifdef CONFIG_ARCH_OMAP1
+
+#define OMAP_LOGICAL_DMA_CH_COUNT	17
+
+/* Common channel specific registers for omap1 */
+#define OMAP_DMA_CSDP_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x00)
+#define OMAP_DMA_CCR_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x02)
+#define OMAP_DMA_CICR_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x04)
+#define OMAP_DMA_CSR_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x06)
+#define OMAP_DMA_CEN_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x10)
+#define OMAP_DMA_CFN_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x12)
+#define OMAP_DMA_CSFI_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x14)
+#define OMAP_DMA_CSEI_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x16)
+#define OMAP_DMA_CSAC_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x18)
+#define OMAP_DMA_CDAC_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x1a)
+#define OMAP_DMA_CDEI_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x1c)
+#define OMAP_DMA_CDFI_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x1e)
+#define OMAP_DMA_CLNK_CTRL_REG(n)	__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x28)
+
+#else
+
+#define OMAP_LOGICAL_DMA_CH_COUNT	32	/* REVISIT: Is this 32 + 2? */
+
+/* Common channel specific registers for omap2 */
+#define OMAP_DMA_CCR_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x80)
+#define OMAP_DMA_CLNK_CTRL_REG(n)	__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x84)
+#define OMAP_DMA_CICR_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x88)
+#define OMAP_DMA_CSR_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x8c)
+#define OMAP_DMA_CSDP_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x90)
+#define OMAP_DMA_CEN_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x94)
+#define OMAP_DMA_CFN_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x98)
+#define OMAP_DMA_CSEI_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xa4)
+#define OMAP_DMA_CSFI_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xa8)
+#define OMAP_DMA_CDEI_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xac)
+#define OMAP_DMA_CDFI_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xb0)
+#define OMAP_DMA_CSAC_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xb4)
+#define OMAP_DMA_CDAC_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xb8)
+
+#endif
+
+/* Channel specific registers only on omap1 */
+#define OMAP1_DMA_CSSA_L_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x08)
+#define OMAP1_DMA_CSSA_U_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x0a)
+#define OMAP1_DMA_CDSA_L_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x0c)
+#define OMAP1_DMA_CDSA_U_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x0e)
+#define OMAP1_DMA_COLOR_L_REG(n)	__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x20)
+#define OMAP1_DMA_CCR2_REG(n)		__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x24)
+#define OMAP1_DMA_COLOR_U_REG(n)	__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x22)
+#define OMAP1_DMA_LCH_CTRL_REG(n)	__REG16(OMAP_DMA_BASE + 0x40 * (n) + 0x2a)
+
+/* Channel specific registers only on omap2 */
+#define OMAP2_DMA_CSSA_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0x9c)
+#define OMAP2_DMA_CDSA_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xa0)
+#define OMAP2_DMA_CCEN_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xbc)
+#define OMAP2_DMA_CCFN_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xc0)
+#define OMAP2_DMA_COLOR_REG(n)		__REG32(OMAP24XX_DMA_BASE + 0x60 * (n) + 0xc4)
+
+/*----------------------------------------------------------------------------*/
+
+/* DMA channels for omap1 */
+#define OMAP_DMA_NO_DEVICE		0
+#define OMAP_DMA_MCSI1_TX		1
+#define OMAP_DMA_MCSI1_RX		2
+#define OMAP_DMA_I2C_RX			3
+#define OMAP_DMA_I2C_TX			4
+#define OMAP_DMA_EXT_NDMA_REQ		5
+#define OMAP_DMA_EXT_NDMA_REQ2		6
+#define OMAP_DMA_UWIRE_TX		7
+#define OMAP_DMA_MCBSP1_TX		8
+#define OMAP_DMA_MCBSP1_RX		9
+#define OMAP_DMA_MCBSP3_TX		10
+#define OMAP_DMA_MCBSP3_RX		11
+#define OMAP_DMA_UART1_TX		12
+#define OMAP_DMA_UART1_RX		13
+#define OMAP_DMA_UART2_TX		14
+#define OMAP_DMA_UART2_RX		15
+#define OMAP_DMA_MCBSP2_TX		16
+#define OMAP_DMA_MCBSP2_RX		17
+#define OMAP_DMA_UART3_TX		18
+#define OMAP_DMA_UART3_RX		19
+#define OMAP_DMA_CAMERA_IF_RX		20
+#define OMAP_DMA_MMC_TX			21
+#define OMAP_DMA_MMC_RX			22
+#define OMAP_DMA_NAND			23
+#define OMAP_DMA_IRQ_LCD_LINE		24
+#define OMAP_DMA_MEMORY_STICK		25
+#define OMAP_DMA_USB_W2FC_RX0		26
+#define OMAP_DMA_USB_W2FC_RX1		27
+#define OMAP_DMA_USB_W2FC_RX2		28
+#define OMAP_DMA_USB_W2FC_TX0		29
+#define OMAP_DMA_USB_W2FC_TX1		30
+#define OMAP_DMA_USB_W2FC_TX2		31
+
+/* These are only for 1610 */
+#define OMAP_DMA_CRYPTO_DES_IN		32
+#define OMAP_DMA_SPI_TX			33
+#define OMAP_DMA_SPI_RX			34
+#define OMAP_DMA_CRYPTO_HASH		35
+#define OMAP_DMA_CCP_ATTN		36
+#define OMAP_DMA_CCP_FIFO_NOT_EMPTY	37
+#define OMAP_DMA_CMT_APE_TX_CHAN_0	38
+#define OMAP_DMA_CMT_APE_RV_CHAN_0	39
+#define OMAP_DMA_CMT_APE_TX_CHAN_1	40
+#define OMAP_DMA_CMT_APE_RV_CHAN_1	41
+#define OMAP_DMA_CMT_APE_TX_CHAN_2	42
+#define OMAP_DMA_CMT_APE_RV_CHAN_2	43
+#define OMAP_DMA_CMT_APE_TX_CHAN_3	44
+#define OMAP_DMA_CMT_APE_RV_CHAN_3	45
+#define OMAP_DMA_CMT_APE_TX_CHAN_4	46
+#define OMAP_DMA_CMT_APE_RV_CHAN_4	47
+#define OMAP_DMA_CMT_APE_TX_CHAN_5	48
+#define OMAP_DMA_CMT_APE_RV_CHAN_5	49
+#define OMAP_DMA_CMT_APE_TX_CHAN_6	50
+#define OMAP_DMA_CMT_APE_RV_CHAN_6	51
+#define OMAP_DMA_CMT_APE_TX_CHAN_7	52
+#define OMAP_DMA_CMT_APE_RV_CHAN_7	53
+#define OMAP_DMA_MMC2_TX		54
+#define OMAP_DMA_MMC2_RX		55
+#define OMAP_DMA_CRYPTO_DES_OUT		56
+
+/* DMA channels for 24xx */
+#define OMAP24XX_DMA_NO_DEVICE		0
+#define OMAP24XX_DMA_XTI_DMA		1	/* S_DMA_0 */
+#define OMAP24XX_DMA_EXT_DMAREQ0	2	/* S_DMA_1 */
+#define OMAP24XX_DMA_EXT_DMAREQ1	3	/* S_DMA_2 */
+#define OMAP24XX_DMA_GPMC		4	/* S_DMA_3 */
+#define OMAP24XX_DMA_GFX		5	/* S_DMA_4 */
+#define OMAP24XX_DMA_DSS		6	/* S_DMA_5 */
+#define OMAP24XX_DMA_VLYNQ_TX		7	/* S_DMA_6 */
+#define OMAP24XX_DMA_CWT		8	/* S_DMA_7 */
+#define OMAP24XX_DMA_AES_TX		9	/* S_DMA_8 */
+#define OMAP24XX_DMA_AES_RX		10	/* S_DMA_9 */
+#define OMAP24XX_DMA_DES_TX		11	/* S_DMA_10 */
+#define OMAP24XX_DMA_DES_RX		12	/* S_DMA_11 */
+#define OMAP24XX_DMA_SHA1MD5_RX		13	/* S_DMA_12 */
+#define OMAP24XX_DMA_EXT_DMAREQ2	14	/* S_DMA_13 */
+#define OMAP24XX_DMA_EXT_DMAREQ3	15	/* S_DMA_14 */
+#define OMAP24XX_DMA_EXT_DMAREQ4	16	/* S_DMA_15 */
+#define OMAP24XX_DMA_EAC_AC_RD		17	/* S_DMA_16 */
+#define OMAP24XX_DMA_EAC_AC_WR		18	/* S_DMA_17 */
+#define OMAP24XX_DMA_EAC_MD_UL_RD	19	/* S_DMA_18 */
+#define OMAP24XX_DMA_EAC_MD_UL_WR	20	/* S_DMA_19 */
+#define OMAP24XX_DMA_EAC_MD_DL_RD	21	/* S_DMA_20 */
+#define OMAP24XX_DMA_EAC_MD_DL_WR	22	/* S_DMA_21 */
+#define OMAP24XX_DMA_EAC_BT_UL_RD	23	/* S_DMA_22 */
+#define OMAP24XX_DMA_EAC_BT_UL_WR	24	/* S_DMA_23 */
+#define OMAP24XX_DMA_EAC_BT_DL_RD	25	/* S_DMA_24 */
+#define OMAP24XX_DMA_EAC_BT_DL_WR	26	/* S_DMA_25 */
+#define OMAP24XX_DMA_I2C1_TX		27	/* S_DMA_26 */
+#define OMAP24XX_DMA_I2C1_RX		28	/* S_DMA_27 */
+#define OMAP24XX_DMA_I2C2_TX		29	/* S_DMA_28 */
+#define OMAP24XX_DMA_I2C2_RX		30	/* S_DMA_29 */
+#define OMAP24XX_DMA_MCBSP1_TX		31	/* SDMA_30 */
+#define OMAP24XX_DMA_MCBSP1_RX		32	/* SDMA_31 */
+#define OMAP24XX_DMA_MCBSP2_TX		33	/* SDMA_32 */
+#define OMAP24XX_DMA_MCBSP2_RX		34	/* SDMA_33 */
+#define OMAP24XX_DMA_SPI1_TX0		35	/* SDMA_34 */
+#define OMAP24XX_DMA_SPI1_RX0		36	/* SDMA_35 */
+#define OMAP24XX_DMA_SPI1_TX1		37	/* SDMA_36 */
+#define OMAP24XX_DMA_SPI1_RX1		38	/* SDMA_37 */
+#define OMAP24XX_DMA_SPI1_TX2		39	/* SDMA_38 */
+#define OMAP24XX_DMA_SPI1_RX2		40	/* SDMA_39 */
+#define OMAP24XX_DMA_SPI1_TX3		41	/* SDMA_40 */
+#define OMAP24XX_DMA_SPI1_RX3		42	/* SDMA_41 */
+#define OMAP24XX_DMA_SPI2_TX0		43	/* SDMA_42 */
+#define OMAP24XX_DMA_SPI2_RX0		44	/* SDMA_43 */
+#define OMAP24XX_DMA_SPI2_TX1		45	/* SDMA_44 */
+#define OMAP24XX_DMA_SPI2_RX1		46	/* SDMA_45 */
+
+#define OMAP24XX_DMA_UART1_TX		49	/* SDMA_48 */
+#define OMAP24XX_DMA_UART1_RX		50	/* SDMA_49 */
+#define OMAP24XX_DMA_UART2_TX		51	/* SDMA_50 */
+#define OMAP24XX_DMA_UART2_RX		52	/* SDMA_51 */
+#define OMAP24XX_DMA_UART3_TX		53	/* SDMA_52 */
+#define OMAP24XX_DMA_UART3_RX		54	/* SDMA_53 */
+#define OMAP24XX_DMA_USB_W2FC_TX0	55	/* SDMA_54 */
+#define OMAP24XX_DMA_USB_W2FC_RX0	56	/* SDMA_55 */
+#define OMAP24XX_DMA_USB_W2FC_TX1	57	/* SDMA_56 */
+#define OMAP24XX_DMA_USB_W2FC_RX1	58	/* SDMA_57 */
+#define OMAP24XX_DMA_USB_W2FC_TX2	59	/* SDMA_58 */
+#define OMAP24XX_DMA_USB_W2FC_RX2	60	/* SDMA_59 */
+#define OMAP24XX_DMA_MMC1_TX		61	/* SDMA_60 */
+#define OMAP24XX_DMA_MMC1_RX		62	/* SDMA_61 */
+#define OMAP24XX_DMA_MS			63	/* SDMA_62 */
+#define OMAP24XX_DMA_EXT_DMAREQ5	64	/* S_DMA_63 */
+
+/*----------------------------------------------------------------------------*/
+
+/* Hardware registers for LCD DMA */
+#define OMAP1510_DMA_LCD_BASE		(0xfffedb00)
+#define OMAP1510_DMA_LCD_CTRL		(OMAP1510_DMA_LCD_BASE + 0x00)
+#define OMAP1510_DMA_LCD_TOP_F1_L	(OMAP1510_DMA_LCD_BASE + 0x02)
+#define OMAP1510_DMA_LCD_TOP_F1_U	(OMAP1510_DMA_LCD_BASE + 0x04)
+#define OMAP1510_DMA_LCD_BOT_F1_L	(OMAP1510_DMA_LCD_BASE + 0x06)
+#define OMAP1510_DMA_LCD_BOT_F1_U	(OMAP1510_DMA_LCD_BASE + 0x08)
+
+#define OMAP1610_DMA_LCD_BASE		(0xfffee300)
+#define OMAP1610_DMA_LCD_CSDP		(OMAP1610_DMA_LCD_BASE + 0xc0)
+#define OMAP1610_DMA_LCD_CCR		(OMAP1610_DMA_LCD_BASE + 0xc2)
+#define OMAP1610_DMA_LCD_CTRL		(OMAP1610_DMA_LCD_BASE + 0xc4)
+#define OMAP1610_DMA_LCD_TOP_B1_L	(OMAP1610_DMA_LCD_BASE + 0xc8)
+#define OMAP1610_DMA_LCD_TOP_B1_U	(OMAP1610_DMA_LCD_BASE + 0xca)
+#define OMAP1610_DMA_LCD_BOT_B1_L	(OMAP1610_DMA_LCD_BASE + 0xcc)
+#define OMAP1610_DMA_LCD_BOT_B1_U	(OMAP1610_DMA_LCD_BASE + 0xce)
+#define OMAP1610_DMA_LCD_TOP_B2_L	(OMAP1610_DMA_LCD_BASE + 0xd0)
+#define OMAP1610_DMA_LCD_TOP_B2_U	(OMAP1610_DMA_LCD_BASE + 0xd2)
+#define OMAP1610_DMA_LCD_BOT_B2_L	(OMAP1610_DMA_LCD_BASE + 0xd4)
+#define OMAP1610_DMA_LCD_BOT_B2_U	(OMAP1610_DMA_LCD_BASE + 0xd6)
+#define OMAP1610_DMA_LCD_SRC_EI_B1	(OMAP1610_DMA_LCD_BASE + 0xd8)
+#define OMAP1610_DMA_LCD_SRC_FI_B1_L	(OMAP1610_DMA_LCD_BASE + 0xda)
+#define OMAP1610_DMA_LCD_SRC_EN_B1	(OMAP1610_DMA_LCD_BASE + 0xe0)
+#define OMAP1610_DMA_LCD_SRC_FN_B1	(OMAP1610_DMA_LCD_BASE + 0xe4)
+#define OMAP1610_DMA_LCD_LCH_CTRL	(OMAP1610_DMA_LCD_BASE + 0xea)
+#define OMAP1610_DMA_LCD_SRC_FI_B1_U	(OMAP1610_DMA_LCD_BASE + 0xf4)
+
+#define OMAP1_DMA_TOUT_IRQ		(1 << 0)
+#define OMAP_DMA_DROP_IRQ		(1 << 1)
+#define OMAP_DMA_HALF_IRQ		(1 << 2)
+#define OMAP_DMA_FRAME_IRQ		(1 << 3)
+#define OMAP_DMA_LAST_IRQ		(1 << 4)
+#define OMAP_DMA_BLOCK_IRQ		(1 << 5)
+#define OMAP1_DMA_SYNC_IRQ		(1 << 6)
+#define OMAP2_DMA_PKT_IRQ		(1 << 7)
+#define OMAP2_DMA_TRANS_ERR_IRQ		(1 << 8)
+#define OMAP2_DMA_SECURE_ERR_IRQ	(1 << 9)
+#define OMAP2_DMA_SUPERVISOR_ERR_IRQ	(1 << 10)
+#define OMAP2_DMA_MISALIGNED_ERR_IRQ	(1 << 11)
+
+#define OMAP_DMA_DATA_TYPE_S8		0x00
+#define OMAP_DMA_DATA_TYPE_S16		0x01
+#define OMAP_DMA_DATA_TYPE_S32		0x02
+
+#define OMAP_DMA_SYNC_ELEMENT		0x00
+#define OMAP_DMA_SYNC_FRAME		0x01
+#define OMAP_DMA_SYNC_BLOCK		0x02
+
+#define OMAP_DMA_PORT_EMIFF		0x00
+#define OMAP_DMA_PORT_EMIFS		0x01
+#define OMAP_DMA_PORT_OCP_T1		0x02
+#define OMAP_DMA_PORT_TIPB		0x03
+#define OMAP_DMA_PORT_OCP_T2		0x04
+#define OMAP_DMA_PORT_MPUI		0x05
+
+#define OMAP_DMA_AMODE_CONSTANT		0x00
+#define OMAP_DMA_AMODE_POST_INC		0x01
+#define OMAP_DMA_AMODE_SINGLE_IDX	0x02
+#define OMAP_DMA_AMODE_DOUBLE_IDX	0x03
+
+/* LCD DMA block numbers */
+enum {
+	OMAP_LCD_DMA_B1_TOP,
+	OMAP_LCD_DMA_B1_BOTTOM,
+	OMAP_LCD_DMA_B2_TOP,
+	OMAP_LCD_DMA_B2_BOTTOM
+};
+
+enum omap_dma_burst_mode {
+	OMAP_DMA_DATA_BURST_DIS = 0,
+	OMAP_DMA_DATA_BURST_4,
+	OMAP_DMA_DATA_BURST_8,
+	OMAP_DMA_DATA_BURST_16,
+};
+
+enum omap_dma_color_mode {
+	OMAP_DMA_COLOR_DIS = 0,
+	OMAP_DMA_CONSTANT_FILL,
+	OMAP_DMA_TRANSPARENT_COPY
+};
+
+enum omap_dma_write_mode {
+	OMAP_DMA_WRITE_NON_POSTED = 0,
+	OMAP_DMA_WRITE_POSTED,
+	OMAP_DMA_WRITE_LAST_NON_POSTED
+};
+
+struct omap_dma_channel_params {
+	int data_type;		/* data type 8,16,32 */
+	int elem_count;		/* number of elements in a frame */
+	int frame_count;	/* number of frames in a element */
+
+	int src_port;		/* Only on OMAP1 REVISIT: Is this needed? */
+	int src_amode;		/* constant , post increment, indexed , double indexed */
+	unsigned long src_start;	/* source address : physical */
+	int src_ei;		/* source element index */
+	int src_fi;		/* source frame index */
+
+	int dst_port;		/* Only on OMAP1 REVISIT: Is this needed? */
+	int dst_amode;		/* constant , post increment, indexed , double indexed */
+	unsigned long dst_start;	/* source address : physical */
+	int dst_ei;		/* source element index */
+	int dst_fi;		/* source frame index */
+
+	int trigger;		/* trigger attached if the channel is synchronized */
+	int sync_mode;		/* sycn on element, frame , block or packet */
+	int src_or_dst_synch;	/* source synch(1) or destination synch(0) */
+
+	int ie;			/* interrupt enabled */
+};
+
+
+extern void omap_set_dma_priority(int lch, int dst_port, int priority);
+extern int omap_request_dma(int dev_id, const char *dev_name,
+			    void (* callback)(int lch, u16 ch_status, void *data),
+			    void *data, int *dma_ch);
+extern void omap_enable_dma_irq(int ch, u16 irq_bits);
+extern void omap_disable_dma_irq(int ch, u16 irq_bits);
+extern void omap_free_dma(int ch);
+extern void omap_start_dma(int lch);
+extern void omap_stop_dma(int lch);
+extern void omap_set_dma_transfer_params(int lch, int data_type,
+					 int elem_count, int frame_count,
+					 int sync_mode,
+					 int dma_trigger, int src_or_dst_synch);
+extern void omap_set_dma_color_mode(int lch, enum omap_dma_color_mode mode,
+				    u32 color);
+extern void omap_set_dma_write_mode(int lch, enum omap_dma_write_mode mode);
+
+extern void omap_set_dma_src_params(int lch, int src_port, int src_amode,
+				    unsigned long src_start,
+				    int src_ei, int src_fi);
+extern void omap_set_dma_src_index(int lch, int eidx, int fidx);
+extern void omap_set_dma_src_data_pack(int lch, int enable);
+extern void omap_set_dma_src_burst_mode(int lch,
+					enum omap_dma_burst_mode burst_mode);
+
+extern void omap_set_dma_dest_params(int lch, int dest_port, int dest_amode,
+				     unsigned long dest_start,
+				     int dst_ei, int dst_fi);
+extern void omap_set_dma_dest_index(int lch, int eidx, int fidx);
+extern void omap_set_dma_dest_data_pack(int lch, int enable);
+extern void omap_set_dma_dest_burst_mode(int lch,
+					 enum omap_dma_burst_mode burst_mode);
+
+extern void omap_set_dma_params(int lch,
+				struct omap_dma_channel_params * params);
+
+extern void omap_dma_link_lch (int lch_head, int lch_queue);
+extern void omap_dma_unlink_lch (int lch_head, int lch_queue);
+
+extern int omap_set_dma_callback(int lch,
+			void (* callback)(int lch, u16 ch_status, void *data),
+			void *data);
+extern dma_addr_t omap_get_dma_src_pos(int lch);
+extern dma_addr_t omap_get_dma_dst_pos(int lch);
+extern int omap_get_dma_src_addr_counter(int lch);
+extern void omap_clear_dma(int lch);
+extern int omap_dma_running(void);
+
+/* LCD DMA functions */
+extern int omap_request_lcd_dma(void (* callback)(u16 status, void *data),
+				void *data);
+extern void omap_free_lcd_dma(void);
+extern void omap_setup_lcd_dma(void);
+extern void omap_enable_lcd_dma(void);
+extern void omap_stop_lcd_dma(void);
+extern int  omap_lcd_dma_ext_running(void);
+extern void omap_set_lcd_dma_ext_controller(int external);
+extern void omap_set_lcd_dma_single_transfer(int single);
+extern void omap_set_lcd_dma_b1(unsigned long addr, u16 fb_xres, u16 fb_yres,
+				int data_type);
+extern void omap_set_lcd_dma_b1_rotation(int rotate);
+extern void omap_set_lcd_dma_b1_vxres(unsigned long vxres);
+extern void omap_set_lcd_dma_b1_mirror(int mirror);
+extern void omap_set_lcd_dma_b1_scale(unsigned int xscale, unsigned int yscale);
+
+#endif /* __ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-omap/dmtimer.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/dmtimer.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/dmtimer.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,83 @@
+/*
+ * linux/include/asm-arm/arch-omap/dmtimer.h
+ *
+ * OMAP Dual-Mode Timers
+ *
+ * Copyright (C) 2005 Nokia Corporation
+ * Author: Lauri Leukkunen <lauri.leukkunen@nokia.com>
+ * PWM and clock framwork support by Timo Teras.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_DMTIMER_H
+#define __ASM_ARCH_DMTIMER_H
+
+/* clock sources */
+#define OMAP_TIMER_SRC_SYS_CLK			0x00
+#define OMAP_TIMER_SRC_32_KHZ			0x01
+#define OMAP_TIMER_SRC_EXT_CLK			0x02
+
+/* timer interrupt enable bits */
+#define OMAP_TIMER_INT_CAPTURE			(1 << 2)
+#define OMAP_TIMER_INT_OVERFLOW			(1 << 1)
+#define OMAP_TIMER_INT_MATCH			(1 << 0)
+
+/* trigger types */
+#define OMAP_TIMER_TRIGGER_NONE			0x00
+#define OMAP_TIMER_TRIGGER_OVERFLOW		0x01
+#define OMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE	0x02
+
+struct omap_dm_timer;
+struct clk;
+
+int omap_dm_timer_init(void);
+
+struct omap_dm_timer *omap_dm_timer_request(void);
+struct omap_dm_timer *omap_dm_timer_request_specific(int timer_id);
+void omap_dm_timer_free(struct omap_dm_timer *timer);
+void omap_dm_timer_enable(struct omap_dm_timer *timer);
+void omap_dm_timer_disable(struct omap_dm_timer *timer);
+
+int omap_dm_timer_get_irq(struct omap_dm_timer *timer);
+
+u32 omap_dm_timer_modify_idlect_mask(u32 inputmask);
+struct clk *omap_dm_timer_get_fclk(struct omap_dm_timer *timer);
+
+void omap_dm_timer_trigger(struct omap_dm_timer *timer);
+void omap_dm_timer_start(struct omap_dm_timer *timer);
+void omap_dm_timer_stop(struct omap_dm_timer *timer);
+
+void omap_dm_timer_set_source(struct omap_dm_timer *timer, int source);
+void omap_dm_timer_set_load(struct omap_dm_timer *timer, int autoreload, unsigned int value);
+void omap_dm_timer_set_match(struct omap_dm_timer *timer, int enable, unsigned int match);
+void omap_dm_timer_set_pwm(struct omap_dm_timer *timer, int def_on, int toggle, int trigger);
+void omap_dm_timer_set_prescaler(struct omap_dm_timer *timer, int prescaler);
+
+void omap_dm_timer_set_int_enable(struct omap_dm_timer *timer, unsigned int value);
+
+unsigned int omap_dm_timer_read_status(struct omap_dm_timer *timer);
+void omap_dm_timer_write_status(struct omap_dm_timer *timer, unsigned int value);
+unsigned int omap_dm_timer_read_counter(struct omap_dm_timer *timer);
+void omap_dm_timer_write_counter(struct omap_dm_timer *timer, unsigned int value);
+
+int omap_dm_timers_active(void);
+
+
+#endif /* __ASM_ARCH_DMTIMER_H */
Index: build_tree/linux/include/asm/arch-omap/dsp.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/dsp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/dsp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,250 @@
+/*
+ * linux/include/asm-arm/arch-omap/dsp.h
+ *
+ * Header for OMAP DSP driver
+ *
+ * Copyright (C) 2002-2005 Nokia Corporation
+ *
+ * Written by Toshihiro Kobayashi <toshihiro.kobayashi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * 2005/06/01:  DSP Gateway version 3.3
+ */
+
+#ifndef ASM_ARCH_DSP_H
+#define ASM_ARCH_DSP_H
+
+
+/*
+ * for /dev/dspctl/ctl
+ */
+#define OMAP_DSP_IOCTL_RESET			1
+#define OMAP_DSP_IOCTL_RUN			2
+#define OMAP_DSP_IOCTL_SETRSTVECT		3
+#define OMAP_DSP_IOCTL_CPU_IDLE			4
+#define OMAP_DSP_IOCTL_MPUI_WORDSWAP_ON		5
+#define OMAP_DSP_IOCTL_MPUI_WORDSWAP_OFF	6
+#define OMAP_DSP_IOCTL_MPUI_BYTESWAP_ON		7
+#define OMAP_DSP_IOCTL_MPUI_BYTESWAP_OFF	8
+#define OMAP_DSP_IOCTL_GBL_IDLE			9
+#define OMAP_DSP_IOCTL_DSPCFG			10
+#define OMAP_DSP_IOCTL_DSPUNCFG			11
+#define OMAP_DSP_IOCTL_TASKCNT			12
+#define OMAP_DSP_IOCTL_POLL			13
+#define OMAP_DSP_IOCTL_REGMEMR			40
+#define OMAP_DSP_IOCTL_REGMEMW			41
+#define OMAP_DSP_IOCTL_REGIOR			42
+#define OMAP_DSP_IOCTL_REGIOW			43
+#define OMAP_DSP_IOCTL_GETVAR			44
+#define OMAP_DSP_IOCTL_SETVAR			45
+#define OMAP_DSP_IOCTL_RUNLEVEL			50
+#define OMAP_DSP_IOCTL_SUSPEND			51
+#define OMAP_DSP_IOCTL_RESUME			52
+#define OMAP_DSP_IOCTL_FBEN			53
+#define OMAP_DSP_IOCTL_FBDIS			54
+#define OMAP_DSP_IOCTL_MBSEND			99
+
+/*
+ * for taskdev
+ * (ioctls below should be >= 0x10000)
+ */
+#define OMAP_DSP_TASK_IOCTL_BFLSH	0x10000
+#define OMAP_DSP_TASK_IOCTL_SETBSZ	0x10001
+#define OMAP_DSP_TASK_IOCTL_LOCK	0x10002
+#define OMAP_DSP_TASK_IOCTL_UNLOCK	0x10003
+#define OMAP_DSP_TASK_IOCTL_GETNAME	0x10004
+
+/*
+ * for /dev/dspctl/mem
+ */
+#define OMAP_DSP_MEM_IOCTL_EXMAP	1
+#define OMAP_DSP_MEM_IOCTL_EXUNMAP	2
+#define OMAP_DSP_MEM_IOCTL_EXMAP_FLUSH	3
+#define OMAP_DSP_MEM_IOCTL_FBEXPORT	5
+#define OMAP_DSP_MEM_IOCTL_MMUITACK	7
+#define OMAP_DSP_MEM_IOCTL_MMUINIT	9
+#define OMAP_DSP_MEM_IOCTL_KMEM_RESERVE	11
+#define OMAP_DSP_MEM_IOCTL_KMEM_RELEASE	12
+
+struct omap_dsp_mapinfo {
+	unsigned long dspadr;
+	unsigned long size;
+};
+
+/*
+ * for /dev/dspctl/twch
+ */
+#define OMAP_DSP_TWCH_IOCTL_MKDEV	1
+#define OMAP_DSP_TWCH_IOCTL_RMDEV	2
+#define OMAP_DSP_TWCH_IOCTL_TADD	11
+#define OMAP_DSP_TWCH_IOCTL_TDEL	12
+#define OMAP_DSP_TWCH_IOCTL_TKILL	13
+
+#define OMAP_DSP_DEVSTATE_NOTASK	0x00000001
+#define OMAP_DSP_DEVSTATE_ATTACHED	0x00000002
+#define OMAP_DSP_DEVSTATE_GARBAGE	0x00000004
+#define OMAP_DSP_DEVSTATE_INVALID	0x00000008
+#define OMAP_DSP_DEVSTATE_ADDREQ	0x00000100
+#define OMAP_DSP_DEVSTATE_DELREQ	0x00000200
+#define OMAP_DSP_DEVSTATE_ADDFAIL	0x00001000
+#define OMAP_DSP_DEVSTATE_ADDING	0x00010000
+#define OMAP_DSP_DEVSTATE_DELING	0x00020000
+#define OMAP_DSP_DEVSTATE_KILLING	0x00040000
+#define OMAP_DSP_DEVSTATE_STATE_MASK	0x7fffffff
+#define OMAP_DSP_DEVSTATE_STALE		0x80000000
+
+struct omap_dsp_taddinfo {
+	unsigned char minor;
+	unsigned long taskadr;
+};
+#define OMAP_DSP_TADD_ABORTADR	0xffffffff
+
+
+/*
+ * error cause definition (for error detection device)
+ */
+#define OMAP_DSP_ERRDT_WDT	0x00000001
+#define OMAP_DSP_ERRDT_MMU	0x00000002
+
+
+/*
+ * mailbox protocol definitions
+ */
+
+struct omap_dsp_mailbox_cmd {
+	unsigned short cmd;
+	unsigned short data;
+};
+
+struct omap_dsp_reginfo {
+	unsigned short adr;
+	unsigned short val;
+};
+
+struct omap_dsp_varinfo {
+	unsigned char varid;
+	unsigned short val[0];
+};
+
+#define OMAP_DSP_MBPROT_REVISION	0x0019
+
+#define OMAP_DSP_MBCMD_WDSND	0x10
+#define OMAP_DSP_MBCMD_WDREQ	0x11
+#define OMAP_DSP_MBCMD_BKSND	0x20
+#define OMAP_DSP_MBCMD_BKREQ	0x21
+#define OMAP_DSP_MBCMD_BKYLD	0x23
+#define OMAP_DSP_MBCMD_BKSNDP	0x24
+#define OMAP_DSP_MBCMD_BKREQP	0x25
+#define OMAP_DSP_MBCMD_TCTL	0x30
+#define OMAP_DSP_MBCMD_TCTLDATA	0x31
+#define OMAP_DSP_MBCMD_POLL	0x32
+#define OMAP_DSP_MBCMD_WDT	0x50	/* v3.3: obsolete */
+#define OMAP_DSP_MBCMD_RUNLEVEL	0x51
+#define OMAP_DSP_MBCMD_PM	0x52
+#define OMAP_DSP_MBCMD_SUSPEND	0x53
+#define OMAP_DSP_MBCMD_KFUNC	0x54
+#define OMAP_DSP_MBCMD_TCFG	0x60
+#define OMAP_DSP_MBCMD_TADD	0x62
+#define OMAP_DSP_MBCMD_TDEL	0x63
+#define OMAP_DSP_MBCMD_TSTOP	0x65
+#define OMAP_DSP_MBCMD_DSPCFG	0x70
+#define OMAP_DSP_MBCMD_REGRW	0x72
+#define OMAP_DSP_MBCMD_GETVAR	0x74
+#define OMAP_DSP_MBCMD_SETVAR	0x75
+#define OMAP_DSP_MBCMD_ERR	0x78
+#define OMAP_DSP_MBCMD_DBG	0x79
+
+#define OMAP_DSP_MBCMD_TCTL_TINIT	0x0000
+#define OMAP_DSP_MBCMD_TCTL_TEN		0x0001
+#define OMAP_DSP_MBCMD_TCTL_TDIS	0x0002
+#define OMAP_DSP_MBCMD_TCTL_TCLR	0x0003
+#define OMAP_DSP_MBCMD_TCTL_TCLR_FORCE	0x0004
+
+#define OMAP_DSP_MBCMD_RUNLEVEL_USER		0x01
+#define OMAP_DSP_MBCMD_RUNLEVEL_SUPER		0x0e
+#define OMAP_DSP_MBCMD_RUNLEVEL_RECOVERY	0x10
+
+#define OMAP_DSP_MBCMD_PM_DISABLE	0x00
+#define OMAP_DSP_MBCMD_PM_ENABLE	0x01
+
+#define OMAP_DSP_MBCMD_KFUNC_FBCTL	0x00
+#define OMAP_DSP_MBCMD_KFUNC_AUDIO_PWR	0x01
+
+#define OMAP_DSP_MBCMD_FBCTL_UPD	0x0000
+#define OMAP_DSP_MBCMD_FBCTL_ENABLE	0x0002
+#define OMAP_DSP_MBCMD_FBCTL_DISABLE	0x0003
+
+#define OMAP_DSP_MBCMD_AUDIO_PWR_UP	0x0000
+#define OMAP_DSP_MBCMD_AUDIO_PWR_DOWN1	0x0001
+#define OMAP_DSP_MBCMD_AUDIO_PWR_DOWN2	0x0002
+
+#define OMAP_DSP_MBCMD_TDEL_SAFE	0x0000
+#define OMAP_DSP_MBCMD_TDEL_KILL	0x0001
+
+#define OMAP_DSP_MBCMD_DSPCFG_REQ	0x00
+#define OMAP_DSP_MBCMD_DSPCFG_SYSADRH	0x28
+#define OMAP_DSP_MBCMD_DSPCFG_SYSADRL	0x29
+#define OMAP_DSP_MBCMD_DSPCFG_PROTREV	0x70
+#define OMAP_DSP_MBCMD_DSPCFG_ABORT	0x78
+#define OMAP_DSP_MBCMD_DSPCFG_LAST	0x80
+
+#define OMAP_DSP_MBCMD_REGRW_MEMR	0x00
+#define OMAP_DSP_MBCMD_REGRW_MEMW	0x01
+#define OMAP_DSP_MBCMD_REGRW_IOR	0x02
+#define OMAP_DSP_MBCMD_REGRW_IOW	0x03
+#define OMAP_DSP_MBCMD_REGRW_DATA	0x04
+
+#define OMAP_DSP_MBCMD_VARID_ICRMASK	0x00
+#define OMAP_DSP_MBCMD_VARID_LOADINFO	0x01
+
+#define OMAP_DSP_TTYP_ARCV	0x0001
+#define OMAP_DSP_TTYP_ASND	0x0002
+#define OMAP_DSP_TTYP_BKMD	0x0004
+#define OMAP_DSP_TTYP_BKDM	0x0008
+#define OMAP_DSP_TTYP_PVMD	0x0010
+#define OMAP_DSP_TTYP_PVDM	0x0020
+
+#define OMAP_DSP_EID_BADTID	0x10
+#define OMAP_DSP_EID_BADTCN	0x11
+#define OMAP_DSP_EID_BADBID	0x20
+#define OMAP_DSP_EID_BADCNT	0x21
+#define OMAP_DSP_EID_NOTLOCKED	0x22
+#define OMAP_DSP_EID_STVBUF	0x23
+#define OMAP_DSP_EID_BADADR	0x24
+#define OMAP_DSP_EID_BADTCTL	0x30
+#define OMAP_DSP_EID_BADPARAM	0x50
+#define OMAP_DSP_EID_FATAL	0x58
+#define OMAP_DSP_EID_NOMEM	0xc0
+#define OMAP_DSP_EID_NORES	0xc1
+#define OMAP_DSP_EID_IPBFULL	0xc2
+#define OMAP_DSP_EID_WDT	0xd0
+#define OMAP_DSP_EID_TASKNOTRDY	0xe0
+#define OMAP_DSP_EID_TASKBSY	0xe1
+#define OMAP_DSP_EID_TASKERR	0xef
+#define OMAP_DSP_EID_BADCFGTYP	0xf0
+#define OMAP_DSP_EID_DEBUG	0xf8
+#define OMAP_DSP_EID_BADSEQ	0xfe
+#define OMAP_DSP_EID_BADCMD	0xff
+
+#define OMAP_DSP_TNM_LEN	16
+
+#define OMAP_DSP_TID_FREE	0xff
+#define OMAP_DSP_TID_ANON	0xfe
+
+#define OMAP_DSP_BID_NULL	0xffff
+#define OMAP_DSP_BID_PVT	0xfffe
+
+#endif /* ASM_ARCH_DSP_H */
Index: build_tree/linux/include/asm/arch-omap/dsp_common.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/dsp_common.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/dsp_common.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * linux/include/asm-arm/arch-omap/dsp_common.h
+ *
+ * Header for OMAP DSP subsystem control
+ *
+ * Copyright (C) 2004,2005 Nokia Corporation
+ *
+ * Written by Toshihiro Kobayashi <toshihiro.kobayashi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * 2005/06/03:  DSP Gateway version 3.3
+ */
+
+#ifndef ASM_ARCH_DSP_COMMON_H
+#define ASM_ARCH_DSP_COMMON_H
+
+extern void omap_dsp_request_mpui(void);
+extern void omap_dsp_release_mpui(void);
+extern int omap_dsp_request_mem(void);
+extern int omap_dsp_release_mem(void);
+
+extern void (*omap_dsp_audio_pwr_up_request)(int stage);
+extern void (*omap_dsp_audio_pwr_down_request)(int stage);
+
+#endif /* ASM_ARCH_DSP_COMMON_H */
Index: build_tree/linux/include/asm/arch-omap/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-omap/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,88 @@
+/*
+ * include/asm-arm/arch-omap/entry-macro.S
+ *
+ * Low-level IRQ helper macros for OMAP-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/arch/irqs.h>
+
+#if defined(CONFIG_ARCH_OMAP1)
+
+#if defined(CONFIG_ARCH_OMAP730) && \
+	(defined(CONFIG_ARCH_OMAP15XX) || defined(CONFIG_ARCH_OMAP16XX))
+#error "FIXME: OMAP730 doesn't support multiple-OMAP"
+#elif defined(CONFIG_ARCH_OMAP730)
+#define INT_IH2_IRQ		INT_730_IH2_IRQ
+#elif defined(CONFIG_ARCH_OMAP15XX)
+#define INT_IH2_IRQ		INT_1510_IH2_IRQ
+#elif defined(CONFIG_ARCH_OMAP16XX)
+#define INT_IH2_IRQ		INT_1610_IH2_IRQ
+#else
+#warning "IH2 IRQ defaulted"
+#define INT_IH2_IRQ		INT_1510_IH2_IRQ
+#endif
+
+ 		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =IO_ADDRESS(OMAP_IH1_BASE)
+		ldr	\irqnr, [\base, #IRQ_ITR_REG_OFFSET]
+		ldr	\tmp, [\base, #IRQ_MIR_REG_OFFSET]
+		mov	\irqstat, #0xffffffff
+		bic	\tmp, \irqstat, \tmp
+		tst	\irqnr, \tmp
+		beq	1510f
+
+		ldr	\irqnr, [\base, #IRQ_SIR_FIQ_REG_OFFSET]
+		cmp	\irqnr, #0
+		ldreq	\irqnr, [\base, #IRQ_SIR_IRQ_REG_OFFSET]
+		cmpeq	\irqnr, #INT_IH2_IRQ
+		ldreq	\base, =IO_ADDRESS(OMAP_IH2_BASE)
+		ldreq	\irqnr, [\base, #IRQ_SIR_IRQ_REG_OFFSET]
+		addeqs	\irqnr, \irqnr, #32
+1510:
+		.endm
+
+#elif defined(CONFIG_ARCH_OMAP24XX)
+
+#include <asm/arch/omap24xx.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =VA_IC_BASE
+		ldr	\irqnr, [\base, #0x98] /* IRQ pending reg 1 */
+		cmp	\irqnr, #0x0
+		bne	2222f
+		ldr	\irqnr, [\base, #0xb8] /* IRQ pending reg 2 */
+		cmp	\irqnr, #0x0
+		bne	2222f
+		ldr	\irqnr, [\base, #0xd8] /* IRQ pending reg 3 */
+		cmp	\irqnr, #0x0
+2222:
+		ldrne	\irqnr, [\base, #IRQ_SIR_IRQ]
+
+		.endm
+
+		.macro	irq_prio_table
+		.endm
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/fpga.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/fpga.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/fpga.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,198 @@
+/*
+ * linux/include/asm-arm/arch-omap/fpga.h
+ *
+ * Interrupt handler for OMAP-1510 FPGA
+ *
+ * Copyright (C) 2001 RidgeRun, Inc.
+ * Author: Greg Lonnon <glonnon@ridgerun.com>
+ *
+ * Copyright (C) 2002 MontaVista Software, Inc.
+ *
+ * Separated FPGA interrupts from innovator1510.c and cleaned up for 2.6
+ * Copyright (C) 2004 Nokia Corporation by Tony Lindrgen <tony@atomide.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_OMAP_FPGA_H
+#define __ASM_ARCH_OMAP_FPGA_H
+
+#if defined(CONFIG_MACH_OMAP_INNOVATOR) && defined(CONFIG_ARCH_OMAP15XX)
+extern void omap1510_fpga_init_irq(void);
+#else
+#define omap1510_fpga_init_irq()	(0)
+#endif
+
+#define fpga_read(reg)			__raw_readb(reg)
+#define fpga_write(val, reg)		__raw_writeb(val, reg)
+
+/*
+ * ---------------------------------------------------------------------------
+ *  H2/P2 Debug board FPGA
+ * ---------------------------------------------------------------------------
+ */
+/* maps in the FPGA registers and the ETHR registers */
+#define H2P2_DBG_FPGA_BASE		0xE8000000	/* VA */
+#define H2P2_DBG_FPGA_SIZE		SZ_4K		/* SIZE */
+#define H2P2_DBG_FPGA_START		0x04000000	/* PA */
+
+#define H2P2_DBG_FPGA_ETHR_START	(H2P2_DBG_FPGA_START + 0x300)
+#define H2P2_DBG_FPGA_FPGA_REV		(H2P2_DBG_FPGA_BASE + 0x10)	/* FPGA Revision */
+#define H2P2_DBG_FPGA_BOARD_REV		(H2P2_DBG_FPGA_BASE + 0x12)	/* Board Revision */
+#define H2P2_DBG_FPGA_GPIO		(H2P2_DBG_FPGA_BASE + 0x14)	/* GPIO outputs */
+#define H2P2_DBG_FPGA_LEDS		(H2P2_DBG_FPGA_BASE + 0x16)	/* LEDs outputs */
+#define H2P2_DBG_FPGA_MISC_INPUTS	(H2P2_DBG_FPGA_BASE + 0x18)	/* Misc inputs */
+#define H2P2_DBG_FPGA_LAN_STATUS	(H2P2_DBG_FPGA_BASE + 0x1A)	/* LAN Status line */
+#define H2P2_DBG_FPGA_LAN_RESET		(H2P2_DBG_FPGA_BASE + 0x1C)	/* LAN Reset line */
+
+/* NOTE:  most boards don't have a static mapping for the FPGA ... */
+struct h2p2_dbg_fpga {
+	/* offset 0x00 */
+	u16		smc91x[8];
+	/* offset 0x10 */
+	u16		fpga_rev;
+	u16		board_rev;
+	u16		gpio_outputs;
+	u16		leds;
+	/* offset 0x18 */
+	u16		misc_inputs;
+	u16		lan_status;
+	u16		lan_reset;
+	u16		reserved0;
+	/* offset 0x20 */
+	u16		ps2_data;
+	u16		ps2_ctrl;
+	/* plus also 4 rs232 ports ... */
+};
+
+/* LEDs definition on debug board (16 LEDs, all physically green) */
+#define H2P2_DBG_FPGA_LED_GREEN		(1 << 15)
+#define H2P2_DBG_FPGA_LED_AMBER		(1 << 14)
+#define H2P2_DBG_FPGA_LED_RED		(1 << 13)
+#define H2P2_DBG_FPGA_LED_BLUE		(1 << 12)
+/*  cpu0 load-meter LEDs */
+#define H2P2_DBG_FPGA_LOAD_METER	(1 << 0)	// A bit of fun on our board ...
+#define H2P2_DBG_FPGA_LOAD_METER_SIZE	11
+#define H2P2_DBG_FPGA_LOAD_METER_MASK	((1 << H2P2_DBG_FPGA_LOAD_METER_SIZE) - 1)
+
+#define H2P2_DBG_FPGA_P2_LED_TIMER		(1 << 0)
+#define H2P2_DBG_FPGA_P2_LED_IDLE		(1 << 1)
+
+/*
+ * ---------------------------------------------------------------------------
+ *  OMAP-1510 FPGA
+ * ---------------------------------------------------------------------------
+ */
+#define OMAP1510_FPGA_BASE			0xE8000000	/* Virtual */
+#define OMAP1510_FPGA_SIZE			SZ_4K
+#define OMAP1510_FPGA_START			0x08000000	/* Physical */
+
+/* Revision */
+#define OMAP1510_FPGA_REV_LOW			(OMAP1510_FPGA_BASE + 0x0)
+#define OMAP1510_FPGA_REV_HIGH			(OMAP1510_FPGA_BASE + 0x1)
+
+#define OMAP1510_FPGA_LCD_PANEL_CONTROL		(OMAP1510_FPGA_BASE + 0x2)
+#define OMAP1510_FPGA_LED_DIGIT			(OMAP1510_FPGA_BASE + 0x3)
+#define INNOVATOR_FPGA_HID_SPI			(OMAP1510_FPGA_BASE + 0x4)
+#define OMAP1510_FPGA_POWER			(OMAP1510_FPGA_BASE + 0x5)
+
+/* Interrupt status */
+#define OMAP1510_FPGA_ISR_LO			(OMAP1510_FPGA_BASE + 0x6)
+#define OMAP1510_FPGA_ISR_HI			(OMAP1510_FPGA_BASE + 0x7)
+
+/* Interrupt mask */
+#define OMAP1510_FPGA_IMR_LO			(OMAP1510_FPGA_BASE + 0x8)
+#define OMAP1510_FPGA_IMR_HI			(OMAP1510_FPGA_BASE + 0x9)
+
+/* Reset registers */
+#define OMAP1510_FPGA_HOST_RESET		(OMAP1510_FPGA_BASE + 0xa)
+#define OMAP1510_FPGA_RST			(OMAP1510_FPGA_BASE + 0xb)
+
+#define OMAP1510_FPGA_AUDIO			(OMAP1510_FPGA_BASE + 0xc)
+#define OMAP1510_FPGA_DIP			(OMAP1510_FPGA_BASE + 0xe)
+#define OMAP1510_FPGA_FPGA_IO			(OMAP1510_FPGA_BASE + 0xf)
+#define OMAP1510_FPGA_UART1			(OMAP1510_FPGA_BASE + 0x14)
+#define OMAP1510_FPGA_UART2			(OMAP1510_FPGA_BASE + 0x15)
+#define OMAP1510_FPGA_OMAP1510_STATUS		(OMAP1510_FPGA_BASE + 0x16)
+#define OMAP1510_FPGA_BOARD_REV			(OMAP1510_FPGA_BASE + 0x18)
+#define OMAP1510P1_PPT_DATA			(OMAP1510_FPGA_BASE + 0x100)
+#define OMAP1510P1_PPT_STATUS			(OMAP1510_FPGA_BASE + 0x101)
+#define OMAP1510P1_PPT_CONTROL			(OMAP1510_FPGA_BASE + 0x102)
+
+#define OMAP1510_FPGA_TOUCHSCREEN		(OMAP1510_FPGA_BASE + 0x204)
+
+#define INNOVATOR_FPGA_INFO			(OMAP1510_FPGA_BASE + 0x205)
+#define INNOVATOR_FPGA_LCD_BRIGHT_LO		(OMAP1510_FPGA_BASE + 0x206)
+#define INNOVATOR_FPGA_LCD_BRIGHT_HI		(OMAP1510_FPGA_BASE + 0x207)
+#define INNOVATOR_FPGA_LED_GRN_LO		(OMAP1510_FPGA_BASE + 0x208)
+#define INNOVATOR_FPGA_LED_GRN_HI		(OMAP1510_FPGA_BASE + 0x209)
+#define INNOVATOR_FPGA_LED_RED_LO		(OMAP1510_FPGA_BASE + 0x20a)
+#define INNOVATOR_FPGA_LED_RED_HI		(OMAP1510_FPGA_BASE + 0x20b)
+#define INNOVATOR_FPGA_CAM_USB_CONTROL		(OMAP1510_FPGA_BASE + 0x20c)
+#define INNOVATOR_FPGA_EXP_CONTROL		(OMAP1510_FPGA_BASE + 0x20d)
+#define INNOVATOR_FPGA_ISR2			(OMAP1510_FPGA_BASE + 0x20e)
+#define INNOVATOR_FPGA_IMR2			(OMAP1510_FPGA_BASE + 0x210)
+
+#define OMAP1510_FPGA_ETHR_START		(OMAP1510_FPGA_START + 0x300)
+
+/*
+ * Power up Giga UART driver, turn on HID clock.
+ * Turn off BT power, since we're not using it and it
+ * draws power.
+ */
+#define OMAP1510_FPGA_RESET_VALUE		0x42
+
+#define OMAP1510_FPGA_PCR_IF_PD0		(1 << 7)
+#define OMAP1510_FPGA_PCR_COM2_EN		(1 << 6)
+#define OMAP1510_FPGA_PCR_COM1_EN		(1 << 5)
+#define OMAP1510_FPGA_PCR_EXP_PD0		(1 << 4)
+#define OMAP1510_FPGA_PCR_EXP_PD1		(1 << 3)
+#define OMAP1510_FPGA_PCR_48MHZ_CLK		(1 << 2)
+#define OMAP1510_FPGA_PCR_4MHZ_CLK		(1 << 1)
+#define OMAP1510_FPGA_PCR_RSRVD_BIT0		(1 << 0)
+
+/*
+ * Innovator/OMAP1510 FPGA HID register bit definitions
+ */
+#define OMAP1510_FPGA_HID_SCLK	(1<<0)	/* output */
+#define OMAP1510_FPGA_HID_MOSI	(1<<1)	/* output */
+#define OMAP1510_FPGA_HID_nSS	(1<<2)	/* output 0/1 chip idle/select */
+#define OMAP1510_FPGA_HID_nHSUS	(1<<3)	/* output 0/1 host active/suspended */
+#define OMAP1510_FPGA_HID_MISO	(1<<4)	/* input */
+#define OMAP1510_FPGA_HID_ATN	(1<<5)	/* input  0/1 chip idle/ATN */
+#define OMAP1510_FPGA_HID_rsrvd	(1<<6)
+#define OMAP1510_FPGA_HID_RESETn (1<<7)	/* output - 0/1 USAR reset/run */
+
+/* The FPGA IRQ is cascaded through GPIO_13 */
+#define OMAP1510_INT_FPGA		(IH_GPIO_BASE + 13)
+
+/* IRQ Numbers for interrupts muxed through the FPGA */
+#define OMAP1510_IH_FPGA_BASE		IH_BOARD_BASE
+#define OMAP1510_INT_FPGA_ATN		(OMAP1510_IH_FPGA_BASE + 0)
+#define OMAP1510_INT_FPGA_ACK		(OMAP1510_IH_FPGA_BASE + 1)
+#define OMAP1510_INT_FPGA2		(OMAP1510_IH_FPGA_BASE + 2)
+#define OMAP1510_INT_FPGA3		(OMAP1510_IH_FPGA_BASE + 3)
+#define OMAP1510_INT_FPGA4		(OMAP1510_IH_FPGA_BASE + 4)
+#define OMAP1510_INT_FPGA5		(OMAP1510_IH_FPGA_BASE + 5)
+#define OMAP1510_INT_FPGA6		(OMAP1510_IH_FPGA_BASE + 6)
+#define OMAP1510_INT_FPGA7		(OMAP1510_IH_FPGA_BASE + 7)
+#define OMAP1510_INT_FPGA8		(OMAP1510_IH_FPGA_BASE + 8)
+#define OMAP1510_INT_FPGA9		(OMAP1510_IH_FPGA_BASE + 9)
+#define OMAP1510_INT_FPGA10		(OMAP1510_IH_FPGA_BASE + 10)
+#define OMAP1510_INT_FPGA11		(OMAP1510_IH_FPGA_BASE + 11)
+#define OMAP1510_INT_FPGA12		(OMAP1510_IH_FPGA_BASE + 12)
+#define OMAP1510_INT_ETHER		(OMAP1510_IH_FPGA_BASE + 13)
+#define OMAP1510_INT_FPGAUART1		(OMAP1510_IH_FPGA_BASE + 14)
+#define OMAP1510_INT_FPGAUART2		(OMAP1510_IH_FPGA_BASE + 15)
+#define OMAP1510_INT_FPGA_TS		(OMAP1510_IH_FPGA_BASE + 16)
+#define OMAP1510_INT_FPGA17		(OMAP1510_IH_FPGA_BASE + 17)
+#define OMAP1510_INT_FPGA_CAM		(OMAP1510_IH_FPGA_BASE + 18)
+#define OMAP1510_INT_FPGA_RTC_A		(OMAP1510_IH_FPGA_BASE + 19)
+#define OMAP1510_INT_FPGA_RTC_B		(OMAP1510_IH_FPGA_BASE + 20)
+#define OMAP1510_INT_FPGA_CD		(OMAP1510_IH_FPGA_BASE + 21)
+#define OMAP1510_INT_FPGA22		(OMAP1510_IH_FPGA_BASE + 22)
+#define OMAP1510_INT_FPGA23		(OMAP1510_IH_FPGA_BASE + 23)
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,146 @@
+/*
+ * linux/include/asm-arm/arch-omap/gpio.h
+ *
+ * OMAP GPIO handling defines and functions
+ *
+ * Copyright (C) 2003-2005 Nokia Corporation
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __ASM_ARCH_OMAP_GPIO_H
+#define __ASM_ARCH_OMAP_GPIO_H
+
+#include <asm/hardware.h>
+#include <asm/arch/irqs.h>
+#include <asm/io.h>
+
+#define OMAP_MPUIO_BASE			(void __iomem *)0xfffb5000
+
+#ifdef CONFIG_ARCH_OMAP730
+#define OMAP_MPUIO_INPUT_LATCH		0x00
+#define OMAP_MPUIO_OUTPUT		0x02
+#define OMAP_MPUIO_IO_CNTL		0x04
+#define OMAP_MPUIO_KBR_LATCH		0x08
+#define OMAP_MPUIO_KBC			0x0a
+#define OMAP_MPUIO_GPIO_EVENT_MODE	0x0c
+#define OMAP_MPUIO_GPIO_INT_EDGE	0x0e
+#define OMAP_MPUIO_KBD_INT		0x10
+#define OMAP_MPUIO_GPIO_INT		0x12
+#define OMAP_MPUIO_KBD_MASKIT		0x14
+#define OMAP_MPUIO_GPIO_MASKIT		0x16
+#define OMAP_MPUIO_GPIO_DEBOUNCING	0x18
+#define OMAP_MPUIO_LATCH		0x1a
+#else
+#define OMAP_MPUIO_INPUT_LATCH		0x00
+#define OMAP_MPUIO_OUTPUT		0x04
+#define OMAP_MPUIO_IO_CNTL		0x08
+#define OMAP_MPUIO_KBR_LATCH		0x10
+#define OMAP_MPUIO_KBC			0x14
+#define OMAP_MPUIO_GPIO_EVENT_MODE	0x18
+#define OMAP_MPUIO_GPIO_INT_EDGE	0x1c
+#define OMAP_MPUIO_KBD_INT		0x20
+#define OMAP_MPUIO_GPIO_INT		0x24
+#define OMAP_MPUIO_KBD_MASKIT		0x28
+#define OMAP_MPUIO_GPIO_MASKIT		0x2c
+#define OMAP_MPUIO_GPIO_DEBOUNCING	0x30
+#define OMAP_MPUIO_LATCH		0x34
+#endif
+
+#define OMAP_MPUIO(nr)		(OMAP_MAX_GPIO_LINES + (nr))
+#define OMAP_GPIO_IS_MPUIO(nr)	((nr) >= OMAP_MAX_GPIO_LINES)
+
+#define OMAP_GPIO_IRQ(nr)	(OMAP_GPIO_IS_MPUIO(nr) ? \
+				 IH_MPUIO_BASE + ((nr) & 0x0f) : \
+				 IH_GPIO_BASE + (nr))
+
+extern int omap_gpio_init(void);	/* Call from board init only */
+extern int omap_request_gpio(int gpio);
+extern void omap_free_gpio(int gpio);
+extern void omap_set_gpio_direction(int gpio, int is_input);
+extern void omap_set_gpio_dataout(int gpio, int enable);
+extern int omap_get_gpio_datain(int gpio);
+
+/*-------------------------------------------------------------------------*/
+
+/* wrappers for "new style" GPIO calls. the old OMAP-specfic ones should
+ * eventually be removed (along with this errno.h inclusion), and maybe
+ * gpios should put MPUIOs last too.
+ */
+
+#include <asm/errno.h>
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return omap_request_gpio(gpio);
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+	omap_free_gpio(gpio);
+}
+
+static inline int __gpio_set_direction(unsigned gpio, int is_input)
+{
+	if (cpu_class_is_omap2()) {
+		if (gpio > OMAP_MAX_GPIO_LINES)
+			return -EINVAL;
+	} else {
+		if (gpio > (OMAP_MAX_GPIO_LINES + 16 /* MPUIO */))
+			return -EINVAL;
+	}
+	omap_set_gpio_direction(gpio, is_input);
+	return 0;
+}
+
+static inline int gpio_direction_input(unsigned gpio)
+{
+	return __gpio_set_direction(gpio, 1);
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	omap_set_gpio_dataout(gpio, value);
+	return __gpio_set_direction(gpio, 0);
+}
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return omap_get_gpio_datain(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	omap_set_gpio_dataout(gpio, value);
+}
+
+#include <asm-generic/gpio.h>		/* cansleep wrappers */
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+	return OMAP_GPIO_IRQ(gpio);
+}
+
+static inline int irq_to_gpio(unsigned irq)
+{
+	if (cpu_class_is_omap1() && (irq < (IH_MPUIO_BASE + 16)))
+		return (irq - IH_MPUIO_BASE) + OMAP_MAX_GPIO_LINES;
+	return irq - IH_GPIO_BASE;
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/gpioexpander.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/gpioexpander.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/gpioexpander.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ * linux/include/asm-arm/arch-omap/gpioexpander.h
+ *
+ *
+ * Copyright (C) 2004 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __ASM_ARCH_OMAP_GPIOEXPANDER_H
+#define __ASM_ARCH_OMAP_GPIOEXPANDER_H
+
+/* Function Prototypes for GPIO Expander functions */
+
+int read_gpio_expa(u8 *, int);
+int write_gpio_expa(u8 , int);
+
+#endif /* __ASM_ARCH_OMAP_GPIOEXPANDER_H */
Index: build_tree/linux/include/asm/arch-omap/gpmc.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/gpmc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/gpmc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,91 @@
+/*
+ * General-Purpose Memory Controller for OMAP2
+ *
+ * Copyright (C) 2005-2006 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __OMAP2_GPMC_H
+#define __OMAP2_GPMC_H
+
+#define GPMC_CS_CONFIG1		0x00
+#define GPMC_CS_CONFIG2		0x04
+#define GPMC_CS_CONFIG3		0x08
+#define GPMC_CS_CONFIG4		0x0c
+#define GPMC_CS_CONFIG5		0x10
+#define GPMC_CS_CONFIG6		0x14
+#define GPMC_CS_CONFIG7		0x18
+#define GPMC_CS_NAND_COMMAND	0x1c
+#define GPMC_CS_NAND_ADDRESS	0x20
+#define GPMC_CS_NAND_DATA	0x24
+
+#define GPMC_CONFIG1_WRAPBURST_SUPP     (1 << 31)
+#define GPMC_CONFIG1_READMULTIPLE_SUPP  (1 << 20)
+#define GPMC_CONFIG1_READTYPE_ASYNC     (0 << 29)
+#define GPMC_CONFIG1_READTYPE_SYNC      (1 << 29)
+#define GPMC_CONFIG1_WRITETYPE_ASYNC    (0 << 27)
+#define GPMC_CONFIG1_WRITETYPE_SYNC     (1 << 27)
+#define GPMC_CONFIG1_CLKACTIVATIONTIME(val) ((val & 3) << 25)
+#define GPMC_CONFIG1_PAGE_LEN(val)      ((val & 3) << 23)
+#define GPMC_CONFIG1_WAIT_READ_MON      (1 << 22)
+#define GPMC_CONFIG1_WAIT_WRITE_MON     (1 << 21)
+#define GPMC_CONFIG1_WAIT_MON_IIME(val) ((val & 3) << 18)
+#define GPMC_CONFIG1_WAIT_PIN_SEL(val)  ((val & 3) << 16)
+#define GPMC_CONFIG1_DEVICESIZE(val)    ((val & 3) << 12)
+#define GPMC_CONFIG1_DEVICESIZE_16      GPMC_CONFIG1_DEVICESIZE(1)
+#define GPMC_CONFIG1_DEVICETYPE(val)    ((val & 3) << 10)
+#define GPMC_CONFIG1_DEVICETYPE_NOR     GPMC_CONFIG1_DEVICETYPE(0)
+#define GPMC_CONFIG1_DEVICETYPE_NAND    GPMC_CONFIG1_DEVICETYPE(1)
+#define GPMC_CONFIG1_MUXADDDATA         (1 << 9)
+#define GPMC_CONFIG1_TIME_PARA_GRAN     (1 << 4)
+#define GPMC_CONFIG1_FCLK_DIV(val)      (val & 3)
+#define GPMC_CONFIG1_FCLK_DIV2          (GPMC_CONFIG1_FCLK_DIV(1))
+#define GPMC_CONFIG1_FCLK_DIV3          (GPMC_CONFIG1_FCLK_DIV(2))
+#define GPMC_CONFIG1_FCLK_DIV4          (GPMC_CONFIG1_FCLK_DIV(3))
+
+/*
+ * Note that all values in this struct are in nanoseconds, while
+ * the register values are in gpmc_fck cycles.
+ */
+struct gpmc_timings {
+	/* Minimum clock period for synchronous mode */
+	u16 sync_clk;
+
+	/* Chip-select signal timings corresponding to GPMC_CS_CONFIG2 */
+	u16 cs_on;		/* Assertion time */
+	u16 cs_rd_off;		/* Read deassertion time */
+	u16 cs_wr_off;		/* Write deassertion time */
+
+	/* ADV signal timings corresponding to GPMC_CONFIG3 */
+	u16 adv_on;		/* Assertion time */
+	u16 adv_rd_off;		/* Read deassertion time */
+	u16 adv_wr_off;		/* Write deassertion time */
+
+	/* WE signals timings corresponding to GPMC_CONFIG4 */
+	u16 we_on;		/* WE assertion time */
+	u16 we_off;		/* WE deassertion time */
+
+	/* OE signals timings corresponding to GPMC_CONFIG4 */
+	u16 oe_on;		/* OE assertion time */
+	u16 oe_off;		/* OE deassertion time */
+
+	/* Access time and cycle time timings corresponding to GPMC_CONFIG5 */
+	u16 page_burst_access;	/* Multiple access word delay */
+	u16 access;		/* Start-cycle to first data valid delay */
+	u16 rd_cycle;		/* Total read cycle time */
+	u16 wr_cycle;		/* Total write cycle time */
+};
+
+extern unsigned int gpmc_ns_to_ticks(unsigned int time_ns);
+
+extern void gpmc_cs_write_reg(int cs, int idx, u32 val);
+extern u32 gpmc_cs_read_reg(int cs, int idx);
+extern int gpmc_cs_calc_divider(int cs, unsigned int sync_clk);
+extern int gpmc_cs_set_timings(int cs, const struct gpmc_timings *t);
+extern int gpmc_cs_request(int cs, unsigned long size, unsigned long *base);
+extern void gpmc_cs_free(int cs);
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,326 @@
+/*
+ * linux/include/asm-arm/arch-omap/hardware.h
+ *
+ * Hardware definitions for TI OMAP processors and boards
+ *
+ * NOTE: Please put device driver specific defines into a separate header
+ *	 file for each driver.
+ *
+ * Copyright (C) 2001 RidgeRun, Inc.
+ * Author: RidgeRun, Inc. Greg Lonnon <glonnon@ridgerun.com>
+ *
+ * Reorganized for Linux-2.6 by Tony Lindgren <tony@atomide.com>
+ *                          and Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_HARDWARE_H
+#define __ASM_ARCH_OMAP_HARDWARE_H
+
+#include <asm/sizes.h>
+#ifndef __ASSEMBLER__
+#include <asm/types.h>
+#include <asm/arch/cpu.h>
+#endif
+#include <asm/arch/io.h>
+#include <asm/arch/serial.h>
+
+/*
+ * ---------------------------------------------------------------------------
+ * Common definitions for all OMAP processors
+ * NOTE: Put all processor or board specific parts to the special header
+ *	 files.
+ * ---------------------------------------------------------------------------
+ */
+
+/*
+ * ----------------------------------------------------------------------------
+ * Timers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP_MPU_TIMER1_BASE	(0xfffec500)
+#define OMAP_MPU_TIMER2_BASE	(0xfffec600)
+#define OMAP_MPU_TIMER3_BASE	(0xfffec700)
+#define MPU_TIMER_FREE		(1 << 6)
+#define MPU_TIMER_CLOCK_ENABLE	(1 << 5)
+#define MPU_TIMER_AR		(1 << 1)
+#define MPU_TIMER_ST		(1 << 0)
+
+/*
+ * ----------------------------------------------------------------------------
+ * Clocks
+ * ----------------------------------------------------------------------------
+ */
+#define CLKGEN_REG_BASE		(0xfffece00)
+#define ARM_CKCTL		(CLKGEN_REG_BASE + 0x0)
+#define ARM_IDLECT1		(CLKGEN_REG_BASE + 0x4)
+#define ARM_IDLECT2		(CLKGEN_REG_BASE + 0x8)
+#define ARM_EWUPCT		(CLKGEN_REG_BASE + 0xC)
+#define ARM_RSTCT1		(CLKGEN_REG_BASE + 0x10)
+#define ARM_RSTCT2		(CLKGEN_REG_BASE + 0x14)
+#define ARM_SYSST		(CLKGEN_REG_BASE + 0x18)
+#define ARM_IDLECT3		(CLKGEN_REG_BASE + 0x24)
+
+#define CK_RATEF		1
+#define CK_IDLEF		2
+#define CK_ENABLEF		4
+#define CK_SELECTF		8
+#define SETARM_IDLE_SHIFT
+
+/* DPLL control registers */
+#define DPLL_CTL		(0xfffecf00)
+
+/* DSP clock control. Must use __raw_readw() and __raw_writew() with these */
+#define DSP_CONFIG_REG_BASE     (0xe1008000)
+#define DSP_CKCTL		(DSP_CONFIG_REG_BASE + 0x0)
+#define DSP_IDLECT1		(DSP_CONFIG_REG_BASE + 0x4)
+#define DSP_IDLECT2		(DSP_CONFIG_REG_BASE + 0x8)
+#define DSP_RSTCT2		(DSP_CONFIG_REG_BASE + 0x14)
+
+/*
+ * ---------------------------------------------------------------------------
+ * UPLD
+ * ---------------------------------------------------------------------------
+ */
+#define ULPD_REG_BASE		(0xfffe0800)
+#define ULPD_IT_STATUS		(ULPD_REG_BASE + 0x14)
+#define ULPD_SETUP_ANALOG_CELL_3	(ULPD_REG_BASE + 0x24)
+#define ULPD_CLOCK_CTRL		(ULPD_REG_BASE + 0x30)
+#	define DIS_USB_PVCI_CLK		(1 << 5)	/* no USB/FAC synch */
+#	define USB_MCLK_EN		(1 << 4)	/* enable W4_USB_CLKO */
+#define ULPD_SOFT_REQ		(ULPD_REG_BASE + 0x34)
+#	define SOFT_UDC_REQ		(1 << 4)
+#	define SOFT_USB_CLK_REQ		(1 << 3)
+#	define SOFT_DPLL_REQ		(1 << 0)
+#define ULPD_DPLL_CTRL		(ULPD_REG_BASE + 0x3c)
+#define ULPD_STATUS_REQ		(ULPD_REG_BASE + 0x40)
+#define ULPD_APLL_CTRL		(ULPD_REG_BASE + 0x4c)
+#define ULPD_POWER_CTRL		(ULPD_REG_BASE + 0x50)
+#define ULPD_SOFT_DISABLE_REQ_REG	(ULPD_REG_BASE + 0x68)
+#	define DIS_MMC2_DPLL_REQ	(1 << 11)
+#	define DIS_MMC1_DPLL_REQ	(1 << 10)
+#	define DIS_UART3_DPLL_REQ	(1 << 9)
+#	define DIS_UART2_DPLL_REQ	(1 << 8)
+#	define DIS_UART1_DPLL_REQ	(1 << 7)
+#	define DIS_USB_HOST_DPLL_REQ	(1 << 6)
+#define ULPD_SDW_CLK_DIV_CTRL_SEL	(ULPD_REG_BASE + 0x74)
+#define ULPD_CAM_CLK_CTRL	(ULPD_REG_BASE + 0x7c)
+
+/*
+ * ---------------------------------------------------------------------------
+ * Watchdog timer
+ * ---------------------------------------------------------------------------
+ */
+
+/* Watchdog timer within the OMAP3.2 gigacell */
+#define OMAP_MPU_WATCHDOG_BASE	(0xfffec800)
+#define OMAP_WDT_TIMER		(OMAP_MPU_WATCHDOG_BASE + 0x0)
+#define OMAP_WDT_LOAD_TIM	(OMAP_MPU_WATCHDOG_BASE + 0x4)
+#define OMAP_WDT_READ_TIM	(OMAP_MPU_WATCHDOG_BASE + 0x4)
+#define OMAP_WDT_TIMER_MODE	(OMAP_MPU_WATCHDOG_BASE + 0x8)
+
+/*
+ * ---------------------------------------------------------------------------
+ * Interrupts
+ * ---------------------------------------------------------------------------
+ */
+#ifdef CONFIG_ARCH_OMAP1
+
+/*
+ * XXX: These probably want to be moved to arch/arm/mach-omap/omap1/irq.c
+ * or something similar.. -- PFM.
+ */
+
+#define OMAP_IH1_BASE		0xfffecb00
+#define OMAP_IH2_BASE		0xfffe0000
+
+#define OMAP_IH1_ITR		(OMAP_IH1_BASE + 0x00)
+#define OMAP_IH1_MIR		(OMAP_IH1_BASE + 0x04)
+#define OMAP_IH1_SIR_IRQ	(OMAP_IH1_BASE + 0x10)
+#define OMAP_IH1_SIR_FIQ	(OMAP_IH1_BASE + 0x14)
+#define OMAP_IH1_CONTROL	(OMAP_IH1_BASE + 0x18)
+#define OMAP_IH1_ILR0		(OMAP_IH1_BASE + 0x1c)
+#define OMAP_IH1_ISR		(OMAP_IH1_BASE + 0x9c)
+
+#define OMAP_IH2_ITR		(OMAP_IH2_BASE + 0x00)
+#define OMAP_IH2_MIR		(OMAP_IH2_BASE + 0x04)
+#define OMAP_IH2_SIR_IRQ	(OMAP_IH2_BASE + 0x10)
+#define OMAP_IH2_SIR_FIQ	(OMAP_IH2_BASE + 0x14)
+#define OMAP_IH2_CONTROL	(OMAP_IH2_BASE + 0x18)
+#define OMAP_IH2_ILR0		(OMAP_IH2_BASE + 0x1c)
+#define OMAP_IH2_ISR		(OMAP_IH2_BASE + 0x9c)
+
+#define IRQ_ITR_REG_OFFSET	0x00
+#define IRQ_MIR_REG_OFFSET	0x04
+#define IRQ_SIR_IRQ_REG_OFFSET	0x10
+#define IRQ_SIR_FIQ_REG_OFFSET	0x14
+#define IRQ_CONTROL_REG_OFFSET	0x18
+#define IRQ_ISR_REG_OFFSET	0x9c
+#define IRQ_ILR0_REG_OFFSET	0x1c
+#define IRQ_GMR_REG_OFFSET	0xa0
+
+#endif
+
+/*
+ * ----------------------------------------------------------------------------
+ * System control registers
+ * ----------------------------------------------------------------------------
+ */
+#define MOD_CONF_CTRL_0		0xfffe1080
+#define MOD_CONF_CTRL_1		0xfffe1110
+
+/*
+ * ----------------------------------------------------------------------------
+ * Pin multiplexing registers
+ * ----------------------------------------------------------------------------
+ */
+#define FUNC_MUX_CTRL_0		0xfffe1000
+#define FUNC_MUX_CTRL_1		0xfffe1004
+#define FUNC_MUX_CTRL_2		0xfffe1008
+#define COMP_MODE_CTRL_0	0xfffe100c
+#define FUNC_MUX_CTRL_3		0xfffe1010
+#define FUNC_MUX_CTRL_4		0xfffe1014
+#define FUNC_MUX_CTRL_5		0xfffe1018
+#define FUNC_MUX_CTRL_6		0xfffe101C
+#define FUNC_MUX_CTRL_7		0xfffe1020
+#define FUNC_MUX_CTRL_8		0xfffe1024
+#define FUNC_MUX_CTRL_9		0xfffe1028
+#define FUNC_MUX_CTRL_A		0xfffe102C
+#define FUNC_MUX_CTRL_B		0xfffe1030
+#define FUNC_MUX_CTRL_C		0xfffe1034
+#define FUNC_MUX_CTRL_D		0xfffe1038
+#define PULL_DWN_CTRL_0		0xfffe1040
+#define PULL_DWN_CTRL_1		0xfffe1044
+#define PULL_DWN_CTRL_2		0xfffe1048
+#define PULL_DWN_CTRL_3		0xfffe104c
+#define PULL_DWN_CTRL_4		0xfffe10ac
+
+/* OMAP-1610 specific multiplexing registers */
+#define FUNC_MUX_CTRL_E		0xfffe1090
+#define FUNC_MUX_CTRL_F		0xfffe1094
+#define FUNC_MUX_CTRL_10	0xfffe1098
+#define FUNC_MUX_CTRL_11	0xfffe109c
+#define FUNC_MUX_CTRL_12	0xfffe10a0
+#define PU_PD_SEL_0		0xfffe10b4
+#define PU_PD_SEL_1		0xfffe10b8
+#define PU_PD_SEL_2		0xfffe10bc
+#define PU_PD_SEL_3		0xfffe10c0
+#define PU_PD_SEL_4		0xfffe10c4
+
+/* Timer32K for 1610 and 1710*/
+#define OMAP_TIMER32K_BASE	0xFFFBC400
+
+/*
+ * ---------------------------------------------------------------------------
+ * TIPB bus interface
+ * ---------------------------------------------------------------------------
+ */
+#define TIPB_PUBLIC_CNTL_BASE		0xfffed300
+#define MPU_PUBLIC_TIPB_CNTL		(TIPB_PUBLIC_CNTL_BASE + 0x8)
+#define TIPB_PRIVATE_CNTL_BASE		0xfffeca00
+#define MPU_PRIVATE_TIPB_CNTL		(TIPB_PRIVATE_CNTL_BASE + 0x8)
+
+/*
+ * ----------------------------------------------------------------------------
+ * MPUI interface
+ * ----------------------------------------------------------------------------
+ */
+#define MPUI_BASE			(0xfffec900)
+#define MPUI_CTRL			(MPUI_BASE + 0x0)
+#define MPUI_DEBUG_ADDR			(MPUI_BASE + 0x4)
+#define MPUI_DEBUG_DATA			(MPUI_BASE + 0x8)
+#define MPUI_DEBUG_FLAG			(MPUI_BASE + 0xc)
+#define MPUI_STATUS_REG			(MPUI_BASE + 0x10)
+#define MPUI_DSP_STATUS			(MPUI_BASE + 0x14)
+#define MPUI_DSP_BOOT_CONFIG		(MPUI_BASE + 0x18)
+#define MPUI_DSP_API_CONFIG		(MPUI_BASE + 0x1c)
+
+/*
+ * ----------------------------------------------------------------------------
+ * LED Pulse Generator
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP_LPG1_BASE			0xfffbd000
+#define OMAP_LPG2_BASE			0xfffbd800
+#define OMAP_LPG1_LCR			(OMAP_LPG1_BASE + 0x00)
+#define OMAP_LPG1_PMR			(OMAP_LPG1_BASE + 0x04)
+#define OMAP_LPG2_LCR			(OMAP_LPG2_BASE + 0x00)
+#define OMAP_LPG2_PMR			(OMAP_LPG2_BASE + 0x04)
+
+/*
+ * ---------------------------------------------------------------------------
+ * Processor specific defines
+ * ---------------------------------------------------------------------------
+ */
+
+#include "omap730.h"
+#include "omap1510.h"
+#include "omap24xx.h"
+#include "omap16xx.h"
+
+#ifndef __ASSEMBLER__
+
+/*
+ * ---------------------------------------------------------------------------
+ * Board specific defines
+ * ---------------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+#include "board-innovator.h"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+#include "board-h2.h"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+#include "board-perseus2.h"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+#include "board-fsample.h"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+#include "board-h3.h"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+#include "board-h4.h"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+#include "board-apollon.h"
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+#include "board-osk.h"
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+#include "board-voiceblue.h"
+#endif
+
+#endif /* !__ASSEMBLER__ */
+
+#endif	/* __ASM_ARCH_OMAP_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-omap/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,132 @@
+/*
+ * linux/include/asm-arm/arch-omap/io.h
+ *
+ * IO definitions for TI OMAP processors and boards
+ *
+ * Copied from linux/include/asm-arm/arch-sa1100/io.h
+ * Copyright (C) 1997-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Modifications:
+ *  06-12-1997	RMK	Created.
+ *  07-04-1999	RMK	Major cleanup
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)			((void __iomem *)(PCIO_BASE + (a)))
+#define __mem_pci(a)		(a)
+
+/*
+ * ----------------------------------------------------------------------------
+ * I/O mapping
+ * ----------------------------------------------------------------------------
+ */
+
+#define PCIO_BASE	0
+
+#if defined(CONFIG_ARCH_OMAP1)
+
+#define IO_PHYS		0xFFFB0000
+#define IO_OFFSET	0x01000000	/* Virtual IO = 0xfefb0000 */
+#define IO_SIZE		0x40000
+#define IO_VIRT		(IO_PHYS - IO_OFFSET)
+#define IO_ADDRESS(pa)	((pa) - IO_OFFSET)
+#define io_p2v(pa)	((pa) - IO_OFFSET)
+#define io_v2p(va)	((va) + IO_OFFSET)
+
+#elif defined(CONFIG_ARCH_OMAP2)
+
+/* We map both L3 and L4 on OMAP2 */
+#define L3_24XX_PHYS	L3_24XX_BASE	/* 0x68000000 */
+#define L3_24XX_VIRT	0xf8000000
+#define L3_24XX_SIZE	SZ_1M		/* 44kB of 128MB used, want 1MB sect */
+#define L4_24XX_PHYS	L4_24XX_BASE	/* 0x48000000 */
+#define L4_24XX_VIRT	0xd8000000
+#define L4_24XX_SIZE	SZ_1M		/* 1MB of 128MB used, want 1MB sect */
+#define IO_OFFSET	0x90000000
+#define IO_ADDRESS(pa)	((pa) + IO_OFFSET)	/* Works for L3 and L4 */
+#define io_p2v(pa)	((pa) + IO_OFFSET)	/* Works for L3 and L4 */
+#define io_v2p(va)	((va) - IO_OFFSET)	/* Works for L3 and L4 */
+
+#endif
+
+#ifndef __ASSEMBLER__
+
+/*
+ * Functions to access the OMAP IO region
+ *
+ * NOTE: - Use omap_read/write[bwl] for physical register addresses
+ *	 - Use __raw_read/write[bwl]() for virtual register addresses
+ *	 - Use IO_ADDRESS(phys_addr) to convert registers to virtual addresses
+ *	 - DO NOT use hardcoded virtual addresses to allow changing the
+ *	   IO address space again if needed
+ */
+#define omap_readb(a)		(*(volatile unsigned char  *)IO_ADDRESS(a))
+#define omap_readw(a)		(*(volatile unsigned short *)IO_ADDRESS(a))
+#define omap_readl(a)		(*(volatile unsigned int   *)IO_ADDRESS(a))
+
+#define omap_writeb(v,a)	(*(volatile unsigned char  *)IO_ADDRESS(a) = (v))
+#define omap_writew(v,a)	(*(volatile unsigned short *)IO_ADDRESS(a) = (v))
+#define omap_writel(v,a)	(*(volatile unsigned int   *)IO_ADDRESS(a) = (v))
+
+/* 16 bit uses LDRH/STRH, base +/- offset_8 */
+typedef struct { volatile u16 offset[256]; } __regbase16;
+#define __REGV16(vaddr)		((__regbase16 *)((vaddr)&~0xff)) \
+					->offset[((vaddr)&0xff)>>1]
+#define __REG16(paddr)          __REGV16(io_p2v(paddr))
+
+/* 8/32 bit uses LDR/STR, base +/- offset_12 */
+typedef struct { volatile u8 offset[4096]; } __regbase8;
+#define __REGV8(vaddr)		((__regbase8  *)((vaddr)&~4095)) \
+					->offset[((vaddr)&4095)>>0]
+#define __REG8(paddr)		__REGV8(io_p2v(paddr))
+
+typedef struct { volatile u32 offset[4096]; } __regbase32;
+#define __REGV32(vaddr)		((__regbase32 *)((vaddr)&~4095)) \
+					->offset[((vaddr)&4095)>>2]
+#define __REG32(paddr)		__REGV32(io_p2v(paddr))
+
+extern void omap1_map_common_io(void);
+extern void omap1_init_common_hw(void);
+
+extern void omap2_map_common_io(void);
+extern void omap2_init_common_hw(void);
+
+#else
+
+#define __REG8(paddr)		io_p2v(paddr)
+#define __REG16(paddr)		io_p2v(paddr)
+#define __REG32(paddr)		io_p2v(paddr)
+
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/irda.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/irda.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/irda.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/arch-omap/irda.h
+ *
+ *  Copyright (C) 2005-2006 Komal Shah <komal_shah802003@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ASMARM_ARCH_IRDA_H
+#define ASMARM_ARCH_IRDA_H
+
+/* board specific transceiver capabilities */
+
+#define IR_SEL		1	/* Selects IrDA */
+#define IR_SIRMODE	2
+#define IR_FIRMODE	4
+#define IR_MIRMODE	8
+
+struct omap_irda_config {
+	int transceiver_cap;
+	int (*transceiver_mode)(struct device *dev, int mode);
+	int (*select_irda)(struct device *dev, int state);
+	/* Very specific to the needs of some platforms (h3,h4)
+	 * having calls which can sleep in irda_set_speed.
+	 */
+	struct delayed_work gpio_expa;
+	int rx_channel;
+	int tx_channel;
+	unsigned long dest_start;
+	unsigned long src_start;
+	int tx_trigger;
+	int rx_trigger;
+};
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,290 @@
+/*
+ *  linux/include/asm-arm/arch-omap/irqs.h
+ *
+ *  Copyright (C) Greg Lonnon 2001
+ *  Updated for OMAP-1610 by Tony Lindgren <tony@atomide.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * NOTE: The interrupt vectors for the OMAP-1509, OMAP-1510, and OMAP-1610
+ *	 are different.
+ */
+
+#ifndef __ASM_ARCH_OMAP15XX_IRQS_H
+#define __ASM_ARCH_OMAP15XX_IRQS_H
+
+/*
+ * IRQ numbers for interrupt handler 1
+ *
+ * NOTE: See also the OMAP-1510 and 1610 specific IRQ numbers below
+ *
+ */
+#define INT_CAMERA		1
+#define INT_FIQ			3
+#define INT_RTDX		6
+#define INT_DSP_MMU_ABORT	7
+#define INT_HOST		8
+#define INT_ABORT		9
+#define INT_DSP_MAILBOX1	10
+#define INT_DSP_MAILBOX2	11
+#define INT_BRIDGE_PRIV		13
+#define INT_GPIO_BANK1		14
+#define INT_UART3		15
+#define INT_TIMER3		16
+#define INT_DMA_CH0_6		19
+#define INT_DMA_CH1_7		20
+#define INT_DMA_CH2_8		21
+#define INT_DMA_CH3		22
+#define INT_DMA_CH4		23
+#define INT_DMA_CH5		24
+#define INT_DMA_LCD		25
+#define INT_TIMER1		26
+#define INT_WD_TIMER		27
+#define INT_BRIDGE_PUB		28
+#define INT_TIMER2		30
+#define INT_LCD_CTRL		31
+
+/*
+ * OMAP-1510 specific IRQ numbers for interrupt handler 1
+ */
+#define INT_1510_IH2_IRQ	0
+#define INT_1510_RES2		2
+#define INT_1510_SPI_TX		4
+#define INT_1510_SPI_RX		5
+#define INT_1510_RES12		12
+#define INT_1510_LB_MMU		17
+#define INT_1510_RES18		18
+#define INT_1510_LOCAL_BUS	29
+
+/*
+ * OMAP-1610 specific IRQ numbers for interrupt handler 1
+ */
+#define INT_1610_IH2_IRQ	0
+#define INT_1610_IH2_FIQ	2
+#define INT_1610_McBSP2_TX	4
+#define INT_1610_McBSP2_RX	5
+#define INT_1610_LCD_LINE	12
+#define INT_1610_GPTIMER1	17
+#define INT_1610_GPTIMER2	18
+#define INT_1610_SSR_FIFO_0	29
+
+/*
+ * OMAP-730 specific IRQ numbers for interrupt handler 1
+ */
+#define INT_730_IH2_FIQ		0
+#define INT_730_IH2_IRQ		1
+#define INT_730_USB_NON_ISO	2
+#define INT_730_USB_ISO		3
+#define INT_730_ICR		4
+#define INT_730_EAC		5
+#define INT_730_GPIO_BANK1	6
+#define INT_730_GPIO_BANK2	7
+#define INT_730_GPIO_BANK3	8
+#define INT_730_McBSP2TX	10
+#define INT_730_McBSP2RX	11
+#define INT_730_McBSP2RX_OVF	12
+#define INT_730_LCD_LINE	14
+#define INT_730_GSM_PROTECT	15
+#define INT_730_TIMER3		16
+#define INT_730_GPIO_BANK5	17
+#define INT_730_GPIO_BANK6	18
+#define INT_730_SPGIO_WR	29
+
+/*
+ * IRQ numbers for interrupt handler 2
+ *
+ * NOTE: See also the OMAP-1510 and 1610 specific IRQ numbers below
+ */
+#define IH2_BASE		32
+
+#define INT_KEYBOARD		(1 + IH2_BASE)
+#define INT_uWireTX		(2 + IH2_BASE)
+#define INT_uWireRX		(3 + IH2_BASE)
+#define INT_I2C			(4 + IH2_BASE)
+#define INT_MPUIO		(5 + IH2_BASE)
+#define INT_USB_HHC_1		(6 + IH2_BASE)
+#define INT_McBSP3TX		(10 + IH2_BASE)
+#define INT_McBSP3RX		(11 + IH2_BASE)
+#define INT_McBSP1TX		(12 + IH2_BASE)
+#define INT_McBSP1RX		(13 + IH2_BASE)
+#define INT_UART1		(14 + IH2_BASE)
+#define INT_UART2		(15 + IH2_BASE)
+#define INT_BT_MCSI1TX		(16 + IH2_BASE)
+#define INT_BT_MCSI1RX		(17 + IH2_BASE)
+#define INT_USB_W2FC		(20 + IH2_BASE)
+#define INT_1WIRE		(21 + IH2_BASE)
+#define INT_OS_TIMER		(22 + IH2_BASE)
+#define INT_MMC			(23 + IH2_BASE)
+#define INT_GAUGE_32K		(24 + IH2_BASE)
+#define INT_RTC_TIMER		(25 + IH2_BASE)
+#define INT_RTC_ALARM		(26 + IH2_BASE)
+#define INT_MEM_STICK		(27 + IH2_BASE)
+#define INT_DSP_MMU		(28 + IH2_BASE)
+
+/*
+ * OMAP-1510 specific IRQ numbers for interrupt handler 2
+ */
+#define INT_1510_COM_SPI_RO	(31 + IH2_BASE)
+
+/*
+ * OMAP-1610 specific IRQ numbers for interrupt handler 2
+ */
+#define INT_1610_FAC		(0 + IH2_BASE)
+#define INT_1610_USB_HHC_2	(7 + IH2_BASE)
+#define INT_1610_USB_OTG	(8 + IH2_BASE)
+#define INT_1610_SoSSI		(9 + IH2_BASE)
+#define INT_1610_SoSSI_MATCH	(19 + IH2_BASE)
+#define INT_1610_McBSP2RX_OF	(31 + IH2_BASE)
+#define INT_1610_STI		(32 + IH2_BASE)
+#define INT_1610_STI_WAKEUP	(33 + IH2_BASE)
+#define INT_1610_GPTIMER3	(34 + IH2_BASE)
+#define INT_1610_GPTIMER4	(35 + IH2_BASE)
+#define INT_1610_GPTIMER5	(36 + IH2_BASE)
+#define INT_1610_GPTIMER6	(37 + IH2_BASE)
+#define INT_1610_GPTIMER7	(38 + IH2_BASE)
+#define INT_1610_GPTIMER8	(39 + IH2_BASE)
+#define INT_1610_GPIO_BANK2	(40 + IH2_BASE)
+#define INT_1610_GPIO_BANK3	(41 + IH2_BASE)
+#define INT_1610_MMC2		(42 + IH2_BASE)
+#define INT_1610_CF		(43 + IH2_BASE)
+#define INT_1610_WAKE_UP_REQ	(46 + IH2_BASE)
+#define INT_1610_GPIO_BANK4	(48 + IH2_BASE)
+#define INT_1610_SPI		(49 + IH2_BASE)
+#define INT_1610_DMA_CH6	(53 + IH2_BASE)
+#define INT_1610_DMA_CH7	(54 + IH2_BASE)
+#define INT_1610_DMA_CH8	(55 + IH2_BASE)
+#define INT_1610_DMA_CH9	(56 + IH2_BASE)
+#define INT_1610_DMA_CH10	(57 + IH2_BASE)
+#define INT_1610_DMA_CH11	(58 + IH2_BASE)
+#define INT_1610_DMA_CH12	(59 + IH2_BASE)
+#define INT_1610_DMA_CH13	(60 + IH2_BASE)
+#define INT_1610_DMA_CH14	(61 + IH2_BASE)
+#define INT_1610_DMA_CH15	(62 + IH2_BASE)
+#define INT_1610_NAND		(63 + IH2_BASE)
+
+/*
+ * OMAP-730 specific IRQ numbers for interrupt handler 2
+ */
+#define INT_730_HW_ERRORS	(0 + IH2_BASE)
+#define INT_730_NFIQ_PWR_FAIL	(1 + IH2_BASE)
+#define INT_730_CFCD		(2 + IH2_BASE)
+#define INT_730_CFIREQ		(3 + IH2_BASE)
+#define INT_730_I2C		(4 + IH2_BASE)
+#define INT_730_PCC		(5 + IH2_BASE)
+#define INT_730_MPU_EXT_NIRQ	(6 + IH2_BASE)
+#define INT_730_SPI_100K_1	(7 + IH2_BASE)
+#define INT_730_SYREN_SPI	(8 + IH2_BASE)
+#define INT_730_VLYNQ		(9 + IH2_BASE)
+#define INT_730_GPIO_BANK4	(10 + IH2_BASE)
+#define INT_730_McBSP1TX	(11 + IH2_BASE)
+#define INT_730_McBSP1RX	(12 + IH2_BASE)
+#define INT_730_McBSP1RX_OF	(13 + IH2_BASE)
+#define INT_730_UART_MODEM_IRDA_2 (14 + IH2_BASE)
+#define INT_730_UART_MODEM_1	(15 + IH2_BASE)
+#define INT_730_MCSI		(16 + IH2_BASE)
+#define INT_730_uWireTX		(17 + IH2_BASE)
+#define INT_730_uWireRX		(18 + IH2_BASE)
+#define INT_730_SMC_CD		(19 + IH2_BASE)
+#define INT_730_SMC_IREQ	(20 + IH2_BASE)
+#define INT_730_HDQ_1WIRE	(21 + IH2_BASE)
+#define INT_730_TIMER32K	(22 + IH2_BASE)
+#define INT_730_MMC_SDIO	(23 + IH2_BASE)
+#define INT_730_UPLD		(24 + IH2_BASE)
+#define INT_730_USB_HHC_1	(27 + IH2_BASE)
+#define INT_730_USB_HHC_2	(28 + IH2_BASE)
+#define INT_730_USB_GENI	(29 + IH2_BASE)
+#define INT_730_USB_OTG		(30 + IH2_BASE)
+#define INT_730_CAMERA_IF	(31 + IH2_BASE)
+#define INT_730_RNG		(32 + IH2_BASE)
+#define INT_730_DUAL_MODE_TIMER (33 + IH2_BASE)
+#define INT_730_DBB_RF_EN	(34 + IH2_BASE)
+#define INT_730_MPUIO_KEYPAD	(35 + IH2_BASE)
+#define INT_730_SHA1_MD5	(36 + IH2_BASE)
+#define INT_730_SPI_100K_2	(37 + IH2_BASE)
+#define INT_730_RNG_IDLE	(38 + IH2_BASE)
+#define INT_730_MPUIO		(39 + IH2_BASE)
+#define INT_730_LLPC_LCD_CTRL_CAN_BE_OFF	(40 + IH2_BASE)
+#define INT_730_LLPC_OE_FALLING (41 + IH2_BASE)
+#define INT_730_LLPC_OE_RISING	(42 + IH2_BASE)
+#define INT_730_LLPC_VSYNC	(43 + IH2_BASE)
+#define INT_730_WAKE_UP_REQ	(46 + IH2_BASE)
+#define INT_730_DMA_CH6		(53 + IH2_BASE)
+#define INT_730_DMA_CH7		(54 + IH2_BASE)
+#define INT_730_DMA_CH8		(55 + IH2_BASE)
+#define INT_730_DMA_CH9		(56 + IH2_BASE)
+#define INT_730_DMA_CH10	(57 + IH2_BASE)
+#define INT_730_DMA_CH11	(58 + IH2_BASE)
+#define INT_730_DMA_CH12	(59 + IH2_BASE)
+#define INT_730_DMA_CH13	(60 + IH2_BASE)
+#define INT_730_DMA_CH14	(61 + IH2_BASE)
+#define INT_730_DMA_CH15	(62 + IH2_BASE)
+#define INT_730_NAND		(63 + IH2_BASE)
+
+#define INT_24XX_SYS_NIRQ	7
+#define INT_24XX_SDMA_IRQ0	12
+#define INT_24XX_SDMA_IRQ1	13
+#define INT_24XX_SDMA_IRQ2	14
+#define INT_24XX_SDMA_IRQ3	15
+#define INT_24XX_CAM_IRQ	24
+#define INT_24XX_DSS_IRQ	25
+#define INT_24XX_GPIO_BANK1	29
+#define INT_24XX_GPIO_BANK2	30
+#define INT_24XX_GPIO_BANK3	31
+#define INT_24XX_GPIO_BANK4	32
+#define INT_24XX_GPTIMER1	37
+#define INT_24XX_GPTIMER2	38
+#define INT_24XX_GPTIMER3	39
+#define INT_24XX_GPTIMER4	40
+#define INT_24XX_GPTIMER5	41
+#define INT_24XX_GPTIMER6	42
+#define INT_24XX_GPTIMER7	43
+#define INT_24XX_GPTIMER8	44
+#define INT_24XX_GPTIMER9	45
+#define INT_24XX_GPTIMER10	46
+#define INT_24XX_GPTIMER11	47
+#define INT_24XX_GPTIMER12	48
+#define INT_24XX_MCBSP1_IRQ_TX	59
+#define INT_24XX_MCBSP1_IRQ_RX	60
+#define INT_24XX_MCBSP2_IRQ_TX	62
+#define INT_24XX_MCBSP2_IRQ_RX	63
+#define INT_24XX_UART1_IRQ	72
+#define INT_24XX_UART2_IRQ	73
+#define INT_24XX_UART3_IRQ	74
+#define INT_24XX_MMC_IRQ	83
+
+/* Max. 128 level 2 IRQs (OMAP1610), 192 GPIOs (OMAP730) and
+ * 16 MPUIO lines */
+#define OMAP_MAX_GPIO_LINES	192
+#define IH_GPIO_BASE		(128 + IH2_BASE)
+#define IH_MPUIO_BASE		(OMAP_MAX_GPIO_LINES + IH_GPIO_BASE)
+#define IH_BOARD_BASE		(16 + IH_MPUIO_BASE)
+
+#define OMAP_IRQ_BIT(irq)	(1 << ((irq) % 32))
+
+#ifndef __ASSEMBLY__
+extern void omap_init_irq(void);
+#endif
+
+/*
+ * The definition of NR_IRQS is in board-specific header file, which is
+ * included via hardware.h
+ */
+#include <asm/hardware.h>
+
+#ifndef NR_IRQS
+#define NR_IRQS                 IH_BOARD_BASE
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/keypad.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/keypad.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/keypad.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ *  linux/include/asm-arm/arch-omap/keypad.h
+ *
+ *  Copyright (C) 2006 Komal Shah <komal_shah802003@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ASMARM_ARCH_KEYPAD_H
+#define ASMARM_ARCH_KEYPAD_H
+
+struct omap_kp_platform_data {
+	int rows;
+	int cols;
+	int *keymap;
+	unsigned int keymapsize;
+	unsigned int rep:1;
+	unsigned long delay;
+	unsigned int dbounce:1;
+	/* specific to OMAP242x*/
+	unsigned int *row_gpios;
+	unsigned int *col_gpios;
+};
+
+/* Group (0..3) -- when multiple keys are pressed, only the
+ * keys pressed in the same group are considered as pressed. This is
+ * in order to workaround certain crappy HW designs that produce ghost
+ * keypresses. */
+#define GROUP_0		(0 << 16)
+#define GROUP_1		(1 << 16)
+#define GROUP_2		(2 << 16)
+#define GROUP_3		(3 << 16)
+#define GROUP_MASK	GROUP_3
+
+#define KEY(col, row, val) (((col) << 28) | ((row) << 24) | (val))
+
+#endif
+
Index: build_tree/linux/include/asm/arch-omap/lcd_lph8923.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/lcd_lph8923.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/lcd_lph8923.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,14 @@
+#ifndef __LCD_LPH8923_H
+#define __LCD_LPH8923_H
+
+enum lcd_lph8923_test_num {
+	LCD_LPH8923_TEST_RGB_LINES,
+};
+
+enum lcd_lph8923_test_result {
+	LCD_LPH8923_TEST_SUCCESS,
+	LCD_LPH8923_TEST_INVALID,
+	LCD_LPH8923_TEST_FAILED,
+};
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/mcbsp.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/mcbsp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/mcbsp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,322 @@
+/*
+ * linux/include/asm-arm/arch-omap/mcbsp.h
+ *
+ * Defines for Multi-Channel Buffered Serial Port
+ *
+ * Copyright (C) 2002 RidgeRun, Inc.
+ * Author: Steve Johnson
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+#ifndef __ASM_ARCH_OMAP_MCBSP_H
+#define __ASM_ARCH_OMAP_MCBSP_H
+
+#include <asm/hardware.h>
+
+#define OMAP730_MCBSP1_BASE	0xfffb1000
+#define OMAP730_MCBSP2_BASE	0xfffb1800
+
+#define OMAP1510_MCBSP1_BASE	0xe1011800
+#define OMAP1510_MCBSP2_BASE	0xfffb1000
+#define OMAP1510_MCBSP3_BASE	0xe1017000
+
+#define OMAP1610_MCBSP1_BASE	0xe1011800
+#define OMAP1610_MCBSP2_BASE	0xfffb1000
+#define OMAP1610_MCBSP3_BASE	0xe1017000
+
+#define OMAP24XX_MCBSP1_BASE	0x48074000
+#define OMAP24XX_MCBSP2_BASE	0x48076000
+
+#if defined(CONFIG_ARCH_OMAP15XX) || defined(CONFIG_ARCH_OMAP16XX) || defined(CONFIG_ARCH_OMAP730)
+
+#define OMAP_MCBSP_REG_DRR2	0x00
+#define OMAP_MCBSP_REG_DRR1	0x02
+#define OMAP_MCBSP_REG_DXR2	0x04
+#define OMAP_MCBSP_REG_DXR1	0x06
+#define OMAP_MCBSP_REG_SPCR2	0x08
+#define OMAP_MCBSP_REG_SPCR1	0x0a
+#define OMAP_MCBSP_REG_RCR2	0x0c
+#define OMAP_MCBSP_REG_RCR1	0x0e
+#define OMAP_MCBSP_REG_XCR2	0x10
+#define OMAP_MCBSP_REG_XCR1	0x12
+#define OMAP_MCBSP_REG_SRGR2	0x14
+#define OMAP_MCBSP_REG_SRGR1	0x16
+#define OMAP_MCBSP_REG_MCR2	0x18
+#define OMAP_MCBSP_REG_MCR1	0x1a
+#define OMAP_MCBSP_REG_RCERA	0x1c
+#define OMAP_MCBSP_REG_RCERB	0x1e
+#define OMAP_MCBSP_REG_XCERA	0x20
+#define OMAP_MCBSP_REG_XCERB	0x22
+#define OMAP_MCBSP_REG_PCR0	0x24
+#define OMAP_MCBSP_REG_RCERC	0x26
+#define OMAP_MCBSP_REG_RCERD	0x28
+#define OMAP_MCBSP_REG_XCERC	0x2A
+#define OMAP_MCBSP_REG_XCERD	0x2C
+#define OMAP_MCBSP_REG_RCERE	0x2E
+#define OMAP_MCBSP_REG_RCERF	0x30
+#define OMAP_MCBSP_REG_XCERE	0x32
+#define OMAP_MCBSP_REG_XCERF	0x34
+#define OMAP_MCBSP_REG_RCERG	0x36
+#define OMAP_MCBSP_REG_RCERH	0x38
+#define OMAP_MCBSP_REG_XCERG	0x3A
+#define OMAP_MCBSP_REG_XCERH	0x3C
+
+#define OMAP_MAX_MCBSP_COUNT 3
+
+#define AUDIO_MCBSP_DATAWRITE	(OMAP1510_MCBSP1_BASE + OMAP_MCBSP_REG_DXR1)
+#define AUDIO_MCBSP_DATAREAD	(OMAP1510_MCBSP1_BASE + OMAP_MCBSP_REG_DRR1)
+
+#define AUDIO_MCBSP		OMAP_MCBSP1
+#define AUDIO_DMA_TX		OMAP_DMA_MCBSP1_TX
+#define AUDIO_DMA_RX		OMAP_DMA_MCBSP1_RX
+
+#elif defined(CONFIG_ARCH_OMAP24XX)
+
+#define OMAP_MCBSP_REG_DRR2	0x00
+#define OMAP_MCBSP_REG_DRR1	0x04
+#define OMAP_MCBSP_REG_DXR2	0x08
+#define OMAP_MCBSP_REG_DXR1	0x0C
+#define OMAP_MCBSP_REG_SPCR2	0x10
+#define OMAP_MCBSP_REG_SPCR1	0x14
+#define OMAP_MCBSP_REG_RCR2	0x18
+#define OMAP_MCBSP_REG_RCR1	0x1C
+#define OMAP_MCBSP_REG_XCR2	0x20
+#define OMAP_MCBSP_REG_XCR1	0x24
+#define OMAP_MCBSP_REG_SRGR2	0x28
+#define OMAP_MCBSP_REG_SRGR1	0x2C
+#define OMAP_MCBSP_REG_MCR2	0x30
+#define OMAP_MCBSP_REG_MCR1	0x34
+#define OMAP_MCBSP_REG_RCERA	0x38
+#define OMAP_MCBSP_REG_RCERB	0x3C
+#define OMAP_MCBSP_REG_XCERA	0x40
+#define OMAP_MCBSP_REG_XCERB	0x44
+#define OMAP_MCBSP_REG_PCR0	0x48
+#define OMAP_MCBSP_REG_RCERC	0x4C
+#define OMAP_MCBSP_REG_RCERD	0x50
+#define OMAP_MCBSP_REG_XCERC	0x54
+#define OMAP_MCBSP_REG_XCERD	0x58
+#define OMAP_MCBSP_REG_RCERE	0x5C
+#define OMAP_MCBSP_REG_RCERF	0x60
+#define OMAP_MCBSP_REG_XCERE	0x64
+#define OMAP_MCBSP_REG_XCERF	0x68
+#define OMAP_MCBSP_REG_RCERG	0x6C
+#define OMAP_MCBSP_REG_RCERH	0x70
+#define OMAP_MCBSP_REG_XCERG	0x74
+#define OMAP_MCBSP_REG_XCERH	0x78
+
+#define OMAP_MAX_MCBSP_COUNT 2
+
+#define AUDIO_MCBSP_DATAWRITE	(OMAP24XX_MCBSP2_BASE + OMAP_MCBSP_REG_DXR1)
+#define AUDIO_MCBSP_DATAREAD	(OMAP24XX_MCBSP2_BASE + OMAP_MCBSP_REG_DRR1)
+
+#define AUDIO_MCBSP		OMAP_MCBSP2
+#define AUDIO_DMA_TX		OMAP24XX_DMA_MCBSP2_TX
+#define AUDIO_DMA_RX		OMAP24XX_DMA_MCBSP2_RX
+
+#endif
+
+#define OMAP_MCBSP_READ(base, reg)		__raw_readw((base) + OMAP_MCBSP_REG_##reg)
+#define OMAP_MCBSP_WRITE(base, reg, val)	__raw_writew((val), (base) + OMAP_MCBSP_REG_##reg)
+
+
+/************************** McBSP SPCR1 bit definitions ***********************/
+#define RRST			0x0001
+#define RRDY			0x0002
+#define RFULL			0x0004
+#define RSYNC_ERR		0x0008
+#define RINTM(value)		((value)<<4)	/* bits 4:5 */
+#define ABIS			0x0040
+#define DXENA			0x0080
+#define CLKSTP(value)		((value)<<11)	/* bits 11:12 */
+#define RJUST(value)		((value)<<13)	/* bits 13:14 */
+#define DLB			0x8000
+
+/************************** McBSP SPCR2 bit definitions ***********************/
+#define XRST		0x0001
+#define XRDY		0x0002
+#define XEMPTY		0x0004
+#define XSYNC_ERR	0x0008
+#define XINTM(value)	((value)<<4)		/* bits 4:5 */
+#define GRST		0x0040
+#define FRST		0x0080
+#define SOFT		0x0100
+#define FREE		0x0200
+
+/************************** McBSP PCR bit definitions *************************/
+#define CLKRP		0x0001
+#define CLKXP		0x0002
+#define FSRP		0x0004
+#define FSXP		0x0008
+#define DR_STAT		0x0010
+#define DX_STAT		0x0020
+#define CLKS_STAT	0x0040
+#define SCLKME		0x0080
+#define CLKRM		0x0100
+#define CLKXM		0x0200
+#define FSRM		0x0400
+#define FSXM		0x0800
+#define RIOEN		0x1000
+#define XIOEN		0x2000
+#define IDLE_EN		0x4000
+
+/************************** McBSP RCR1 bit definitions ************************/
+#define RWDLEN1(value)		((value)<<5)	/* Bits 5:7 */
+#define RFRLEN1(value)		((value)<<8)	/* Bits 8:14 */
+
+/************************** McBSP XCR1 bit definitions ************************/
+#define XWDLEN1(value)		((value)<<5)	/* Bits 5:7 */
+#define XFRLEN1(value)		((value)<<8)	/* Bits 8:14 */
+
+/*************************** McBSP RCR2 bit definitions ***********************/
+#define RDATDLY(value)		(value)		/* Bits 0:1 */
+#define RFIG			0x0004
+#define RCOMPAND(value)		((value)<<3)	/* Bits 3:4 */
+#define RWDLEN2(value)		((value)<<5)	/* Bits 5:7 */
+#define RFRLEN2(value)		((value)<<8)	/* Bits 8:14 */
+#define RPHASE			0x8000
+
+/*************************** McBSP XCR2 bit definitions ***********************/
+#define XDATDLY(value)		(value)		/* Bits 0:1 */
+#define XFIG			0x0004
+#define XCOMPAND(value)		((value)<<3)	/* Bits 3:4 */
+#define XWDLEN2(value)		((value)<<5)	/* Bits 5:7 */
+#define XFRLEN2(value)		((value)<<8)	/* Bits 8:14 */
+#define XPHASE			0x8000
+
+/************************* McBSP SRGR1 bit definitions ************************/
+#define CLKGDV(value)		(value)		/* Bits 0:7 */
+#define FWID(value)		((value)<<8)	/* Bits 8:15 */
+
+/************************* McBSP SRGR2 bit definitions ************************/
+#define FPER(value)		(value)		/* Bits 0:11 */
+#define FSGM			0x1000
+#define CLKSM			0x2000
+#define CLKSP			0x4000
+#define GSYNC			0x8000
+
+/************************* McBSP MCR1 bit definitions *************************/
+#define RMCM			0x0001
+#define RCBLK(value)		((value)<<2)	/* Bits 2:4 */
+#define RPABLK(value)		((value)<<5)	/* Bits 5:6 */
+#define RPBBLK(value)		((value)<<7)	/* Bits 7:8 */
+
+/************************* McBSP MCR2 bit definitions *************************/
+#define XMCM(value)		(value)		/* Bits 0:1 */
+#define XCBLK(value)		((value)<<2)	/* Bits 2:4 */
+#define XPABLK(value)		((value)<<5)	/* Bits 5:6 */
+#define XPBBLK(value)		((value)<<7)	/* Bits 7:8 */
+
+
+/* we don't do multichannel for now */
+struct omap_mcbsp_reg_cfg {
+	u16 spcr2;
+	u16 spcr1;
+	u16 rcr2;
+	u16 rcr1;
+	u16 xcr2;
+	u16 xcr1;
+	u16 srgr2;
+	u16 srgr1;
+	u16 mcr2;
+	u16 mcr1;
+	u16 pcr0;
+	u16 rcerc;
+	u16 rcerd;
+	u16 xcerc;
+	u16 xcerd;
+	u16 rcere;
+	u16 rcerf;
+	u16 xcere;
+	u16 xcerf;
+	u16 rcerg;
+	u16 rcerh;
+	u16 xcerg;
+	u16 xcerh;
+};
+
+typedef enum {
+	OMAP_MCBSP1 = 0,
+	OMAP_MCBSP2,
+	OMAP_MCBSP3,
+} omap_mcbsp_id;
+
+typedef int __bitwise omap_mcbsp_io_type_t;
+#define OMAP_MCBSP_IRQ_IO ((__force omap_mcbsp_io_type_t) 1)
+#define OMAP_MCBSP_POLL_IO ((__force omap_mcbsp_io_type_t) 2)
+
+typedef enum {
+	OMAP_MCBSP_WORD_8 = 0,
+	OMAP_MCBSP_WORD_12,
+	OMAP_MCBSP_WORD_16,
+	OMAP_MCBSP_WORD_20,
+	OMAP_MCBSP_WORD_24,
+	OMAP_MCBSP_WORD_32,
+} omap_mcbsp_word_length;
+
+typedef enum {
+	OMAP_MCBSP_CLK_RISING = 0,
+	OMAP_MCBSP_CLK_FALLING,
+} omap_mcbsp_clk_polarity;
+
+typedef enum {
+	OMAP_MCBSP_FS_ACTIVE_HIGH = 0,
+	OMAP_MCBSP_FS_ACTIVE_LOW,
+} omap_mcbsp_fs_polarity;
+
+typedef enum {
+	OMAP_MCBSP_CLK_STP_MODE_NO_DELAY = 0,
+	OMAP_MCBSP_CLK_STP_MODE_DELAY,
+} omap_mcbsp_clk_stp_mode;
+
+
+/******* SPI specific mode **********/
+typedef enum {
+	OMAP_MCBSP_SPI_MASTER = 0,
+	OMAP_MCBSP_SPI_SLAVE,
+} omap_mcbsp_spi_mode;
+
+struct omap_mcbsp_spi_cfg {
+	omap_mcbsp_spi_mode		spi_mode;
+	omap_mcbsp_clk_polarity		rx_clock_polarity;
+	omap_mcbsp_clk_polarity		tx_clock_polarity;
+	omap_mcbsp_fs_polarity		fsx_polarity;
+	u8				clk_div;
+	omap_mcbsp_clk_stp_mode		clk_stp_mode;
+	omap_mcbsp_word_length		word_length;
+};
+
+void omap_mcbsp_config(unsigned int id, const struct omap_mcbsp_reg_cfg * config);
+int omap_mcbsp_request(unsigned int id);
+void omap_mcbsp_free(unsigned int id);
+void omap_mcbsp_start(unsigned int id);
+void omap_mcbsp_stop(unsigned int id);
+void omap_mcbsp_xmit_word(unsigned int id, u32 word);
+u32 omap_mcbsp_recv_word(unsigned int id);
+
+int omap_mcbsp_xmit_buffer(unsigned int id, dma_addr_t buffer, unsigned int length);
+int omap_mcbsp_recv_buffer(unsigned int id, dma_addr_t buffer, unsigned int length);
+int omap_mcbsp_spi_master_xmit_word_poll(unsigned int id, u32 word);
+int omap_mcbsp_spi_master_recv_word_poll(unsigned int id, u32 * word);
+
+
+/* SPI specific API */
+void omap_mcbsp_set_spi_mode(unsigned int id, const struct omap_mcbsp_spi_cfg * spi_cfg);
+
+/* Polled read/write functions */
+int omap_mcbsp_pollread(unsigned int id, u16 * buf);
+int omap_mcbsp_pollwrite(unsigned int id, u16 buf);
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/mcspi.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/mcspi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/mcspi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+#ifndef _OMAP2_MCSPI_H
+#define _OMAP2_MCSPI_H
+
+struct omap2_mcspi_platform_config {
+	unsigned long	base;
+	unsigned short	num_cs;
+};
+
+struct omap2_mcspi_device_config {
+	unsigned turbo_mode:1;
+
+	/* Do we want one channel enabled at the same time? */
+	unsigned single_channel:1;
+};
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,90 @@
+/*
+ * linux/include/asm-arm/arch-omap/memory.h
+ *
+ * Memory map for OMAP-1510 and 1610
+ *
+ * Copyright (C) 2000 RidgeRun, Inc.
+ * Author: Greg Lonnon <glonnon@ridgerun.com>
+ *
+ * This file was derived from linux/include/asm-arm/arch-intergrator/memory.h
+ * Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#if defined(CONFIG_ARCH_OMAP1)
+#define PHYS_OFFSET		UL(0x10000000)
+#elif defined(CONFIG_ARCH_OMAP2)
+#define PHYS_OFFSET		UL(0x80000000)
+#endif
+
+/*
+ * Conversion between SDRAM and fake PCI bus, used by USB
+ * NOTE: Physical address must be converted to Local Bus address
+ *	 on OMAP-1510 only
+ */
+
+/*
+ * Bus address is physical address, except for OMAP-1510 Local Bus.
+ */
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+/*
+ * OMAP-1510 bus address is translated into a Local Bus address if the
+ * OMAP bus type is lbus. We do the address translation based on the
+ * device overriding the defaults used in the dma-mapping API.
+ * Note that the is_lbus_device() test is not very efficient on 1510
+ * because of the strncmp().
+ */
+#ifdef CONFIG_ARCH_OMAP15XX
+
+/*
+ * OMAP-1510 Local Bus address offset
+ */
+#define OMAP1510_LB_OFFSET	UL(0x30000000)
+
+#define virt_to_lbus(x)		((x) - PAGE_OFFSET + OMAP1510_LB_OFFSET)
+#define lbus_to_virt(x)		((x) - OMAP1510_LB_OFFSET + PAGE_OFFSET)
+#define is_lbus_device(dev)	(cpu_is_omap15xx() && dev && (strncmp(dev->bus_id, "ohci", 4) == 0))
+
+#define __arch_page_to_dma(dev, page)	({is_lbus_device(dev) ? \
+					(dma_addr_t)virt_to_lbus(page_address(page)) : \
+					(dma_addr_t)__virt_to_bus(page_address(page));})
+
+#define __arch_dma_to_virt(dev, addr)	({is_lbus_device(dev) ? \
+					lbus_to_virt(addr) : \
+					__bus_to_virt(addr);})
+
+#define __arch_virt_to_dma(dev, addr)	({is_lbus_device(dev) ? \
+					virt_to_lbus(addr) : \
+					__virt_to_bus(addr);})
+
+#endif	/* CONFIG_ARCH_OMAP15XX */
+
+#endif
+
Index: build_tree/linux/include/asm/arch-omap/menelaus.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/menelaus.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/menelaus.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/*
+ * linux/include/asm-arm/arch-omap/menelaus.h
+ *
+ * Functions to access Menelaus power management chip
+ */
+
+#ifndef __ASM_ARCH_MENELAUS_H
+#define __ASM_ARCH_MENELAUS_H
+
+extern void menelaus_mmc_register(void (*callback)(unsigned long data, u8 card_mask),
+				  unsigned long data);
+extern void menelaus_mmc_remove(void);
+extern void menelaus_mmc_opendrain(int enable);
+
+#if defined(CONFIG_ARCH_OMAP24XX) && defined(CONFIG_MENELAUS)
+#define omap_has_menelaus()	1
+#else
+#define omap_has_menelaus()	0
+#endif
+
+#endif
+
Index: build_tree/linux/include/asm/arch-omap/mtd-xip.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/mtd-xip.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/mtd-xip.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,61 @@
+/*
+ * MTD primitives for XIP support. Architecture specific functions.
+ *
+ * Do not include this file directly. It's included from linux/mtd/xip.h
+ *
+ * Author: Vladimir Barinov <vbarinov@ru.mvista.com>
+ *
+ * (c) 2005 MontaVista Software, Inc.  This file is licensed under the
+ * terms of the GNU General Public License version 2.  This program is
+ * licensed "as is" without any warranty of any kind, whether express or
+ * implied.
+ */
+
+#ifndef __ARCH_OMAP_MTD_XIP_H__
+#define __ARCH_OMAP_MTD_XIP_H__
+
+#include <asm/hardware.h>
+#define OMAP_MPU_TIMER_BASE	(0xfffec500)
+#define OMAP_MPU_TIMER_OFFSET	0x100
+
+typedef struct {
+	u32 cntl;			/* CNTL_TIMER, R/W */
+	u32 load_tim;			/* LOAD_TIM,   W */
+	u32 read_tim;			/* READ_TIM,   R */
+} xip_omap_mpu_timer_regs_t;
+
+#define xip_omap_mpu_timer_base(n)					\
+((volatile xip_omap_mpu_timer_regs_t*)IO_ADDRESS(OMAP_MPU_TIMER_BASE +	\
+	(n)*OMAP_MPU_TIMER_OFFSET))
+
+static inline unsigned long xip_omap_mpu_timer_read(int nr)
+{
+	volatile xip_omap_mpu_timer_regs_t* timer = xip_omap_mpu_timer_base(nr);
+	return timer->read_tim;
+}
+
+#define xip_irqpending()	\
+	(omap_readl(OMAP_IH1_ITR) & ~omap_readl(OMAP_IH1_MIR))
+#define xip_currtime()		(~xip_omap_mpu_timer_read(0))
+
+/*
+ * It's permitted to do approxmation for xip_elapsed_since macro
+ * (see linux/mtd/xip.h)
+ */
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+#define xip_elapsed_since(x)	(signed)((~xip_omap_mpu_timer_read(0) - (x)) / 7)
+#else
+#define xip_elapsed_since(x)	(signed)((~xip_omap_mpu_timer_read(0) - (x)) / 6)
+#endif
+
+/*
+ * xip_cpu_idle() is used when waiting for a delay equal or larger than
+ * the system timer tick period.  This should put the CPU into idle mode
+ * to save power and to be woken up only when some interrupts are pending.
+ * As above, this should not rely upon standard kernel code.
+ */
+
+#define xip_cpu_idle()  asm volatile ("mcr p15, 0, %0, c7, c0, 4" :: "r" (1))
+
+#endif /* __ARCH_OMAP_MTD_XIP_H__ */
Index: build_tree/linux/include/asm/arch-omap/mux.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/mux.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/mux.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,523 @@
+/*
+ * linux/include/asm-arm/arch-omap/mux.h
+ *
+ * Table of the Omap register configurations for the FUNC_MUX and
+ * PULL_DWN combinations.
+ *
+ * Copyright (C) 2003 - 2005 Nokia Corporation
+ *
+ * Written by Tony Lindgren <tony.lindgren@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * NOTE: Please use the following naming style for new pin entries.
+ *	 For example, W8_1610_MMC2_DAT0, where:
+ *	 - W8	     = ball
+ *	 - 1610	     = 1510 or 1610, none if common for both 1510 and 1610
+ *	 - MMC2_DAT0 = function
+ *
+ * Change log:
+ *   Added entry for the I2C interface. (02Feb 2004)
+ *   Copyright (C) 2004 Texas Instruments
+ *
+ *   Added entry for the keypad and uwire CS1. (09Mar 2004)
+ *   Copyright (C) 2004 Texas Instruments
+ *
+ */
+
+#ifndef __ASM_ARCH_MUX_H
+#define __ASM_ARCH_MUX_H
+
+#define PU_PD_SEL_NA		0	/* No pu_pd reg available */
+#define PULL_DWN_CTRL_NA	0	/* No pull-down control needed */
+
+#ifdef	CONFIG_OMAP_MUX_DEBUG
+#define MUX_REG(reg, mode_offset, mode) .mux_reg_name = "FUNC_MUX_CTRL_"#reg, \
+					.mux_reg = FUNC_MUX_CTRL_##reg, \
+					.mask_offset = mode_offset, \
+					.mask = mode,
+
+#define PULL_REG(reg, bit, status)	.pull_name = "PULL_DWN_CTRL_"#reg, \
+					.pull_reg = PULL_DWN_CTRL_##reg, \
+					.pull_bit = bit, \
+					.pull_val = status,
+
+#define PU_PD_REG(reg, status)		.pu_pd_name = "PU_PD_SEL_"#reg, \
+					.pu_pd_reg = PU_PD_SEL_##reg, \
+					.pu_pd_val = status,
+
+#define MUX_REG_730(reg, mode_offset, mode) .mux_reg_name = "OMAP730_IO_CONF_"#reg, \
+					.mux_reg = OMAP730_IO_CONF_##reg, \
+					.mask_offset = mode_offset, \
+					.mask = mode,
+
+#define PULL_REG_730(reg, bit, status)	.pull_name = "OMAP730_IO_CONF_"#reg, \
+					.pull_reg = OMAP730_IO_CONF_##reg, \
+					.pull_bit = bit, \
+					.pull_val = status,
+
+#else
+
+#define MUX_REG(reg, mode_offset, mode) .mux_reg = FUNC_MUX_CTRL_##reg, \
+					.mask_offset = mode_offset, \
+					.mask = mode,
+
+#define PULL_REG(reg, bit, status)	.pull_reg = PULL_DWN_CTRL_##reg, \
+					.pull_bit = bit, \
+					.pull_val = status,
+
+#define PU_PD_REG(reg, status)		.pu_pd_reg = PU_PD_SEL_##reg, \
+					.pu_pd_val = status,
+
+#define MUX_REG_730(reg, mode_offset, mode) \
+					.mux_reg = OMAP730_IO_CONF_##reg, \
+					.mask_offset = mode_offset, \
+					.mask = mode,
+
+#define PULL_REG_730(reg, bit, status)	.pull_reg = OMAP730_IO_CONF_##reg, \
+					.pull_bit = bit, \
+					.pull_val = status,
+
+#endif /* CONFIG_OMAP_MUX_DEBUG */
+
+#define MUX_CFG(desc, mux_reg, mode_offset, mode,	\
+		pull_reg, pull_bit, pull_status,	\
+		pu_pd_reg, pu_pd_status, debug_status)	\
+{							\
+	.name =	 desc,					\
+	.debug = debug_status,				\
+	MUX_REG(mux_reg, mode_offset, mode)		\
+	PULL_REG(pull_reg, pull_bit, pull_status)	\
+	PU_PD_REG(pu_pd_reg, pu_pd_status)		\
+},
+
+
+/*
+ * OMAP730 has a slightly different config for the pin mux.
+ * - config regs are the OMAP730_IO_CONF_x regs (see omap730.h) regs and
+ *   not the FUNC_MUX_CTRL_x regs from hardware.h
+ * - for pull-up/down, only has one enable bit which is is in the same register
+ *   as mux config
+ */
+#define MUX_CFG_730(desc, mux_reg, mode_offset, mode,	\
+		   pull_bit, pull_status, debug_status)\
+{							\
+	.name =	 desc,					\
+	.debug = debug_status,				\
+	MUX_REG_730(mux_reg, mode_offset, mode)		\
+	PULL_REG_730(mux_reg, pull_bit, pull_status)	\
+	PU_PD_REG(NA, 0)		\
+},
+
+#define MUX_CFG_24XX(desc, reg_offset, mode,			\
+				pull_en, pull_mode, dbg)	\
+{								\
+	.name		= desc,					\
+	.debug		= dbg,					\
+	.mux_reg	= reg_offset,				\
+	.mask		= mode,					\
+	.pull_val	= pull_en,				\
+	.pu_pd_val	= pull_mode,				\
+},
+
+
+#define PULL_DISABLED	0
+#define PULL_ENABLED	1
+
+#define PULL_DOWN	0
+#define PULL_UP		1
+
+struct pin_config {
+	char *name;
+	unsigned char busy;
+	unsigned char debug;
+
+	const char *mux_reg_name;
+	const unsigned int mux_reg;
+	const unsigned char mask_offset;
+	const unsigned char mask;
+
+	const char *pull_name;
+	const unsigned int pull_reg;
+	const unsigned char pull_val;
+	const unsigned char pull_bit;
+
+	const char *pu_pd_name;
+	const unsigned int pu_pd_reg;
+	const unsigned char pu_pd_val;
+};
+
+enum omap730_index {
+	/* OMAP 730 keyboard */
+	E2_730_KBR0,
+	J7_730_KBR1,
+	E1_730_KBR2,
+	F3_730_KBR3,
+	D2_730_KBR4,
+	C2_730_KBC0,
+	D3_730_KBC1,
+	E4_730_KBC2,
+	F4_730_KBC3,
+	E3_730_KBC4,
+
+	/* USB */
+	AA17_730_USB_DM,
+	W16_730_USB_PU_EN,
+	W17_730_USB_VBUSI,
+};
+
+enum omap1xxx_index {
+	/* UART1 (BT_UART_GATING)*/
+	UART1_TX = 0,
+	UART1_RTS,
+
+	/* UART2 (COM_UART_GATING)*/
+	UART2_TX,
+	UART2_RX,
+	UART2_CTS,
+	UART2_RTS,
+
+	/* UART3 (GIGA_UART_GATING) */
+	UART3_TX,
+	UART3_RX,
+	UART3_CTS,
+	UART3_RTS,
+	UART3_CLKREQ,
+	UART3_BCLK,	/* 12MHz clock out */
+	Y15_1610_UART3_RTS,
+
+	/* PWT & PWL */
+	PWT,
+	PWL,
+
+	/* USB master generic */
+	R18_USB_VBUS,
+	R18_1510_USB_GPIO0,
+	W4_USB_PUEN,
+	W4_USB_CLKO,
+	W4_USB_HIGHZ,
+	W4_GPIO58,
+
+	/* USB1 master */
+	USB1_SUSP,
+	USB1_SEO,
+	W13_1610_USB1_SE0,
+	USB1_TXEN,
+	USB1_TXD,
+	USB1_VP,
+	USB1_VM,
+	USB1_RCV,
+	USB1_SPEED,
+	R13_1610_USB1_SPEED,
+	R13_1710_USB1_SE0,
+
+	/* USB2 master */
+	USB2_SUSP,
+	USB2_VP,
+	USB2_TXEN,
+	USB2_VM,
+	USB2_RCV,
+	USB2_SEO,
+	USB2_TXD,
+
+	/* OMAP-1510 GPIO */
+	R18_1510_GPIO0,
+	R19_1510_GPIO1,
+	M14_1510_GPIO2,
+
+	/* OMAP1610 GPIO */
+	P18_1610_GPIO3,
+	Y15_1610_GPIO17,
+
+	/* OMAP-1710 GPIO */
+	R18_1710_GPIO0,
+	V2_1710_GPIO10,
+	N21_1710_GPIO14,
+	W15_1710_GPIO40,
+
+	/* MPUIO */
+	MPUIO2,
+	N15_1610_MPUIO2,
+	MPUIO4,
+	MPUIO5,
+	T20_1610_MPUIO5,
+	W11_1610_MPUIO6,
+	V10_1610_MPUIO7,
+	W11_1610_MPUIO9,
+	V10_1610_MPUIO10,
+	W10_1610_MPUIO11,
+	E20_1610_MPUIO13,
+	U20_1610_MPUIO14,
+	E19_1610_MPUIO15,
+
+	/* MCBSP2 */
+	MCBSP2_CLKR,
+	MCBSP2_CLKX,
+	MCBSP2_DR,
+	MCBSP2_DX,
+	MCBSP2_FSR,
+	MCBSP2_FSX,
+
+	/* MCBSP3 */
+	MCBSP3_CLKX,
+
+	/* Misc ballouts */
+	BALLOUT_V8_ARMIO3,
+	N20_HDQ,
+
+	/* OMAP-1610 MMC2 */
+	W8_1610_MMC2_DAT0,
+	V8_1610_MMC2_DAT1,
+	W15_1610_MMC2_DAT2,
+	R10_1610_MMC2_DAT3,
+	Y10_1610_MMC2_CLK,
+	Y8_1610_MMC2_CMD,
+	V9_1610_MMC2_CMDDIR,
+	V5_1610_MMC2_DATDIR0,
+	W19_1610_MMC2_DATDIR1,
+	R18_1610_MMC2_CLKIN,
+
+	/* OMAP-1610 External Trace Interface */
+	M19_1610_ETM_PSTAT0,
+	L15_1610_ETM_PSTAT1,
+	L18_1610_ETM_PSTAT2,
+	L19_1610_ETM_D0,
+	J19_1610_ETM_D6,
+	J18_1610_ETM_D7,
+
+	/* OMAP16XX GPIO */
+	P20_1610_GPIO4,
+	V9_1610_GPIO7,
+	W8_1610_GPIO9,
+	N20_1610_GPIO11,
+	N19_1610_GPIO13,
+	P10_1610_GPIO22,
+	V5_1610_GPIO24,
+	AA20_1610_GPIO_41,
+	W19_1610_GPIO48,
+	M7_1610_GPIO62,
+	V14_16XX_GPIO37,
+	R9_16XX_GPIO18,
+	L14_16XX_GPIO49,
+
+	/* OMAP-1610 uWire */
+	V19_1610_UWIRE_SCLK,
+	U18_1610_UWIRE_SDI,
+	W21_1610_UWIRE_SDO,
+	N14_1610_UWIRE_CS0,
+	P15_1610_UWIRE_CS3,
+	N15_1610_UWIRE_CS1,
+
+	/* OMAP-1610 SPI */
+	U19_1610_SPIF_SCK,
+	U18_1610_SPIF_DIN,
+	P20_1610_SPIF_DIN,
+	W21_1610_SPIF_DOUT,
+	R18_1610_SPIF_DOUT,
+	N14_1610_SPIF_CS0,
+	N15_1610_SPIF_CS1,
+	T19_1610_SPIF_CS2,
+	P15_1610_SPIF_CS3,
+
+	/* OMAP-1610 Flash */
+	L3_1610_FLASH_CS2B_OE,
+	M8_1610_FLASH_CS2B_WE,
+
+	/* First MMC */
+	MMC_CMD,
+	MMC_DAT1,
+	MMC_DAT2,
+	MMC_DAT0,
+	MMC_CLK,
+	MMC_DAT3,
+
+	/* OMAP-1710 MMC CMDDIR and DATDIR0 */
+	M15_1710_MMC_CLKI,
+	P19_1710_MMC_CMDDIR,
+	P20_1710_MMC_DATDIR0,
+
+	/* OMAP-1610 USB0 alternate pin configuration */
+	W9_USB0_TXEN,
+	AA9_USB0_VP,
+	Y5_USB0_RCV,
+	R9_USB0_VM,
+	V6_USB0_TXD,
+	W5_USB0_SE0,
+	V9_USB0_SPEED,
+	V9_USB0_SUSP,
+
+	/* USB2 */
+	W9_USB2_TXEN,
+	AA9_USB2_VP,
+	Y5_USB2_RCV,
+	R9_USB2_VM,
+	V6_USB2_TXD,
+	W5_USB2_SE0,
+
+	/* 16XX UART */
+	R13_1610_UART1_TX,
+	V14_16XX_UART1_RX,
+	R14_1610_UART1_CTS,
+	AA15_1610_UART1_RTS,
+	R9_16XX_UART2_RX,
+	L14_16XX_UART3_RX,
+
+	/* I2C OMAP-1610 */
+	I2C_SCL,
+	I2C_SDA,
+
+	/* Keypad */
+	F18_1610_KBC0,
+	D20_1610_KBC1,
+	D19_1610_KBC2,
+	E18_1610_KBC3,
+	C21_1610_KBC4,
+	G18_1610_KBR0,
+	F19_1610_KBR1,
+	H14_1610_KBR2,
+	E20_1610_KBR3,
+	E19_1610_KBR4,
+	N19_1610_KBR5,
+
+	/* Power management */
+	T20_1610_LOW_PWR,
+
+	/* MCLK Settings */
+	V5_1710_MCLK_ON,
+	V5_1710_MCLK_OFF,
+	R10_1610_MCLK_ON,
+	R10_1610_MCLK_OFF,
+
+	/* CompactFlash controller */
+	P11_1610_CF_CD2,
+	R11_1610_CF_IOIS16,
+	V10_1610_CF_IREQ,
+	W10_1610_CF_RESET,
+	W11_1610_CF_CD1,
+};
+
+enum omap24xx_index {
+	/* 24xx I2C */
+	M19_24XX_I2C1_SCL,
+	L15_24XX_I2C1_SDA,
+	J15_24XX_I2C2_SCL,
+	H19_24XX_I2C2_SDA,
+
+	/* 24xx Menelaus interrupt */
+	W19_24XX_SYS_NIRQ,
+
+	/* 24xx clock */
+	W14_24XX_SYS_CLKOUT,
+
+	/* 24xx GPMC wait pin monitoring */
+	L3_GPMC_WAIT0,
+	N7_GPMC_WAIT1,
+	M1_GPMC_WAIT2,
+	P1_GPMC_WAIT3,
+
+	/* 242X McBSP */
+	Y15_24XX_MCBSP2_CLKX,
+	R14_24XX_MCBSP2_FSX,
+	W15_24XX_MCBSP2_DR,
+	V15_24XX_MCBSP2_DX,
+
+	/* 24xx GPIO */
+	M21_242X_GPIO11,
+	AA10_242X_GPIO13,
+	AA6_242X_GPIO14,
+	AA4_242X_GPIO15,
+	Y11_242X_GPIO16,
+	AA12_242X_GPIO17,
+	AA8_242X_GPIO58,
+	Y20_24XX_GPIO60,
+	W4__24XX_GPIO74,
+	M15_24XX_GPIO92,
+	V14_24XX_GPIO117,
+
+	/* 242x DBG GPIO */
+	V4_242X_GPIO49,
+	W2_242X_GPIO50,
+	U4_242X_GPIO51,
+	V3_242X_GPIO52,
+	V2_242X_GPIO53,
+	V6_242X_GPIO53,
+	T4_242X_GPIO54,
+	Y4_242X_GPIO54,
+	T3_242X_GPIO55,
+	U2_242X_GPIO56,
+
+	/* 24xx external DMA requests */
+	AA10_242X_DMAREQ0,
+	AA6_242X_DMAREQ1,
+	E4_242X_DMAREQ2,
+	G4_242X_DMAREQ3,
+	D3_242X_DMAREQ4,
+	E3_242X_DMAREQ5,
+
+	P20_24XX_TSC_IRQ,
+
+	/* UART3 */
+	K15_24XX_UART3_TX,
+	K14_24XX_UART3_RX,
+
+	/* MMC/SDIO */
+	G19_24XX_MMC_CLKO,
+	H18_24XX_MMC_CMD,
+	F20_24XX_MMC_DAT0,
+	H14_24XX_MMC_DAT1,
+	E19_24XX_MMC_DAT2,
+	D19_24XX_MMC_DAT3,
+	F19_24XX_MMC_DAT_DIR0,
+	E20_24XX_MMC_DAT_DIR1,
+	F18_24XX_MMC_DAT_DIR2,
+	E18_24XX_MMC_DAT_DIR3,
+	G18_24XX_MMC_CMD_DIR,
+	H15_24XX_MMC_CLKI,
+
+	/* Keypad GPIO*/
+	T19_24XX_KBR0,
+	R19_24XX_KBR1,
+	V18_24XX_KBR2,
+	M21_24XX_KBR3,
+	E5__24XX_KBR4,
+	M18_24XX_KBR5,
+	R20_24XX_KBC0,
+	M14_24XX_KBC1,
+	H19_24XX_KBC2,
+	V17_24XX_KBC3,
+	P21_24XX_KBC4,
+	L14_24XX_KBC5,
+	N19_24XX_KBC6,
+
+	/* 24xx Menelaus Keypad GPIO */
+	B3__24XX_KBR5,
+	AA4_24XX_KBC2,
+	B13_24XX_KBC6,
+};
+
+#ifdef	CONFIG_OMAP_MUX
+/* setup pin muxing in Linux */
+extern int omap1_mux_init(void);
+extern int omap2_mux_init(void);
+extern int omap_mux_register(struct pin_config * pins, unsigned long size);
+extern int omap_cfg_reg(unsigned long reg_cfg);
+#else
+/* boot loader does it all (no warnings from CONFIG_OMAP_MUX_WARNINGS) */
+static inline int omap1_mux_init(void) { return 0; }
+static inline int omap2_mux_init(void) { return 0; }
+static inline int omap_cfg_reg(unsigned long reg_cfg) { return 0; }
+#endif
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/omap-alsa.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/omap-alsa.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/omap-alsa.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,124 @@
+/*
+ * linux/include/asm-arm/arch-omap/omap-alsa.h
+ *
+ * Alsa Driver for AIC23 and TSC2101 codecs on OMAP platform boards.
+ *
+ * Copyright (C) 2006 Mika Laitio <lamikr@cc.jyu.fi>
+ *
+ * Copyright (C) 2005 Instituto Nokia de Tecnologia - INdT - Manaus Brazil
+ * Written by Daniel Petrini, David Cohen, Anderson Briglia
+ *            {daniel.petrini, david.cohen, anderson.briglia}@indt.org.br
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  History
+ *  -------
+ *
+ *  2005/07/25 INdT-10LE Kernel Team - 	Alsa driver for omap osk,
+ *  					original version based in sa1100 driver
+ *  					and omap oss driver.
+ */
+
+#ifndef __OMAP_ALSA_H
+#define __OMAP_ALSA_H
+
+#include <sound/driver.h>
+#include <asm/arch/dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <asm/arch/mcbsp.h>
+#include <linux/platform_device.h>
+
+#define DMA_BUF_SIZE	(1024 * 8)
+
+/*
+ * Buffer management for alsa and dma
+ */
+struct audio_stream {
+	char *id;		/* identification string */
+	int stream_id;		/* numeric identification */
+	int dma_dev;		/* dma number of that device */
+	int *lch;		/* Chain of channels this stream is linked to */
+	char started;		/* to store if the chain was started or not */
+	int dma_q_head;		/* DMA Channel Q Head */
+	int dma_q_tail;		/* DMA Channel Q Tail */
+	char dma_q_count;	/* DMA Channel Q Count */
+	int active:1;		/* we are using this stream for transfer now */
+	int period;		/* current transfer period */
+	int periods;		/* current count of periods registerd in the DMA engine */
+	spinlock_t dma_lock;	/* for locking in DMA operations */
+	struct snd_pcm_substream *stream;	/* the pcm stream */
+	unsigned linked:1;	/* dma channels linked */
+	int offset;		/* store start position of the last period in the alsa buffer */
+	int (*hw_start)(void);  /* interface to start HW interface, e.g. McBSP */
+	int (*hw_stop)(void);   /* interface to stop HW interface, e.g. McBSP */
+};
+
+/*
+ * Alsa card structure for aic23
+ */
+struct snd_card_omap_codec {
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	long samplerate;
+	struct audio_stream s[2];	/* playback & capture */
+};
+
+/* Codec specific information and function pointers.
+ * Codec (omap-alsa-aic23.c and omap-alsa-tsc2101.c)
+ * are responsible for defining the function pointers.
+ */
+struct omap_alsa_codec_config {
+	char 	*name;
+	struct	omap_mcbsp_reg_cfg *mcbsp_regs_alsa;
+	struct	snd_pcm_hw_constraint_list *hw_constraints_rates;
+	struct	snd_pcm_hardware *snd_omap_alsa_playback;
+	struct	snd_pcm_hardware *snd_omap_alsa_capture;
+	void	(*codec_configure_dev)(void);
+	void	(*codec_set_samplerate)(long);
+	void	(*codec_clock_setup)(void);
+	int	(*codec_clock_on)(void);
+	int 	(*codec_clock_off)(void);
+	int	(*get_default_samplerate)(void);
+};
+
+/*********** Mixer function prototypes *************************/
+int snd_omap_mixer(struct snd_card_omap_codec *);
+void snd_omap_init_mixer(void);
+
+#ifdef CONFIG_PM
+void snd_omap_suspend_mixer(void);
+void snd_omap_resume_mixer(void);
+#endif
+
+int snd_omap_alsa_post_probe(struct platform_device *pdev, struct omap_alsa_codec_config *config);
+int snd_omap_alsa_remove(struct platform_device *pdev);
+#ifdef CONFIG_PM
+int snd_omap_alsa_suspend(struct platform_device *pdev, pm_message_t state);
+int snd_omap_alsa_resume(struct platform_device *pdev);
+#else
+#define snd_omap_alsa_suspend	NULL
+#define snd_omap_alsa_resume	NULL
+#endif
+
+void callback_omap_alsa_sound_dma(void *);
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/omap1510.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/omap1510.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/omap1510.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,48 @@
+/* linux/include/asm-arm/arch-omap/omap1510.h
+ *
+ * Hardware definitions for TI OMAP1510 processor.
+ *
+ * Cleanup for Linux-2.6 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP15XX_H
+#define __ASM_ARCH_OMAP15XX_H
+
+/*
+ * ----------------------------------------------------------------------------
+ * Base addresses
+ * ----------------------------------------------------------------------------
+ */
+
+/* Syntax: XX_BASE = Virtual base address, XX_START = Physical base address */
+
+#define OMAP1510_DSP_BASE	0xE0000000
+#define OMAP1510_DSP_SIZE	0x28000
+#define OMAP1510_DSP_START	0xE0000000
+
+#define OMAP1510_DSPREG_BASE	0xE1000000
+#define OMAP1510_DSPREG_SIZE	SZ_128K
+#define OMAP1510_DSPREG_START	0xE1000000
+
+#endif /*  __ASM_ARCH_OMAP15XX_H */
+
Index: build_tree/linux/include/asm/arch-omap/omap16xx.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/omap16xx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/omap16xx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,203 @@
+/* linux/include/asm-arm/arch-omap/omap16xx.h
+ *
+ * Hardware definitions for TI OMAP1610/5912/1710 processors.
+ *
+ * Cleanup for Linux-2.6 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP16XX_H
+#define __ASM_ARCH_OMAP16XX_H
+
+/*
+ * ----------------------------------------------------------------------------
+ * Base addresses
+ * ----------------------------------------------------------------------------
+ */
+
+/* Syntax: XX_BASE = Virtual base address, XX_START = Physical base address */
+
+#define OMAP16XX_DSP_BASE	0xE0000000
+#define OMAP16XX_DSP_SIZE	0x28000
+#define OMAP16XX_DSP_START	0xE0000000
+
+#define OMAP16XX_DSPREG_BASE	0xE1000000
+#define OMAP16XX_DSPREG_SIZE	SZ_128K
+#define OMAP16XX_DSPREG_START	0xE1000000
+
+/*
+ * ---------------------------------------------------------------------------
+ * Interrupts
+ * ---------------------------------------------------------------------------
+ */
+#define OMAP_IH2_0_BASE		(0xfffe0000)
+#define OMAP_IH2_1_BASE		(0xfffe0100)
+#define OMAP_IH2_2_BASE		(0xfffe0200)
+#define OMAP_IH2_3_BASE		(0xfffe0300)
+
+#define OMAP_IH2_0_ITR		(OMAP_IH2_0_BASE + 0x00)
+#define OMAP_IH2_0_MIR		(OMAP_IH2_0_BASE + 0x04)
+#define OMAP_IH2_0_SIR_IRQ	(OMAP_IH2_0_BASE + 0x10)
+#define OMAP_IH2_0_SIR_FIQ	(OMAP_IH2_0_BASE + 0x14)
+#define OMAP_IH2_0_CONTROL	(OMAP_IH2_0_BASE + 0x18)
+#define OMAP_IH2_0_ILR0		(OMAP_IH2_0_BASE + 0x1c)
+#define OMAP_IH2_0_ISR		(OMAP_IH2_0_BASE + 0x9c)
+
+#define OMAP_IH2_1_ITR		(OMAP_IH2_1_BASE + 0x00)
+#define OMAP_IH2_1_MIR		(OMAP_IH2_1_BASE + 0x04)
+#define OMAP_IH2_1_SIR_IRQ	(OMAP_IH2_1_BASE + 0x10)
+#define OMAP_IH2_1_SIR_FIQ	(OMAP_IH2_1_BASE + 0x14)
+#define OMAP_IH2_1_CONTROL	(OMAP_IH2_1_BASE + 0x18)
+#define OMAP_IH2_1_ILR1		(OMAP_IH2_1_BASE + 0x1c)
+#define OMAP_IH2_1_ISR		(OMAP_IH2_1_BASE + 0x9c)
+
+#define OMAP_IH2_2_ITR		(OMAP_IH2_2_BASE + 0x00)
+#define OMAP_IH2_2_MIR		(OMAP_IH2_2_BASE + 0x04)
+#define OMAP_IH2_2_SIR_IRQ	(OMAP_IH2_2_BASE + 0x10)
+#define OMAP_IH2_2_SIR_FIQ	(OMAP_IH2_2_BASE + 0x14)
+#define OMAP_IH2_2_CONTROL	(OMAP_IH2_2_BASE + 0x18)
+#define OMAP_IH2_2_ILR2		(OMAP_IH2_2_BASE + 0x1c)
+#define OMAP_IH2_2_ISR		(OMAP_IH2_2_BASE + 0x9c)
+
+#define OMAP_IH2_3_ITR		(OMAP_IH2_3_BASE + 0x00)
+#define OMAP_IH2_3_MIR		(OMAP_IH2_3_BASE + 0x04)
+#define OMAP_IH2_3_SIR_IRQ	(OMAP_IH2_3_BASE + 0x10)
+#define OMAP_IH2_3_SIR_FIQ	(OMAP_IH2_3_BASE + 0x14)
+#define OMAP_IH2_3_CONTROL	(OMAP_IH2_3_BASE + 0x18)
+#define OMAP_IH2_3_ILR3		(OMAP_IH2_3_BASE + 0x1c)
+#define OMAP_IH2_3_ISR		(OMAP_IH2_3_BASE + 0x9c)
+
+/*
+ * ----------------------------------------------------------------------------
+ * Clocks
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP16XX_ARM_IDLECT3	(CLKGEN_REG_BASE + 0x24)
+
+/*
+ * ----------------------------------------------------------------------------
+ * Pin configuration registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP16XX_CONF_VOLTAGE_VDDSHV6	(1 << 8)
+#define OMAP16XX_CONF_VOLTAGE_VDDSHV7	(1 << 9)
+#define OMAP16XX_CONF_VOLTAGE_VDDSHV8	(1 << 10)
+#define OMAP16XX_CONF_VOLTAGE_VDDSHV9	(1 << 11)
+#define OMAP16XX_SUBLVDS_CONF_VALID	(1 << 13)
+
+/*
+ * ----------------------------------------------------------------------------
+ * System control registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP1610_RESET_CONTROL  0xfffe1140
+
+/*
+ * ---------------------------------------------------------------------------
+ * TIPB bus interface
+ * ---------------------------------------------------------------------------
+ */
+#define TIPB_SWITCH_BASE		 (0xfffbc800)
+#define OMAP16XX_MMCSD2_SSW_MPU_CONF	(TIPB_SWITCH_BASE + 0x160)
+
+/* UART3 Registers Maping through MPU bus */
+#define UART3_RHR               (OMAP_UART3_BASE + 0)
+#define UART3_THR               (OMAP_UART3_BASE + 0)
+#define UART3_DLL               (OMAP_UART3_BASE + 0)
+#define UART3_IER               (OMAP_UART3_BASE + 4)
+#define UART3_DLH               (OMAP_UART3_BASE + 4)
+#define UART3_IIR               (OMAP_UART3_BASE + 8)
+#define UART3_FCR               (OMAP_UART3_BASE + 8)
+#define UART3_EFR               (OMAP_UART3_BASE + 8)
+#define UART3_LCR               (OMAP_UART3_BASE + 0x0C)
+#define UART3_MCR               (OMAP_UART3_BASE + 0x10)
+#define UART3_XON1_ADDR1        (OMAP_UART3_BASE + 0x10)
+#define UART3_XON2_ADDR2        (OMAP_UART3_BASE + 0x14)
+#define UART3_LSR               (OMAP_UART3_BASE + 0x14)
+#define UART3_TCR               (OMAP_UART3_BASE + 0x18)
+#define UART3_MSR               (OMAP_UART3_BASE + 0x18)
+#define UART3_XOFF1             (OMAP_UART3_BASE + 0x18)
+#define UART3_XOFF2             (OMAP_UART3_BASE + 0x1C)
+#define UART3_SPR               (OMAP_UART3_BASE + 0x1C)
+#define UART3_TLR               (OMAP_UART3_BASE + 0x1C)
+#define UART3_MDR1              (OMAP_UART3_BASE + 0x20)
+#define UART3_MDR2              (OMAP_UART3_BASE + 0x24)
+#define UART3_SFLSR             (OMAP_UART3_BASE + 0x28)
+#define UART3_TXFLL             (OMAP_UART3_BASE + 0x28)
+#define UART3_RESUME            (OMAP_UART3_BASE + 0x2C)
+#define UART3_TXFLH             (OMAP_UART3_BASE + 0x2C)
+#define UART3_SFREGL            (OMAP_UART3_BASE + 0x30)
+#define UART3_RXFLL             (OMAP_UART3_BASE + 0x30)
+#define UART3_SFREGH            (OMAP_UART3_BASE + 0x34)
+#define UART3_RXFLH             (OMAP_UART3_BASE + 0x34)
+#define UART3_BLR               (OMAP_UART3_BASE + 0x38)
+#define UART3_ACREG             (OMAP_UART3_BASE + 0x3C)
+#define UART3_DIV16             (OMAP_UART3_BASE + 0x3C)
+#define UART3_SCR               (OMAP_UART3_BASE + 0x40)
+#define UART3_SSR               (OMAP_UART3_BASE + 0x44)
+#define UART3_EBLR              (OMAP_UART3_BASE + 0x48)
+#define UART3_OSC_12M_SEL       (OMAP_UART3_BASE + 0x4C)
+#define UART3_MVR               (OMAP_UART3_BASE + 0x50)
+
+/*
+ * ----------------------------------------------------------------------------
+ * Pulse-Width Light
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP16XX_PWL_BASE	(0xfffb5800)
+#define OMAP16XX_PWL_ENABLE	(OMAP16XX_PWL_BASE + 0x00)
+#define OMAP16XX_PWL_CLK_ENABLE	(OMAP16XX_PWL_BASE + 0x04)
+
+/*
+ * ---------------------------------------------------------------------------
+ * Watchdog timer
+ * ---------------------------------------------------------------------------
+ */
+
+/* 32-bit Watchdog timer in OMAP 16XX */
+#define OMAP_16XX_WATCHDOG_BASE        (0xfffeb000)
+#define OMAP_16XX_WIDR         (OMAP_16XX_WATCHDOG_BASE + 0x00)
+#define OMAP_16XX_WD_SYSCONFIG (OMAP_16XX_WATCHDOG_BASE + 0x10)
+#define OMAP_16XX_WD_SYSSTATUS (OMAP_16XX_WATCHDOG_BASE + 0x14)
+#define OMAP_16XX_WCLR         (OMAP_16XX_WATCHDOG_BASE + 0x24)
+#define OMAP_16XX_WCRR         (OMAP_16XX_WATCHDOG_BASE + 0x28)
+#define OMAP_16XX_WLDR         (OMAP_16XX_WATCHDOG_BASE + 0x2c)
+#define OMAP_16XX_WTGR         (OMAP_16XX_WATCHDOG_BASE + 0x30)
+#define OMAP_16XX_WWPS         (OMAP_16XX_WATCHDOG_BASE + 0x34)
+#define OMAP_16XX_WSPR         (OMAP_16XX_WATCHDOG_BASE + 0x48)
+
+#define WCLR_PRE_SHIFT         5
+#define WCLR_PTV_SHIFT         2
+
+#define WWPS_W_PEND_WSPR       (1 << 4)
+#define WWPS_W_PEND_WTGR       (1 << 3)
+#define WWPS_W_PEND_WLDR       (1 << 2)
+#define WWPS_W_PEND_WCRR       (1 << 1)
+#define WWPS_W_PEND_WCLR       (1 << 0)
+
+#define WSPR_ENABLE_0          (0x0000bbbb)
+#define WSPR_ENABLE_1          (0x00004444)
+#define WSPR_DISABLE_0         (0x0000aaaa)
+#define WSPR_DISABLE_1         (0x00005555)
+
+#endif /*  __ASM_ARCH_OMAP16XX_H */
+
Index: build_tree/linux/include/asm/arch-omap/omap24xx.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/omap24xx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/omap24xx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+#ifndef __ASM_ARCH_OMAP24XX_H
+#define __ASM_ARCH_OMAP24XX_H
+
+/*
+ * Please place only base defines here and put the rest in device
+ * specific headers. Note also that some of these defines are needed
+ * for omap1 to compile without adding ifdefs.
+ */
+
+#define L4_24XX_BASE		0x48000000
+#define L3_24XX_BASE		0x68000000
+
+/* interrupt controller */
+#define OMAP24XX_IC_BASE	(L4_24XX_BASE + 0xfe000)
+#define VA_IC_BASE		IO_ADDRESS(OMAP24XX_IC_BASE)
+#define OMAP24XX_IVA_INTC_BASE	0x40000000
+#define IRQ_SIR_IRQ		0x0040
+
+#define OMAP24XX_32KSYNCT_BASE	(L4_24XX_BASE + 0x4000)
+#define OMAP24XX_PRCM_BASE	(L4_24XX_BASE + 0x8000)
+#define OMAP24XX_SDRC_BASE	(L3_24XX_BASE + 0x9000)
+
+#endif /* __ASM_ARCH_OMAP24XX_H */
+
Index: build_tree/linux/include/asm/arch-omap/omap730.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/omap730.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/omap730.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,102 @@
+/* linux/include/asm-arm/arch-omap/omap730.h
+ *
+ * Hardware definitions for TI OMAP730 processor.
+ *
+ * Cleanup for Linux-2.6 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP730_H
+#define __ASM_ARCH_OMAP730_H
+
+/*
+ * ----------------------------------------------------------------------------
+ * Base addresses
+ * ----------------------------------------------------------------------------
+ */
+
+/* Syntax: XX_BASE = Virtual base address, XX_START = Physical base address */
+
+#define OMAP730_DSP_BASE	0xE0000000
+#define OMAP730_DSP_SIZE	0x50000
+#define OMAP730_DSP_START	0xE0000000
+
+#define OMAP730_DSPREG_BASE	0xE1000000
+#define OMAP730_DSPREG_SIZE	SZ_128K
+#define OMAP730_DSPREG_START	0xE1000000
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP730 specific configuration registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP730_CONFIG_BASE	0xfffe1000
+#define OMAP730_IO_CONF_0	0xfffe1070
+#define OMAP730_IO_CONF_1	0xfffe1074
+#define OMAP730_IO_CONF_2	0xfffe1078
+#define OMAP730_IO_CONF_3	0xfffe107c
+#define OMAP730_IO_CONF_4	0xfffe1080
+#define OMAP730_IO_CONF_5	0xfffe1084
+#define OMAP730_IO_CONF_6	0xfffe1088
+#define OMAP730_IO_CONF_7	0xfffe108c
+#define OMAP730_IO_CONF_8	0xfffe1090
+#define OMAP730_IO_CONF_9	0xfffe1094
+#define OMAP730_IO_CONF_10	0xfffe1098
+#define OMAP730_IO_CONF_11	0xfffe109c
+#define OMAP730_IO_CONF_12	0xfffe10a0
+#define OMAP730_IO_CONF_13	0xfffe10a4
+
+#define OMAP730_MODE_1		0xfffe1010
+#define OMAP730_MODE_2		0xfffe1014
+
+/* CSMI specials: in terms of base + offset */
+#define OMAP730_MODE2_OFFSET	0x14
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP730 traffic controller configuration registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP730_FLASH_CFG_0	0xfffecc10
+#define OMAP730_FLASH_ACFG_0	0xfffecc50
+#define OMAP730_FLASH_CFG_1	0xfffecc14
+#define OMAP730_FLASH_ACFG_1	0xfffecc54
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP730 DSP control registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP730_ICR_BASE	0xfffbb800
+#define OMAP730_DSP_M_CTL	0xfffbb804
+#define OMAP730_DSP_MMU_BASE	0xfffed200
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP730 PCC_UPLD configuration registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP730_PCC_UPLD_CTRL_BASE	(0xfffe0900)
+#define OMAP730_PCC_UPLD_CTRL		(OMAP730_PCC_UPLD_CTRL_BASE + 0x00)
+
+#endif /*  __ASM_ARCH_OMAP730_H */
+
Index: build_tree/linux/include/asm/arch-omap/omapfb.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/omapfb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/omapfb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,325 @@
+/*
+ * File: include/asm-arm/arch-omap/omapfb.h
+ *
+ * Framebuffer driver for TI OMAP boards
+ *
+ * Copyright (C) 2004 Nokia Corporation
+ * Author: Imre Deak <imre.deak@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __OMAPFB_H
+#define __OMAPFB_H
+
+/* IOCTL commands. */
+
+#define OMAP_IOW(num, dtype)	_IOW('O', num, dtype)
+#define OMAP_IOR(num, dtype)	_IOR('O', num, dtype)
+#define OMAP_IOWR(num, dtype)	_IOWR('O', num, dtype)
+#define OMAP_IO(num)		_IO('O', num)
+
+#define OMAPFB_MIRROR		OMAP_IOW(31, int)
+#define OMAPFB_SYNC_GFX		OMAP_IO(37)
+#define OMAPFB_VSYNC		OMAP_IO(38)
+#define OMAPFB_SET_UPDATE_MODE	OMAP_IOW(40, int)
+#define OMAPFB_UPDATE_WINDOW_OLD OMAP_IOW(41, struct omapfb_update_window_old)
+#define OMAPFB_GET_CAPS		OMAP_IOR(42, unsigned long)
+#define OMAPFB_GET_UPDATE_MODE	OMAP_IOW(43, int)
+#define OMAPFB_LCD_TEST		OMAP_IOW(45, int)
+#define OMAPFB_CTRL_TEST	OMAP_IOW(46, int)
+#define OMAPFB_UPDATE_WINDOW	OMAP_IOW(47, struct omapfb_update_window)
+#define OMAPFB_SETUP_PLANE	OMAP_IOW(48, struct omapfb_setup_plane)
+#define OMAPFB_ENABLE_PLANE	OMAP_IOW(49, struct omapfb_enable_plane)
+#define OMAPFB_SET_COLOR_KEY	OMAP_IOW(50, struct omapfb_color_key)
+
+#define OMAPFB_CAPS_GENERIC_MASK	0x00000fff
+#define OMAPFB_CAPS_LCDC_MASK		0x00fff000
+#define OMAPFB_CAPS_PANEL_MASK		0xff000000
+
+#define OMAPFB_CAPS_MANUAL_UPDATE	0x00001000
+#define OMAPFB_CAPS_SET_BACKLIGHT	0x01000000
+
+/* Values from DSP must map to lower 16-bits */
+#define OMAPFB_FORMAT_MASK         0x00ff
+#define OMAPFB_FORMAT_FLAG_DOUBLE  0x0100
+
+enum omapfb_color_format {
+	OMAPFB_COLOR_RGB565 = 0,
+	OMAPFB_COLOR_YUV422,
+	OMAPFB_COLOR_YUV420,
+	OMAPFB_COLOR_CLUT_8BPP,
+	OMAPFB_COLOR_CLUT_4BPP,
+	OMAPFB_COLOR_CLUT_2BPP,
+	OMAPFB_COLOR_CLUT_1BPP,
+};
+
+struct omapfb_update_window {
+	__u32 x, y;
+	__u32 width, height;
+	__u32 format;
+};
+
+struct omapfb_update_window_old {
+	__u32 x, y;
+	__u32 width, height;
+};
+
+enum omapfb_plane {
+	OMAPFB_PLANE_GFX = 0,
+	OMAPFB_PLANE_VID1,
+	OMAPFB_PLANE_VID2,
+};
+
+enum omapfb_channel_out {
+	OMAPFB_CHANNEL_OUT_LCD = 0,
+	OMAPFB_CHANNEL_OUT_DIGIT,
+};
+
+struct omapfb_setup_plane {
+	__u8  plane;
+	__u8  channel_out;
+	__u32 offset;
+	__u32 pos_x, pos_y;
+	__u32 width, height;
+	__u32 color_mode;
+};
+
+struct omapfb_enable_plane {
+	__u8  plane;
+	__u8  enable;
+};
+
+enum omapfb_color_key_type {
+	OMAPFB_COLOR_KEY_DISABLED = 0,
+	OMAPFB_COLOR_KEY_GFX_DST,
+	OMAPFB_COLOR_KEY_VID_SRC,
+};
+
+struct omapfb_color_key {
+	__u8  channel_out;
+	__u32 background;
+	__u32 trans_key;
+	__u8  key_type;
+};
+
+enum omapfb_update_mode {
+	OMAPFB_UPDATE_DISABLED = 0,
+	OMAPFB_AUTO_UPDATE,
+	OMAPFB_MANUAL_UPDATE
+};
+
+#ifdef __KERNEL__
+
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/mutex.h>
+
+#include <asm/arch/board.h>
+
+#define OMAP_LCDC_INV_VSYNC             0x0001
+#define OMAP_LCDC_INV_HSYNC             0x0002
+#define OMAP_LCDC_INV_PIX_CLOCK         0x0004
+#define OMAP_LCDC_INV_OUTPUT_EN         0x0008
+#define OMAP_LCDC_HSVS_RISING_EDGE      0x0010
+#define OMAP_LCDC_HSVS_OPPOSITE         0x0020
+
+#define OMAP_LCDC_SIGNAL_MASK		0x003f
+
+#define OMAP_LCDC_PANEL_TFT		0x0100
+
+#ifdef CONFIG_ARCH_OMAP1
+#define OMAPFB_PLANE_NUM		1
+#else
+#define OMAPFB_PLANE_NUM		3
+#endif
+
+struct omapfb_device;
+
+struct lcd_panel {
+	const char	*name;
+	int		config;		/* TFT/STN, signal inversion */
+	int		bpp;		/* Pixel format in fb mem */
+	int		data_lines;	/* Lines on LCD HW interface */
+
+	int		x_res, y_res;
+	int		pixel_clock;	/* In kHz */
+	int		hsw;		/* Horizontal synchronization
+					   pulse width */
+	int		hfp;		/* Horizontal front porch */
+	int		hbp;		/* Horizontal back porch */
+	int		vsw;		/* Vertical synchronization
+					   pulse width */
+	int		vfp;		/* Vertical front porch */
+	int		vbp;		/* Vertical back porch */
+	int		acb;		/* ac-bias pin frequency */
+	int		pcd;		/* pixel clock divider.
+					   Obsolete use pixel_clock instead */
+
+	int		(*init)		(struct omapfb_device *fbdev);
+	void		(*cleanup)	(void);
+	int		(*enable)	(void);
+	void		(*disable)	(void);
+	unsigned long	(*get_caps)	(void);
+	int		(*set_bklight_level)(unsigned int level);
+	unsigned int	(*get_bklight_level)(void);
+	unsigned int	(*get_bklight_max)  (void);
+	int		(*run_test)	(int test_num);
+};
+
+struct omapfb_device;
+
+struct extif_timings {
+	int cs_on_time;
+	int cs_off_time;
+	int we_on_time;
+	int we_off_time;
+	int re_on_time;
+	int re_off_time;
+	int we_cycle_time;
+	int re_cycle_time;
+	int cs_pulse_width;
+	int access_time;
+
+	int clk_div;
+
+	u32 tim[5];		/* set by extif->convert_timings */
+
+	int converted;
+};
+
+struct lcd_ctrl_extif {
+	int  (*init)		(void);
+	void (*cleanup)		(void);
+	void (*get_clk_info)	(u32 *clk_period, u32 *max_clk_div);
+	int  (*convert_timings)	(struct extif_timings *timings);
+	void (*set_timings)	(const struct extif_timings *timings);
+	void (*set_bits_per_cycle)(int bpc);
+	void (*write_command)	(const void *buf, unsigned int len);
+	void (*read_data)	(void *buf, unsigned int len);
+	void (*write_data)	(const void *buf, unsigned int len);
+	void (*transfer_area)	(int width, int height,
+				 void (callback)(void * data), void *data);
+	unsigned long		max_transmit_size;
+};
+
+struct omapfb_notifier_block {
+	struct notifier_block	nb;
+	void			*data;
+};
+
+typedef int (*omapfb_notifier_callback_t)(struct omapfb_notifier_block *,
+					   unsigned long event,
+					   struct omapfb_device *fbdev);
+
+struct lcd_ctrl {
+	const char	*name;
+	void		*data;
+
+	int		(*init)		  (struct omapfb_device *fbdev,
+					   int ext_mode, int req_vram_size);
+	void		(*cleanup)	  (void);
+	void		(*bind_client)	  (struct omapfb_notifier_block *nb);
+	void		(*get_vram_layout)(unsigned long *size,
+					   void **virt_base,
+					   dma_addr_t *phys_base);
+	int		(*mmap)		  (struct vm_area_struct *vma);
+	unsigned long	(*get_caps)	  (void);
+	int		(*set_update_mode)(enum omapfb_update_mode mode);
+	enum omapfb_update_mode (*get_update_mode)(void);
+	int		(*setup_plane)	  (int plane, int channel_out,
+					   unsigned long offset,
+					   int screen_width,
+					   int pos_x, int pos_y, int width,
+					   int height, int color_mode);
+	int		(*enable_plane)	  (int plane, int enable);
+	int		(*update_window)  (struct omapfb_update_window *win,
+					   void (*callback)(void *),
+					   void *callback_data);
+	void		(*sync)		  (void);
+	void		(*suspend)	  (void);
+	void		(*resume)	  (void);
+	int		(*run_test)	  (int test_num);
+	int		(*setcolreg)	  (u_int regno, u16 red, u16 green,
+					   u16 blue, u16 transp,
+					   int update_hw_mem);
+	int		(*set_color_key)  (struct omapfb_color_key *ck);
+
+};
+
+enum omapfb_state {
+	OMAPFB_DISABLED	= 0,
+	OMAPFB_SUSPENDED= 99,
+	OMAPFB_ACTIVE	= 100
+};
+
+struct omapfb_device {
+	int			state;
+	int                     ext_lcdc;               /* Using external
+                                                           LCD controller */
+	struct mutex		rqueue_mutex;
+
+	void			*vram_virt_base;
+	dma_addr_t		vram_phys_base;
+	unsigned long		vram_size;
+
+	int			color_mode;
+	int			palette_size;
+	int			mirror;
+	u32			pseudo_palette[17];
+
+	struct lcd_panel	*panel;			/* LCD panel */
+	struct lcd_ctrl         *ctrl;			/* LCD controller */
+	struct lcd_ctrl		*int_ctrl;		/* internal LCD ctrl */
+	struct lcd_ctrl_extif	*ext_if;		/* LCD ctrl external
+							   interface */
+	struct fb_info		*fb_info;
+
+	struct device		*dev;
+};
+
+struct omapfb_platform_data {
+	struct omap_lcd_config   lcd;
+	struct omap_fbmem_config fbmem;
+};
+
+#define OMAPFB_EVENT_READY	1
+#define OMAPFB_EVENT_DISABLED	2
+
+#ifdef CONFIG_ARCH_OMAP1
+extern struct lcd_ctrl omap1_lcd_ctrl;
+#else
+extern struct lcd_ctrl omap2_disp_ctrl;
+#endif
+
+extern void omapfb_register_panel(struct lcd_panel *panel);
+extern void omapfb_write_first_pixel(struct omapfb_device *fbdev, u16 pixval);
+extern void omapfb_notify_clients(struct omapfb_device *fbdev,
+				  unsigned long event);
+extern int  omapfb_register_client(struct omapfb_notifier_block *nb,
+				    omapfb_notifier_callback_t callback,
+				    void *callback_data);
+extern int  omapfb_unregister_client(struct omapfb_notifier_block *nb);
+extern int  omapfb_update_window_async(struct omapfb_update_window *win,
+					void (*callback)(void *),
+					void *callback_data);
+
+/* in arch/arm/plat-omap/devices.c */
+extern void omapfb_reserve_mem(void);
+
+#endif /* __KERNEL__ */
+
+#endif /* __OMAPFB_H */
Index: build_tree/linux/include/asm/arch-omap/param.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/param.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/param.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,8 @@
+/*
+ *  linux/include/asm-arm/arch-omap/param.h
+ *
+ */
+
+#ifdef CONFIG_OMAP_32K_TIMER_HZ
+#define HZ	CONFIG_OMAP_32K_TIMER_HZ
+#endif
Index: build_tree/linux/include/asm/arch-omap/pm.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/pm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/pm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,356 @@
+/*
+ * linux/include/asm-arm/arch-omap/pm.h
+ *
+ * Header file for OMAP Power Management Routines
+ *
+ * Author: MontaVista Software, Inc.
+ *	   support@mvista.com
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ *
+ * Cleanup 2004 for Linux 2.6 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_PM_H
+#define __ASM_ARCH_OMAP_PM_H
+
+/*
+ * ----------------------------------------------------------------------------
+ * Register and offset definitions to be used in PM assembler code
+ * ----------------------------------------------------------------------------
+ */
+#define CLKGEN_REG_ASM_BASE		io_p2v(0xfffece00)
+#define ARM_IDLECT1_ASM_OFFSET		0x04
+#define ARM_IDLECT2_ASM_OFFSET		0x08
+
+#define TCMIF_ASM_BASE			io_p2v(0xfffecc00)
+#define EMIFS_CONFIG_ASM_OFFSET		0x0c
+#define EMIFF_SDRAM_CONFIG_ASM_OFFSET	0x20
+
+/*
+ * ----------------------------------------------------------------------------
+ * Power management bitmasks
+ * ----------------------------------------------------------------------------
+ */
+#define IDLE_WAIT_CYCLES		0x00000fff
+#define PERIPHERAL_ENABLE		0x2
+
+#define SELF_REFRESH_MODE		0x0c000001
+#define IDLE_EMIFS_REQUEST		0xc
+#define MODEM_32K_EN			0x1
+#define PER_EN				0x1
+
+#define CPU_SUSPEND_SIZE		200
+#define ULPD_LOW_PWR_EN			0x0001
+#define ULPD_DEEP_SLEEP_TRANSITION_EN	0x0010
+#define ULPD_SETUP_ANALOG_CELL_3_VAL	0
+#define ULPD_POWER_CTRL_REG_VAL		0x0219
+
+#define DSP_IDLE_DELAY			10
+#define DSP_IDLE			0x0040
+#define DSP_RST				0x0004
+#define DSP_ENABLE			0x0002
+#define SUFFICIENT_DSP_RESET_TIME	1000
+#define DEFAULT_MPUI_CONFIG		0x05cf
+#define ENABLE_XORCLK			0x2
+#define DSP_CLOCK_ENABLE		0x2000
+#define DSP_IDLE_MODE			0x2
+#define TC_IDLE_REQUEST			(0x0000000c)
+
+#define IRQ_LEVEL2			(1<<0)
+#define IRQ_KEYBOARD			(1<<1)
+#define IRQ_UART2			(1<<15)
+
+#define PDE_BIT				0x08
+#define PWD_EN_BIT			0x04
+#define EN_PERCK_BIT			0x04
+
+#define OMAP1510_DEEP_SLEEP_REQUEST	0x0ec7
+#define OMAP1510_BIG_SLEEP_REQUEST	0x0cc5
+#define OMAP1510_IDLE_LOOP_REQUEST	0x0c00
+#define OMAP1510_IDLE_CLOCK_DOMAINS	0x2
+
+/* Both big sleep and deep sleep use same values. Difference is in ULPD. */
+#define OMAP1610_IDLECT1_SLEEP_VAL	0x13c7
+#define OMAP1610_IDLECT2_SLEEP_VAL	0x09c7
+#define OMAP1610_IDLECT3_VAL		0x3f
+#define OMAP1610_IDLECT3_SLEEP_ORMASK	0x2c
+#define OMAP1610_IDLECT3		0xfffece24
+#define OMAP1610_IDLE_LOOP_REQUEST	0x0400
+
+#define OMAP730_IDLECT1_SLEEP_VAL	0x16c7
+#define OMAP730_IDLECT2_SLEEP_VAL	0x09c7
+#define OMAP730_IDLECT3_VAL		0x3f
+#define OMAP730_IDLECT3		0xfffece24
+#define OMAP730_IDLE_LOOP_REQUEST	0x0C00
+
+#if     !defined(CONFIG_ARCH_OMAP730) && \
+	!defined(CONFIG_ARCH_OMAP15XX) && \
+	!defined(CONFIG_ARCH_OMAP16XX) && \
+	!defined(CONFIG_ARCH_OMAP24XX)
+#error "Power management for this processor not implemented yet"
+#endif
+
+#ifndef __ASSEMBLER__
+
+#include <linux/clk.h>
+
+extern void prevent_idle_sleep(void);
+extern void allow_idle_sleep(void);
+
+/**
+ * clk_deny_idle - Prevents the clock from being idled during MPU idle
+ * @clk: clock signal handle
+ */
+void clk_deny_idle(struct clk *clk);
+
+/**
+ * clk_allow_idle - Counters previous clk_deny_idle
+ * @clk: clock signal handle
+ */
+void clk_deny_idle(struct clk *clk);
+
+extern void omap_pm_idle(void);
+extern void omap_pm_suspend(void);
+extern void omap730_cpu_suspend(unsigned short, unsigned short);
+extern void omap1510_cpu_suspend(unsigned short, unsigned short);
+extern void omap1610_cpu_suspend(unsigned short, unsigned short);
+extern void omap24xx_cpu_suspend(u32 dll_ctrl, u32 cpu_revision);
+extern void omap730_idle_loop_suspend(void);
+extern void omap1510_idle_loop_suspend(void);
+extern void omap1610_idle_loop_suspend(void);
+extern void omap24xx_idle_loop_suspend(void);
+
+extern unsigned int omap730_cpu_suspend_sz;
+extern unsigned int omap1510_cpu_suspend_sz;
+extern unsigned int omap1610_cpu_suspend_sz;
+extern unsigned int omap24xx_cpu_suspend_sz;
+extern unsigned int omap730_idle_loop_suspend_sz;
+extern unsigned int omap1510_idle_loop_suspend_sz;
+extern unsigned int omap1610_idle_loop_suspend_sz;
+extern unsigned int omap24xx_idle_loop_suspend_sz;
+
+#ifdef CONFIG_OMAP_SERIAL_WAKE
+extern void omap_serial_wake_trigger(int enable);
+#else
+#define omap_serial_wakeup_init()	{}
+#define omap_serial_wake_trigger(x)	{}
+#endif	/* CONFIG_OMAP_SERIAL_WAKE */
+
+#define ARM_SAVE(x) arm_sleep_save[ARM_SLEEP_SAVE_##x] = omap_readl(x)
+#define ARM_RESTORE(x) omap_writel((arm_sleep_save[ARM_SLEEP_SAVE_##x]), (x))
+#define ARM_SHOW(x) arm_sleep_save[ARM_SLEEP_SAVE_##x]
+
+#define DSP_SAVE(x) dsp_sleep_save[DSP_SLEEP_SAVE_##x] = __raw_readw(x)
+#define DSP_RESTORE(x) __raw_writew((dsp_sleep_save[DSP_SLEEP_SAVE_##x]), (x))
+#define DSP_SHOW(x) dsp_sleep_save[DSP_SLEEP_SAVE_##x]
+
+#define ULPD_SAVE(x) ulpd_sleep_save[ULPD_SLEEP_SAVE_##x] = omap_readw(x)
+#define ULPD_RESTORE(x) omap_writew((ulpd_sleep_save[ULPD_SLEEP_SAVE_##x]), (x))
+#define ULPD_SHOW(x) ulpd_sleep_save[ULPD_SLEEP_SAVE_##x]
+
+#define MPUI730_SAVE(x) mpui730_sleep_save[MPUI730_SLEEP_SAVE_##x] = omap_readl(x)
+#define MPUI730_RESTORE(x) omap_writel((mpui730_sleep_save[MPUI730_SLEEP_SAVE_##x]), (x))
+#define MPUI730_SHOW(x) mpui730_sleep_save[MPUI730_SLEEP_SAVE_##x]
+
+#define MPUI1510_SAVE(x) mpui1510_sleep_save[MPUI1510_SLEEP_SAVE_##x] = omap_readl(x)
+#define MPUI1510_RESTORE(x) omap_writel((mpui1510_sleep_save[MPUI1510_SLEEP_SAVE_##x]), (x))
+#define MPUI1510_SHOW(x) mpui1510_sleep_save[MPUI1510_SLEEP_SAVE_##x]
+
+#define MPUI1610_SAVE(x) mpui1610_sleep_save[MPUI1610_SLEEP_SAVE_##x] = omap_readl(x)
+#define MPUI1610_RESTORE(x) omap_writel((mpui1610_sleep_save[MPUI1610_SLEEP_SAVE_##x]), (x))
+#define MPUI1610_SHOW(x) mpui1610_sleep_save[MPUI1610_SLEEP_SAVE_##x]
+
+#define OMAP24XX_SAVE(x) omap24xx_sleep_save[OMAP24XX_SLEEP_SAVE_##x] = x
+#define OMAP24XX_RESTORE(x) x = omap24xx_sleep_save[OMAP24XX_SLEEP_SAVE_##x]
+#define OMAP24XX_SHOW(x) omap24xx_sleep_save[OMAP24XX_SLEEP_SAVE_##x]
+
+/*
+ * List of global OMAP registers to preserve.
+ * More ones like CP and general purpose register values are preserved
+ * with the stack pointer in sleep.S.
+ */
+
+enum arm_save_state {
+	ARM_SLEEP_SAVE_START = 0,
+	/*
+	 * MPU control registers 32 bits
+	 */
+	ARM_SLEEP_SAVE_ARM_CKCTL,
+	ARM_SLEEP_SAVE_ARM_IDLECT1,
+	ARM_SLEEP_SAVE_ARM_IDLECT2,
+	ARM_SLEEP_SAVE_ARM_IDLECT3,
+	ARM_SLEEP_SAVE_ARM_EWUPCT,
+	ARM_SLEEP_SAVE_ARM_RSTCT1,
+	ARM_SLEEP_SAVE_ARM_RSTCT2,
+	ARM_SLEEP_SAVE_ARM_SYSST,
+	ARM_SLEEP_SAVE_SIZE
+};
+
+enum dsp_save_state {
+	DSP_SLEEP_SAVE_START = 0,
+	/*
+	 * DSP registers 16 bits
+	 */
+	DSP_SLEEP_SAVE_DSP_IDLECT2,
+	DSP_SLEEP_SAVE_SIZE
+};
+
+enum ulpd_save_state {
+	ULPD_SLEEP_SAVE_START = 0,
+	/*
+	 * ULPD registers 16 bits
+	 */
+	ULPD_SLEEP_SAVE_ULPD_IT_STATUS,
+	ULPD_SLEEP_SAVE_ULPD_CLOCK_CTRL,
+	ULPD_SLEEP_SAVE_ULPD_SOFT_REQ,
+	ULPD_SLEEP_SAVE_ULPD_STATUS_REQ,
+	ULPD_SLEEP_SAVE_ULPD_DPLL_CTRL,
+	ULPD_SLEEP_SAVE_ULPD_POWER_CTRL,
+	ULPD_SLEEP_SAVE_SIZE
+};
+
+enum mpui1510_save_state {
+	MPUI1510_SLEEP_SAVE_START = 0,
+	/*
+	 * MPUI registers 32 bits
+	 */
+	MPUI1510_SLEEP_SAVE_MPUI_CTRL,
+	MPUI1510_SLEEP_SAVE_MPUI_DSP_BOOT_CONFIG,
+	MPUI1510_SLEEP_SAVE_MPUI_DSP_API_CONFIG,
+	MPUI1510_SLEEP_SAVE_MPUI_DSP_STATUS,
+	MPUI1510_SLEEP_SAVE_EMIFF_SDRAM_CONFIG,
+	MPUI1510_SLEEP_SAVE_EMIFS_CONFIG,
+	MPUI1510_SLEEP_SAVE_OMAP_IH1_MIR,
+	MPUI1510_SLEEP_SAVE_OMAP_IH2_MIR,
+#if defined(CONFIG_ARCH_OMAP15XX)
+	MPUI1510_SLEEP_SAVE_SIZE
+#else
+	MPUI1510_SLEEP_SAVE_SIZE = 0
+#endif
+};
+
+enum mpui730_save_state {
+	MPUI730_SLEEP_SAVE_START = 0,
+	/*
+	 * MPUI registers 32 bits
+	 */
+	MPUI730_SLEEP_SAVE_MPUI_CTRL,
+	MPUI730_SLEEP_SAVE_MPUI_DSP_BOOT_CONFIG,
+	MPUI730_SLEEP_SAVE_MPUI_DSP_API_CONFIG,
+	MPUI730_SLEEP_SAVE_MPUI_DSP_STATUS,
+	MPUI730_SLEEP_SAVE_EMIFF_SDRAM_CONFIG,
+	MPUI730_SLEEP_SAVE_EMIFS_CONFIG,
+	MPUI730_SLEEP_SAVE_OMAP_IH1_MIR,
+	MPUI730_SLEEP_SAVE_OMAP_IH2_0_MIR,
+	MPUI730_SLEEP_SAVE_OMAP_IH2_1_MIR,
+#if defined(CONFIG_ARCH_OMAP730)
+	MPUI730_SLEEP_SAVE_SIZE
+#else
+	MPUI730_SLEEP_SAVE_SIZE = 0
+#endif
+};
+
+enum mpui1610_save_state {
+	MPUI1610_SLEEP_SAVE_START = 0,
+	/*
+	 * MPUI registers 32 bits
+	 */
+	MPUI1610_SLEEP_SAVE_MPUI_CTRL,
+	MPUI1610_SLEEP_SAVE_MPUI_DSP_BOOT_CONFIG,
+	MPUI1610_SLEEP_SAVE_MPUI_DSP_API_CONFIG,
+	MPUI1610_SLEEP_SAVE_MPUI_DSP_STATUS,
+	MPUI1610_SLEEP_SAVE_EMIFF_SDRAM_CONFIG,
+	MPUI1610_SLEEP_SAVE_EMIFS_CONFIG,
+	MPUI1610_SLEEP_SAVE_OMAP_IH1_MIR,
+	MPUI1610_SLEEP_SAVE_OMAP_IH2_0_MIR,
+	MPUI1610_SLEEP_SAVE_OMAP_IH2_1_MIR,
+	MPUI1610_SLEEP_SAVE_OMAP_IH2_2_MIR,
+	MPUI1610_SLEEP_SAVE_OMAP_IH2_3_MIR,
+#if defined(CONFIG_ARCH_OMAP16XX)
+	MPUI1610_SLEEP_SAVE_SIZE
+#else
+	MPUI1610_SLEEP_SAVE_SIZE = 0
+#endif
+};
+
+enum omap24xx_save_state {
+	OMAP24XX_SLEEP_SAVE_START = 0,
+	OMAP24XX_SLEEP_SAVE_INTC_MIR0,
+	OMAP24XX_SLEEP_SAVE_INTC_MIR1,
+	OMAP24XX_SLEEP_SAVE_INTC_MIR2,
+
+	OMAP24XX_SLEEP_SAVE_CM_CLKSTCTRL_MPU,
+	OMAP24XX_SLEEP_SAVE_CM_CLKSTCTRL_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_CLKSTCTRL_GFX,
+	OMAP24XX_SLEEP_SAVE_CM_CLKSTCTRL_DSP,
+	OMAP24XX_SLEEP_SAVE_CM_CLKSTCTRL_MDM,
+
+	OMAP24XX_SLEEP_SAVE_PM_PWSTCTRL_MPU,
+	OMAP24XX_SLEEP_SAVE_PM_PWSTCTRL_CORE,
+	OMAP24XX_SLEEP_SAVE_PM_PWSTCTRL_GFX,
+	OMAP24XX_SLEEP_SAVE_PM_PWSTCTRL_DSP,
+	OMAP24XX_SLEEP_SAVE_PM_PWSTCTRL_MDM,
+
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST1_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST2_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST3_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST4_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST_GFX,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST_WKUP,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST_CKGEN,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST_DSP,
+	OMAP24XX_SLEEP_SAVE_CM_IDLEST_MDM,
+
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE1_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE2_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE3_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE4_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE_WKUP,
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE_PLL,
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE_DSP,
+	OMAP24XX_SLEEP_SAVE_CM_AUTOIDLE_MDM,
+
+	OMAP24XX_SLEEP_SAVE_CM_FCLKEN1_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_FCLKEN2_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_ICLKEN1_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_ICLKEN2_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_ICLKEN3_CORE,
+	OMAP24XX_SLEEP_SAVE_CM_ICLKEN4_CORE,
+	OMAP24XX_SLEEP_SAVE_GPIO1_IRQENABLE1,
+	OMAP24XX_SLEEP_SAVE_GPIO2_IRQENABLE1,
+	OMAP24XX_SLEEP_SAVE_GPIO3_IRQENABLE1,
+	OMAP24XX_SLEEP_SAVE_GPIO4_IRQENABLE1,
+	OMAP24XX_SLEEP_SAVE_GPIO3_OE,
+	OMAP24XX_SLEEP_SAVE_GPIO4_OE,
+	OMAP24XX_SLEEP_SAVE_GPIO3_RISINGDETECT,
+	OMAP24XX_SLEEP_SAVE_GPIO3_FALLINGDETECT,
+	OMAP24XX_SLEEP_SAVE_CONTROL_PADCONF_SPI1_NCS2,
+	OMAP24XX_SLEEP_SAVE_CONTROL_PADCONF_MCBSP1_DX,
+	OMAP24XX_SLEEP_SAVE_CONTROL_PADCONF_SSI1_FLAG_TX,
+	OMAP24XX_SLEEP_SAVE_CONTROL_PADCONF_SYS_NIRQW0,
+	OMAP24XX_SLEEP_SAVE_SIZE
+};
+
+#endif /* ASSEMBLER */
+#endif /* __ASM_ARCH_OMAP_PM_H */
Index: build_tree/linux/include/asm/arch-omap/prcm.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/prcm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/prcm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ * linux/include/asm-arm/arch-omap/prcm.h
+ *
+ * Access definations for use in OMAP24XX clock and power management
+ *
+ * Copyright (C) 2005 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARM_ARCH_DPM_PRCM_H
+#define __ASM_ARM_ARCH_DPM_PRCM_H
+
+u32 omap_prcm_get_reset_sources(void);
+
+#endif
+
+
+
+
+
Index: build_tree/linux/include/asm/arch-omap/serial.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/serial.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/serial.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ *  linux/include/asm-arm/arch-omap/serial.h
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#if defined(CONFIG_ARCH_OMAP1)
+/* OMAP1 serial ports */
+#define OMAP_UART1_BASE		0xfffb0000
+#define OMAP_UART2_BASE		0xfffb0800
+#define OMAP_UART3_BASE		0xfffb9800
+#elif defined(CONFIG_ARCH_OMAP2)
+/* OMAP2 serial ports */
+#define OMAP_UART1_BASE		0x4806a000
+#define OMAP_UART2_BASE		0x4806c000
+#define OMAP_UART3_BASE		0x4806e000
+#endif
+
+#define OMAP_MAX_NR_PORTS	3
+#define OMAP1510_BASE_BAUD	(12000000/16)
+#define OMAP16XX_BASE_BAUD	(48000000/16)
+
+#define is_omap_port(p)	({int __ret = 0;			\
+			if (p == IO_ADDRESS(OMAP_UART1_BASE) ||	\
+			    p == IO_ADDRESS(OMAP_UART2_BASE) ||	\
+			    p == IO_ADDRESS(OMAP_UART3_BASE))	\
+				__ret = 1;			\
+			__ret;					\
+			})
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/sram.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/sram.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/sram.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ * linux/include/asm-arm/arch-omap/sram.h
+ *
+ * Interface for functions that need to be run in internal SRAM
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ARCH_ARM_OMAP_SRAM_H
+#define __ARCH_ARM_OMAP_SRAM_H
+
+extern void * omap_sram_push(void * start, unsigned long size);
+extern void omap_sram_reprogram_clock(u32 dpllctl, u32 ckctl);
+
+extern void omap2_sram_ddr_init(u32 *slow_dll_ctrl, u32 fast_dll_ctrl,
+				u32 base_cs, u32 force_unlock);
+extern void omap2_sram_reprogram_sdrc(u32 perf_level, u32 dll_val,
+				      u32 mem_type);
+extern u32 omap2_set_prcm(u32 dpll_ctrl_val, u32 sdrc_rfr_val, int bypass);
+
+extern unsigned long omap_fb_sram_start;
+extern unsigned long omap_fb_sram_size;
+
+/* Do not use these */
+extern void sram_reprogram_clock(u32 ckctl, u32 dpllctl);
+extern unsigned long sram_reprogram_clock_sz;
+
+extern void sram_ddr_init(u32 *slow_dll_ctrl, u32 fast_dll_ctrl,
+			  u32 base_cs, u32 force_unlock);
+extern unsigned long sram_ddr_init_sz;
+
+extern u32 sram_set_prcm(u32 dpll_ctrl_val, u32 sdrc_rfr_val, int bypass);
+extern unsigned long sram_set_prcm_sz;
+
+extern void sram_reprogram_sdrc(u32 perf_level, u32 dll_val, u32 mem_type);
+extern unsigned long sram_reprogram_sdrc_sz;
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ * Copied from linux/include/asm-arm/arch-sa1100/system.h
+ * Copyright (c) 1999 Nicolas Pitre <nico@cam.org>
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+#include <linux/clk.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+
+#ifndef CONFIG_MACH_VOICEBLUE
+#define voiceblue_reset()		do {} while (0)
+#endif
+
+extern void omap_prcm_arch_reset(char mode);
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void omap1_arch_reset(char mode)
+{
+	/*
+	 * Workaround for 5912/1611b bug mentioned in sprz209d.pdf p. 28
+	 * "Global Software Reset Affects Traffic Controller Frequency".
+	 */
+	if (cpu_is_omap5912()) {
+		omap_writew(omap_readw(DPLL_CTL) & ~(1 << 4),
+				 DPLL_CTL);
+		omap_writew(0x8, ARM_RSTCT1);
+	}
+
+	if (machine_is_voiceblue())
+		voiceblue_reset();
+	else
+		omap_writew(1, ARM_RSTCT1);
+}
+
+static inline void arch_reset(char mode)
+{
+	if (!cpu_is_omap24xx())
+		omap1_arch_reset(mode);
+	else
+		omap_prcm_arch_reset(mode);
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-omap/tc.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/tc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/tc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,108 @@
+/*
+ * linux/include/asm-arm/arch-omap/tc.h
+ *
+ * OMAP Traffic Controller
+ *
+ * Copyright (C) 2004 Nokia Corporation
+ * Author: Imre Deak <imre.deak@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __ASM_ARCH_TC_H
+#define __ASM_ARCH_TC_H
+
+#define TCMIF_BASE		0xfffecc00
+#define OMAP_TC_OCPT1_PRIOR	(TCMIF_BASE + 0x00)
+#define OMAP_TC_EMIFS_PRIOR	(TCMIF_BASE + 0x04)
+#define OMAP_TC_EMIFF_PRIOR	(TCMIF_BASE + 0x08)
+#define EMIFS_CONFIG		(TCMIF_BASE + 0x0c)
+#define EMIFS_CS0_CONFIG	(TCMIF_BASE + 0x10)
+#define EMIFS_CS1_CONFIG	(TCMIF_BASE + 0x14)
+#define EMIFS_CS2_CONFIG	(TCMIF_BASE + 0x18)
+#define EMIFS_CS3_CONFIG	(TCMIF_BASE + 0x1c)
+#define EMIFF_SDRAM_CONFIG	(TCMIF_BASE + 0x20)
+#define EMIFF_MRS		(TCMIF_BASE + 0x24)
+#define TC_TIMEOUT1		(TCMIF_BASE + 0x28)
+#define TC_TIMEOUT2		(TCMIF_BASE + 0x2c)
+#define TC_TIMEOUT3		(TCMIF_BASE + 0x30)
+#define TC_ENDIANISM		(TCMIF_BASE + 0x34)
+#define EMIFF_SDRAM_CONFIG_2	(TCMIF_BASE + 0x3c)
+#define EMIF_CFG_DYNAMIC_WS	(TCMIF_BASE + 0x40)
+#define EMIFS_ACS0		(TCMIF_BASE + 0x50)
+#define EMIFS_ACS1		(TCMIF_BASE + 0x54)
+#define EMIFS_ACS2		(TCMIF_BASE + 0x58)
+#define EMIFS_ACS3		(TCMIF_BASE + 0x5c)
+#define OMAP_TC_OCPT2_PRIOR	(TCMIF_BASE + 0xd0)
+
+/* external EMIFS chipselect regions */
+#define	OMAP_CS0_PHYS		0x00000000
+#define	OMAP_CS0_SIZE		SZ_64M
+
+#define	OMAP_CS1_PHYS		0x04000000
+#define	OMAP_CS1_SIZE		SZ_64M
+
+#define	OMAP_CS1A_PHYS		OMAP_CS1_PHYS
+#define	OMAP_CS1A_SIZE		SZ_32M
+
+#define	OMAP_CS1B_PHYS		(OMAP_CS1A_PHYS + OMAP_CS1A_SIZE)
+#define	OMAP_CS1B_SIZE		SZ_32M
+
+#define	OMAP_CS2_PHYS		0x08000000
+#define	OMAP_CS2_SIZE		SZ_64M
+
+#define	OMAP_CS2A_PHYS		OMAP_CS2_PHYS
+#define	OMAP_CS2A_SIZE		SZ_32M
+
+#define	OMAP_CS2B_PHYS		(OMAP_CS2A_PHYS + OMAP_CS2A_SIZE)
+#define	OMAP_CS2B_SIZE		SZ_32M
+
+#define	OMAP_CS3_PHYS		0x0c000000
+#define	OMAP_CS3_SIZE		SZ_64M
+
+#ifndef	__ASSEMBLER__
+
+/* EMIF Slow Interface Configuration Register */
+#define	OMAP_EMIFS_CONFIG_REG	__REG32(EMIFS_CONFIG)
+
+#define OMAP_EMIFS_CONFIG_FR		(1 << 4)
+#define OMAP_EMIFS_CONFIG_PDE		(1 << 3)
+#define OMAP_EMIFS_CONFIG_PWD_EN	(1 << 2)
+#define OMAP_EMIFS_CONFIG_BM		(1 << 1)
+#define OMAP_EMIFS_CONFIG_WP		(1 << 0)
+
+#define EMIFS_CCS(n)		__REG32(EMIFS_CS0_CONFIG + (4 * (n)))
+#define EMIFS_ACS(n)		__REG32(EMIFS_ACS0 + (4 * (n)))
+
+/* Almost all documentation for chip and board memory maps assumes
+ * BM is clear.  Most devel boards have a switch to control booting
+ * from NOR flash (using external chipselect 3) rather than mask ROM,
+ * which uses BM to interchange the physical CS0 and CS3 addresses.
+ */
+static inline u32 omap_cs0_phys(void)
+{
+	return (OMAP_EMIFS_CONFIG_REG & OMAP_EMIFS_CONFIG_BM)
+			?  OMAP_CS3_PHYS : 0;
+}
+
+static inline u32 omap_cs3_phys(void)
+{
+	return (OMAP_EMIFS_CONFIG_REG & OMAP_EMIFS_CONFIG_BM)
+			? 0 : OMAP_CS3_PHYS;
+}
+
+#endif	/* __ASSEMBLER__ */
+
+#endif	/* __ASM_ARCH_TC_H */
Index: build_tree/linux/include/asm/arch-omap/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/*
+ * linux/include/asm-arm/arch-omap/timex.h
+ *
+ * Copyright (C) 2000 RidgeRun, Inc.
+ * Author:  Greg Lonnon <glonnon@ridgerun.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#if !defined(__ASM_ARCH_OMAP_TIMEX_H)
+#define __ASM_ARCH_OMAP_TIMEX_H
+
+/*
+ * OMAP 32KHz timer updates time one jiffie at a time from a secondary timer,
+ * and that's why the CLOCK_TICK_RATE is not 32768.
+ */
+#ifdef CONFIG_OMAP_32K_TIMER
+#define CLOCK_TICK_RATE		(CONFIG_OMAP_32K_TIMER_HZ)
+#else
+#define CLOCK_TICK_RATE		(HZ * 100000UL)
+#endif
+
+#endif /* __ASM_ARCH_OMAP_TIMEX_H */
Index: build_tree/linux/include/asm/arch-omap/tps65010.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/tps65010.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/tps65010.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,156 @@
+/* linux/include/asm-arm/arch-omap/tps65010.h
+ *
+ * Functions to access TPS65010 power management device.
+ *
+ * Copyright (C) 2004 Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_TPS65010_H
+#define __ASM_ARCH_TPS65010_H
+
+/*
+ * ----------------------------------------------------------------------------
+ * Registers, all 8 bits
+ * ----------------------------------------------------------------------------
+ */
+
+#define	TPS_CHGSTATUS		0x01
+#	define	TPS_CHG_USB		(1 << 7)
+#	define	TPS_CHG_AC		(1 << 6)
+#	define	TPS_CHG_THERM		(1 << 5)
+#	define	TPS_CHG_TERM		(1 << 4)
+#	define	TPS_CHG_TAPER_TMO	(1 << 3)
+#	define	TPS_CHG_CHG_TMO		(1 << 2)
+#	define	TPS_CHG_PRECHG_TMO	(1 << 1)
+#	define	TPS_CHG_TEMP_ERR	(1 << 0)
+#define	TPS_REGSTATUS		0x02
+#	define	TPS_REG_ONOFF		(1 << 7)
+#	define	TPS_REG_COVER		(1 << 6)
+#	define	TPS_REG_UVLO		(1 << 5)
+#	define	TPS_REG_NO_CHG		(1 << 4)	/* tps65013 */
+#	define	TPS_REG_PG_LD02		(1 << 3)
+#	define	TPS_REG_PG_LD01		(1 << 2)
+#	define	TPS_REG_PG_MAIN		(1 << 1)
+#	define	TPS_REG_PG_CORE		(1 << 0)
+#define	TPS_MASK1		0x03
+#define	TPS_MASK2		0x04
+#define	TPS_ACKINT1		0x05
+#define	TPS_ACKINT2		0x06
+#define	TPS_CHGCONFIG		0x07
+#	define	TPS_CHARGE_POR		(1 << 7)	/* 65010/65012 */
+#	define	TPS65013_AUA		(1 << 7)	/* 65011/65013 */
+#	define	TPS_CHARGE_RESET	(1 << 6)
+#	define	TPS_CHARGE_FAST		(1 << 5)
+#	define	TPS_CHARGE_CURRENT	(3 << 3)
+#	define	TPS_VBUS_500MA		(1 << 2)
+#	define	TPS_VBUS_CHARGING	(1 << 1)
+#	define	TPS_CHARGE_ENABLE	(1 << 0)
+#define	TPS_LED1_ON		0x08
+#define	TPS_LED1_PER		0x09
+#define	TPS_LED2_ON		0x0a
+#define	TPS_LED2_PER		0x0b
+#define	TPS_VDCDC1		0x0c
+#	define	TPS_ENABLE_LP		(1 << 3)
+#define	TPS_VDCDC2		0x0d
+#define	TPS_VREGS1		0x0e
+#	define	TPS_LDO2_ENABLE	(1 << 7)
+#	define	TPS_LDO2_OFF	(1 << 6)
+#	define	TPS_VLDO2_3_0V	(3 << 4)
+#	define	TPS_VLDO2_2_75V	(2 << 4)
+#	define	TPS_VLDO2_2_5V	(1 << 4)
+#	define	TPS_VLDO2_1_8V	(0 << 4)
+#	define	TPS_LDO1_ENABLE	(1 << 3)
+#	define	TPS_LDO1_OFF	(1 << 2)
+#	define	TPS_VLDO1_3_0V	(3 << 0)
+#	define	TPS_VLDO1_2_75V	(2 << 0)
+#	define	TPS_VLDO1_2_5V	(1 << 0)
+#	define	TPS_VLDO1_ADJ	(0 << 0)
+#define	TPS_MASK3		0x0f
+#define	TPS_DEFGPIO		0x10
+
+/*
+ * ----------------------------------------------------------------------------
+ * Macros used by exported functions
+ * ----------------------------------------------------------------------------
+ */
+
+#define LED1  1
+#define LED2  2
+#define OFF   0
+#define ON    1
+#define BLINK 2
+#define GPIO1 1
+#define GPIO2 2
+#define GPIO3 3
+#define GPIO4 4
+#define LOW   0
+#define HIGH  1
+
+/*
+ * ----------------------------------------------------------------------------
+ * Exported functions
+ * ----------------------------------------------------------------------------
+ */
+
+/* Draw from VBUS:
+ *   0 mA -- DON'T DRAW (might supply power instead)
+ * 100 mA -- usb unit load (slowest charge rate)
+ * 500 mA -- usb high power (fast battery charge)
+ */
+extern int tps65010_set_vbus_draw(unsigned mA);
+
+/* tps65010_set_gpio_out_value parameter:
+ * gpio:  GPIO1, GPIO2, GPIO3 or GPIO4
+ * value: LOW or HIGH
+ */
+extern int tps65010_set_gpio_out_value(unsigned gpio, unsigned value);
+
+/* tps65010_set_led parameter:
+ * led:  LED1 or LED2
+ * mode: ON, OFF or BLINK
+ */
+extern int tps65010_set_led(unsigned led, unsigned mode);
+
+/* tps65010_set_vib parameter:
+ * value: ON or OFF
+ */
+extern int tps65010_set_vib(unsigned value);
+
+/* tps65010_set_low_pwr parameter:
+ * mode: ON or OFF
+ */
+extern int tps65010_set_low_pwr(unsigned mode);
+
+/* tps65010_config_vregs1 parameter:
+ * value to be written to VREGS1 register
+ * Note: The complete register is written, set all bits you need
+ */
+extern int tps65010_config_vregs1(unsigned value);
+
+/* tps65013_set_low_pwr parameter:
+ * mode: ON or OFF
+ */
+extern int tps65013_set_low_pwr(unsigned mode);
+
+#endif /*  __ASM_ARCH_TPS65010_H */
+
Index: build_tree/linux/include/asm/arch-omap/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,83 @@
+/*
+ * linux/include/asm-arm/arch-omap/uncompress.h
+ *
+ * Serial port stubs for kernel decompress status messages
+ *
+ * Initially based on:
+ * linux-2.4.15-rmk1-dsplinux1.6/include/asm-arm/arch-omap1510/uncompress.h
+ * Copyright (C) 2000 RidgeRun, Inc.
+ * Author: Greg Lonnon <glonnon@ridgerun.com>
+ *
+ * Rewritten by:
+ * Author: <source@mvista.com>
+ * 2004 (c) MontaVista Software, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/types.h>
+#include <linux/serial_reg.h>
+#include <asm/arch/serial.h>
+
+unsigned int system_rev;
+
+#define UART_OMAP_MDR1		0x08	/* mode definition register */
+#define OMAP_ID_730		0x355F
+#define ID_MASK			0x7fff
+#define check_port(base, shift) ((base[UART_OMAP_MDR1 << shift] & 7) == 0)
+#define omap_get_id() ((*(volatile unsigned int *)(0xfffed404)) >> 12) & ID_MASK
+
+static void putc(int c)
+{
+	volatile u8 * uart = 0;
+	int shift = 2;
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+	return;
+#endif
+
+#ifdef CONFIG_ARCH_OMAP
+#ifdef	CONFIG_OMAP_LL_DEBUG_UART3
+	uart = (volatile u8 *)(OMAP_UART3_BASE);
+#elif defined(CONFIG_OMAP_LL_DEBUG_UART2)
+	uart = (volatile u8 *)(OMAP_UART2_BASE);
+#else
+	uart = (volatile u8 *)(OMAP_UART1_BASE);
+#endif
+
+#ifdef CONFIG_ARCH_OMAP1
+	/* Determine which serial port to use */
+	do {
+		/* MMU is not on, so cpu_is_omapXXXX() won't work here */
+		unsigned int omap_id = omap_get_id();
+
+		if (omap_id == OMAP_ID_730)
+			shift = 0;
+
+		if (check_port(uart, shift))
+			break;
+		/* Silent boot if no serial ports are enabled. */
+		return;
+	} while (0);
+#endif /* CONFIG_ARCH_OMAP1 */
+#endif
+
+	/*
+	 * Now, xmit each character
+	 */
+	while (!(uart[UART_LSR << shift] & UART_LSR_THRE))
+		barrier();
+	uart[UART_TX << shift] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-omap/usb.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/usb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/usb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,117 @@
+// include/asm-arm/mach-omap/usb.h
+
+#ifndef	__ASM_ARCH_OMAP_USB_H
+#define	__ASM_ARCH_OMAP_USB_H
+
+#include <asm/arch/board.h>
+
+/*-------------------------------------------------------------------------*/
+
+#define OTG_BASE			0xfffb0400
+#define UDC_BASE			0xfffb4000
+#define OMAP_OHCI_BASE			0xfffba000
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * OTG and transceiver registers, for OMAPs starting with ARM926
+ */
+#define OTG_REG32(offset)		__REG32(OTG_BASE + (offset))
+#define OTG_REG16(offset)		__REG16(OTG_BASE + (offset))
+
+#define OTG_REV_REG			OTG_REG32(0x00)
+#define OTG_SYSCON_1_REG		OTG_REG32(0x04)
+#	define	 USB2_TRX_MODE(w)	(((w)>>24)&0x07)
+#	define	 USB1_TRX_MODE(w)	(((w)>>20)&0x07)
+#	define	 USB0_TRX_MODE(w)	(((w)>>16)&0x07)
+#	define	 OTG_IDLE_EN		(1 << 15)
+#	define	 HST_IDLE_EN		(1 << 14)
+#	define	 DEV_IDLE_EN		(1 << 13)
+#	define	 OTG_RESET_DONE		(1 << 2)
+#define OTG_SYSCON_2_REG		OTG_REG32(0x08)
+#	define	 OTG_EN			(1 << 31)
+#	define	 USBX_SYNCHRO		(1 << 30)
+#	define	 OTG_MST16		(1 << 29)
+#	define	 SRP_GPDATA		(1 << 28)
+#	define	 SRP_GPDVBUS		(1 << 27)
+#	define	 SRP_GPUVBUS(w)		(((w)>>24)&0x07)
+#	define	 A_WAIT_VRISE(w)	(((w)>>20)&0x07)
+#	define	 B_ASE_BRST(w)		(((w)>>16)&0x07)
+#	define	 SRP_DPW		(1 << 14)
+#	define	 SRP_DATA		(1 << 13)
+#	define	 SRP_VBUS		(1 << 12)
+#	define	 OTG_PADEN		(1 << 10)
+#	define	 HMC_PADEN		(1 << 9)
+#	define	 UHOST_EN		(1 << 8)
+#	define	 HMC_TLLSPEED		(1 << 7)
+#	define	 HMC_TLLATTACH		(1 << 6)
+#	define	 OTG_HMC(w)		(((w)>>0)&0x3f)
+#define OTG_CTRL_REG			OTG_REG32(0x0c)
+#	define	 OTG_USB2_EN		(1 << 29)
+#	define	 OTG_USB2_DP		(1 << 28)
+#	define	 OTG_USB2_DM		(1 << 27)
+#	define	 OTG_USB1_EN		(1 << 26)
+#	define	 OTG_USB1_DP		(1 << 25)
+#	define	 OTG_USB1_DM		(1 << 24)
+#	define	 OTG_USB0_EN		(1 << 23)
+#	define	 OTG_USB0_DP		(1 << 22)
+#	define	 OTG_USB0_DM		(1 << 21)
+#	define	 OTG_ASESSVLD		(1 << 20)
+#	define	 OTG_BSESSEND		(1 << 19)
+#	define	 OTG_BSESSVLD		(1 << 18)
+#	define	 OTG_VBUSVLD		(1 << 17)
+#	define	 OTG_ID			(1 << 16)
+#	define	 OTG_DRIVER_SEL		(1 << 15)
+#	define	 OTG_A_SETB_HNPEN	(1 << 12)
+#	define	 OTG_A_BUSREQ		(1 << 11)
+#	define	 OTG_B_HNPEN		(1 << 9)
+#	define	 OTG_B_BUSREQ		(1 << 8)
+#	define	 OTG_BUSDROP		(1 << 7)
+#	define	 OTG_PULLDOWN		(1 << 5)
+#	define	 OTG_PULLUP		(1 << 4)
+#	define	 OTG_DRV_VBUS		(1 << 3)
+#	define	 OTG_PD_VBUS		(1 << 2)
+#	define	 OTG_PU_VBUS		(1 << 1)
+#	define	 OTG_PU_ID		(1 << 0)
+#define OTG_IRQ_EN_REG			OTG_REG16(0x10)
+#	define	 DRIVER_SWITCH		(1 << 15)
+#	define	 A_VBUS_ERR		(1 << 13)
+#	define	 A_REQ_TMROUT		(1 << 12)
+#	define	 A_SRP_DETECT		(1 << 11)
+#	define	 B_HNP_FAIL		(1 << 10)
+#	define	 B_SRP_TMROUT		(1 << 9)
+#	define	 B_SRP_DONE		(1 << 8)
+#	define	 B_SRP_STARTED		(1 << 7)
+#	define	 OPRT_CHG		(1 << 0)
+#define OTG_IRQ_SRC_REG			OTG_REG16(0x14)
+	// same bits as in IRQ_EN
+#define OTG_OUTCTRL_REG			OTG_REG16(0x18)
+#	define	 OTGVPD			(1 << 14)
+#	define	 OTGVPU			(1 << 13)
+#	define	 OTGPUID		(1 << 12)
+#	define	 USB2VDR		(1 << 10)
+#	define	 USB2PDEN		(1 << 9)
+#	define	 USB2PUEN		(1 << 8)
+#	define	 USB1VDR		(1 << 6)
+#	define	 USB1PDEN		(1 << 5)
+#	define	 USB1PUEN		(1 << 4)
+#	define	 USB0VDR		(1 << 2)
+#	define	 USB0PDEN		(1 << 1)
+#	define	 USB0PUEN		(1 << 0)
+#define OTG_TEST_REG			OTG_REG16(0x20)
+#define OTG_VENDOR_CODE_REG		OTG_REG32(0xfc)
+
+/*-------------------------------------------------------------------------*/
+
+#define	USB_TRANSCEIVER_CTRL_REG	__REG32(0xfffe1000 + 0x0064)
+#	define	CONF_USB2_UNI_R		(1 << 8)
+#	define	CONF_USB1_UNI_R		(1 << 7)
+#	define	CONF_USB_PORT0_R(x)	(((x)>>4)&0x7)
+#	define	CONF_USB0_ISOLATE_R	(1 << 3)
+#	define	CONF_USB_PWRDN_DM_R	(1 << 2)
+#	define	CONF_USB_PWRDN_DP_R	(1 << 1)
+
+
+
+
+#endif	/* __ASM_ARCH_OMAP_USB_H */
Index: build_tree/linux/include/asm/arch-omap/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-omap/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-omap/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/arch-omap/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#define VMALLOC_END	  (PAGE_OFFSET + 0x10000000)
+
Index: build_tree/linux/include/asm/arch-pnx4008/clock.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/clock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/clock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,62 @@
+/*
+ * include/asm-arm/arch-pnx4008/clock.h
+ *
+ * Clock control driver for PNX4008 - header file
+ *
+ * Authors: Vitaly Wool, Dmitry Chigirev <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __PNX4008_CLOCK_H__
+#define __PNX4008_CLOCK_H__
+
+struct module;
+struct clk;
+
+#define PWRMAN_VA_BASE		IO_ADDRESS(PNX4008_PWRMAN_BASE)
+#define HCLKDIVCTRL_REG		(PWRMAN_VA_BASE + 0x40)
+#define PWRCTRL_REG		(PWRMAN_VA_BASE + 0x44)
+#define PLLCTRL_REG		(PWRMAN_VA_BASE + 0x48)
+#define OSC13CTRL_REG		(PWRMAN_VA_BASE + 0x4c)
+#define SYSCLKCTRL_REG		(PWRMAN_VA_BASE + 0x50)
+#define HCLKPLLCTRL_REG		(PWRMAN_VA_BASE + 0x58)
+#define USBCTRL_REG		(PWRMAN_VA_BASE + 0x64)
+#define SDRAMCLKCTRL_REG	(PWRMAN_VA_BASE + 0x68)
+#define MSCTRL_REG		(PWRMAN_VA_BASE + 0x80)
+#define BTCLKCTRL		(PWRMAN_VA_BASE + 0x84)
+#define DUMCLKCTRL_REG		(PWRMAN_VA_BASE + 0x90)
+#define I2CCLKCTRL_REG		(PWRMAN_VA_BASE + 0xac)
+#define KEYCLKCTRL_REG		(PWRMAN_VA_BASE + 0xb0)
+#define TSCLKCTRL_REG		(PWRMAN_VA_BASE + 0xb4)
+#define PWMCLKCTRL_REG		(PWRMAN_VA_BASE + 0xb8)
+#define TIMCLKCTRL_REG		(PWRMAN_VA_BASE + 0xbc)
+#define SPICTRL_REG		(PWRMAN_VA_BASE + 0xc4)
+#define FLASHCLKCTRL_REG	(PWRMAN_VA_BASE + 0xc8)
+#define UART3CLK_REG		(PWRMAN_VA_BASE + 0xd0)
+#define UARTCLKCTRL_REG		(PWRMAN_VA_BASE + 0xe4)
+#define DMACLKCTRL_REG		(PWRMAN_VA_BASE + 0xe8)
+#define AUTOCLK_CTRL		(PWRMAN_VA_BASE + 0xec)
+#define JPEGCLKCTRL_REG		(PWRMAN_VA_BASE + 0xfc)
+
+#define AUDIOCONFIG_VA_BASE	IO_ADDRESS(PNX4008_AUDIOCONFIG_BASE)
+#define DSPPLLCTRL_REG		(AUDIOCONFIG_VA_BASE + 0x60)
+#define DSPCLKCTRL_REG		(AUDIOCONFIG_VA_BASE + 0x64)
+#define AUDIOCLKCTRL_REG	(AUDIOCONFIG_VA_BASE + 0x68)
+#define AUDIOPLLCTRL_REG	(AUDIOCONFIG_VA_BASE + 0x6C)
+
+#define USB_OTG_CLKCTRL_REG	IO_ADDRESS(PNX4008_USB_CONFIG_BASE + 0xff4)
+
+#define VFP9CLKCTRL_REG		IO_ADDRESS(PNX4008_DEBUG_BASE)
+
+#define CLK_RATE_13MHZ 13000
+#define CLK_RATE_1MHZ 1000
+#define CLK_RATE_208MHZ 208000
+#define CLK_RATE_48MHZ 48000
+#define CLK_RATE_32KHZ 32
+
+#define PNX4008_UART_CLK CLK_RATE_13MHZ * 1000 /* in MHz */
+
+#endif
Index: build_tree/linux/include/asm/arch-pnx4008/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/* linux/include/asm-arm/arch-pnx4008/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		mov	\rx, #0x00090000
+		addeq	\rx, \rx, #0x40000000
+		addne	\rx, \rx, #0xf4000000
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-pnx4008/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,162 @@
+/*
+ *  linux/include/asm-arm/arch-pnx4008/dma.h
+ *
+ *  PNX4008 DMA header file
+ *
+ *  Author:	Vitaly Wool
+ *  Copyright:	MontaVista Software Inc. (c) 2005
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include "platform.h"
+
+#define MAX_DMA_ADDRESS		0xffffffff
+
+#define MAX_DMA_CHANNELS	8
+
+#define DMAC_BASE		IO_ADDRESS(PNX4008_DMA_CONFIG_BASE)
+#define DMAC_INT_STAT		(DMAC_BASE + 0x0000)
+#define DMAC_INT_TC_STAT	(DMAC_BASE + 0x0004)
+#define DMAC_INT_TC_CLEAR	(DMAC_BASE + 0x0008)
+#define DMAC_INT_ERR_STAT	(DMAC_BASE + 0x000c)
+#define DMAC_INT_ERR_CLEAR	(DMAC_BASE + 0x0010)
+#define DMAC_SOFT_SREQ		(DMAC_BASE + 0x0024)
+#define DMAC_CONFIG		(DMAC_BASE + 0x0030)
+#define DMAC_Cx_SRC_ADDR(c)	(DMAC_BASE + 0x0100 + (c) * 0x20)
+#define DMAC_Cx_DEST_ADDR(c)	(DMAC_BASE + 0x0104 + (c) * 0x20)
+#define DMAC_Cx_LLI(c)		(DMAC_BASE + 0x0108 + (c) * 0x20)
+#define DMAC_Cx_CONTROL(c)	(DMAC_BASE + 0x010c + (c) * 0x20)
+#define DMAC_Cx_CONFIG(c)	(DMAC_BASE + 0x0110 + (c) * 0x20)
+
+enum {
+	WIDTH_BYTE = 0,
+	WIDTH_HWORD,
+	WIDTH_WORD
+};
+
+enum {
+	FC_MEM2MEM_DMA,
+	FC_MEM2PER_DMA,
+	FC_PER2MEM_DMA,
+	FC_PER2PER_DMA,
+	FC_PER2PER_DPER,
+	FC_MEM2PER_PER,
+	FC_PER2MEM_PER,
+	FC_PER2PER_SPER
+};
+
+enum {
+	DMA_INT_UNKNOWN = 0,
+	DMA_ERR_INT = 1,
+	DMA_TC_INT = 2,
+};
+
+enum {
+	DMA_BUFFER_ALLOCATED = 1,
+	DMA_HAS_LL = 2,
+};
+
+enum {
+	PER_CAM_DMA_1 = 0,
+	PER_NDF_FLASH = 1,
+	PER_MBX_SLAVE_FIFO = 2,
+	PER_SPI2_REC_XMIT = 3,
+	PER_MS_SD_RX_XMIT = 4,
+	PER_HS_UART_1_XMIT = 5,
+	PER_HS_UART_1_RX = 6,
+	PER_HS_UART_2_XMIT = 7,
+	PER_HS_UART_2_RX = 8,
+	PER_HS_UART_7_XMIT = 9,
+	PER_HS_UART_7_RX = 10,
+	PER_SPI1_REC_XMIT = 11,
+	PER_MLC_NDF_SREC = 12,
+	PER_CAM_DMA_2 = 13,
+	PER_PRNG_INFIFO = 14,
+	PER_PRNG_OUTFIFO = 15,
+};
+
+struct pnx4008_dma_ch_ctrl {
+	int tc_mask;
+	int cacheable;
+	int bufferable;
+	int priv_mode;
+	int di;
+	int si;
+	int dest_ahb1;
+	int src_ahb1;
+	int dwidth;
+	int swidth;
+	int dbsize;
+	int sbsize;
+	int tr_size;
+};
+
+struct pnx4008_dma_ch_config {
+	int halt;
+	int active;
+	int lock;
+	int itc;
+	int ie;
+	int flow_cntrl;
+	int dest_per;
+	int src_per;
+};
+
+struct pnx4008_dma_ll {
+	unsigned long src_addr;
+	unsigned long dest_addr;
+	u32 next_dma;
+	unsigned long ch_ctrl;
+	struct pnx4008_dma_ll *next;
+	int flags;
+	void *alloc_data;
+	int (*free) (void *);
+};
+
+struct pnx4008_dma_config {
+	int is_ll;
+	unsigned long src_addr;
+	unsigned long dest_addr;
+	unsigned long ch_ctrl;
+	unsigned long ch_cfg;
+	struct pnx4008_dma_ll *ll;
+	u32 ll_dma;
+	int flags;
+	void *alloc_data;
+	int (*free) (void *);
+};
+
+extern struct pnx4008_dma_ll *pnx4008_alloc_ll_entry(dma_addr_t *);
+extern void pnx4008_free_ll_entry(struct pnx4008_dma_ll *, dma_addr_t);
+extern void pnx4008_free_ll(u32 ll_dma, struct pnx4008_dma_ll *);
+
+extern int pnx4008_request_channel(char *, int,
+				   void (*)(int, int, void *),
+				   void *);
+extern void pnx4008_free_channel(int);
+extern int pnx4008_config_dma(int, int, int);
+extern int pnx4008_dma_pack_control(const struct pnx4008_dma_ch_ctrl *,
+				    unsigned long *);
+extern int pnx4008_dma_parse_control(unsigned long,
+				     struct pnx4008_dma_ch_ctrl *);
+extern int pnx4008_dma_pack_config(const struct pnx4008_dma_ch_config *,
+				   unsigned long *);
+extern int pnx4008_dma_parse_config(unsigned long,
+				    struct pnx4008_dma_ch_config *);
+extern int pnx4008_config_channel(int, struct pnx4008_dma_config *);
+extern int pnx4008_channel_get_config(int, struct pnx4008_dma_config *);
+extern int pnx4008_dma_ch_enable(int);
+extern int pnx4008_dma_ch_disable(int);
+extern int pnx4008_dma_ch_enabled(int);
+extern void pnx4008_dma_split_head_entry(struct pnx4008_dma_config *,
+					 struct pnx4008_dma_ch_ctrl *);
+extern void pnx4008_dma_split_ll_entry(struct pnx4008_dma_ll *,
+				       struct pnx4008_dma_ch_ctrl *);
+
+#endif				/* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-pnx4008/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,127 @@
+/*
+ * include/asm-arm/arch-pnx4008/entry-macro.S
+ *
+ * Low-level IRQ helper macros for PNX4008-based platforms
+ *
+ * 2005-2006 (c) MontaVista Software, Inc.
+ * Author: Vitaly Wool <vwool@ru.mvista.com>
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include "platform.h"
+
+#define IO_BASE         0xF0000000
+#define IO_ADDRESS(x)  (((((x) & 0xff000000) >> 4) | ((x) & 0xfffff)) | IO_BASE)
+
+#define INTRC_MASK			0x00
+#define INTRC_RAW_STAT			0x04
+#define INTRC_STAT			0x08
+#define INTRC_POLAR			0x0C
+#define INTRC_ACT_TYPE			0x10
+#define INTRC_TYPE			0x14
+
+#define SIC1_BASE_INT   32
+#define SIC2_BASE_INT   64
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+/* decode the MIC interrupt numbers */
+		ldr	\base, =IO_ADDRESS(PNX4008_INTCTRLMIC_BASE)
+		ldr	\irqstat, [\base, #INTRC_STAT]
+
+		cmp	\irqstat,#1<<16
+		movhs	\irqnr,#16
+		movlo	\irqnr,#0
+		movhs	\irqstat,\irqstat,lsr#16
+		cmp	\irqstat,#1<<8
+		addhs	\irqnr,\irqnr,#8
+		movhs	\irqstat,\irqstat,lsr#8
+		cmp	\irqstat,#1<<4
+		addhs	\irqnr,\irqnr,#4
+		movhs	\irqstat,\irqstat,lsr#4
+		cmp	\irqstat,#1<<2
+		addhs	\irqnr,\irqnr,#2
+		movhs	\irqstat,\irqstat,lsr#2
+		cmp	\irqstat,#1<<1
+		addhs	\irqnr,\irqnr,#1
+
+/* was there an interrupt ? if not then drop out with EQ status */
+		teq	\irqstat,#0
+		beq	1003f
+
+/* and now check for extended IRQ reasons */
+		cmp	\irqnr,#1
+		bls	1003f
+		cmp	\irqnr,#30
+		blo	1002f
+
+/* IRQ 31,30  : High priority cascade IRQ handle */
+/* read the correct SIC */
+/* decoding status after compare : eq is 30 (SIC1) , ne is 31 (SIC2) */
+/* set the base IRQ number */
+		ldreq	\base, =IO_ADDRESS(PNX4008_INTCTRLSIC1_BASE)
+		moveq  \irqnr,#SIC1_BASE_INT
+		ldrne	\base, =IO_ADDRESS(PNX4008_INTCTRLSIC2_BASE)
+		movne   \irqnr,#SIC2_BASE_INT
+		ldr	\irqstat, [\base, #INTRC_STAT]
+		ldr	\tmp,	  [\base, #INTRC_TYPE]
+/* and with inverted mask : low priority interrupts  */
+		and	\irqstat,\irqstat,\tmp
+		b	1004f
+
+1003:
+/* IRQ 1,0  : Low priority cascade IRQ handle */
+/* read the correct SIC */
+/* decoding status after compare : eq is 1 (SIC2) , ne is 0 (SIC1)*/
+/* read the correct SIC */
+/* set the base IRQ number  */
+		ldrne	\base, =IO_ADDRESS(PNX4008_INTCTRLSIC1_BASE)
+		movne   \irqnr,#SIC1_BASE_INT
+		ldreq	\base, =IO_ADDRESS(PNX4008_INTCTRLSIC2_BASE)
+		moveq   \irqnr,#SIC2_BASE_INT
+		ldr	\irqstat, [\base, #INTRC_STAT]
+		ldr	\tmp,	  [\base, #INTRC_TYPE]
+/* and with inverted mask : low priority interrupts  */
+		bic	\irqstat,\irqstat,\tmp
+
+1004:
+
+		cmp	\irqstat,#1<<16
+		addhs	\irqnr,\irqnr,#16
+		movhs	\irqstat,\irqstat,lsr#16
+		cmp	\irqstat,#1<<8
+		addhs	\irqnr,\irqnr,#8
+		movhs	\irqstat,\irqstat,lsr#8
+		cmp	\irqstat,#1<<4
+		addhs	\irqnr,\irqnr,#4
+		movhs	\irqstat,\irqstat,lsr#4
+		cmp	\irqstat,#1<<2
+		addhs	\irqnr,\irqnr,#2
+		movhs	\irqstat,\irqstat,lsr#2
+		cmp	\irqstat,#1<<1
+		addhs	\irqnr,\irqnr,#1
+
+
+/* is irqstat not zero */
+
+1002:
+/* we assert that irqstat is not equal to zero and return ne status if true*/
+		teq	\irqstat,#0
+1003:
+		.endm
+
+
+		.macro	irq_prio_table
+		.endm
+
+
Index: build_tree/linux/include/asm/arch-pnx4008/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,241 @@
+/*
+ * include/asm-arm/arch-pnx4008/gpio.h
+ *
+ * PNX4008 GPIO driver - header file
+ *
+ * Author: Dmitry Chigirev <source@mvista.com>
+ *
+ * Based on reference code by Iwo Mergler and Z.Tabaaloute from Philips:
+ * Copyright (c) 2005 Koninklijke Philips Electronics N.V.
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef _PNX4008_GPIO_H_
+#define _PNX4008_GPIO_H_
+
+
+/* Block numbers */
+#define GPIO_IN		(0)
+#define GPIO_OUT		(0x100)
+#define GPIO_BID		(0x200)
+#define GPIO_RAM		(0x300)
+#define GPIO_MUX		(0x400)
+
+#define GPIO_TYPE_MASK(K) ((K) & 0x700)
+
+/* INPUT GPIOs */
+/* GPI */
+#define GPI_00		(GPIO_IN | 0)
+#define GPI_01		(GPIO_IN | 1)
+#define GPI_02   	(GPIO_IN | 2)
+#define GPI_03 	 	(GPIO_IN | 3)
+#define GPI_04   	(GPIO_IN | 4)
+#define GPI_05   	(GPIO_IN | 5)
+#define GPI_06   	(GPIO_IN | 6)
+#define GPI_07   	(GPIO_IN | 7)
+#define GPI_08   	(GPIO_IN | 8)
+#define GPI_09   	(GPIO_IN | 9)
+#define U1_RX 		(GPIO_IN | 15)
+#define U2_HTCS 	(GPIO_IN | 16)
+#define U2_RX	 	(GPIO_IN | 17)
+#define U3_RX		(GPIO_IN | 18)
+#define U4_RX		(GPIO_IN | 19)
+#define U5_RX		(GPIO_IN | 20)
+#define U6_IRRX 	(GPIO_IN | 21)
+#define U7_HCTS 	(GPIO_IN | 22)
+#define U7_RX		(GPIO_IN | 23)
+/* MISC IN */
+#define SPI1_DATIN	(GPIO_IN | 25)
+#define DISP_SYNC	(GPIO_IN | 26)
+#define SPI2_DATIN	(GPIO_IN | 27)
+#define GPI_11  	(GPIO_IN | 28)
+
+#define GPIO_IN_MASK   0x1eff83ff
+
+/* OUTPUT GPIOs */
+/* GPO */
+#define GPO_00		(GPIO_OUT | 0)
+#define GPO_01   	(GPIO_OUT | 1)
+#define GPO_02   	(GPIO_OUT | 2)
+#define GPO_03 	 	(GPIO_OUT | 3)
+#define GPO_04   	(GPIO_OUT | 4)
+#define GPO_05   	(GPIO_OUT | 5)
+#define GPO_06   	(GPIO_OUT | 6)
+#define GPO_07   	(GPIO_OUT | 7)
+#define GPO_08		(GPIO_OUT | 8)
+#define GPO_09   	(GPIO_OUT | 9)
+#define GPO_10   	(GPIO_OUT | 10)
+#define GPO_11 	 	(GPIO_OUT | 11)
+#define GPO_12   	(GPIO_OUT | 12)
+#define GPO_13   	(GPIO_OUT | 13)
+#define GPO_14   	(GPIO_OUT | 14)
+#define GPO_15   	(GPIO_OUT | 15)
+#define GPO_16  	(GPIO_OUT | 16)
+#define GPO_17 	 	(GPIO_OUT | 17)
+#define GPO_18   	(GPIO_OUT | 18)
+#define GPO_19   	(GPIO_OUT | 19)
+#define GPO_20   	(GPIO_OUT | 20)
+#define GPO_21   	(GPIO_OUT | 21)
+#define GPO_22   	(GPIO_OUT | 22)
+#define GPO_23   	(GPIO_OUT | 23)
+
+#define GPIO_OUT_MASK   0xffffff
+
+/* BIDIRECTIONAL GPIOs */
+/* RAM pins */
+#define RAM_D19		(GPIO_RAM | 0)
+#define RAM_D20  	(GPIO_RAM | 1)
+#define RAM_D21  	(GPIO_RAM | 2)
+#define RAM_D22 	(GPIO_RAM | 3)
+#define RAM_D23  	(GPIO_RAM | 4)
+#define RAM_D24  	(GPIO_RAM | 5)
+#define RAM_D25  	(GPIO_RAM | 6)
+#define RAM_D26  	(GPIO_RAM | 7)
+#define RAM_D27		(GPIO_RAM | 8)
+#define RAM_D28  	(GPIO_RAM | 9)
+#define RAM_D29  	(GPIO_RAM | 10)
+#define RAM_D30 	(GPIO_RAM | 11)
+#define RAM_D31  	(GPIO_RAM | 12)
+
+#define GPIO_RAM_MASK   0x1fff
+
+/* I/O pins */
+#define GPIO_00  	(GPIO_BID | 25)
+#define GPIO_01 	(GPIO_BID | 26)
+#define GPIO_02  	(GPIO_BID | 27)
+#define GPIO_03  	(GPIO_BID | 28)
+#define GPIO_04 	(GPIO_BID | 29)
+#define GPIO_05  	(GPIO_BID | 30)
+
+#define GPIO_BID_MASK   0x7e000000
+
+/* Non-GPIO multiplexed PIOs. For multiplexing with GPIO, please use GPIO macros */
+#define GPIO_SDRAM_SEL 	(GPIO_MUX | 3)
+
+#define GPIO_MUX_MASK   0x8
+
+/* Extraction/assembly macros */
+#define GPIO_BIT_MASK(K) ((K) & 0x1F)
+#define GPIO_BIT(K) (1 << GPIO_BIT_MASK(K))
+#define GPIO_ISMUX(K) ((GPIO_TYPE_MASK(K) == GPIO_MUX) && (GPIO_BIT(K) & GPIO_MUX_MASK))
+#define GPIO_ISRAM(K) ((GPIO_TYPE_MASK(K) == GPIO_RAM) && (GPIO_BIT(K) & GPIO_RAM_MASK))
+#define GPIO_ISBID(K) ((GPIO_TYPE_MASK(K) == GPIO_BID) && (GPIO_BIT(K) & GPIO_BID_MASK))
+#define GPIO_ISOUT(K) ((GPIO_TYPE_MASK(K) == GPIO_OUT) && (GPIO_BIT(K) & GPIO_OUT_MASK))
+#define GPIO_ISIN(K)  ((GPIO_TYPE_MASK(K) == GPIO_IN) && (GPIO_BIT(K) & GPIO_IN_MASK))
+
+/* Start Enable Pin Interrupts - table 58 page 66 */
+
+#define SE_PIN_BASE_INT   32
+
+#define SE_U7_RX_INT            63
+#define SE_U7_HCTS_INT          62
+#define SE_BT_CLKREQ_INT        61
+#define SE_U6_IRRX_INT          60
+/*59 unused*/
+#define SE_U5_RX_INT            58
+#define SE_GPI_11_INT           57
+#define SE_U3_RX_INT            56
+#define SE_U2_HCTS_INT          55
+#define SE_U2_RX_INT            54
+#define SE_U1_RX_INT            53
+#define SE_DISP_SYNC_INT        52
+/*51 unused*/
+#define SE_SDIO_INT_N           50
+#define SE_MSDIO_START_INT      49
+#define SE_GPI_06_INT           48
+#define SE_GPI_05_INT           47
+#define SE_GPI_04_INT           46
+#define SE_GPI_03_INT           45
+#define SE_GPI_02_INT           44
+#define SE_GPI_01_INT           43
+#define SE_GPI_00_INT           42
+#define SE_SYSCLKEN_PIN_INT     41
+#define SE_SPI1_DATAIN_INT      40
+#define SE_GPI_07_INT           39
+#define SE_SPI2_DATAIN_INT      38
+#define SE_GPI_10_INT           37
+#define SE_GPI_09_INT           36
+#define SE_GPI_08_INT           35
+/*34-32 unused*/
+
+/* Start Enable Internal Interrupts - table 57 page 65 */
+
+#define SE_INT_BASE_INT   0
+
+#define SE_TS_IRQ               31
+#define SE_TS_P_INT             30
+#define SE_TS_AUX_INT           29
+/*27-28 unused*/
+#define SE_USB_AHB_NEED_CLK_INT 26
+#define SE_MSTIMER_INT          25
+#define SE_RTC_INT              24
+#define SE_USB_NEED_CLK_INT     23
+#define SE_USB_INT              22
+#define SE_USB_I2C_INT          21
+#define SE_USB_OTG_TIMER_INT    20
+#define SE_USB_OTG_ATX_INT_N    19
+/*18 unused*/
+#define SE_DSP_GPIO4_INT        17
+#define SE_KEY_IRQ              16
+#define SE_DSP_SLAVEPORT_INT    15
+#define SE_DSP_GPIO1_INT        14
+#define SE_DSP_GPIO0_INT        13
+#define SE_DSP_AHB_INT          12
+/*11-6 unused*/
+#define SE_GPIO_05_INT          5
+#define SE_GPIO_04_INT          4
+#define SE_GPIO_03_INT          3
+#define SE_GPIO_02_INT          2
+#define SE_GPIO_01_INT          1
+#define SE_GPIO_00_INT          0
+
+#define START_INT_REG_BIT(irq) (1<<((irq)&0x1F))
+
+#define START_INT_ER_REG(irq)     IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x20 + (((irq)&(0x1<<5))>>1)))
+#define START_INT_RSR_REG(irq)    IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x24 + (((irq)&(0x1<<5))>>1)))
+#define START_INT_SR_REG(irq)     IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x28 + (((irq)&(0x1<<5))>>1)))
+#define START_INT_APR_REG(irq)    IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x2C + (((irq)&(0x1<<5))>>1)))
+
+extern int pnx4008_gpio_register_pin(unsigned short pin);
+extern int pnx4008_gpio_unregister_pin(unsigned short pin);
+extern unsigned long pnx4008_gpio_read_pin(unsigned short pin);
+extern int pnx4008_gpio_write_pin(unsigned short pin, int output);
+extern int pnx4008_gpio_set_pin_direction(unsigned short pin, int output);
+extern int pnx4008_gpio_read_pin_direction(unsigned short pin);
+extern int pnx4008_gpio_set_pin_mux(unsigned short pin, int output);
+extern int pnx4008_gpio_read_pin_mux(unsigned short pin);
+
+static inline void start_int_umask(u8 irq)
+{
+	__raw_writel(__raw_readl(START_INT_ER_REG(irq)) |
+		     START_INT_REG_BIT(irq), START_INT_ER_REG(irq));
+}
+
+static inline void start_int_mask(u8 irq)
+{
+	__raw_writel(__raw_readl(START_INT_ER_REG(irq)) &
+		     ~START_INT_REG_BIT(irq), START_INT_ER_REG(irq));
+}
+
+static inline void start_int_ack(u8 irq)
+{
+	__raw_writel(START_INT_REG_BIT(irq), START_INT_RSR_REG(irq));
+}
+
+static inline void start_int_set_falling_edge(u8 irq)
+{
+	__raw_writel(__raw_readl(START_INT_APR_REG(irq)) &
+		     ~START_INT_REG_BIT(irq), START_INT_APR_REG(irq));
+}
+
+static inline void start_int_set_rising_edge(u8 irq)
+{
+	__raw_writel(__raw_readl(START_INT_APR_REG(irq)) |
+		     START_INT_REG_BIT(irq), START_INT_APR_REG(irq));
+}
+
+#endif				/* _PNX4008_GPIO_H_ */
Index: build_tree/linux/include/asm/arch-pnx4008/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * linux/include/asm-arm/arch-pnx4008/hardware.h
+ *
+ * Copyright (c) 2005 MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <asm/arch/platform.h>
+
+/* Start of virtual addresses for IO devices */
+#define IO_BASE         0xF0000000
+
+/* This macro relies on fact that for all HW i/o addresses bits 20-23 are 0 */
+#define IO_ADDRESS(x)  (((((x) & 0xff000000) >> 4) | ((x) & 0xfffff)) | IO_BASE)
+
+#endif
Index: build_tree/linux/include/asm/arch-pnx4008/i2c.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/i2c.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/i2c.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,67 @@
+/*
+ * PNX4008-specific tweaks for I2C IP3204 block
+ *
+ * Author: Vitaly Wool <vwool@ru.mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef __ASM_ARCH_I2C_H__
+#define __ASM_ARCH_I2C_H__
+
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+
+enum {
+	mstatus_tdi = 0x00000001,
+	mstatus_afi = 0x00000002,
+	mstatus_nai = 0x00000004,
+	mstatus_drmi = 0x00000008,
+	mstatus_active = 0x00000020,
+	mstatus_scl = 0x00000040,
+	mstatus_sda = 0x00000080,
+	mstatus_rff = 0x00000100,
+	mstatus_rfe = 0x00000200,
+	mstatus_tff = 0x00000400,
+	mstatus_tfe = 0x00000800,
+};
+
+enum {
+	mcntrl_tdie = 0x00000001,
+	mcntrl_afie = 0x00000002,
+	mcntrl_naie = 0x00000004,
+	mcntrl_drmie = 0x00000008,
+	mcntrl_daie = 0x00000020,
+	mcntrl_rffie = 0x00000040,
+	mcntrl_tffie = 0x00000080,
+	mcntrl_reset = 0x00000100,
+	mcntrl_cdbmode = 0x00000400,
+};
+
+enum {
+	rw_bit = 1 << 0,
+	start_bit = 1 << 8,
+	stop_bit = 1 << 9,
+};
+
+#define I2C_REG_RX(a)	((a)->ioaddr)		/* Rx FIFO reg (RO) */
+#define I2C_REG_TX(a)	((a)->ioaddr)		/* Tx FIFO reg (WO) */
+#define I2C_REG_STS(a)	((a)->ioaddr + 0x04)	/* Status reg (RO) */
+#define I2C_REG_CTL(a)	((a)->ioaddr + 0x08)	/* Ctl reg */
+#define I2C_REG_CKL(a)	((a)->ioaddr + 0x0c)	/* Clock divider low */
+#define I2C_REG_CKH(a)	((a)->ioaddr + 0x10)	/* Clock divider high */
+#define I2C_REG_ADR(a)	((a)->ioaddr + 0x14)	/* I2C address */
+#define I2C_REG_RFL(a)	((a)->ioaddr + 0x18)	/* Rx FIFO level (RO) */
+#define I2C_REG_TFL(a)	((a)->ioaddr + 0x1c)	/* Tx FIFO level (RO) */
+#define I2C_REG_RXB(a)	((a)->ioaddr + 0x20)	/* Num of bytes Rx-ed (RO) */
+#define I2C_REG_TXB(a)	((a)->ioaddr + 0x24)	/* Num of bytes Tx-ed (RO) */
+#define I2C_REG_TXS(a)	((a)->ioaddr + 0x28)	/* Tx slave FIFO (RO) */
+#define I2C_REG_STFL(a)	((a)->ioaddr + 0x2c)	/* Tx slave FIFO level (RO) */
+
+#define HCLK_MHZ		13
+#define I2C_CHIP_NAME		"PNX4008-I2C"
+
+#endif				/* __ASM_ARCH_I2C_H___ */
Index: build_tree/linux/include/asm/arch-pnx4008/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+
+/*
+ *  include/asm-arm/arch-pnx4008/io.h
+ *
+ * Author: Dmitry Chigirev <chigirev@ru.mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-pnx4008/irq.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/irq.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ * include/asm-arm/arch-pnx4008/irq.h
+ *
+ * PNX4008 IRQ controller driver - header file
+ * this one is used in entry-arnv.S as well so it cannot contain C code
+ *
+ * Copyright (c) 2005 Philips Semiconductors
+ * Copyright (c) 2005 MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+#ifndef __PNX4008_IRQ_H__
+#define __PNX4008_IRQ_H__
+
+#define MIC_VA_BASE             IO_ADDRESS(PNX4008_INTCTRLMIC_BASE)
+#define SIC1_VA_BASE            IO_ADDRESS(PNX4008_INTCTRLSIC1_BASE)
+#define SIC2_VA_BASE            IO_ADDRESS(PNX4008_INTCTRLSIC2_BASE)
+
+/* Manual: Chapter 20, page 195 */
+
+#define INTC_BIT(irq) (1<< ((irq) & 0x1F))
+
+#define INTC_ER(irq)    IO_ADDRESS((PNX4008_INTCTRLMIC_BASE + 0x0 + (((irq)&(0x3<<5))<<9)))
+#define INTC_RSR(irq)   IO_ADDRESS((PNX4008_INTCTRLMIC_BASE + 0x4 + (((irq)&(0x3<<5))<<9)))
+#define INTC_SR(irq)    IO_ADDRESS((PNX4008_INTCTRLMIC_BASE + 0x8 + (((irq)&(0x3<<5))<<9)))
+#define INTC_APR(irq)   IO_ADDRESS((PNX4008_INTCTRLMIC_BASE + 0xC + (((irq)&(0x3<<5))<<9)))
+#define INTC_ATR(irq)   IO_ADDRESS((PNX4008_INTCTRLMIC_BASE + 0x10 + (((irq)&(0x3<<5))<<9)))
+#define INTC_ITR(irq)   IO_ADDRESS((PNX4008_INTCTRLMIC_BASE + 0x14 + (((irq)&(0x3<<5))<<9)))
+
+#define START_INT_REG_BIT(irq) (1<<((irq)&0x1F))
+
+#define START_INT_ER_REG(irq)     IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x20 + (((irq)&(0x1<<5))>>1)))
+#define START_INT_RSR_REG(irq)    IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x24 + (((irq)&(0x1<<5))>>1)))
+#define START_INT_SR_REG(irq)     IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x28 + (((irq)&(0x1<<5))>>1)))
+#define START_INT_APR_REG(irq)    IO_ADDRESS((PNX4008_PWRMAN_BASE + 0x2C + (((irq)&(0x1<<5))>>1)))
+
+extern void __init pnx4008_init_irq(void);
+
+#endif /* __PNX4008_IRQ_H__ */
Index: build_tree/linux/include/asm/arch-pnx4008/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,215 @@
+/*
+ * include/asm-arm/arch-pnx4008/irqs.h
+ *
+ * PNX4008 IRQ controller driver - header file
+ *
+ * Author: Dmitry Chigirev <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __PNX4008_IRQS_h__
+#define __PNX4008_IRQS_h__
+
+#define NR_IRQS         96
+
+/*Manual: table 259, page 199*/
+
+/*SUB2 Interrupt Routing (SIC2)*/
+
+#define SIC2_BASE_INT   64
+
+#define CLK_SWITCH_ARM_INT 95	/*manual: Clkswitch ARM  */
+#define CLK_SWITCH_DSP_INT 94	/*manual: ClkSwitch DSP  */
+#define CLK_SWITCH_AUD_INT 93	/*manual: Clkswitch AUD  */
+#define GPI_06_INT         92
+#define GPI_05_INT         91
+#define GPI_04_INT         90
+#define GPI_03_INT         89
+#define GPI_02_INT         88
+#define GPI_01_INT         87
+#define GPI_00_INT         86
+#define BT_CLKREQ_INT      85
+#define SPI1_DATIN_INT     84
+#define U5_RX_INT          83
+#define SDIO_INT_N         82
+#define CAM_HS_INT         81
+#define CAM_VS_INT         80
+#define GPI_07_INT         79
+#define DISP_SYNC_INT      78
+#define DSP_INT8           77
+#define U7_HCTS_INT        76
+#define GPI_10_INT         75
+#define GPI_09_INT         74
+#define GPI_08_INT         73
+#define DSP_INT7           72
+#define U2_HCTS_INT        71
+#define SPI2_DATIN_INT     70
+#define GPIO_05_INT        69
+#define GPIO_04_INT        68
+#define GPIO_03_INT        67
+#define GPIO_02_INT        66
+#define GPIO_01_INT        65
+#define GPIO_00_INT        64
+
+/*Manual: table 258, page 198*/
+
+/*SUB1 Interrupt Routing (SIC1)*/
+
+#define SIC1_BASE_INT   32
+
+#define USB_I2C_INT        63
+#define USB_DEV_HP_INT     62
+#define USB_DEV_LP_INT     61
+#define USB_DEV_DMA_INT    60
+#define USB_HOST_INT       59
+#define USB_OTG_ATX_INT_N  58
+#define USB_OTG_TIMER_INT  57
+#define SW_INT             56
+#define SPI1_INT           55
+#define KEY_IRQ            54
+#define DSP_M_INT          53
+#define RTC_INT            52
+#define I2C_1_INT          51
+#define I2C_2_INT          50
+#define PLL1_LOCK_INT      49
+#define PLL2_LOCK_INT      48
+#define PLL3_LOCK_INT      47
+#define PLL4_LOCK_INT      46
+#define PLL5_LOCK_INT      45
+#define SPI2_INT           44
+#define DSP_INT1           43
+#define DSP_INT2           42
+#define DSP_TDM_INT2       41
+#define TS_AUX_INT         40
+#define TS_IRQ             39
+#define TS_P_INT           38
+#define UOUT1_TO_PAD_INT   37
+#define GPI_11_INT         36
+#define DSP_INT4           35
+#define JTAG_COMM_RX_INT   34
+#define JTAG_COMM_TX_INT   33
+#define DSP_INT3           32
+
+/*Manual: table 257, page 197*/
+
+/*MAIN Interrupt Routing*/
+
+#define MAIN_BASE_INT   0
+
+#define SUB2_FIQ_N         31	/*active low */
+#define SUB1_FIQ_N         30	/*active low */
+#define JPEG_INT           29
+#define DMA_INT            28
+#define MSTIMER_INT        27
+#define IIR1_INT           26
+#define IIR2_INT           25
+#define IIR7_INT           24
+#define DSP_TDM_INT0       23
+#define DSP_TDM_INT1       22
+#define DSP_P_INT          21
+#define DSP_INT0           20
+#define DUM_INT            19
+#define UOUT0_TO_PAD_INT   18
+#define MP4_ENC_INT        17
+#define MP4_DEC_INT        16
+#define SD0_INT            15
+#define MBX_INT            14
+#define SD1_INT            13
+#define MS_INT_N           12
+#define FLASH_INT          11 /*NAND*/
+#define IIR6_INT           10
+#define IIR5_INT           9
+#define IIR4_INT           8
+#define IIR3_INT           7
+#define WATCH_INT          6
+#define HSTIMER_INT        5
+#define ARCH_TIMER_IRQ     HSTIMER_INT
+#define CAM_INT            4
+#define PRNG_INT           3
+#define CRYPTO_INT         2
+#define SUB2_IRQ_N         1	/*active low */
+#define SUB1_IRQ_N         0	/*active low */
+
+#define PNX4008_IRQ_TYPES \
+{                                           /*IRQ #'s: */         \
+IRQT_LOW,  IRQT_LOW,  IRQT_LOW,  IRQT_HIGH, /*  0, 1, 2, 3 */     \
+IRQT_LOW,  IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /*  4, 5, 6, 7 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /*  8, 9,10,11 */     \
+IRQT_LOW,  IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 12,13,14,15 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 16,17,18,19 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 20,21,22,23 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 24,25,26,27 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_LOW,  IRQT_LOW,  /* 28,29,30,31 */     \
+IRQT_HIGH, IRQT_LOW,  IRQT_HIGH, IRQT_HIGH, /* 32,33,34,35 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_FALLING, IRQT_HIGH, /* 36,37,38,39 */  \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 40,41,42,43 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 44,45,46,47 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_LOW,  IRQT_LOW,  /* 48,49,50,51 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 52,53,54,55 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_LOW,  IRQT_HIGH, /* 56,57,58,59 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 60,61,62,63 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 64,65,66,67 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 68,69,70,71 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 72,73,74,75 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 76,77,78,79 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 80,81,82,83 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 84,85,86,87 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 88,89,90,91 */     \
+IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, IRQT_HIGH, /* 92,93,94,95 */     \
+}
+
+/* Start Enable Pin Interrupts - table 58 page 66 */
+
+#define SE_PIN_BASE_INT   32
+
+#define SE_U7_RX_INT            63
+#define SE_U7_HCTS_INT          62
+#define SE_BT_CLKREQ_INT        61
+#define SE_U6_IRRX_INT          60
+/*59 unused*/
+#define SE_U5_RX_INT            58
+#define SE_GPI_11_INT           57
+#define SE_U3_RX_INT            56
+#define SE_U2_HCTS_INT          55
+#define SE_U2_RX_INT            54
+#define SE_U1_RX_INT            53
+#define SE_DISP_SYNC_INT        52
+/*51 unused*/
+#define SE_SDIO_INT_N           50
+#define SE_MSDIO_START_INT      49
+#define SE_GPI_06_INT           48
+#define SE_GPI_05_INT           47
+#define SE_GPI_04_INT           46
+#define SE_GPI_03_INT           45
+#define SE_GPI_02_INT           44
+#define SE_GPI_01_INT           43
+#define SE_GPI_00_INT           42
+#define SE_SYSCLKEN_PIN_INT     41
+#define SE_SPI1_DATAIN_INT      40
+#define SE_GPI_07_INT           39
+#define SE_SPI2_DATAIN_INT      38
+#define SE_GPI_10_INT           37
+#define SE_GPI_09_INT           36
+#define SE_GPI_08_INT           35
+/*34-32 unused*/
+
+/* Start Enable Internal Interrupts - table 57 page 65 */
+
+#define SE_INT_BASE_INT   0
+
+#define SE_TS_IRQ               31
+#define SE_TS_P_INT             30
+#define SE_TS_AUX_INT           29
+/*27-28 unused*/
+#define SE_USB_AHB_NEED_CLK_INT 26
+#define SE_MSTIMER_INT          25
+#define SE_RTC_INT              24
+#define SE_USB_NEED_CLK_INT     23
+#define SE_USB_INT              22
+#define SE_USB_I2C_INT          21
+#define SE_USB_OTG_TIMER_INT    20
+
+#endif /* __PNX4008_IRQS_h__ */
Index: build_tree/linux/include/asm/arch-pnx4008/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ * linux/include/asm-arm/arch-pnx4008/memory.h
+ *
+ * Copyright (c) 2005 Philips Semiconductors
+ * Copyright (c) 2005 MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET     (0x80000000)
+
+#define __virt_to_bus(x) ((x) - PAGE_OFFSET + PHYS_OFFSET)
+#define __bus_to_virt(x) ((x) + PAGE_OFFSET - PHYS_OFFSET)
+
+#endif
Index: build_tree/linux/include/asm/arch-pnx4008/param.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/param.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/param.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/arch-pnx4008/param.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define HZ 100
Index: build_tree/linux/include/asm/arch-pnx4008/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/platform.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,69 @@
+/*
+ * include/asm-arm/arch-pnx4008/platform.h
+ *
+ * PNX4008 Base addresses - header file
+ *
+ * Author: Dmitry Chigirev <source@mvista.com>
+ *
+ * Based on reference code received from Philips:
+ * Copyright (C) 2003 Philips Semiconductors
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+
+#ifndef __ASM_ARCH_PLATFORM_H__
+#define __ASM_ARCH_PLATFORM_H__
+
+#define PNX4008_IRAM_BASE		0x08000000
+#define PNX4008_IRAM_SIZE		0x00010000
+#define PNX4008_YUV_SLAVE_BASE		0x10000000
+#define PNX4008_DUM_SLAVE_BASE		0x18000000
+#define PNX4008_NDF_FLASH_BASE		0x20020000
+#define PNX4008_SPI1_BASE		0x20088000
+#define PNX4008_SPI2_BASE		0x20090000
+#define PNX4008_SD_CONFIG_BASE		0x20098000
+#define PNX4008_FLASH_DATA		0x200B0000
+#define PNX4008_MLC_FLASH_BASE		0x200B8000
+#define PNX4008_JPEG_CONFIG_BASE	0x300A0000
+#define PNX4008_DMA_CONFIG_BASE		0x31000000
+#define PNX4008_USB_CONFIG_BASE		0x31020000
+#define PNX4008_SDRAM_CFG_BASE		0x31080000
+#define PNX4008_AHB2FAB_BASE		0x40000000
+#define PNX4008_PWRMAN_BASE		0x40004000
+#define PNX4008_INTCTRLMIC_BASE		0x40008000
+#define PNX4008_INTCTRLSIC1_BASE	0x4000C000
+#define PNX4008_INTCTRLSIC2_BASE	0x40010000
+#define PNX4008_HSUART1_BASE		0x40014000
+#define PNX4008_HSUART2_BASE		0x40018000
+#define PNX4008_HSUART7_BASE		0x4001C000
+#define PNX4008_RTC_BASE		0x40024000
+#define PNX4008_PIO_BASE		0x40028000
+#define PNX4008_MSTIMER_BASE		0x40034000
+#define PNX4008_HSTIMER_BASE		0x40038000
+#define PNX4008_WDOG_BASE		0x4003C000
+#define PNX4008_DEBUG_BASE		0x40040000
+#define PNX4008_TOUCH1_BASE		0x40048000
+#define PNX4008_KEYSCAN_BASE		0x40050000
+#define PNX4008_UARTCTRL_BASE		0x40054000
+#define PNX4008_PWM_BASE		0x4005C000
+#define PNX4008_UART3_BASE		0x40080000
+#define PNX4008_UART4_BASE		0x40088000
+#define PNX4008_UART5_BASE		0x40090000
+#define PNX4008_UART6_BASE		0x40098000
+#define PNX4008_I2C1_BASE		0x400A0000
+#define PNX4008_I2C2_BASE		0x400A8000
+#define PNX4008_MAGICGATE_BASE		0x400B0000
+#define PNX4008_DUMCONF_BASE		0x400B8000
+#define PNX4008_DUM_MAINCFG_BASE       	0x400BC000
+#define PNX4008_DSP_BASE		0x400C0000
+#define PNX4008_PROFCOUNTER_BASE	0x400C8000
+#define PNX4008_CRYPTO_BASE		0x400D0000
+#define PNX4008_CAMIFCONF_BASE		0x400D8000
+#define PNX4008_YUV2RGB_BASE		0x400E0000
+#define PNX4008_AUDIOCONFIG_BASE	0x400E8000
+
+#endif
Index: build_tree/linux/include/asm/arch-pnx4008/pm.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/pm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/pm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/arch-pnx4008/pm.h
+ *
+ * PNX4008 Power Management Routiness - header file
+ *
+ * Authors: Vitaly Wool, Dmitry Chigirev <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef __ASM_ARCH_PNX4008_PM_H
+#define __ASM_ARCH_PNX4008_PM_H
+
+#ifndef __ASSEMBLER__
+#include "irq.h"
+#include "irqs.h"
+#include "clock.h"
+
+extern void pnx4008_pm_idle(void);
+extern void pnx4008_pm_suspend(void);
+extern unsigned int pnx4008_cpu_suspend_sz;
+extern void pnx4008_cpu_suspend(void);
+extern unsigned int pnx4008_cpu_standby_sz;
+extern void pnx4008_cpu_standby(void);
+
+extern int pnx4008_startup_pll(struct clk *);
+extern int pnx4008_shutdown_pll(struct clk *);
+
+#endif				/* ASSEMBLER */
+#endif				/* __ASM_ARCH_PNX4008_PM_H */
Index: build_tree/linux/include/asm/arch-pnx4008/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * linux/include/asm-arm/arch-pnx4008/system.h
+ *
+ * Copyright (C) 2003 Philips Semiconductors
+ * Copyright (C) 2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	cpu_reset(0);
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-pnx4008/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:42 2008
+++ build_tree/linux/include/asm/arch-pnx4008/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,73 @@
+/*
+ * include/asm-arm/arch-pnx4008/timex.h
+ *
+ * PNX4008 timers header file
+ *
+ * Author: Dmitry Chigirev <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef __PNX4008_TIMEX_H
+#define __PNX4008_TIMEX_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#define CLOCK_TICK_RATE		1000000
+
+#define TICKS2USECS(x)	(x)
+
+/* MilliSecond Timer - Chapter 21 Page 202 */
+
+#define MSTIM_INT     IO_ADDRESS((PNX4008_MSTIMER_BASE + 0x0))
+#define MSTIM_CTRL    IO_ADDRESS((PNX4008_MSTIMER_BASE + 0x4))
+#define MSTIM_COUNTER IO_ADDRESS((PNX4008_MSTIMER_BASE + 0x8))
+#define MSTIM_MCTRL   IO_ADDRESS((PNX4008_MSTIMER_BASE + 0x14))
+#define MSTIM_MATCH0  IO_ADDRESS((PNX4008_MSTIMER_BASE + 0x18))
+#define MSTIM_MATCH1  IO_ADDRESS((PNX4008_MSTIMER_BASE + 0x1c))
+
+/* High Speed Timer - Chpater 22, Page 205 */
+
+#define HSTIM_INT     IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x0))
+#define HSTIM_CTRL    IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x4))
+#define HSTIM_COUNTER IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x8))
+#define HSTIM_PMATCH  IO_ADDRESS((PNX4008_HSTIMER_BASE + 0xC))
+#define HSTIM_PCOUNT  IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x10))
+#define HSTIM_MCTRL   IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x14))
+#define HSTIM_MATCH0  IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x18))
+#define HSTIM_MATCH1  IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x1c))
+#define HSTIM_MATCH2  IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x20))
+#define HSTIM_CCR     IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x28))
+#define HSTIM_CR0     IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x2C))
+#define HSTIM_CR1     IO_ADDRESS((PNX4008_HSTIMER_BASE + 0x30))
+
+/* IMPORTANT: both timers are UPCOUNTING */
+
+/* xSTIM_MCTRL bit definitions */
+#define MR0_INT        1
+#define RESET_COUNT0   (1<<1)
+#define STOP_COUNT0    (1<<2)
+#define MR1_INT        (1<<3)
+#define RESET_COUNT1   (1<<4)
+#define STOP_COUNT1    (1<<5)
+#define MR2_INT        (1<<6)
+#define RESET_COUNT2   (1<<7)
+#define STOP_COUNT2    (1<<8)
+
+/* xSTIM_CTRL bit definitions */
+#define COUNT_ENAB     1
+#define RESET_COUNT    (1<<1)
+#define DEBUG_EN       (1<<2)
+
+/* xSTIM_INT bit definitions */
+#define MATCH0_INT     1
+#define MATCH1_INT     (1<<1)
+#define MATCH2_INT     (1<<2)
+#define RTC_TICK0      (1<<4)
+#define RTC_TICK1      (1<<5)
+
+#endif
Index: build_tree/linux/include/asm/arch-pnx4008/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pnx4008/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-arm/arch-pnx4008/uncompress.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2006 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define UART5_BASE 0x40090000
+
+#define UART5_DR    (*(volatile unsigned char *) (UART5_BASE))
+#define UART5_FR    (*(volatile unsigned char *) (UART5_BASE + 18))
+
+static __inline__ void putc(char c)
+{
+	while (UART5_FR & (1 << 5))
+		barrier();
+
+	UART5_DR = c;
+}
+
+/*
+ * This does not append a newline
+ */
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-pnx4008/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-pnx4008/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pnx4008/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-pnx4008/vmalloc.h
+ *
+ * Author: Vitaly Wool <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
Index: build_tree/linux/include/asm/arch-pxa/akita.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/akita.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/akita.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ * Hardware specific definitions for SL-C1000 (Akita)
+ *
+ * Copyright (c) 2005 Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/* Akita IO Expander GPIOs */
+
+#define AKITA_IOEXP_RESERVED_7      (1 << 7)
+#define AKITA_IOEXP_IR_ON           (1 << 6)
+#define AKITA_IOEXP_AKIN_PULLUP     (1 << 5)
+#define AKITA_IOEXP_BACKLIGHT_CONT  (1 << 4)
+#define AKITA_IOEXP_BACKLIGHT_ON    (1 << 3)
+#define AKITA_IOEXP_MIC_BIAS        (1 << 2)
+#define AKITA_IOEXP_RESERVED_1      (1 << 1)
+#define AKITA_IOEXP_RESERVED_0      (1 << 0)
+
+/* Direction Bitfield  0=output  1=input */
+#define AKITA_IOEXP_IO_DIR	0
+/* Default Values */
+#define AKITA_IOEXP_IO_OUT	(AKITA_IOEXP_IR_ON | AKITA_IOEXP_AKIN_PULLUP)
+
+extern struct platform_device akitaioexp_device;
+
+void akita_set_ioexp(struct device *dev, unsigned char bitmask);
+void akita_reset_ioexp(struct device *dev, unsigned char bitmask);
+
Index: build_tree/linux/include/asm/arch-pxa/audio.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/audio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/audio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+#ifndef __ASM_ARCH_AUDIO_H__
+#define __ASM_ARCH_AUDIO_H__
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+
+typedef struct {
+	int (*startup)(struct snd_pcm_substream *, void *);
+	void (*shutdown)(struct snd_pcm_substream *, void *);
+	void (*suspend)(void *);
+	void (*resume)(void *);
+	void *priv;
+} pxa2xx_audio_ops_t;
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/bitfield.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/bitfield.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/bitfield.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,113 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+                	(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+                	((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
Index: build_tree/linux/include/asm/arch-pxa/corgi.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/corgi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/corgi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,110 @@
+/*
+ * Hardware specific definitions for SL-C7xx series of PDAs
+ *
+ * Copyright (c) 2004-2005 Richard Purdie
+ *
+ * Based on Sharp's 2.4 kernel patches
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ASM_ARCH_CORGI_H
+#define __ASM_ARCH_CORGI_H  1
+
+
+/*
+ * Corgi (Non Standard) GPIO Definitions
+ */
+#define CORGI_GPIO_KEY_INT			(0)	/* Keyboard Interrupt */
+#define CORGI_GPIO_AC_IN			(1) /* Charger Detection */
+#define CORGI_GPIO_WAKEUP			(3) /* System wakeup notification? */
+#define CORGI_GPIO_AK_INT			(4)	/* Headphone Jack Control Interrupt */
+#define CORGI_GPIO_TP_INT			(5)	/* Touch Panel Interrupt */
+#define CORGI_GPIO_nSD_WP			(7) /* SD Write Protect? */
+#define CORGI_GPIO_nSD_DETECT		(9) /* MMC/SD Card Detect */
+#define CORGI_GPIO_nSD_INT			(10) /* SD Interrupt for SDIO? */
+#define CORGI_GPIO_MAIN_BAT_LOW		(11) /* Main Battery Low Notification */
+#define CORGI_GPIO_BAT_COVER		(11) /* Battery Cover Detect */
+#define CORGI_GPIO_LED_ORANGE		(13) /* Orange LED Control */
+#define CORGI_GPIO_CF_CD			(14) /* Compact Flash Card Detect */
+#define CORGI_GPIO_CHRG_FULL		(16) /* Charging Complete Notification */
+#define CORGI_GPIO_CF_IRQ			(17) /* Compact Flash Interrupt */
+#define CORGI_GPIO_LCDCON_CS		(19) /* LCD Control Chip Select */
+#define CORGI_GPIO_MAX1111_CS		(20) /* MAX1111 Chip Select */
+#define CORGI_GPIO_ADC_TEMP_ON		(21) /* Select battery voltage or temperature */
+#define CORGI_GPIO_IR_ON			(22) /* Enable IR Transciever */
+#define CORGI_GPIO_ADS7846_CS		(24) /* ADS7846 Chip Select */
+#define CORGI_GPIO_SD_PWR			(33) /* MMC/SD Power */
+#define CORGI_GPIO_CHRG_ON			(38) /* Enable battery Charging */
+#define CORGI_GPIO_DISCHARGE_ON		(42) /* Enable battery Discharge */
+#define CORGI_GPIO_CHRG_UKN			(43) /* Unknown Charging (Bypass Control?) */
+#define CORGI_GPIO_HSYNC			(44) /* LCD HSync Pulse */
+#define CORGI_GPIO_USB_PULLUP		(45) /* USB show presence to host */
+
+
+/*
+ * Corgi Keyboard Definitions
+ */
+#define CORGI_KEY_STROBE_NUM		(12)
+#define CORGI_KEY_SENSE_NUM			(8)
+#define CORGI_GPIO_ALL_STROBE_BIT	(0x00003ffc)
+#define CORGI_GPIO_HIGH_SENSE_BIT	(0xfc000000)
+#define CORGI_GPIO_HIGH_SENSE_RSHIFT	(26)
+#define CORGI_GPIO_LOW_SENSE_BIT	(0x00000003)
+#define CORGI_GPIO_LOW_SENSE_LSHIFT	(6)
+#define CORGI_GPIO_STROBE_BIT(a)	GPIO_bit(66+(a))
+#define CORGI_GPIO_SENSE_BIT(a)		GPIO_bit(58+(a))
+#define CORGI_GAFR_ALL_STROBE_BIT	(0x0ffffff0)
+#define CORGI_GAFR_HIGH_SENSE_BIT	(0xfff00000)
+#define CORGI_GAFR_LOW_SENSE_BIT	(0x0000000f)
+#define CORGI_GPIO_KEY_SENSE(a)		(58+(a))
+#define CORGI_GPIO_KEY_STROBE(a)	(66+(a))
+
+
+/*
+ * Corgi Interrupts
+ */
+#define CORGI_IRQ_GPIO_KEY_INT		IRQ_GPIO(0)
+#define CORGI_IRQ_GPIO_AC_IN		IRQ_GPIO(1)
+#define CORGI_IRQ_GPIO_WAKEUP		IRQ_GPIO(3)
+#define CORGI_IRQ_GPIO_AK_INT		IRQ_GPIO(4)
+#define CORGI_IRQ_GPIO_TP_INT		IRQ_GPIO(5)
+#define CORGI_IRQ_GPIO_nSD_DETECT	IRQ_GPIO(9)
+#define CORGI_IRQ_GPIO_nSD_INT		IRQ_GPIO(10)
+#define CORGI_IRQ_GPIO_MAIN_BAT_LOW	IRQ_GPIO(11)
+#define CORGI_IRQ_GPIO_CF_CD		IRQ_GPIO(14)
+#define CORGI_IRQ_GPIO_CHRG_FULL	IRQ_GPIO(16)	/* Battery fully charged */
+#define CORGI_IRQ_GPIO_CF_IRQ		IRQ_GPIO(17)
+#define CORGI_IRQ_GPIO_KEY_SENSE(a)	IRQ_GPIO(58+(a))	/* Keyboard Sense lines */
+
+
+/*
+ * Corgi SCOOP GPIOs and Config
+ */
+#define CORGI_SCP_LED_GREEN		SCOOP_GPCR_PA11
+#define CORGI_SCP_SWA			SCOOP_GPCR_PA12  /* Hinge Switch A */
+#define CORGI_SCP_SWB			SCOOP_GPCR_PA13  /* Hinge Switch B */
+#define CORGI_SCP_MUTE_L		SCOOP_GPCR_PA14
+#define CORGI_SCP_MUTE_R		SCOOP_GPCR_PA15
+#define CORGI_SCP_AKIN_PULLUP	SCOOP_GPCR_PA16
+#define CORGI_SCP_APM_ON		SCOOP_GPCR_PA17
+#define CORGI_SCP_BACKLIGHT_CONT	SCOOP_GPCR_PA18
+#define CORGI_SCP_MIC_BIAS		SCOOP_GPCR_PA19
+
+#define CORGI_SCOOP_IO_DIR	( CORGI_SCP_LED_GREEN | CORGI_SCP_MUTE_L | CORGI_SCP_MUTE_R | \
+			CORGI_SCP_AKIN_PULLUP | CORGI_SCP_APM_ON | CORGI_SCP_BACKLIGHT_CONT | \
+			CORGI_SCP_MIC_BIAS )
+#define CORGI_SCOOP_IO_OUT	( CORGI_SCP_MUTE_L | CORGI_SCP_MUTE_R )
+
+
+/*
+ * Shared data structures
+ */
+extern struct platform_device corgiscoop_device;
+extern struct platform_device corgissp_device;
+extern struct platform_device corgifb_device;
+
+#endif /* __ASM_ARCH_CORGI_H  */
+
Index: build_tree/linux/include/asm/arch-pxa/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,25 @@
+/* linux/include/asm-arm/arch-pxa/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include "hardware.h"
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x40000000		@ physical
+		movne	\rx, #io_p2v(0x40000000)	@ virtual
+		orr	\rx, \rx, #0x00100000
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-pxa/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,64 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/dma.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/*
+ * Descriptor structure for PXA's DMA engine
+ * Note: this structure must always be aligned to a 16-byte boundary.
+ */
+
+typedef struct pxa_dma_desc {
+	volatile u32 ddadr;	/* Points to the next descriptor + flags */
+	volatile u32 dsadr;	/* DSADR value for the current transfer */
+	volatile u32 dtadr;	/* DTADR value for the current transfer */
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+} pxa_dma_desc;
+
+typedef enum {
+	DMA_PRIO_HIGH = 0,
+	DMA_PRIO_MEDIUM = 1,
+	DMA_PRIO_LOW = 2
+} pxa_dma_prio;
+
+#if defined(CONFIG_PXA27x)
+
+#define PXA_DMA_CHANNELS	32
+
+#define pxa_for_each_dma_prio(ch, prio)					\
+for (									\
+	ch = prio * 4;							\
+	ch != (4 << prio) + 16;						\
+	ch = (ch + 1 == (4 << prio)) ? (prio * 4 + 16) : (ch + 1)	\
+)
+
+#elif defined(CONFIG_PXA25x)
+
+#define PXA_DMA_CHANNELS	16
+
+#define pxa_for_each_dma_prio(ch, prio)					\
+	for (ch = prio * 4; ch != (4 << prio); ch++)
+
+#endif
+
+/*
+ * DMA registration
+ */
+
+int pxa_request_dma (char *name,
+			 pxa_dma_prio prio,
+			 void (*irq_handler)(int, void *),
+			 void *data);
+
+void pxa_free_dma (int dma_ch);
+
+#endif /* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-pxa/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-pxa/entry-macro.S
+ *
+ * Low-level IRQ helper macros for PXA-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/arch/irqs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+#ifdef CONFIG_PXA27x
+		mrc	p6, 0, \irqstat, c0, c0, 0		@ ICIP
+		mrc	p6, 0, \irqnr, c1, c0, 0		@ ICMR
+#else
+		mov	\base, #io_p2v(0x40000000)	@ IIR Ctl = 0x40d00000
+		add	\base, \base, #0x00d00000
+		ldr	\irqstat, [\base, #0]		@ ICIP
+		ldr	\irqnr, [\base, #4]		@ ICMR
+#endif
+		ands	\irqnr, \irqstat, \irqnr
+		beq	1001f
+		rsb	\irqstat, \irqnr, #0
+		and	\irqstat, \irqstat, \irqnr
+		clz	\irqnr, \irqstat
+		rsb	\irqnr, \irqnr, #(31 - PXA_IRQ_SKIP)
+1001:
+		.endm
Index: build_tree/linux/include/asm/arch-pxa/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,80 @@
+/*
+ * linux/include/asm-arm/arch-pxa/gpio.h
+ *
+ * PXA GPIO wrappers for arch-neutral GPIO calls
+ *
+ * Written by Philipp Zabel <philipp.zabel@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __ASM_ARCH_PXA_GPIO_H
+#define __ASM_ARCH_PXA_GPIO_H
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+	return;
+}
+
+static inline int gpio_direction_input(unsigned gpio)
+{
+	return pxa_gpio_mode(gpio | GPIO_IN);
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	return pxa_gpio_mode(gpio | GPIO_OUT | (value ? 0 : GPIO_DFLT_LOW));
+}
+
+static inline int __gpio_get_value(unsigned gpio)
+{
+	return GPLR(gpio) & GPIO_bit(gpio);
+}
+
+#define gpio_get_value(gpio)			\
+	(__builtin_constant_p(gpio) ?		\
+	 __gpio_get_value(gpio) :		\
+	 pxa_gpio_get_value(gpio))
+
+static inline void __gpio_set_value(unsigned gpio, int value)
+{
+	if (value)
+		GPSR(gpio) = GPIO_bit(gpio);
+	else
+		GPCR(gpio) = GPIO_bit(gpio);
+}
+
+#define gpio_set_value(gpio,value)		\
+	(__builtin_constant_p(gpio) ?		\
+	 __gpio_set_value(gpio, value) :	\
+	 pxa_gpio_set_value(gpio, value))
+
+#include <asm-generic/gpio.h>			/* cansleep wrappers */
+
+#define gpio_to_irq(gpio)	IRQ_GPIO(gpio)
+#define irq_to_gpio(irq)	IRQ_TO_GPIO(irq)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,93 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/hardware.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/*
+ * We requires absolute addresses.
+ */
+#define PCIO_BASE		0
+
+/*
+ * Workarounds for at least 2 errata so far require this.
+ * The mapping is set in mach-pxa/generic.c.
+ */
+#define UNCACHED_PHYS_0		0xff000000
+#define UNCACHED_ADDR		UNCACHED_PHYS_0
+
+/*
+ * Intel PXA2xx internal register mapping:
+ *
+ * 0x40000000 - 0x41ffffff <--> 0xf2000000 - 0xf3ffffff
+ * 0x44000000 - 0x45ffffff <--> 0xf4000000 - 0xf5ffffff
+ * 0x48000000 - 0x49ffffff <--> 0xf6000000 - 0xf7ffffff
+ * 0x4c000000 - 0x4dffffff <--> 0xf8000000 - 0xf9ffffff
+ * 0x50000000 - 0x51ffffff <--> 0xfa000000 - 0xfbffffff
+ * 0x54000000 - 0x55ffffff <--> 0xfc000000 - 0xfdffffff
+ * 0x58000000 - 0x59ffffff <--> 0xfe000000 - 0xffffffff
+ *
+ * Note that not all PXA2xx chips implement all those addresses, and the
+ * kernel only maps the minimum needed range of this mapping.
+ */
+#define io_p2v(x) (0xf2000000 + ((x) & 0x01ffffff) + (((x) & 0x1c000000) >> 1))
+#define io_v2p(x) (0x3c000000 + ((x) & 0x01ffffff) + (((x) & 0x0e000000) << 1))
+
+#ifndef __ASSEMBLY__
+
+# define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+
+/* With indexed regs we don't want to feed the index through io_p2v()
+   especially if it is a variable, otherwise horrible code will result. */
+# define __REG2(x,y)	\
+	(*(volatile u32 *)((u32)&__REG(x) + (y)))
+
+# define __PREG(x)	(io_v2p((u32)&(x)))
+
+#else
+
+# define __REG(x)	io_p2v(x)
+# define __PREG(x)	io_v2p(x)
+
+#endif
+
+#ifndef __ASSEMBLY__
+
+/*
+ * Handy routine to set GPIO alternate functions
+ */
+extern int pxa_gpio_mode( int gpio_mode );
+
+/*
+ * Return GPIO level, nonzero means high, zero is low
+ */
+extern int pxa_gpio_get_value(unsigned gpio);
+
+/*
+ * Set output GPIO level
+ */
+extern void pxa_gpio_set_value(unsigned gpio, int value);
+
+/*
+ * Routine to enable or disable CKEN
+ */
+extern void pxa_set_cken(int clock, int enable);
+
+/*
+ * return current memory and LCD clock frequency in units of 10kHz
+ */
+extern unsigned int get_memclk_frequency_10khz(void);
+extern unsigned int get_lcdclk_frequency_10khz(void);
+
+#endif
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-pxa/i2c.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/i2c.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/i2c.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,70 @@
+/*
+ *  i2c_pxa.h
+ *
+ *  Copyright (C) 2002 Intrinsyc Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+#ifndef _I2C_PXA_H_
+#define _I2C_PXA_H_
+
+#if 0
+#define DEF_TIMEOUT             3
+#else
+/* need a longer timeout if we're dealing with the fact we may well be
+ * looking at a multi-master environment
+*/
+#define DEF_TIMEOUT             32
+#endif
+
+#define BUS_ERROR               (-EREMOTEIO)
+#define XFER_NAKED              (-ECONNREFUSED)
+#define I2C_RETRY               (-2000) /* an error has occurred retry transmit */
+
+/* ICR initialize bit values
+*
+*  15. FM       0 (100 Khz operation)
+*  14. UR       0 (No unit reset)
+*  13. SADIE    0 (Disables the unit from interrupting on slave addresses
+*                                       matching its slave address)
+*  12. ALDIE    0 (Disables the unit from interrupt when it loses arbitration
+*                                       in master mode)
+*  11. SSDIE    0 (Disables interrupts from a slave stop detected, in slave mode)
+*  10. BEIE     1 (Enable interrupts from detected bus errors, no ACK sent)
+*  9.  IRFIE    1 (Enable interrupts from full buffer received)
+*  8.  ITEIE    1 (Enables the I2C unit to interrupt when transmit buffer empty)
+*  7.  GCD      1 (Disables i2c unit response to general call messages as a slave)
+*  6.  IUE      0 (Disable unit until we change settings)
+*  5.  SCLE     1 (Enables the i2c clock output for master mode (drives SCL)
+*  4.  MA       0 (Only send stop with the ICR stop bit)
+*  3.  TB       0 (We are not transmitting a byte initially)
+*  2.  ACKNAK   0 (Send an ACK after the unit receives a byte)
+*  1.  STOP     0 (Do not send a STOP)
+*  0.  START    0 (Do not send a START)
+*
+*/
+#define I2C_ICR_INIT	(ICR_BEIE | ICR_IRFIE | ICR_ITEIE | ICR_GCD | ICR_SCLE)
+
+/* I2C status register init values
+ *
+ * 10. BED      1 (Clear bus error detected)
+ * 9.  SAD      1 (Clear slave address detected)
+ * 7.  IRF      1 (Clear IDBR Receive Full)
+ * 6.  ITE      1 (Clear IDBR Transmit Empty)
+ * 5.  ALD      1 (Clear Arbitration Loss Detected)
+ * 4.  SSD      1 (Clear Slave Stop Detected)
+ */
+#define I2C_ISR_INIT	0x7FF  /* status register init */
+
+struct i2c_slave_client;
+
+struct i2c_pxa_platform_data {
+	unsigned int		slave_addr;
+	struct i2c_slave_client	*slave;
+};
+
+extern void pxa_set_i2c_info(struct i2c_pxa_platform_data *info);
+#endif
Index: build_tree/linux/include/asm/arch-pxa/idp.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/idp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/idp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,199 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/idp.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) 2001 Cliff Brake, Accelent Systems Inc.
+ *
+ * 2001-09-13: Cliff Brake <cbrake@accelent.com>
+ *             Initial code
+ *
+ * 2005-02-15: Cliff Brake <cliff.brake@gmail.com>
+ *             <http://www.vibren.com> <http://bec-systems.com>
+ *             Changes for 2.6 kernel.
+ */
+
+
+/*
+ * Note: this file must be safe to include in assembly files
+ *
+ * Support for the Vibren PXA255 IDP requires rev04 or later
+ * IDP hardware.
+ */
+
+
+#define IDP_FLASH_PHYS		(PXA_CS0_PHYS)
+#define IDP_ALT_FLASH_PHYS	(PXA_CS1_PHYS)
+#define IDP_MEDIAQ_PHYS		(PXA_CS3_PHYS)
+#define IDP_IDE_PHYS		(PXA_CS5_PHYS + 0x03000000)
+#define IDP_ETH_PHYS		(PXA_CS5_PHYS + 0x03400000)
+#define IDP_COREVOLT_PHYS	(PXA_CS5_PHYS + 0x03800000)
+#define IDP_CPLD_PHYS		(PXA_CS5_PHYS + 0x03C00000)
+
+
+/*
+ * virtual memory map
+ */
+
+#define IDP_COREVOLT_VIRT	(0xf0000000)
+#define IDP_COREVOLT_SIZE	(1*1024*1024)
+
+#define IDP_CPLD_VIRT		(IDP_COREVOLT_VIRT + IDP_COREVOLT_SIZE)
+#define IDP_CPLD_SIZE		(1*1024*1024)
+
+#if (IDP_CPLD_VIRT + IDP_CPLD_SIZE) > 0xfc000000
+#error Your custom IO space is getting a bit large !!
+#endif
+
+#define CPLD_P2V(x)		((x) - IDP_CPLD_PHYS + IDP_CPLD_VIRT)
+#define CPLD_V2P(x)		((x) - IDP_CPLD_VIRT + IDP_CPLD_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __CPLD_REG(x)		(*((volatile unsigned long *)CPLD_P2V(x)))
+#else
+#  define __CPLD_REG(x)		CPLD_P2V(x)
+#endif
+
+/* board level registers in the CPLD: (offsets from CPLD_VIRT) */
+
+#define _IDP_CPLD_REV			(IDP_CPLD_PHYS + 0x00)
+#define _IDP_CPLD_PERIPH_PWR		(IDP_CPLD_PHYS + 0x04)
+#define _IDP_CPLD_LED_CONTROL		(IDP_CPLD_PHYS + 0x08)
+#define _IDP_CPLD_KB_COL_HIGH		(IDP_CPLD_PHYS + 0x0C)
+#define _IDP_CPLD_KB_COL_LOW		(IDP_CPLD_PHYS + 0x10)
+#define _IDP_CPLD_PCCARD_EN		(IDP_CPLD_PHYS + 0x14)
+#define _IDP_CPLD_GPIOH_DIR		(IDP_CPLD_PHYS + 0x18)
+#define _IDP_CPLD_GPIOH_VALUE		(IDP_CPLD_PHYS + 0x1C)
+#define _IDP_CPLD_GPIOL_DIR		(IDP_CPLD_PHYS + 0x20)
+#define _IDP_CPLD_GPIOL_VALUE		(IDP_CPLD_PHYS + 0x24)
+#define _IDP_CPLD_PCCARD_PWR		(IDP_CPLD_PHYS + 0x28)
+#define _IDP_CPLD_MISC_CTRL		(IDP_CPLD_PHYS + 0x2C)
+#define _IDP_CPLD_LCD			(IDP_CPLD_PHYS + 0x30)
+#define _IDP_CPLD_FLASH_WE		(IDP_CPLD_PHYS + 0x34)
+
+#define _IDP_CPLD_KB_ROW		(IDP_CPLD_PHYS + 0x50)
+#define _IDP_CPLD_PCCARD0_STATUS	(IDP_CPLD_PHYS + 0x54)
+#define _IDP_CPLD_PCCARD1_STATUS	(IDP_CPLD_PHYS + 0x58)
+#define _IDP_CPLD_MISC_STATUS		(IDP_CPLD_PHYS + 0x5C)
+
+/* FPGA register virtual addresses */
+
+#define IDP_CPLD_REV			__CPLD_REG(_IDP_CPLD_REV)
+#define IDP_CPLD_PERIPH_PWR		__CPLD_REG(_IDP_CPLD_PERIPH_PWR)
+#define IDP_CPLD_LED_CONTROL		__CPLD_REG(_IDP_CPLD_LED_CONTROL)
+#define IDP_CPLD_KB_COL_HIGH		__CPLD_REG(_IDP_CPLD_KB_COL_HIGH)
+#define IDP_CPLD_KB_COL_LOW		__CPLD_REG(_IDP_CPLD_KB_COL_LOW)
+#define IDP_CPLD_PCCARD_EN		__CPLD_REG(_IDP_CPLD_PCCARD_EN)
+#define IDP_CPLD_GPIOH_DIR		__CPLD_REG(_IDP_CPLD_GPIOH_DIR)
+#define IDP_CPLD_GPIOH_VALUE		__CPLD_REG(_IDP_CPLD_GPIOH_VALUE)
+#define IDP_CPLD_GPIOL_DIR		__CPLD_REG(_IDP_CPLD_GPIOL_DIR)
+#define IDP_CPLD_GPIOL_VALUE		__CPLD_REG(_IDP_CPLD_GPIOL_VALUE)
+#define IDP_CPLD_PCCARD_PWR		__CPLD_REG(_IDP_CPLD_PCCARD_PWR)
+#define IDP_CPLD_MISC_CTRL		__CPLD_REG(_IDP_CPLD_MISC_CTRL)
+#define IDP_CPLD_LCD			__CPLD_REG(_IDP_CPLD_LCD)
+#define IDP_CPLD_FLASH_WE		__CPLD_REG(_IDP_CPLD_FLASH_WE)
+
+#define IDP_CPLD_KB_ROW		        __CPLD_REG(_IDP_CPLD_KB_ROW)
+#define IDP_CPLD_PCCARD0_STATUS	        __CPLD_REG(_IDP_CPLD_PCCARD0_STATUS)
+#define IDP_CPLD_PCCARD1_STATUS	        __CPLD_REG(_IDP_CPLD_PCCARD1_STATUS)
+#define IDP_CPLD_MISC_STATUS		__CPLD_REG(_IDP_CPLD_MISC_STATUS)
+
+
+/*
+ * Bit masks for various registers
+ */
+
+// IDP_CPLD_PCCARD_PWR
+#define PCC0_PWR0	(1 << 0)
+#define PCC0_PWR1	(1 << 1)
+#define PCC0_PWR2	(1 << 2)
+#define PCC0_PWR3	(1 << 3)
+#define PCC1_PWR0	(1 << 4)
+#define PCC1_PWR1	(1 << 5)
+#define PCC1_PWR2	(1 << 6)
+#define PCC1_PWR3	(1 << 7)
+
+// IDP_CPLD_PCCARD_EN
+#define PCC0_RESET	(1 << 6)
+#define PCC1_RESET	(1 << 7)
+#define PCC0_ENABLE	(1 << 0)
+#define PCC1_ENABLE	(1 << 1)
+
+// IDP_CPLD_PCCARDx_STATUS
+#define _PCC_WRPROT	(1 << 7) // 7-4 read as low true
+#define _PCC_RESET	(1 << 6)
+#define _PCC_IRQ	(1 << 5)
+#define _PCC_INPACK	(1 << 4)
+#define PCC_BVD2	(1 << 3)
+#define PCC_BVD1	(1 << 2)
+#define PCC_VS2		(1 << 1)
+#define PCC_VS1		(1 << 0)
+
+#define PCC_DETECT(x)	(GPLR(7 + (x)) & GPIO_bit(7 + (x)))
+
+/* A listing of interrupts used by external hardware devices */
+
+#define TOUCH_PANEL_IRQ			IRQ_GPIO(5)
+#define IDE_IRQ				IRQ_GPIO(21)
+
+#define TOUCH_PANEL_IRQ_EDGE		IRQT_FALLING
+
+#define ETHERNET_IRQ			IRQ_GPIO(4)
+#define ETHERNET_IRQ_EDGE		IRQT_RISING
+
+#define IDE_IRQ_EDGE			IRQT_RISING
+
+#define PCMCIA_S0_CD_VALID		IRQ_GPIO(7)
+#define PCMCIA_S0_CD_VALID_EDGE		IRQT_BOTHEDGE
+
+#define PCMCIA_S1_CD_VALID		IRQ_GPIO(8)
+#define PCMCIA_S1_CD_VALID_EDGE		IRQT_BOTHEDGE
+
+#define PCMCIA_S0_RDYINT		IRQ_GPIO(19)
+#define PCMCIA_S1_RDYINT		IRQ_GPIO(22)
+
+
+/*
+ * Macros for LED Driver
+ */
+
+/* leds 0 = ON */
+#define IDP_HB_LED	(1<<5)
+#define IDP_BUSY_LED	(1<<6)
+
+#define IDP_LEDS_MASK	(IDP_HB_LED | IDP_BUSY_LED)
+
+/*
+ * macros for MTD driver
+ */
+
+#define FLASH_WRITE_PROTECT_DISABLE()	((IDP_CPLD_FLASH_WE) &= ~(0x1))
+#define FLASH_WRITE_PROTECT_ENABLE()	((IDP_CPLD_FLASH_WE) |= (0x1))
+
+/*
+ * macros for matrix keyboard driver
+ */
+
+#define KEYBD_MATRIX_NUMBER_INPUTS	7
+#define KEYBD_MATRIX_NUMBER_OUTPUTS	14
+
+#define KEYBD_MATRIX_INVERT_OUTPUT_LOGIC	FALSE
+#define KEYBD_MATRIX_INVERT_INPUT_LOGIC		FALSE
+
+#define KEYBD_MATRIX_SETTLING_TIME_US			100
+#define KEYBD_MATRIX_KEYSTATE_DEBOUNCE_CONSTANT		2
+
+#define KEYBD_MATRIX_SET_OUTPUTS(outputs) \
+{\
+	IDP_CPLD_KB_COL_LOW = outputs;\
+	IDP_CPLD_KB_COL_HIGH = outputs >> 7;\
+}
+
+#define KEYBD_MATRIX_GET_INPUTS(inputs) \
+{\
+	inputs = (IDP_CPLD_KB_ROW & 0x7f);\
+}
+
+
Index: build_tree/linux/include/asm/arch-pxa/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ * linux/include/asm-arm/arch-pxa/io.h
+ *
+ * Copied from asm/arch/sa1100/io.h
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)			((void __iomem *)(a))
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/irda.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/irda.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/irda.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,17 @@
+#ifndef ASMARM_ARCH_IRDA_H
+#define ASMARM_ARCH_IRDA_H
+
+/* board specific transceiver capabilities */
+
+#define IR_OFF		1
+#define IR_SIRMODE	2
+#define IR_FIRMODE	4
+
+struct pxaficp_platform_data {
+	int transceiver_cap;
+	void (*transceiver_mode)(struct device *dev, int mode);
+};
+
+extern void pxa_set_ficp_info(struct pxaficp_platform_data *info);
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,224 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/irqs.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifdef CONFIG_PXA27x
+#define PXA_IRQ_SKIP	0
+#else
+#define PXA_IRQ_SKIP	7
+#endif
+
+#define PXA_IRQ(x)	((x) - PXA_IRQ_SKIP)
+
+#define IRQ_SSP3	PXA_IRQ(0)	/* SSP3 service request */
+#define IRQ_MSL		PXA_IRQ(1)	/* MSL Interface interrupt */
+#define IRQ_USBH2	PXA_IRQ(2)	/* USB Host interrupt 1 (OHCI) */
+#define IRQ_USBH1	PXA_IRQ(3)	/* USB Host interrupt 2 (non-OHCI) */
+#define IRQ_KEYPAD	PXA_IRQ(4)	/* Key pad controller */
+#define IRQ_MEMSTK	PXA_IRQ(5)	/* Memory Stick interrupt */
+#define IRQ_PWRI2C	PXA_IRQ(6)	/* Power I2C interrupt */
+#define IRQ_HWUART	PXA_IRQ(7)	/* HWUART Transmit/Receive/Error (PXA26x) */
+#define IRQ_OST_4_11	PXA_IRQ(7)	/* OS timer 4-11 matches (PXA27x) */
+#define	IRQ_GPIO0	PXA_IRQ(8)	/* GPIO0 Edge Detect */
+#define	IRQ_GPIO1	PXA_IRQ(9)	/* GPIO1 Edge Detect */
+#define	IRQ_GPIO_2_x	PXA_IRQ(10)	/* GPIO[2-x] Edge Detect */
+#define	IRQ_USB		PXA_IRQ(11)	/* USB Service */
+#define	IRQ_PMU		PXA_IRQ(12)	/* Performance Monitoring Unit */
+#define	IRQ_I2S		PXA_IRQ(13)	/* I2S Interrupt */
+#define	IRQ_AC97	PXA_IRQ(14)	/* AC97 Interrupt */
+#define IRQ_ASSP	PXA_IRQ(15)	/* Audio SSP Service Request (PXA25x) */
+#define IRQ_USIM	PXA_IRQ(15)     /* Smart Card interface interrupt (PXA27x) */
+#define IRQ_NSSP	PXA_IRQ(16)	/* Network SSP Service Request (PXA25x) */
+#define IRQ_SSP2	PXA_IRQ(16)	/* SSP2 interrupt (PXA27x) */
+#define	IRQ_LCD		PXA_IRQ(17)	/* LCD Controller Service Request */
+#define	IRQ_I2C		PXA_IRQ(18)	/* I2C Service Request */
+#define	IRQ_ICP		PXA_IRQ(19)	/* ICP Transmit/Receive/Error */
+#define	IRQ_STUART	PXA_IRQ(20)	/* STUART Transmit/Receive/Error */
+#define	IRQ_BTUART	PXA_IRQ(21)	/* BTUART Transmit/Receive/Error */
+#define	IRQ_FFUART	PXA_IRQ(22)	/* FFUART Transmit/Receive/Error*/
+#define	IRQ_MMC		PXA_IRQ(23)	/* MMC Status/Error Detection */
+#define	IRQ_SSP		PXA_IRQ(24)	/* SSP Service Request */
+#define	IRQ_DMA 	PXA_IRQ(25)	/* DMA Channel Service Request */
+#define	IRQ_OST0 	PXA_IRQ(26)	/* OS Timer match 0 */
+#define	IRQ_OST1 	PXA_IRQ(27)	/* OS Timer match 1 */
+#define	IRQ_OST2 	PXA_IRQ(28)	/* OS Timer match 2 */
+#define	IRQ_OST3 	PXA_IRQ(29)	/* OS Timer match 3 */
+#define	IRQ_RTC1Hz	PXA_IRQ(30)	/* RTC HZ Clock Tick */
+#define	IRQ_RTCAlrm	PXA_IRQ(31)	/* RTC Alarm */
+
+#ifdef CONFIG_PXA27x
+#define IRQ_TPM		PXA_IRQ(32)	/* TPM interrupt */
+#define IRQ_CAMERA	PXA_IRQ(33)	/* Camera Interface */
+
+#define PXA_INTERNAL_IRQS 34
+#else
+#define PXA_INTERNAL_IRQS 32
+#endif
+
+#define GPIO_2_x_TO_IRQ(x)	\
+			PXA_IRQ((x) - 2 + PXA_INTERNAL_IRQS)
+#define IRQ_GPIO(x)	(((x) < 2) ? (IRQ_GPIO0 + (x)) : GPIO_2_x_TO_IRQ(x))
+
+#define IRQ_TO_GPIO_2_x(i)	\
+			((i) - IRQ_GPIO(2) + 2)
+#define IRQ_TO_GPIO(i)	(((i) < IRQ_GPIO(2)) ? ((i) - IRQ_GPIO0) : IRQ_TO_GPIO_2_x(i))
+
+#if defined(CONFIG_PXA25x)
+#define PXA_LAST_GPIO	84
+#elif defined(CONFIG_PXA27x)
+#define PXA_LAST_GPIO	127
+#endif
+
+/*
+ * The next 16 interrupts are for board specific purposes.  Since
+ * the kernel can only run on one machine at a time, we can re-use
+ * these.  If you need more, increase IRQ_BOARD_END, but keep it
+ * within sensible limits.
+ */
+#define IRQ_BOARD_START		(IRQ_GPIO(PXA_LAST_GPIO) + 1)
+#define IRQ_BOARD_END		(IRQ_BOARD_START + 16)
+
+#define IRQ_SA1111_START	(IRQ_BOARD_END)
+#define IRQ_GPAIN0		(IRQ_BOARD_END + 0)
+#define IRQ_GPAIN1		(IRQ_BOARD_END + 1)
+#define IRQ_GPAIN2		(IRQ_BOARD_END + 2)
+#define IRQ_GPAIN3		(IRQ_BOARD_END + 3)
+#define IRQ_GPBIN0		(IRQ_BOARD_END + 4)
+#define IRQ_GPBIN1		(IRQ_BOARD_END + 5)
+#define IRQ_GPBIN2		(IRQ_BOARD_END + 6)
+#define IRQ_GPBIN3		(IRQ_BOARD_END + 7)
+#define IRQ_GPBIN4		(IRQ_BOARD_END + 8)
+#define IRQ_GPBIN5		(IRQ_BOARD_END + 9)
+#define IRQ_GPCIN0		(IRQ_BOARD_END + 10)
+#define IRQ_GPCIN1		(IRQ_BOARD_END + 11)
+#define IRQ_GPCIN2		(IRQ_BOARD_END + 12)
+#define IRQ_GPCIN3		(IRQ_BOARD_END + 13)
+#define IRQ_GPCIN4		(IRQ_BOARD_END + 14)
+#define IRQ_GPCIN5		(IRQ_BOARD_END + 15)
+#define IRQ_GPCIN6		(IRQ_BOARD_END + 16)
+#define IRQ_GPCIN7		(IRQ_BOARD_END + 17)
+#define IRQ_MSTXINT		(IRQ_BOARD_END + 18)
+#define IRQ_MSRXINT		(IRQ_BOARD_END + 19)
+#define IRQ_MSSTOPERRINT	(IRQ_BOARD_END + 20)
+#define IRQ_TPTXINT		(IRQ_BOARD_END + 21)
+#define IRQ_TPRXINT		(IRQ_BOARD_END + 22)
+#define IRQ_TPSTOPERRINT	(IRQ_BOARD_END + 23)
+#define SSPXMTINT		(IRQ_BOARD_END + 24)
+#define SSPRCVINT		(IRQ_BOARD_END + 25)
+#define SSPROR			(IRQ_BOARD_END + 26)
+#define AUDXMTDMADONEA		(IRQ_BOARD_END + 32)
+#define AUDRCVDMADONEA		(IRQ_BOARD_END + 33)
+#define AUDXMTDMADONEB		(IRQ_BOARD_END + 34)
+#define AUDRCVDMADONEB		(IRQ_BOARD_END + 35)
+#define AUDTFSR			(IRQ_BOARD_END + 36)
+#define AUDRFSR			(IRQ_BOARD_END + 37)
+#define AUDTUR			(IRQ_BOARD_END + 38)
+#define AUDROR			(IRQ_BOARD_END + 39)
+#define AUDDTS			(IRQ_BOARD_END + 40)
+#define AUDRDD			(IRQ_BOARD_END + 41)
+#define AUDSTO			(IRQ_BOARD_END + 42)
+#define IRQ_USBPWR		(IRQ_BOARD_END + 43)
+#define IRQ_HCIM		(IRQ_BOARD_END + 44)
+#define IRQ_HCIBUFFACC		(IRQ_BOARD_END + 45)
+#define IRQ_HCIRMTWKP		(IRQ_BOARD_END + 46)
+#define IRQ_NHCIMFCIR		(IRQ_BOARD_END + 47)
+#define IRQ_USB_PORT_RESUME	(IRQ_BOARD_END + 48)
+#define IRQ_S0_READY_NINT	(IRQ_BOARD_END + 49)
+#define IRQ_S1_READY_NINT	(IRQ_BOARD_END + 50)
+#define IRQ_S0_CD_VALID		(IRQ_BOARD_END + 51)
+#define IRQ_S1_CD_VALID		(IRQ_BOARD_END + 52)
+#define IRQ_S0_BVD1_STSCHG	(IRQ_BOARD_END + 53)
+#define IRQ_S1_BVD1_STSCHG	(IRQ_BOARD_END + 54)
+
+#define IRQ_LOCOMO_START	(IRQ_BOARD_END)
+#define IRQ_LOCOMO_KEY		(IRQ_BOARD_END + 0)
+#define IRQ_LOCOMO_GPIO0	(IRQ_BOARD_END + 1)
+#define IRQ_LOCOMO_GPIO1	(IRQ_BOARD_END + 2)
+#define IRQ_LOCOMO_GPIO2	(IRQ_BOARD_END + 3)
+#define IRQ_LOCOMO_GPIO3	(IRQ_BOARD_END + 4)
+#define IRQ_LOCOMO_GPIO4	(IRQ_BOARD_END + 5)
+#define IRQ_LOCOMO_GPIO5	(IRQ_BOARD_END + 6)
+#define IRQ_LOCOMO_GPIO6	(IRQ_BOARD_END + 7)
+#define IRQ_LOCOMO_GPIO7	(IRQ_BOARD_END + 8)
+#define IRQ_LOCOMO_GPIO8	(IRQ_BOARD_END + 9)
+#define IRQ_LOCOMO_GPIO9	(IRQ_BOARD_END + 10)
+#define IRQ_LOCOMO_GPIO10	(IRQ_BOARD_END + 11)
+#define IRQ_LOCOMO_GPIO11	(IRQ_BOARD_END + 12)
+#define IRQ_LOCOMO_GPIO12	(IRQ_BOARD_END + 13)
+#define IRQ_LOCOMO_GPIO13	(IRQ_BOARD_END + 14)
+#define IRQ_LOCOMO_GPIO14	(IRQ_BOARD_END + 15)
+#define IRQ_LOCOMO_GPIO15	(IRQ_BOARD_END + 16)
+#define IRQ_LOCOMO_LT		(IRQ_BOARD_END + 17)
+#define IRQ_LOCOMO_SPI_RFR	(IRQ_BOARD_END + 18)
+#define IRQ_LOCOMO_SPI_RFW	(IRQ_BOARD_END + 19)
+#define IRQ_LOCOMO_SPI_OVRN	(IRQ_BOARD_END + 20)
+#define IRQ_LOCOMO_SPI_TEND	(IRQ_BOARD_END + 21)
+
+/*
+ * Figure out the MAX IRQ number.
+ *
+ * If we have an SA1111, the max IRQ is S1_BVD1_STSCHG+1.
+ * If we have an LoCoMo, the max IRQ is IRQ_LOCOMO_SPI_TEND+1
+ * Otherwise, we have the standard IRQs only.
+ */
+#ifdef CONFIG_SA1111
+#define NR_IRQS			(IRQ_S1_BVD1_STSCHG + 1)
+#elif defined(CONFIG_SHARP_LOCOMO)
+#define NR_IRQS			(IRQ_LOCOMO_SPI_TEND + 1)
+#elif defined(CONFIG_ARCH_LUBBOCK) || \
+      defined(CONFIG_MACH_LOGICPD_PXA270) || \
+      defined(CONFIG_MACH_MAINSTONE)
+#define NR_IRQS			(IRQ_BOARD_END)
+#else
+#define NR_IRQS			(IRQ_BOARD_START)
+#endif
+
+/*
+ * Board specific IRQs.  Define them here.
+ * Do not surround them with ifdefs.
+ */
+#define LUBBOCK_IRQ(x)		(IRQ_BOARD_START + (x))
+#define LUBBOCK_SD_IRQ		LUBBOCK_IRQ(0)
+#define LUBBOCK_SA1111_IRQ	LUBBOCK_IRQ(1)
+#define LUBBOCK_USB_IRQ		LUBBOCK_IRQ(2)  /* usb connect */
+#define LUBBOCK_ETH_IRQ		LUBBOCK_IRQ(3)
+#define LUBBOCK_UCB1400_IRQ	LUBBOCK_IRQ(4)
+#define LUBBOCK_BB_IRQ		LUBBOCK_IRQ(5)
+#define LUBBOCK_USB_DISC_IRQ	LUBBOCK_IRQ(6)  /* usb disconnect */
+#define LUBBOCK_LAST_IRQ	LUBBOCK_IRQ(6)
+
+#define LPD270_IRQ(x)		(IRQ_BOARD_START + (x))
+#define LPD270_USBC_IRQ		LPD270_IRQ(2)
+#define LPD270_ETHERNET_IRQ	LPD270_IRQ(3)
+#define LPD270_AC97_IRQ		LPD270_IRQ(4)
+
+#define MAINSTONE_IRQ(x)	(IRQ_BOARD_START + (x))
+#define MAINSTONE_MMC_IRQ	MAINSTONE_IRQ(0)
+#define MAINSTONE_USIM_IRQ	MAINSTONE_IRQ(1)
+#define MAINSTONE_USBC_IRQ	MAINSTONE_IRQ(2)
+#define MAINSTONE_ETHERNET_IRQ	MAINSTONE_IRQ(3)
+#define MAINSTONE_AC97_IRQ	MAINSTONE_IRQ(4)
+#define MAINSTONE_PEN_IRQ	MAINSTONE_IRQ(5)
+#define MAINSTONE_MSINS_IRQ	MAINSTONE_IRQ(6)
+#define MAINSTONE_EXBRD_IRQ	MAINSTONE_IRQ(7)
+#define MAINSTONE_S0_CD_IRQ	MAINSTONE_IRQ(9)
+#define MAINSTONE_S0_STSCHG_IRQ	MAINSTONE_IRQ(10)
+#define MAINSTONE_S0_IRQ	MAINSTONE_IRQ(11)
+#define MAINSTONE_S1_CD_IRQ	MAINSTONE_IRQ(13)
+#define MAINSTONE_S1_STSCHG_IRQ	MAINSTONE_IRQ(14)
+#define MAINSTONE_S1_IRQ	MAINSTONE_IRQ(15)
+
+/* LoCoMo Interrupts (CONFIG_SHARP_LOCOMO) */
+#define IRQ_LOCOMO_KEY_BASE	(IRQ_BOARD_START + 0)
+#define IRQ_LOCOMO_GPIO_BASE	(IRQ_BOARD_START + 1)
+#define IRQ_LOCOMO_LT_BASE	(IRQ_BOARD_START + 2)
+#define IRQ_LOCOMO_SPI_BASE	(IRQ_BOARD_START + 3)
Index: build_tree/linux/include/asm/arch-pxa/lpd270.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/lpd270.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/lpd270.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * include/asm-arm/arch-pxa/lpd270.h
+ *
+ * Author:	Lennert Buytenhek
+ * Created:	Feb 10, 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_LPD270_H
+#define __ASM_ARCH_LPD270_H
+
+#define LPD270_CPLD_PHYS	PXA_CS2_PHYS
+#define LPD270_CPLD_VIRT	0xf0000000
+#define LPD270_CPLD_SIZE	0x00100000
+
+#define LPD270_ETH_PHYS		(PXA_CS2_PHYS + 0x01000000)
+
+/* CPLD registers  */
+#define LPD270_CPLD_REG(x)	((unsigned long)(LPD270_CPLD_VIRT + (x)))
+#define LPD270_CONTROL		LPD270_CPLD_REG(0x00)
+#define LPD270_PERIPHERAL0	LPD270_CPLD_REG(0x04)
+#define LPD270_PERIPHERAL1	LPD270_CPLD_REG(0x08)
+#define LPD270_CPLD_REVISION	LPD270_CPLD_REG(0x14)
+#define LPD270_EEPROM_SPI_ITF	LPD270_CPLD_REG(0x20)
+#define LPD270_MODE_PINS	LPD270_CPLD_REG(0x24)
+#define LPD270_EGPIO		LPD270_CPLD_REG(0x30)
+#define LPD270_INT_MASK		LPD270_CPLD_REG(0x40)
+#define LPD270_INT_STATUS	LPD270_CPLD_REG(0x50)
+
+#define LPD270_INT_AC97		(1 << 4)  /* AC'97 CODEC IRQ */
+#define LPD270_INT_ETHERNET	(1 << 3)  /* Ethernet controller IRQ */
+#define LPD270_INT_USBC		(1 << 2)  /* USB client cable detection IRQ */
+
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/lubbock.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/lubbock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/lubbock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/lubbock.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define LUBBOCK_ETH_PHYS	PXA_CS3_PHYS
+
+#define LUBBOCK_FPGA_PHYS	PXA_CS2_PHYS
+#define LUBBOCK_FPGA_VIRT	(0xf0000000)
+#define LUB_P2V(x)		((x) - LUBBOCK_FPGA_PHYS + LUBBOCK_FPGA_VIRT)
+#define LUB_V2P(x)		((x) - LUBBOCK_FPGA_VIRT + LUBBOCK_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __LUB_REG(x)		(*((volatile unsigned long *)LUB_P2V(x)))
+#else
+#  define __LUB_REG(x)		LUB_P2V(x)
+#endif
+
+/* FPGA register virtual addresses */
+#define LUB_WHOAMI		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x000)
+#define LUB_HEXLED		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x010)
+#define LUB_DISC_BLNK_LED	__LUB_REG(LUBBOCK_FPGA_PHYS + 0x040)
+#define LUB_CONF_SWITCHES	__LUB_REG(LUBBOCK_FPGA_PHYS + 0x050)
+#define LUB_USER_SWITCHES	__LUB_REG(LUBBOCK_FPGA_PHYS + 0x060)
+#define LUB_MISC_WR		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x080)
+#define LUB_MISC_RD		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x090)
+#define LUB_IRQ_MASK_EN		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x0c0)
+#define LUB_IRQ_SET_CLR		__LUB_REG(LUBBOCK_FPGA_PHYS + 0x0d0)
+#define LUB_GP			__LUB_REG(LUBBOCK_FPGA_PHYS + 0x100)
+
+#ifndef __ASSEMBLY__
+extern void lubbock_set_misc_wr(unsigned int mask, unsigned int set);
+#endif
Index: build_tree/linux/include/asm/arch-pxa/mainstone.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/mainstone.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/mainstone.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,120 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/mainstone.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Nov 14, 2002
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef ASM_ARCH_MAINSTONE_H
+#define ASM_ARCH_MAINSTONE_H
+
+#define MST_ETH_PHYS		PXA_CS4_PHYS
+
+#define MST_FPGA_PHYS		PXA_CS2_PHYS
+#define MST_FPGA_VIRT		(0xf0000000)
+#define MST_P2V(x)		((x) - MST_FPGA_PHYS + MST_FPGA_VIRT)
+#define MST_V2P(x)		((x) - MST_FPGA_VIRT + MST_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+# define __MST_REG(x)		(*((volatile unsigned long *)MST_P2V(x)))
+#else
+# define __MST_REG(x)		MST_P2V(x)
+#endif
+
+/* board level registers in the FPGA */
+
+#define MST_LEDDAT1		__MST_REG(0x08000010)
+#define MST_LEDDAT2		__MST_REG(0x08000014)
+#define MST_LEDCTRL		__MST_REG(0x08000040)
+#define MST_GPSWR		__MST_REG(0x08000060)
+#define MST_MSCWR1		__MST_REG(0x08000080)
+#define MST_MSCWR2		__MST_REG(0x08000084)
+#define MST_MSCWR3		__MST_REG(0x08000088)
+#define MST_MSCRD		__MST_REG(0x08000090)
+#define MST_INTMSKENA		__MST_REG(0x080000c0)
+#define MST_INTSETCLR		__MST_REG(0x080000d0)
+#define MST_PCMCIA0		__MST_REG(0x080000e0)
+#define MST_PCMCIA1		__MST_REG(0x080000e4)
+
+#define MST_MSCWR1_CAMERA_ON	(1 << 15)  /* Camera interface power control */
+#define MST_MSCWR1_CAMERA_SEL	(1 << 14)  /* Camera interface mux control */
+#define MST_MSCWR1_LCD_CTL	(1 << 13)  /* General-purpose LCD control */
+#define MST_MSCWR1_MS_ON	(1 << 12)  /* Memory Stick power control */
+#define MST_MSCWR1_MMC_ON	(1 << 11)  /* MultiMediaCard* power control */
+#define MST_MSCWR1_MS_SEL	(1 << 10)  /* SD/MS multiplexer control */
+#define MST_MSCWR1_BB_SEL	(1 << 9)   /* PCMCIA/Baseband multiplexer */
+#define MST_MSCWR1_BT_ON	(1 << 8)   /* Bluetooth UART transceiver */
+#define MST_MSCWR1_BTDTR	(1 << 7)   /* Bluetooth UART DTR */
+
+#define MST_MSCWR1_IRDA_MASK	(3 << 5)   /* IrDA transceiver mode */
+#define MST_MSCWR1_IRDA_FULL	(0 << 5)   /* full distance power */
+#define MST_MSCWR1_IRDA_OFF	(1 << 5)   /* shutdown */
+#define MST_MSCWR1_IRDA_MED	(2 << 5)   /* 2/3 distance power */
+#define MST_MSCWR1_IRDA_LOW	(3 << 5)   /* 1/3 distance power */
+
+#define MST_MSCWR1_IRDA_FIR	(1 << 4)   /* IrDA transceiver SIR/FIR */
+#define MST_MSCWR1_GREENLED	(1 << 3)   /* LED D1 control */
+#define MST_MSCWR1_PDC_CTL	(1 << 2)   /* reserved */
+#define MST_MSCWR1_MTR_ON	(1 << 1)   /* Silent alert motor */
+#define MST_MSCWR1_SYSRESET	(1 << 0)   /* System reset */
+
+#define MST_MSCWR2_USB_OTG_RST	(1 << 6)   /* USB On The Go reset */
+#define MST_MSCWR2_USB_OTG_SEL	(1 << 5)   /* USB On The Go control */
+#define MST_MSCWR2_nUSBC_SC	(1 << 4)   /* USB client soft connect control */
+#define MST_MSCWR2_I2S_SPKROFF	(1 << 3)   /* I2S CODEC amplifier control */
+#define MST_MSCWR2_AC97_SPKROFF	(1 << 2)   /* AC97 CODEC amplifier control */
+#define MST_MSCWR2_RADIO_PWR	(1 << 1)   /* Radio module power control */
+#define MST_MSCWR2_RADIO_WAKE	(1 << 0)   /* Radio module wake-up signal */
+
+#define MST_MSCWR3_GPIO_RESET_EN	(1 << 2) /* Enable GPIO Reset */
+#define MST_MSCWR3_GPIO_RESET		(1 << 1) /* Initiate a GPIO Reset */
+#define MST_MSCWR3_COMMS_SW_RESET	(1 << 0) /* Communications Processor Reset Control */
+
+#define MST_MSCRD_nPENIRQ	(1 << 9)   /* ADI7873* nPENIRQ signal */
+#define MST_MSCRD_nMEMSTK_CD	(1 << 8)   /* Memory Stick detection signal */
+#define MST_MSCRD_nMMC_CD	(1 << 7)   /* SD/MMC card detection signal */
+#define MST_MSCRD_nUSIM_CD	(1 << 6)   /* USIM card detection signal */
+#define MST_MSCRD_USB_CBL	(1 << 5)   /* USB client cable status */
+#define MST_MSCRD_TS_BUSY	(1 << 4)   /* ADI7873 busy */
+#define MST_MSCRD_BTDSR		(1 << 3)   /* Bluetooth UART DSR */
+#define MST_MSCRD_BTRI		(1 << 2)   /* Bluetooth UART Ring Indicator */
+#define MST_MSCRD_BTDCD		(1 << 1)   /* Bluetooth UART DCD */
+#define MST_MSCRD_nMMC_WP	(1 << 0)   /* SD/MMC write-protect status */
+
+#define MST_INT_S1_IRQ		(1 << 15)  /* PCMCIA socket 1 IRQ */
+#define MST_INT_S1_STSCHG	(1 << 14)  /* PCMCIA socket 1 status changed */
+#define MST_INT_S1_CD		(1 << 13)  /* PCMCIA socket 1 card detection */
+#define MST_INT_S0_IRQ		(1 << 11)  /* PCMCIA socket 0 IRQ */
+#define MST_INT_S0_STSCHG	(1 << 10)  /* PCMCIA socket 0 status changed */
+#define MST_INT_S0_CD		(1 << 9)   /* PCMCIA socket 0 card detection */
+#define MST_INT_nEXBRD_INT	(1 << 7)   /* Expansion board IRQ */
+#define MST_INT_MSINS		(1 << 6)   /* Memory Stick* detection */
+#define MST_INT_PENIRQ		(1 << 5)   /* ADI7873* touch-screen IRQ */
+#define MST_INT_AC97		(1 << 4)   /* AC'97 CODEC IRQ */
+#define MST_INT_ETHERNET	(1 << 3)   /* Ethernet controller IRQ */
+#define MST_INT_USBC		(1 << 2)   /* USB client cable detection IRQ */
+#define MST_INT_USIM		(1 << 1)   /* USIM card detection IRQ */
+#define MST_INT_MMC		(1 << 0)   /* MMC/SD card detection IRQ */
+
+#define MST_PCMCIA_nIRQ		(1 << 10)  /* IRQ / ready signal */
+#define MST_PCMCIA_nSPKR_BVD2	(1 << 9)   /* VDD sense / digital speaker */
+#define MST_PCMCIA_nSTSCHG_BVD1	(1 << 8)   /* VDD sense / card status changed */
+#define MST_PCMCIA_nVS2		(1 << 7)   /* VSS voltage sense */
+#define MST_PCMCIA_nVS1		(1 << 6)   /* VSS voltage sense */
+#define MST_PCMCIA_nCD		(1 << 5)   /* Card detection signal */
+#define MST_PCMCIA_RESET	(1 << 4)   /* Card reset signal */
+#define MST_PCMCIA_PWR_MASK	(0x000f)   /* MAX1602 power-supply controls */
+
+#define MST_PCMCIA_PWR_VPP_0    0x0	   /* voltage VPP = 0V */
+#define MST_PCMCIA_PWR_VPP_120  0x2 	   /* voltage VPP = 12V*/
+#define MST_PCMCIA_PWR_VPP_VCC  0x1	   /* voltage VPP = VCC */
+#define MST_PCMCIA_PWR_VCC_0    0x0	   /* voltage VCC = 0V */
+#define MST_PCMCIA_PWR_VCC_33   0x8	   /* voltage VCC = 3.3V */
+#define MST_PCMCIA_PWR_VCC_50   0x4	   /* voltage VCC = 5.0V */
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/memory.h
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0xa0000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+/*
+ * The nodes are matched with the physical SDRAM banks as follows:
+ *
+ * 	node 0:  0xa0000000-0xa3ffffff	-->  0xc0000000-0xc3ffffff
+ * 	node 1:  0xa4000000-0xa7ffffff	-->  0xc4000000-0xc7ffffff
+ * 	node 2:  0xa8000000-0xabffffff	-->  0xc8000000-0xcbffffff
+ * 	node 3:  0xac000000-0xafffffff	-->  0xcc000000-0xcfffffff
+ *
+ * This needs a node mem size of 26 bits.
+ */
+#define NODE_MEM_SIZE_BITS	26
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/mmc.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/mmc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/mmc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+#ifndef ASMARM_ARCH_MMC_H
+#define ASMARM_ARCH_MMC_H
+
+#include <linux/mmc/protocol.h>
+#include <linux/interrupt.h>
+
+struct device;
+struct mmc_host;
+
+struct pxamci_platform_data {
+	unsigned int ocr_mask;			/* available voltages */
+	unsigned long detect_delay;		/* delay in jiffies before detecting cards after interrupt */
+	int (*init)(struct device *, irq_handler_t , void *);
+	int (*get_ro)(struct device *);
+	void (*setpower)(struct device *, unsigned int);
+	void (*exit)(struct device *, void *);
+};
+
+extern void pxa_set_mci_info(struct pxamci_platform_data *info);
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/mtd-xip.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/mtd-xip.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/mtd-xip.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * MTD primitives for XIP support. Architecture specific functions
+ *
+ * Do not include this file directly. It's included from linux/mtd/xip.h
+ * 
+ * Author:	Nicolas Pitre
+ * Created:	Nov 2, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * $Id: xip.h,v 1.2 2004/12/01 15:49:10 nico Exp $
+ */
+
+#ifndef __ARCH_PXA_MTD_XIP_H__
+#define __ARCH_PXA_MTD_XIP_H__
+
+#include <asm/arch/pxa-regs.h>
+
+#define xip_irqpending()	(ICIP & ICMR)
+
+/* we sample OSCR and convert desired delta to usec (1/4 ~= 1000000/3686400) */
+#define xip_currtime()		(OSCR)
+#define xip_elapsed_since(x)	(signed)((OSCR - (x)) / 4)
+
+/*
+ * xip_cpu_idle() is used when waiting for a delay equal or larger than
+ * the system timer tick period.  This should put the CPU into idle mode
+ * to save power and to be woken up only when some interrupts are pending.
+ * As above, this should not rely upon standard kernel code.
+ */
+
+#define xip_cpu_idle()  asm volatile ("mcr p14, 0, %0, c7, c0, 0" :: "r" (1))
+
+#endif /* __ARCH_PXA_MTD_XIP_H__ */
Index: build_tree/linux/include/asm/arch-pxa/ohci.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/ohci.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/ohci.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+#ifndef ASMARM_ARCH_OHCI_H
+#define ASMARM_ARCH_OHCI_H
+
+struct device;
+
+struct pxaohci_platform_data {
+	int (*init)(struct device *);
+	void (*exit)(struct device *);
+
+	int port_mode;
+#define PMM_NPS_MODE           1
+#define PMM_GLOBAL_MODE        2
+#define PMM_PERPORT_MODE       3
+
+	int power_budget;
+};
+
+extern void pxa_set_ohci_info(struct pxaohci_platform_data *info);
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/pm.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/pm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/pm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2005 Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+extern int pxa_pm_prepare(suspend_state_t state);
+extern int pxa_pm_enter(suspend_state_t state);
+extern int pxa_pm_finish(suspend_state_t state);
Index: build_tree/linux/include/asm/arch-pxa/poodle.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/poodle.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/poodle.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,75 @@
+/*
+ * linux/include/asm-arm/arch-pxa/poodle.h
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Based on:
+ *   linux/include/asm-arm/arch-sa1100/collie.h
+ *
+ * ChangeLog:
+ *   04-06-2001 Lineo Japan, Inc.
+ *   04-16-2001 SHARP Corporation
+ *   Update to 2.6 John Lenz
+ */
+#ifndef __ASM_ARCH_POODLE_H
+#define __ASM_ARCH_POODLE_H  1
+
+/*
+ * GPIOs
+ */
+/* PXA GPIOs */
+#define POODLE_GPIO_ON_KEY		(0)
+#define POODLE_GPIO_AC_IN		(1)
+#define POODLE_GPIO_CO			16
+#define POODLE_GPIO_TP_INT		(5)
+#define POODLE_GPIO_WAKEUP		(11)	/* change battery */
+#define POODLE_GPIO_GA_INT		(10)
+#define POODLE_GPIO_IR_ON		(22)
+#define POODLE_GPIO_HP_IN		(4)
+#define POODLE_GPIO_CF_IRQ		(17)
+#define POODLE_GPIO_CF_CD		(14)
+#define POODLE_GPIO_CF_STSCHG		(14)
+#define POODLE_GPIO_SD_PWR		(33)
+#define POODLE_GPIO_SD_PWR1		(3)
+#define POODLE_GPIO_nSD_CLK		(6)
+#define POODLE_GPIO_nSD_WP		(7)
+#define POODLE_GPIO_nSD_INT		(8)
+#define POODLE_GPIO_nSD_DETECT		(9)
+#define POODLE_GPIO_MAIN_BAT_LOW	(13)
+#define POODLE_GPIO_BAT_COVER		(13)
+#define POODLE_GPIO_USB_PULLUP		(20)
+#define POODLE_GPIO_ADC_TEMP_ON		(21)
+#define POODLE_GPIO_BYPASS_ON		(36)
+#define POODLE_GPIO_CHRG_ON		(38)
+#define POODLE_GPIO_CHRG_FULL		(16)
+#define POODLE_GPIO_DISCHARGE_ON        (42) /* Enable battery discharge */
+
+/* PXA GPIOs */
+#define POODLE_IRQ_GPIO_ON_KEY		IRQ_GPIO(0)
+#define POODLE_IRQ_GPIO_AC_IN		IRQ_GPIO(1)
+#define POODLE_IRQ_GPIO_HP_IN		IRQ_GPIO(4)
+#define POODLE_IRQ_GPIO_CO		IRQ_GPIO(16)
+#define POODLE_IRQ_GPIO_TP_INT		IRQ_GPIO(5)
+#define POODLE_IRQ_GPIO_WAKEUP		IRQ_GPIO(11)
+#define POODLE_IRQ_GPIO_GA_INT		IRQ_GPIO(10)
+#define POODLE_IRQ_GPIO_CF_IRQ		IRQ_GPIO(17)
+#define POODLE_IRQ_GPIO_CF_CD		IRQ_GPIO(14)
+#define POODLE_IRQ_GPIO_nSD_INT		IRQ_GPIO(8)
+#define POODLE_IRQ_GPIO_nSD_DETECT	IRQ_GPIO(9)
+#define POODLE_IRQ_GPIO_MAIN_BAT_LOW	IRQ_GPIO(13)
+
+/* SCOOP GPIOs */
+#define POODLE_SCOOP_CHARGE_ON	SCOOP_GPCR_PA11
+#define POODLE_SCOOP_CP401	SCOOP_GPCR_PA13
+#define POODLE_SCOOP_VPEN	SCOOP_GPCR_PA18
+#define POODLE_SCOOP_L_PCLK	SCOOP_GPCR_PA20
+#define POODLE_SCOOP_L_LCLK	SCOOP_GPCR_PA21
+#define POODLE_SCOOP_HS_OUT	SCOOP_GPCR_PA22
+
+#define POODLE_SCOOP_IO_DIR	( POODLE_SCOOP_VPEN | POODLE_SCOOP_HS_OUT )
+#define POODLE_SCOOP_IO_OUT	( 0 )
+
+extern struct platform_device poodle_locomo_device;
+
+#endif /* __ASM_ARCH_POODLE_H  */
Index: build_tree/linux/include/asm/arch-pxa/pxa-regs.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/pxa-regs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/pxa-regs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,2369 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/pxa-regs.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __PXA_REGS_H
+#define __PXA_REGS_H
+
+
+/*
+ * PXA Chip selects
+ */
+
+#define PXA_CS0_PHYS	0x00000000
+#define PXA_CS1_PHYS	0x04000000
+#define PXA_CS2_PHYS	0x08000000
+#define PXA_CS3_PHYS	0x0C000000
+#define PXA_CS4_PHYS	0x10000000
+#define PXA_CS5_PHYS	0x14000000
+
+
+/*
+ * Personal Computer Memory Card International Association (PCMCIA) sockets
+ */
+
+#define PCMCIAPrtSp	0x04000000	/* PCMCIA Partition Space [byte]   */
+#define PCMCIASp	(4*PCMCIAPrtSp)	/* PCMCIA Space [byte]             */
+#define PCMCIAIOSp	PCMCIAPrtSp	/* PCMCIA I/O Space [byte]         */
+#define PCMCIAAttrSp	PCMCIAPrtSp	/* PCMCIA Attribute Space [byte]   */
+#define PCMCIAMemSp	PCMCIAPrtSp	/* PCMCIA Memory Space [byte]      */
+
+#define PCMCIA0Sp	PCMCIASp	/* PCMCIA 0 Space [byte]           */
+#define PCMCIA0IOSp	PCMCIAIOSp	/* PCMCIA 0 I/O Space [byte]       */
+#define PCMCIA0AttrSp	PCMCIAAttrSp	/* PCMCIA 0 Attribute Space [byte] */
+#define PCMCIA0MemSp	PCMCIAMemSp	/* PCMCIA 0 Memory Space [byte]    */
+
+#define PCMCIA1Sp	PCMCIASp	/* PCMCIA 1 Space [byte]           */
+#define PCMCIA1IOSp	PCMCIAIOSp	/* PCMCIA 1 I/O Space [byte]       */
+#define PCMCIA1AttrSp	PCMCIAAttrSp	/* PCMCIA 1 Attribute Space [byte] */
+#define PCMCIA1MemSp	PCMCIAMemSp	/* PCMCIA 1 Memory Space [byte]    */
+
+#define _PCMCIA(Nb)	        	/* PCMCIA [0..1]                   */ \
+                	(0x20000000 + (Nb)*PCMCIASp)
+#define _PCMCIAIO(Nb)	_PCMCIA (Nb)	/* PCMCIA I/O [0..1]               */
+#define _PCMCIAAttr(Nb)	        	/* PCMCIA Attribute [0..1]         */ \
+                	(_PCMCIA (Nb) + 2*PCMCIAPrtSp)
+#define _PCMCIAMem(Nb)	        	/* PCMCIA Memory [0..1]            */ \
+                	(_PCMCIA (Nb) + 3*PCMCIAPrtSp)
+
+#define _PCMCIA0	_PCMCIA (0)	/* PCMCIA 0                        */
+#define _PCMCIA0IO	_PCMCIAIO (0)	/* PCMCIA 0 I/O                    */
+#define _PCMCIA0Attr	_PCMCIAAttr (0)	/* PCMCIA 0 Attribute              */
+#define _PCMCIA0Mem	_PCMCIAMem (0)	/* PCMCIA 0 Memory                 */
+
+#define _PCMCIA1	_PCMCIA (1)	/* PCMCIA 1                        */
+#define _PCMCIA1IO	_PCMCIAIO (1)	/* PCMCIA 1 I/O                    */
+#define _PCMCIA1Attr	_PCMCIAAttr (1)	/* PCMCIA 1 Attribute              */
+#define _PCMCIA1Mem	_PCMCIAMem (1)	/* PCMCIA 1 Memory                 */
+
+
+
+/*
+ * DMA Controller
+ */
+
+#define DCSR0		__REG(0x40000000)  /* DMA Control / Status Register for Channel 0 */
+#define DCSR1		__REG(0x40000004)  /* DMA Control / Status Register for Channel 1 */
+#define DCSR2		__REG(0x40000008)  /* DMA Control / Status Register for Channel 2 */
+#define DCSR3		__REG(0x4000000c)  /* DMA Control / Status Register for Channel 3 */
+#define DCSR4		__REG(0x40000010)  /* DMA Control / Status Register for Channel 4 */
+#define DCSR5		__REG(0x40000014)  /* DMA Control / Status Register for Channel 5 */
+#define DCSR6		__REG(0x40000018)  /* DMA Control / Status Register for Channel 6 */
+#define DCSR7		__REG(0x4000001c)  /* DMA Control / Status Register for Channel 7 */
+#define DCSR8		__REG(0x40000020)  /* DMA Control / Status Register for Channel 8 */
+#define DCSR9		__REG(0x40000024)  /* DMA Control / Status Register for Channel 9 */
+#define DCSR10		__REG(0x40000028)  /* DMA Control / Status Register for Channel 10 */
+#define DCSR11		__REG(0x4000002c)  /* DMA Control / Status Register for Channel 11 */
+#define DCSR12		__REG(0x40000030)  /* DMA Control / Status Register for Channel 12 */
+#define DCSR13		__REG(0x40000034)  /* DMA Control / Status Register for Channel 13 */
+#define DCSR14		__REG(0x40000038)  /* DMA Control / Status Register for Channel 14 */
+#define DCSR15		__REG(0x4000003c)  /* DMA Control / Status Register for Channel 15 */
+
+#define DCSR(x)		__REG2(0x40000000, (x) << 2)
+
+#define DCSR_RUN	(1 << 31)	/* Run Bit (read / write) */
+#define DCSR_NODESC	(1 << 30)	/* No-Descriptor Fetch (read / write) */
+#define DCSR_STOPIRQEN	(1 << 29)	/* Stop Interrupt Enable (read / write) */
+#ifdef CONFIG_PXA27x
+#define DCSR_EORIRQEN	(1 << 28)       /* End of Receive Interrupt Enable (R/W) */
+#define DCSR_EORJMPEN	(1 << 27)       /* Jump to next descriptor on EOR */
+#define DCSR_EORSTOPEN	(1 << 26)       /* STOP on an EOR */
+#define DCSR_SETCMPST	(1 << 25)       /* Set Descriptor Compare Status */
+#define DCSR_CLRCMPST	(1 << 24)       /* Clear Descriptor Compare Status */
+#define DCSR_CMPST	(1 << 10)       /* The Descriptor Compare Status */
+#define DCSR_EORINTR	(1 << 9)        /* The end of Receive */
+#endif
+#define DCSR_REQPEND	(1 << 8)	/* Request Pending (read-only) */
+#define DCSR_STOPSTATE	(1 << 3)	/* Stop State (read-only) */
+#define DCSR_ENDINTR	(1 << 2)	/* End Interrupt (read / write) */
+#define DCSR_STARTINTR	(1 << 1)	/* Start Interrupt (read / write) */
+#define DCSR_BUSERR	(1 << 0)	/* Bus Error Interrupt (read / write) */
+
+#define DALGN		__REG(0x400000a0)  /* DMA Alignment Register */
+#define DINT		__REG(0x400000f0)  /* DMA Interrupt Register */
+
+#define DRCMR(n)	__REG2(0x40000100, (n)<<2)
+#define DRCMR0		__REG(0x40000100)  /* Request to Channel Map Register for DREQ 0 */
+#define DRCMR1		__REG(0x40000104)  /* Request to Channel Map Register for DREQ 1 */
+#define DRCMR2		__REG(0x40000108)  /* Request to Channel Map Register for I2S receive Request */
+#define DRCMR3		__REG(0x4000010c)  /* Request to Channel Map Register for I2S transmit Request */
+#define DRCMR4		__REG(0x40000110)  /* Request to Channel Map Register for BTUART receive Request */
+#define DRCMR5		__REG(0x40000114)  /* Request to Channel Map Register for BTUART transmit Request. */
+#define DRCMR6		__REG(0x40000118)  /* Request to Channel Map Register for FFUART receive Request */
+#define DRCMR7		__REG(0x4000011c)  /* Request to Channel Map Register for FFUART transmit Request */
+#define DRCMR8		__REG(0x40000120)  /* Request to Channel Map Register for AC97 microphone Request */
+#define DRCMR9		__REG(0x40000124)  /* Request to Channel Map Register for AC97 modem receive Request */
+#define DRCMR10		__REG(0x40000128)  /* Request to Channel Map Register for AC97 modem transmit Request */
+#define DRCMR11		__REG(0x4000012c)  /* Request to Channel Map Register for AC97 audio receive Request */
+#define DRCMR12		__REG(0x40000130)  /* Request to Channel Map Register for AC97 audio transmit Request */
+#define DRCMR13		__REG(0x40000134)  /* Request to Channel Map Register for SSP receive Request */
+#define DRCMR14		__REG(0x40000138)  /* Request to Channel Map Register for SSP transmit Request */
+#define DRCMR15		__REG(0x4000013c)  /* Request to Channel Map Register for SSP2 receive Request */
+#define DRCMR16		__REG(0x40000140)  /* Request to Channel Map Register for SSP2 transmit Request */
+#define DRCMR17		__REG(0x40000144)  /* Request to Channel Map Register for ICP receive Request */
+#define DRCMR18		__REG(0x40000148)  /* Request to Channel Map Register for ICP transmit Request */
+#define DRCMR19		__REG(0x4000014c)  /* Request to Channel Map Register for STUART receive Request */
+#define DRCMR20		__REG(0x40000150)  /* Request to Channel Map Register for STUART transmit Request */
+#define DRCMR21		__REG(0x40000154)  /* Request to Channel Map Register for MMC receive Request */
+#define DRCMR22		__REG(0x40000158)  /* Request to Channel Map Register for MMC transmit Request */
+#define DRCMR23		__REG(0x4000015c)  /* Reserved */
+#define DRCMR24		__REG(0x40000160)  /* Reserved */
+#define DRCMR25		__REG(0x40000164)  /* Request to Channel Map Register for USB endpoint 1 Request */
+#define DRCMR26		__REG(0x40000168)  /* Request to Channel Map Register for USB endpoint 2 Request */
+#define DRCMR27		__REG(0x4000016C)  /* Request to Channel Map Register for USB endpoint 3 Request */
+#define DRCMR28		__REG(0x40000170)  /* Request to Channel Map Register for USB endpoint 4 Request */
+#define DRCMR29		__REG(0x40000174)  /* Reserved */
+#define DRCMR30		__REG(0x40000178)  /* Request to Channel Map Register for USB endpoint 6 Request */
+#define DRCMR31		__REG(0x4000017C)  /* Request to Channel Map Register for USB endpoint 7 Request */
+#define DRCMR32		__REG(0x40000180)  /* Request to Channel Map Register for USB endpoint 8 Request */
+#define DRCMR33		__REG(0x40000184)  /* Request to Channel Map Register for USB endpoint 9 Request */
+#define DRCMR34		__REG(0x40000188)  /* Reserved */
+#define DRCMR35		__REG(0x4000018C)  /* Request to Channel Map Register for USB endpoint 11 Request */
+#define DRCMR36		__REG(0x40000190)  /* Request to Channel Map Register for USB endpoint 12 Request */
+#define DRCMR37		__REG(0x40000194)  /* Request to Channel Map Register for USB endpoint 13 Request */
+#define DRCMR38		__REG(0x40000198)  /* Request to Channel Map Register for USB endpoint 14 Request */
+#define DRCMR39		__REG(0x4000019C)  /* Reserved */
+#define DRCMR66		__REG(0x40001108)  /* Request to Channel Map Register for SSP3 receive Request */
+#define DRCMR67		__REG(0x4000110C)  /* Request to Channel Map Register for SSP3 transmit Request */
+#define DRCMR68		__REG(0x40001110)  /* Request to Channel Map Register for Camera FIFO 0 Request */
+#define DRCMR69		__REG(0x40001114)  /* Request to Channel Map Register for Camera FIFO 1 Request */
+#define DRCMR70		__REG(0x40001118)  /* Request to Channel Map Register for Camera FIFO 2 Request */
+
+#define DRCMRRXSADR	DRCMR2
+#define DRCMRTXSADR	DRCMR3
+#define DRCMRRXBTRBR	DRCMR4
+#define DRCMRTXBTTHR	DRCMR5
+#define DRCMRRXFFRBR	DRCMR6
+#define DRCMRTXFFTHR	DRCMR7
+#define DRCMRRXMCDR	DRCMR8
+#define DRCMRRXMODR	DRCMR9
+#define DRCMRTXMODR	DRCMR10
+#define DRCMRRXPCDR	DRCMR11
+#define DRCMRTXPCDR	DRCMR12
+#define DRCMRRXSSDR	DRCMR13
+#define DRCMRTXSSDR	DRCMR14
+#define DRCMRRXSS2DR   DRCMR15
+#define DRCMRTXSS2DR   DRCMR16
+#define DRCMRRXICDR	DRCMR17
+#define DRCMRTXICDR	DRCMR18
+#define DRCMRRXSTRBR	DRCMR19
+#define DRCMRTXSTTHR	DRCMR20
+#define DRCMRRXMMC	DRCMR21
+#define DRCMRTXMMC	DRCMR22
+#define DRCMRRXSS3DR   DRCMR66
+#define DRCMRTXSS3DR   DRCMR67
+#define DRCMRUDC(x)	DRCMR((x) + 24)
+
+#define DRCMR_MAPVLD	(1 << 7)	/* Map Valid (read / write) */
+#define DRCMR_CHLNUM	0x1f		/* mask for Channel Number (read / write) */
+
+#define DDADR0		__REG(0x40000200)  /* DMA Descriptor Address Register Channel 0 */
+#define DSADR0		__REG(0x40000204)  /* DMA Source Address Register Channel 0 */
+#define DTADR0		__REG(0x40000208)  /* DMA Target Address Register Channel 0 */
+#define DCMD0		__REG(0x4000020c)  /* DMA Command Address Register Channel 0 */
+#define DDADR1		__REG(0x40000210)  /* DMA Descriptor Address Register Channel 1 */
+#define DSADR1		__REG(0x40000214)  /* DMA Source Address Register Channel 1 */
+#define DTADR1		__REG(0x40000218)  /* DMA Target Address Register Channel 1 */
+#define DCMD1		__REG(0x4000021c)  /* DMA Command Address Register Channel 1 */
+#define DDADR2		__REG(0x40000220)  /* DMA Descriptor Address Register Channel 2 */
+#define DSADR2		__REG(0x40000224)  /* DMA Source Address Register Channel 2 */
+#define DTADR2		__REG(0x40000228)  /* DMA Target Address Register Channel 2 */
+#define DCMD2		__REG(0x4000022c)  /* DMA Command Address Register Channel 2 */
+#define DDADR3		__REG(0x40000230)  /* DMA Descriptor Address Register Channel 3 */
+#define DSADR3		__REG(0x40000234)  /* DMA Source Address Register Channel 3 */
+#define DTADR3		__REG(0x40000238)  /* DMA Target Address Register Channel 3 */
+#define DCMD3		__REG(0x4000023c)  /* DMA Command Address Register Channel 3 */
+#define DDADR4		__REG(0x40000240)  /* DMA Descriptor Address Register Channel 4 */
+#define DSADR4		__REG(0x40000244)  /* DMA Source Address Register Channel 4 */
+#define DTADR4		__REG(0x40000248)  /* DMA Target Address Register Channel 4 */
+#define DCMD4		__REG(0x4000024c)  /* DMA Command Address Register Channel 4 */
+#define DDADR5		__REG(0x40000250)  /* DMA Descriptor Address Register Channel 5 */
+#define DSADR5		__REG(0x40000254)  /* DMA Source Address Register Channel 5 */
+#define DTADR5		__REG(0x40000258)  /* DMA Target Address Register Channel 5 */
+#define DCMD5		__REG(0x4000025c)  /* DMA Command Address Register Channel 5 */
+#define DDADR6		__REG(0x40000260)  /* DMA Descriptor Address Register Channel 6 */
+#define DSADR6		__REG(0x40000264)  /* DMA Source Address Register Channel 6 */
+#define DTADR6		__REG(0x40000268)  /* DMA Target Address Register Channel 6 */
+#define DCMD6		__REG(0x4000026c)  /* DMA Command Address Register Channel 6 */
+#define DDADR7		__REG(0x40000270)  /* DMA Descriptor Address Register Channel 7 */
+#define DSADR7		__REG(0x40000274)  /* DMA Source Address Register Channel 7 */
+#define DTADR7		__REG(0x40000278)  /* DMA Target Address Register Channel 7 */
+#define DCMD7		__REG(0x4000027c)  /* DMA Command Address Register Channel 7 */
+#define DDADR8		__REG(0x40000280)  /* DMA Descriptor Address Register Channel 8 */
+#define DSADR8		__REG(0x40000284)  /* DMA Source Address Register Channel 8 */
+#define DTADR8		__REG(0x40000288)  /* DMA Target Address Register Channel 8 */
+#define DCMD8		__REG(0x4000028c)  /* DMA Command Address Register Channel 8 */
+#define DDADR9		__REG(0x40000290)  /* DMA Descriptor Address Register Channel 9 */
+#define DSADR9		__REG(0x40000294)  /* DMA Source Address Register Channel 9 */
+#define DTADR9		__REG(0x40000298)  /* DMA Target Address Register Channel 9 */
+#define DCMD9		__REG(0x4000029c)  /* DMA Command Address Register Channel 9 */
+#define DDADR10		__REG(0x400002a0)  /* DMA Descriptor Address Register Channel 10 */
+#define DSADR10		__REG(0x400002a4)  /* DMA Source Address Register Channel 10 */
+#define DTADR10		__REG(0x400002a8)  /* DMA Target Address Register Channel 10 */
+#define DCMD10		__REG(0x400002ac)  /* DMA Command Address Register Channel 10 */
+#define DDADR11		__REG(0x400002b0)  /* DMA Descriptor Address Register Channel 11 */
+#define DSADR11		__REG(0x400002b4)  /* DMA Source Address Register Channel 11 */
+#define DTADR11		__REG(0x400002b8)  /* DMA Target Address Register Channel 11 */
+#define DCMD11		__REG(0x400002bc)  /* DMA Command Address Register Channel 11 */
+#define DDADR12		__REG(0x400002c0)  /* DMA Descriptor Address Register Channel 12 */
+#define DSADR12		__REG(0x400002c4)  /* DMA Source Address Register Channel 12 */
+#define DTADR12		__REG(0x400002c8)  /* DMA Target Address Register Channel 12 */
+#define DCMD12		__REG(0x400002cc)  /* DMA Command Address Register Channel 12 */
+#define DDADR13		__REG(0x400002d0)  /* DMA Descriptor Address Register Channel 13 */
+#define DSADR13		__REG(0x400002d4)  /* DMA Source Address Register Channel 13 */
+#define DTADR13		__REG(0x400002d8)  /* DMA Target Address Register Channel 13 */
+#define DCMD13		__REG(0x400002dc)  /* DMA Command Address Register Channel 13 */
+#define DDADR14		__REG(0x400002e0)  /* DMA Descriptor Address Register Channel 14 */
+#define DSADR14		__REG(0x400002e4)  /* DMA Source Address Register Channel 14 */
+#define DTADR14		__REG(0x400002e8)  /* DMA Target Address Register Channel 14 */
+#define DCMD14		__REG(0x400002ec)  /* DMA Command Address Register Channel 14 */
+#define DDADR15		__REG(0x400002f0)  /* DMA Descriptor Address Register Channel 15 */
+#define DSADR15		__REG(0x400002f4)  /* DMA Source Address Register Channel 15 */
+#define DTADR15		__REG(0x400002f8)  /* DMA Target Address Register Channel 15 */
+#define DCMD15		__REG(0x400002fc)  /* DMA Command Address Register Channel 15 */
+
+#define DDADR(x)	__REG2(0x40000200, (x) << 4)
+#define DSADR(x)	__REG2(0x40000204, (x) << 4)
+#define DTADR(x)	__REG2(0x40000208, (x) << 4)
+#define DCMD(x)		__REG2(0x4000020c, (x) << 4)
+
+#define DDADR_DESCADDR	0xfffffff0	/* Address of next descriptor (mask) */
+#define DDADR_STOP	(1 << 0)	/* Stop (read / write) */
+
+#define DCMD_INCSRCADDR	(1 << 31)	/* Source Address Increment Setting. */
+#define DCMD_INCTRGADDR	(1 << 30)	/* Target Address Increment Setting. */
+#define DCMD_FLOWSRC	(1 << 29)	/* Flow Control by the source. */
+#define DCMD_FLOWTRG	(1 << 28)	/* Flow Control by the target. */
+#define DCMD_STARTIRQEN	(1 << 22)	/* Start Interrupt Enable */
+#define DCMD_ENDIRQEN	(1 << 21)	/* End Interrupt Enable */
+#define DCMD_ENDIAN	(1 << 18)	/* Device Endian-ness. */
+#define DCMD_BURST8	(1 << 16)	/* 8 byte burst */
+#define DCMD_BURST16	(2 << 16)	/* 16 byte burst */
+#define DCMD_BURST32	(3 << 16)	/* 32 byte burst */
+#define DCMD_WIDTH1	(1 << 14)	/* 1 byte width */
+#define DCMD_WIDTH2	(2 << 14)	/* 2 byte width (HalfWord) */
+#define DCMD_WIDTH4	(3 << 14)	/* 4 byte width (Word) */
+#define DCMD_LENGTH	0x01fff		/* length mask (max = 8K - 1) */
+
+
+/*
+ * UARTs
+ */
+
+/* Full Function UART (FFUART) */
+#define FFUART		FFRBR
+#define FFRBR		__REG(0x40100000)  /* Receive Buffer Register (read only) */
+#define FFTHR		__REG(0x40100000)  /* Transmit Holding Register (write only) */
+#define FFIER		__REG(0x40100004)  /* Interrupt Enable Register (read/write) */
+#define FFIIR		__REG(0x40100008)  /* Interrupt ID Register (read only) */
+#define FFFCR		__REG(0x40100008)  /* FIFO Control Register (write only) */
+#define FFLCR		__REG(0x4010000C)  /* Line Control Register (read/write) */
+#define FFMCR		__REG(0x40100010)  /* Modem Control Register (read/write) */
+#define FFLSR		__REG(0x40100014)  /* Line Status Register (read only) */
+#define FFMSR		__REG(0x40100018)  /* Modem Status Register (read only) */
+#define FFSPR		__REG(0x4010001C)  /* Scratch Pad Register (read/write) */
+#define FFISR		__REG(0x40100020)  /* Infrared Selection Register (read/write) */
+#define FFDLL		__REG(0x40100000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define FFDLH		__REG(0x40100004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Bluetooth UART (BTUART) */
+#define BTUART		BTRBR
+#define BTRBR		__REG(0x40200000)  /* Receive Buffer Register (read only) */
+#define BTTHR		__REG(0x40200000)  /* Transmit Holding Register (write only) */
+#define BTIER		__REG(0x40200004)  /* Interrupt Enable Register (read/write) */
+#define BTIIR		__REG(0x40200008)  /* Interrupt ID Register (read only) */
+#define BTFCR		__REG(0x40200008)  /* FIFO Control Register (write only) */
+#define BTLCR		__REG(0x4020000C)  /* Line Control Register (read/write) */
+#define BTMCR		__REG(0x40200010)  /* Modem Control Register (read/write) */
+#define BTLSR		__REG(0x40200014)  /* Line Status Register (read only) */
+#define BTMSR		__REG(0x40200018)  /* Modem Status Register (read only) */
+#define BTSPR		__REG(0x4020001C)  /* Scratch Pad Register (read/write) */
+#define BTISR		__REG(0x40200020)  /* Infrared Selection Register (read/write) */
+#define BTDLL		__REG(0x40200000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define BTDLH		__REG(0x40200004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Standard UART (STUART) */
+#define STUART		STRBR
+#define STRBR		__REG(0x40700000)  /* Receive Buffer Register (read only) */
+#define STTHR		__REG(0x40700000)  /* Transmit Holding Register (write only) */
+#define STIER		__REG(0x40700004)  /* Interrupt Enable Register (read/write) */
+#define STIIR		__REG(0x40700008)  /* Interrupt ID Register (read only) */
+#define STFCR		__REG(0x40700008)  /* FIFO Control Register (write only) */
+#define STLCR		__REG(0x4070000C)  /* Line Control Register (read/write) */
+#define STMCR		__REG(0x40700010)  /* Modem Control Register (read/write) */
+#define STLSR		__REG(0x40700014)  /* Line Status Register (read only) */
+#define STMSR		__REG(0x40700018)  /* Reserved */
+#define STSPR		__REG(0x4070001C)  /* Scratch Pad Register (read/write) */
+#define STISR		__REG(0x40700020)  /* Infrared Selection Register (read/write) */
+#define STDLL		__REG(0x40700000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define STDLH		__REG(0x40700004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Hardware UART (HWUART) */
+#define HWUART		HWRBR
+#define HWRBR		__REG(0x41600000)  /* Receive Buffer Register (read only) */
+#define HWTHR		__REG(0x41600000)  /* Transmit Holding Register (write only) */
+#define HWIER		__REG(0x41600004)  /* Interrupt Enable Register (read/write) */
+#define HWIIR		__REG(0x41600008)  /* Interrupt ID Register (read only) */
+#define HWFCR		__REG(0x41600008)  /* FIFO Control Register (write only) */
+#define HWLCR		__REG(0x4160000C)  /* Line Control Register (read/write) */
+#define HWMCR		__REG(0x41600010)  /* Modem Control Register (read/write) */
+#define HWLSR		__REG(0x41600014)  /* Line Status Register (read only) */
+#define HWMSR		__REG(0x41600018)  /* Modem Status Register (read only) */
+#define HWSPR		__REG(0x4160001C)  /* Scratch Pad Register (read/write) */
+#define HWISR		__REG(0x41600020)  /* Infrared Selection Register (read/write) */
+#define HWFOR		__REG(0x41600024)  /* Receive FIFO Occupancy Register (read only) */
+#define HWABR		__REG(0x41600028)  /* Auto-Baud Control Register (read/write) */
+#define HWACR		__REG(0x4160002C)  /* Auto-Baud Count Register (read only) */
+#define HWDLL		__REG(0x41600000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define HWDLH		__REG(0x41600004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+#define IER_DMAE	(1 << 7)	/* DMA Requests Enable */
+#define IER_UUE		(1 << 6)	/* UART Unit Enable */
+#define IER_NRZE	(1 << 5)	/* NRZ coding Enable */
+#define IER_RTIOE	(1 << 4)	/* Receiver Time Out Interrupt Enable */
+#define IER_MIE		(1 << 3)	/* Modem Interrupt Enable */
+#define IER_RLSE	(1 << 2)	/* Receiver Line Status Interrupt Enable */
+#define IER_TIE		(1 << 1)	/* Transmit Data request Interrupt Enable */
+#define IER_RAVIE	(1 << 0)	/* Receiver Data Available Interrupt Enable */
+
+#define IIR_FIFOES1	(1 << 7)	/* FIFO Mode Enable Status */
+#define IIR_FIFOES0	(1 << 6)	/* FIFO Mode Enable Status */
+#define IIR_TOD		(1 << 3)	/* Time Out Detected */
+#define IIR_IID2	(1 << 2)	/* Interrupt Source Encoded */
+#define IIR_IID1	(1 << 1)	/* Interrupt Source Encoded */
+#define IIR_IP		(1 << 0)	/* Interrupt Pending (active low) */
+
+#define FCR_ITL2	(1 << 7)	/* Interrupt Trigger Level */
+#define FCR_ITL1	(1 << 6)	/* Interrupt Trigger Level */
+#define FCR_RESETTF	(1 << 2)	/* Reset Transmitter FIFO */
+#define FCR_RESETRF	(1 << 1)	/* Reset Receiver FIFO */
+#define FCR_TRFIFOE	(1 << 0)	/* Transmit and Receive FIFO Enable */
+#define FCR_ITL_1	(0)
+#define FCR_ITL_8	(FCR_ITL1)
+#define FCR_ITL_16	(FCR_ITL2)
+#define FCR_ITL_32	(FCR_ITL2|FCR_ITL1)
+
+#define LCR_DLAB	(1 << 7)	/* Divisor Latch Access Bit */
+#define LCR_SB		(1 << 6)	/* Set Break */
+#define LCR_STKYP	(1 << 5)	/* Sticky Parity */
+#define LCR_EPS		(1 << 4)	/* Even Parity Select */
+#define LCR_PEN		(1 << 3)	/* Parity Enable */
+#define LCR_STB		(1 << 2)	/* Stop Bit */
+#define LCR_WLS1	(1 << 1)	/* Word Length Select */
+#define LCR_WLS0	(1 << 0)	/* Word Length Select */
+
+#define LSR_FIFOE	(1 << 7)	/* FIFO Error Status */
+#define LSR_TEMT	(1 << 6)	/* Transmitter Empty */
+#define LSR_TDRQ	(1 << 5)	/* Transmit Data Request */
+#define LSR_BI		(1 << 4)	/* Break Interrupt */
+#define LSR_FE		(1 << 3)	/* Framing Error */
+#define LSR_PE		(1 << 2)	/* Parity Error */
+#define LSR_OE		(1 << 1)	/* Overrun Error */
+#define LSR_DR		(1 << 0)	/* Data Ready */
+
+#define MCR_LOOP	(1 << 4)
+#define MCR_OUT2	(1 << 3)	/* force MSR_DCD in loopback mode */
+#define MCR_OUT1	(1 << 2)	/* force MSR_RI in loopback mode */
+#define MCR_RTS		(1 << 1)	/* Request to Send */
+#define MCR_DTR		(1 << 0)	/* Data Terminal Ready */
+
+#define MSR_DCD		(1 << 7)	/* Data Carrier Detect */
+#define MSR_RI		(1 << 6)	/* Ring Indicator */
+#define MSR_DSR		(1 << 5)	/* Data Set Ready */
+#define MSR_CTS		(1 << 4)	/* Clear To Send */
+#define MSR_DDCD	(1 << 3)	/* Delta Data Carrier Detect */
+#define MSR_TERI	(1 << 2)	/* Trailing Edge Ring Indicator */
+#define MSR_DDSR	(1 << 1)	/* Delta Data Set Ready */
+#define MSR_DCTS	(1 << 0)	/* Delta Clear To Send */
+
+/*
+ * IrSR (Infrared Selection Register)
+ */
+#define STISR_RXPL      (1 << 4)        /* Receive Data Polarity */
+#define STISR_TXPL      (1 << 3)        /* Transmit Data Polarity */
+#define STISR_XMODE     (1 << 2)        /* Transmit Pulse Width Select */
+#define STISR_RCVEIR    (1 << 1)        /* Receiver SIR Enable */
+#define STISR_XMITIR    (1 << 0)        /* Transmitter SIR Enable */
+
+
+/*
+ * I2C registers
+ */
+
+#define IBMR		__REG(0x40301680)  /* I2C Bus Monitor Register - IBMR */
+#define IDBR		__REG(0x40301688)  /* I2C Data Buffer Register - IDBR */
+#define ICR		__REG(0x40301690)  /* I2C Control Register - ICR */
+#define ISR		__REG(0x40301698)  /* I2C Status Register - ISR */
+#define ISAR		__REG(0x403016A0)  /* I2C Slave Address Register - ISAR */
+
+#define PWRIBMR    __REG(0x40f00180)  /* Power I2C Bus Monitor Register-IBMR */
+#define PWRIDBR    __REG(0x40f00188)  /* Power I2C Data Buffer Register-IDBR */
+#define PWRICR __REG(0x40f00190)  /* Power I2C Control Register - ICR */
+#define PWRISR __REG(0x40f00198)  /* Power I2C Status Register - ISR */
+#define PWRISAR    __REG(0x40f001A0)  /*Power I2C Slave Address Register-ISAR */
+
+#define ICR_START	(1 << 0)	   /* start bit */
+#define ICR_STOP	(1 << 1)	   /* stop bit */
+#define ICR_ACKNAK	(1 << 2)	   /* send ACK(0) or NAK(1) */
+#define ICR_TB		(1 << 3)	   /* transfer byte bit */
+#define ICR_MA		(1 << 4)	   /* master abort */
+#define ICR_SCLE	(1 << 5)	   /* master clock enable */
+#define ICR_IUE		(1 << 6)	   /* unit enable */
+#define ICR_GCD		(1 << 7)	   /* general call disable */
+#define ICR_ITEIE	(1 << 8)	   /* enable tx interrupts */
+#define ICR_IRFIE	(1 << 9)	   /* enable rx interrupts */
+#define ICR_BEIE	(1 << 10)	   /* enable bus error ints */
+#define ICR_SSDIE	(1 << 11)	   /* slave STOP detected int enable */
+#define ICR_ALDIE	(1 << 12)	   /* enable arbitration interrupt */
+#define ICR_SADIE	(1 << 13)	   /* slave address detected int enable */
+#define ICR_UR		(1 << 14)	   /* unit reset */
+
+#define ISR_RWM		(1 << 0)	   /* read/write mode */
+#define ISR_ACKNAK	(1 << 1)	   /* ack/nak status */
+#define ISR_UB		(1 << 2)	   /* unit busy */
+#define ISR_IBB		(1 << 3)	   /* bus busy */
+#define ISR_SSD		(1 << 4)	   /* slave stop detected */
+#define ISR_ALD		(1 << 5)	   /* arbitration loss detected */
+#define ISR_ITE		(1 << 6)	   /* tx buffer empty */
+#define ISR_IRF		(1 << 7)	   /* rx buffer full */
+#define ISR_GCAD	(1 << 8)	   /* general call address detected */
+#define ISR_SAD		(1 << 9)	   /* slave address detected */
+#define ISR_BED		(1 << 10)	   /* bus error no ACK/NAK */
+
+
+/*
+ * Serial Audio Controller
+ */
+
+#define SACR0		__REG(0x40400000)  /* Global Control Register */
+#define SACR1		__REG(0x40400004)  /* Serial Audio I 2 S/MSB-Justified Control Register */
+#define SASR0		__REG(0x4040000C)  /* Serial Audio I 2 S/MSB-Justified Interface and FIFO Status Register */
+#define SAIMR		__REG(0x40400014)  /* Serial Audio Interrupt Mask Register */
+#define SAICR		__REG(0x40400018)  /* Serial Audio Interrupt Clear Register */
+#define SADIV		__REG(0x40400060)  /* Audio Clock Divider Register. */
+#define SADR		__REG(0x40400080)  /* Serial Audio Data Register (TX and RX FIFO access Register). */
+
+#define SACR0_RFTH(x)	((x) << 12)	/* Rx FIFO Interrupt or DMA Trigger Threshold */
+#define SACR0_TFTH(x)	((x) << 8)	/* Tx FIFO Interrupt or DMA Trigger Threshold */
+#define SACR0_STRF	(1 << 5)	/* FIFO Select for EFWR Special Function */
+#define SACR0_EFWR	(1 << 4)	/* Enable EFWR Function  */
+#define SACR0_RST	(1 << 3)	/* FIFO, i2s Register Reset */
+#define SACR0_BCKD	(1 << 2) 	/* Bit Clock Direction */
+#define SACR0_ENB	(1 << 0)	/* Enable I2S Link */
+#define SACR1_ENLBF	(1 << 5)	/* Enable Loopback */
+#define SACR1_DRPL	(1 << 4) 	/* Disable Replaying Function */
+#define SACR1_DREC	(1 << 3)	/* Disable Recording Function */
+#define SACR1_AMSL	(1 << 0)	/* Specify Alternate Mode */
+
+#define SASR0_I2SOFF	(1 << 7)	/* Controller Status */
+#define SASR0_ROR	(1 << 6)	/* Rx FIFO Overrun */
+#define SASR0_TUR	(1 << 5)	/* Tx FIFO Underrun */
+#define SASR0_RFS	(1 << 4)	/* Rx FIFO Service Request */
+#define SASR0_TFS	(1 << 3)	/* Tx FIFO Service Request */
+#define SASR0_BSY	(1 << 2)	/* I2S Busy */
+#define SASR0_RNE	(1 << 1)	/* Rx FIFO Not Empty */
+#define SASR0_TNF	(1 << 0) 	/* Tx FIFO Not Empty */
+
+#define SAICR_ROR	(1 << 6)	/* Clear Rx FIFO Overrun Interrupt */
+#define SAICR_TUR	(1 << 5)	/* Clear Tx FIFO Underrun Interrupt */
+
+#define SAIMR_ROR	(1 << 6)	/* Enable Rx FIFO Overrun Condition Interrupt */
+#define SAIMR_TUR	(1 << 5)	/* Enable Tx FIFO Underrun Condition Interrupt */
+#define SAIMR_RFS	(1 << 4)	/* Enable Rx FIFO Service Interrupt */
+#define SAIMR_TFS	(1 << 3)	/* Enable Tx FIFO Service Interrupt */
+
+/*
+ * AC97 Controller registers
+ */
+
+#define POCR		__REG(0x40500000)  /* PCM Out Control Register */
+#define POCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+#define POCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define PICR		__REG(0x40500004)  /* PCM In Control Register */
+#define PICR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+#define PICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define MCCR		__REG(0x40500008)  /* Mic In Control Register */
+#define MCCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+#define MCCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define GCR		__REG(0x4050000C)  /* Global Control Register */
+#define GCR_nDMAEN	(1 << 24)	/* non DMA Enable */
+#define GCR_CDONE_IE	(1 << 19)	/* Command Done Interrupt Enable */
+#define GCR_SDONE_IE	(1 << 18)	/* Status Done Interrupt Enable */
+#define GCR_SECRDY_IEN	(1 << 9)	/* Secondary Ready Interrupt Enable */
+#define GCR_PRIRDY_IEN	(1 << 8)	/* Primary Ready Interrupt Enable */
+#define GCR_SECRES_IEN	(1 << 5)	/* Secondary Resume Interrupt Enable */
+#define GCR_PRIRES_IEN	(1 << 4)	/* Primary Resume Interrupt Enable */
+#define GCR_ACLINK_OFF	(1 << 3)	/* AC-link Shut Off */
+#define GCR_WARM_RST	(1 << 2)	/* AC97 Warm Reset */
+#define GCR_COLD_RST	(1 << 1)	/* AC'97 Cold Reset (0 = active) */
+#define GCR_GIE		(1 << 0)	/* Codec GPI Interrupt Enable */
+
+#define POSR		__REG(0x40500010)  /* PCM Out Status Register */
+#define POSR_FIFOE	(1 << 4)	/* FIFO error */
+#define POSR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define PISR		__REG(0x40500014)  /* PCM In Status Register */
+#define PISR_FIFOE	(1 << 4)	/* FIFO error */
+#define PISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
+#define PISR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define MCSR		__REG(0x40500018)  /* Mic In Status Register */
+#define MCSR_FIFOE	(1 << 4)	/* FIFO error */
+#define MCSR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
+#define MCSR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define GSR		__REG(0x4050001C)  /* Global Status Register */
+#define GSR_CDONE	(1 << 19)	/* Command Done */
+#define GSR_SDONE	(1 << 18)	/* Status Done */
+#define GSR_RDCS	(1 << 15)	/* Read Completion Status */
+#define GSR_BIT3SLT12	(1 << 14)	/* Bit 3 of slot 12 */
+#define GSR_BIT2SLT12	(1 << 13)	/* Bit 2 of slot 12 */
+#define GSR_BIT1SLT12	(1 << 12)	/* Bit 1 of slot 12 */
+#define GSR_SECRES	(1 << 11)	/* Secondary Resume Interrupt */
+#define GSR_PRIRES	(1 << 10)	/* Primary Resume Interrupt */
+#define GSR_SCR		(1 << 9)	/* Secondary Codec Ready */
+#define GSR_PCR		(1 << 8)	/*  Primary Codec Ready */
+#define GSR_MCINT	(1 << 7)	/* Mic In Interrupt */
+#define GSR_POINT	(1 << 6)	/* PCM Out Interrupt */
+#define GSR_PIINT	(1 << 5)	/* PCM In Interrupt */
+#define GSR_ACOFFD	(1 << 3)	/* AC-link Shut Off Done */
+#define GSR_MOINT	(1 << 2)	/* Modem Out Interrupt */
+#define GSR_MIINT	(1 << 1)	/* Modem In Interrupt */
+#define GSR_GSCI	(1 << 0)	/* Codec GPI Status Change Interrupt */
+
+#define CAR		__REG(0x40500020)  /* CODEC Access Register */
+#define CAR_CAIP	(1 << 0)	/* Codec Access In Progress */
+
+#define PCDR		__REG(0x40500040)  /* PCM FIFO Data Register */
+#define MCDR		__REG(0x40500060)  /* Mic-in FIFO Data Register */
+
+#define MOCR		__REG(0x40500100)  /* Modem Out Control Register */
+#define MOCR_FEIE	(1 << 3)	/* FIFO Error */
+#define MOCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define MICR		__REG(0x40500108)  /* Modem In Control Register */
+#define MICR_FEIE	(1 << 3)	/* FIFO Error */
+#define MICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
+
+#define MOSR		__REG(0x40500110)  /* Modem Out Status Register */
+#define MOSR_FIFOE	(1 << 4)	/* FIFO error */
+#define MOSR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define MISR		__REG(0x40500118)  /* Modem In Status Register */
+#define MISR_FIFOE	(1 << 4)	/* FIFO error */
+#define MISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
+#define MISR_FSR	(1 << 2)	/* FIFO Service Request */
+
+#define MODR		__REG(0x40500140)  /* Modem FIFO Data Register */
+
+#define PAC_REG_BASE	__REG(0x40500200)  /* Primary Audio Codec */
+#define SAC_REG_BASE	__REG(0x40500300)  /* Secondary Audio Codec */
+#define PMC_REG_BASE	__REG(0x40500400)  /* Primary Modem Codec */
+#define SMC_REG_BASE	__REG(0x40500500)  /* Secondary Modem Codec */
+
+
+/*
+ * USB Device Controller
+ * PXA25x and PXA27x USB device controller registers are different.
+ */
+#if defined(CONFIG_PXA25x)
+
+#define UDC_RES1	__REG(0x40600004)  /* UDC Undocumented - Reserved1 */
+#define UDC_RES2	__REG(0x40600008)  /* UDC Undocumented - Reserved2 */
+#define UDC_RES3	__REG(0x4060000C)  /* UDC Undocumented - Reserved3 */
+
+#define UDCCR		__REG(0x40600000)  /* UDC Control Register */
+#define UDCCR_UDE	(1 << 0)	/* UDC enable */
+#define UDCCR_UDA	(1 << 1)	/* UDC active */
+#define UDCCR_RSM	(1 << 2)	/* Device resume */
+#define UDCCR_RESIR	(1 << 3)	/* Resume interrupt request */
+#define UDCCR_SUSIR	(1 << 4)	/* Suspend interrupt request */
+#define UDCCR_SRM	(1 << 5)	/* Suspend/resume interrupt mask */
+#define UDCCR_RSTIR	(1 << 6)	/* Reset interrupt request */
+#define UDCCR_REM	(1 << 7)	/* Reset interrupt mask */
+
+#define UDCCS0		__REG(0x40600010)  /* UDC Endpoint 0 Control/Status Register */
+#define UDCCS0_OPR	(1 << 0)	/* OUT packet ready */
+#define UDCCS0_IPR	(1 << 1)	/* IN packet ready */
+#define UDCCS0_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS0_DRWF	(1 << 3)	/* Device remote wakeup feature */
+#define UDCCS0_SST	(1 << 4)	/* Sent stall */
+#define UDCCS0_FST	(1 << 5)	/* Force stall */
+#define UDCCS0_RNE	(1 << 6)	/* Receive FIFO no empty */
+#define UDCCS0_SA	(1 << 7)	/* Setup active */
+
+/* Bulk IN - Endpoint 1,6,11 */
+#define UDCCS1		__REG(0x40600014)  /* UDC Endpoint 1 (IN) Control/Status Register */
+#define UDCCS6		__REG(0x40600028)  /* UDC Endpoint 6 (IN) Control/Status Register */
+#define UDCCS11		__REG(0x4060003C)  /* UDC Endpoint 11 (IN) Control/Status Register */
+
+#define UDCCS_BI_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_BI_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_BI_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_BI_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_BI_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BI_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BI_TSP	(1 << 7)	/* Transmit short packet */
+
+/* Bulk OUT - Endpoint 2,7,12 */
+#define UDCCS2		__REG(0x40600018)  /* UDC Endpoint 2 (OUT) Control/Status Register */
+#define UDCCS7		__REG(0x4060002C)  /* UDC Endpoint 7 (OUT) Control/Status Register */
+#define UDCCS12		__REG(0x40600040)  /* UDC Endpoint 12 (OUT) Control/Status Register */
+
+#define UDCCS_BO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_BO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_BO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_BO_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BO_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_BO_RSP	(1 << 7)	/* Receive short packet */
+
+/* Isochronous IN - Endpoint 3,8,13 */
+#define UDCCS3		__REG(0x4060001C)  /* UDC Endpoint 3 (IN) Control/Status Register */
+#define UDCCS8		__REG(0x40600030)  /* UDC Endpoint 8 (IN) Control/Status Register */
+#define UDCCS13		__REG(0x40600044)  /* UDC Endpoint 13 (IN) Control/Status Register */
+
+#define UDCCS_II_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_II_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_II_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_II_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_II_TSP	(1 << 7)	/* Transmit short packet */
+
+/* Isochronous OUT - Endpoint 4,9,14 */
+#define UDCCS4		__REG(0x40600020)  /* UDC Endpoint 4 (OUT) Control/Status Register */
+#define UDCCS9		__REG(0x40600034)  /* UDC Endpoint 9 (OUT) Control/Status Register */
+#define UDCCS14		__REG(0x40600048)  /* UDC Endpoint 14 (OUT) Control/Status Register */
+
+#define UDCCS_IO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_IO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_IO_ROF	(1 << 2)	/* Receive overflow */
+#define UDCCS_IO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_IO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_IO_RSP	(1 << 7)	/* Receive short packet */
+
+/* Interrupt IN - Endpoint 5,10,15 */
+#define UDCCS5		__REG(0x40600024)  /* UDC Endpoint 5 (Interrupt) Control/Status Register */
+#define UDCCS10		__REG(0x40600038)  /* UDC Endpoint 10 (Interrupt) Control/Status Register */
+#define UDCCS15		__REG(0x4060004C)  /* UDC Endpoint 15 (Interrupt) Control/Status Register */
+
+#define UDCCS_INT_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_INT_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_INT_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_INT_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_INT_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_INT_FST	(1 << 5)	/* Force stall */
+#define UDCCS_INT_TSP	(1 << 7)	/* Transmit short packet */
+
+#define UFNRH		__REG(0x40600060)  /* UDC Frame Number Register High */
+#define UFNRL		__REG(0x40600064)  /* UDC Frame Number Register Low */
+#define UBCR2		__REG(0x40600068)  /* UDC Byte Count Reg 2 */
+#define UBCR4		__REG(0x4060006c)  /* UDC Byte Count Reg 4 */
+#define UBCR7		__REG(0x40600070)  /* UDC Byte Count Reg 7 */
+#define UBCR9		__REG(0x40600074)  /* UDC Byte Count Reg 9 */
+#define UBCR12		__REG(0x40600078)  /* UDC Byte Count Reg 12 */
+#define UBCR14		__REG(0x4060007c)  /* UDC Byte Count Reg 14 */
+#define UDDR0		__REG(0x40600080)  /* UDC Endpoint 0 Data Register */
+#define UDDR1		__REG(0x40600100)  /* UDC Endpoint 1 Data Register */
+#define UDDR2		__REG(0x40600180)  /* UDC Endpoint 2 Data Register */
+#define UDDR3		__REG(0x40600200)  /* UDC Endpoint 3 Data Register */
+#define UDDR4		__REG(0x40600400)  /* UDC Endpoint 4 Data Register */
+#define UDDR5		__REG(0x406000A0)  /* UDC Endpoint 5 Data Register */
+#define UDDR6		__REG(0x40600600)  /* UDC Endpoint 6 Data Register */
+#define UDDR7		__REG(0x40600680)  /* UDC Endpoint 7 Data Register */
+#define UDDR8		__REG(0x40600700)  /* UDC Endpoint 8 Data Register */
+#define UDDR9		__REG(0x40600900)  /* UDC Endpoint 9 Data Register */
+#define UDDR10		__REG(0x406000C0)  /* UDC Endpoint 10 Data Register */
+#define UDDR11		__REG(0x40600B00)  /* UDC Endpoint 11 Data Register */
+#define UDDR12		__REG(0x40600B80)  /* UDC Endpoint 12 Data Register */
+#define UDDR13		__REG(0x40600C00)  /* UDC Endpoint 13 Data Register */
+#define UDDR14		__REG(0x40600E00)  /* UDC Endpoint 14 Data Register */
+#define UDDR15		__REG(0x406000E0)  /* UDC Endpoint 15 Data Register */
+
+#define UICR0		__REG(0x40600050)  /* UDC Interrupt Control Register 0 */
+
+#define UICR0_IM0	(1 << 0)	/* Interrupt mask ep 0 */
+#define UICR0_IM1	(1 << 1)	/* Interrupt mask ep 1 */
+#define UICR0_IM2	(1 << 2)	/* Interrupt mask ep 2 */
+#define UICR0_IM3	(1 << 3)	/* Interrupt mask ep 3 */
+#define UICR0_IM4	(1 << 4)	/* Interrupt mask ep 4 */
+#define UICR0_IM5	(1 << 5)	/* Interrupt mask ep 5 */
+#define UICR0_IM6	(1 << 6)	/* Interrupt mask ep 6 */
+#define UICR0_IM7	(1 << 7)	/* Interrupt mask ep 7 */
+
+#define UICR1		__REG(0x40600054)  /* UDC Interrupt Control Register 1 */
+
+#define UICR1_IM8	(1 << 0)	/* Interrupt mask ep 8 */
+#define UICR1_IM9	(1 << 1)	/* Interrupt mask ep 9 */
+#define UICR1_IM10	(1 << 2)	/* Interrupt mask ep 10 */
+#define UICR1_IM11	(1 << 3)	/* Interrupt mask ep 11 */
+#define UICR1_IM12	(1 << 4)	/* Interrupt mask ep 12 */
+#define UICR1_IM13	(1 << 5)	/* Interrupt mask ep 13 */
+#define UICR1_IM14	(1 << 6)	/* Interrupt mask ep 14 */
+#define UICR1_IM15	(1 << 7)	/* Interrupt mask ep 15 */
+
+#define USIR0		__REG(0x40600058)  /* UDC Status Interrupt Register 0 */
+
+#define USIR0_IR0	(1 << 0)	/* Interrup request ep 0 */
+#define USIR0_IR1	(1 << 1)	/* Interrup request ep 1 */
+#define USIR0_IR2	(1 << 2)	/* Interrup request ep 2 */
+#define USIR0_IR3	(1 << 3)	/* Interrup request ep 3 */
+#define USIR0_IR4	(1 << 4)	/* Interrup request ep 4 */
+#define USIR0_IR5	(1 << 5)	/* Interrup request ep 5 */
+#define USIR0_IR6	(1 << 6)	/* Interrup request ep 6 */
+#define USIR0_IR7	(1 << 7)	/* Interrup request ep 7 */
+
+#define USIR1		__REG(0x4060005C)  /* UDC Status Interrupt Register 1 */
+
+#define USIR1_IR8	(1 << 0)	/* Interrup request ep 8 */
+#define USIR1_IR9	(1 << 1)	/* Interrup request ep 9 */
+#define USIR1_IR10	(1 << 2)	/* Interrup request ep 10 */
+#define USIR1_IR11	(1 << 3)	/* Interrup request ep 11 */
+#define USIR1_IR12	(1 << 4)	/* Interrup request ep 12 */
+#define USIR1_IR13	(1 << 5)	/* Interrup request ep 13 */
+#define USIR1_IR14	(1 << 6)	/* Interrup request ep 14 */
+#define USIR1_IR15	(1 << 7)	/* Interrup request ep 15 */
+
+#elif defined(CONFIG_PXA27x)
+
+#define UDCCR           __REG(0x40600000) /* UDC Control Register */
+#define UDCCR_OEN	(1 << 31)	/* On-the-Go Enable */
+#define UDCCR_AALTHNP	(1 << 30)	/* A-device Alternate Host Negotiation
+					   Protocol Port Support */
+#define UDCCR_AHNP	(1 << 29)	/* A-device Host Negotiation Protocol
+					   Support */
+#define UDCCR_BHNP	(1 << 28)	/* B-device Host Negotiation Protocol
+					   Enable */
+#define UDCCR_DWRE	(1 << 16)	/* Device Remote Wake-up Enable */
+#define UDCCR_ACN	(0x03 << 11)	/* Active UDC configuration Number */
+#define UDCCR_ACN_S	11
+#define UDCCR_AIN	(0x07 << 8)	/* Active UDC interface Number */
+#define UDCCR_AIN_S	8
+#define UDCCR_AAISN	(0x07 << 5)	/* Active UDC Alternate Interface
+					   Setting Number */
+#define UDCCR_AAISN_S	5
+#define UDCCR_SMAC	(1 << 4)	/* Switch Endpoint Memory to Active
+					   Configuration */
+#define UDCCR_EMCE	(1 << 3)	/* Endpoint Memory Configuration
+					   Error */
+#define UDCCR_UDR	(1 << 2)	/* UDC Resume */
+#define UDCCR_UDA	(1 << 1)	/* UDC Active */
+#define UDCCR_UDE	(1 << 0)	/* UDC Enable */
+
+#define UDCICR0         __REG(0x40600004) /* UDC Interrupt Control Register0 */
+#define UDCICR1         __REG(0x40600008) /* UDC Interrupt Control Register1 */
+#define UDCICR_FIFOERR	(1 << 1)	/* FIFO Error interrupt for EP */
+#define UDCICR_PKTCOMPL (1 << 0)	/* Packet Complete interrupt for EP */
+
+#define UDC_INT_FIFOERROR  (0x2)
+#define UDC_INT_PACKETCMP  (0x1)
+
+#define UDCICR_INT(n,intr) (((intr) & 0x03) << (((n) & 0x0F) * 2))
+#define UDCICR1_IECC	(1 << 31)	/* IntEn - Configuration Change */
+#define UDCICR1_IESOF	(1 << 30)	/* IntEn - Start of Frame */
+#define UDCICR1_IERU	(1 << 29)	/* IntEn - Resume */
+#define UDCICR1_IESU	(1 << 28)	/* IntEn - Suspend */
+#define UDCICR1_IERS	(1 << 27)	/* IntEn - Reset */
+
+#define UDCISR0         __REG(0x4060000C) /* UDC Interrupt Status Register 0 */
+#define UDCISR1         __REG(0x40600010) /* UDC Interrupt Status Register 1 */
+#define UDCISR_INT(n,intr) (((intr) & 0x03) << (((n) & 0x0F) * 2))
+#define UDCISR1_IRCC	(1 << 31)	/* IntReq - Configuration Change */
+#define UDCISR1_IRSOF	(1 << 30)	/* IntReq - Start of Frame */
+#define UDCISR1_IRRU	(1 << 29)	/* IntReq - Resume */
+#define UDCISR1_IRSU	(1 << 28)	/* IntReq - Suspend */
+#define UDCISR1_IRRS	(1 << 27)	/* IntReq - Reset */
+
+#define UDCFNR          __REG(0x40600014) /* UDC Frame Number Register */
+#define UDCOTGICR	__REG(0x40600018) /* UDC On-The-Go interrupt control */
+#define UDCOTGICR_IESF	(1 << 24)	/* OTG SET_FEATURE command recvd */
+#define UDCOTGICR_IEXR	(1 << 17)	/* Extra Transciever Interrupt
+					   Rising Edge Interrupt Enable */
+#define UDCOTGICR_IEXF	(1 << 16)	/* Extra Transciever Interrupt
+					   Falling Edge Interrupt Enable */
+#define UDCOTGICR_IEVV40R (1 << 9)	/* OTG Vbus Valid 4.0V Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEVV40F (1 << 8)	/* OTG Vbus Valid 4.0V Falling Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEVV44R (1 << 7)	/* OTG Vbus Valid 4.4V Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEVV44F (1 << 6)	/* OTG Vbus Valid 4.4V Falling Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IESVR	(1 << 5)	/* OTG Session Valid Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IESVF	(1 << 4)	/* OTG Session Valid Falling Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IESDR	(1 << 3)	/* OTG A-Device SRP Detect Rising
+					   Edge Interrupt Enable */
+#define UDCOTGICR_IESDF	(1 << 2)	/* OTG A-Device SRP Detect Falling
+					   Edge Interrupt Enable */
+#define UDCOTGICR_IEIDR	(1 << 1)	/* OTG ID Change Rising Edge
+					   Interrupt Enable */
+#define UDCOTGICR_IEIDF	(1 << 0)	/* OTG ID Change Falling Edge
+					   Interrupt Enable */
+
+#define UP2OCR		  __REG(0x40600020)  /* USB Port 2 Output Control register */
+
+#define UP2OCR_CPVEN	(1 << 0)	/* Charge Pump Vbus Enable */
+#define UP2OCR_CPVPE	(1 << 1)	/* Charge Pump Vbus Pulse Enable */
+#define UP2OCR_DPPDE	(1 << 2)	/* Host Port 2 Transceiver D+ Pull Down Enable */
+#define UP2OCR_DMPDE	(1 << 3)	/* Host Port 2 Transceiver D- Pull Down Enable */
+#define UP2OCR_DPPUE	(1 << 4)	/* Host Port 2 Transceiver D+ Pull Up Enable */
+#define UP2OCR_DMPUE	(1 << 5)	/* Host Port 2 Transceiver D- Pull Up Enable */
+#define UP2OCR_DPPUBE	(1 << 6)	/* Host Port 2 Transceiver D+ Pull Up Bypass Enable */
+#define UP2OCR_DMPUBE	(1 << 7)	/* Host Port 2 Transceiver D- Pull Up Bypass Enable */
+#define UP2OCR_EXSP		(1 << 8)	/* External Transceiver Speed Control */
+#define UP2OCR_EXSUS	(1 << 9)	/* External Transceiver Speed Enable */
+#define UP2OCR_IDON		(1 << 10)	/* OTG ID Read Enable */
+#define UP2OCR_HXS		(1 << 16)	/* Host Port 2 Transceiver Output Select */
+#define UP2OCR_HXOE		(1 << 17)	/* Host Port 2 Transceiver Output Enable */
+#define UP2OCR_SEOS		(1 << 24)	/* Single-Ended Output Select */
+
+#define UDCCSN(x)	__REG2(0x40600100, (x) << 2)
+#define UDCCSR0         __REG(0x40600100) /* UDC Control/Status register - Endpoint 0 */
+#define UDCCSR0_SA	(1 << 7)	/* Setup Active */
+#define UDCCSR0_RNE	(1 << 6)	/* Receive FIFO Not Empty */
+#define UDCCSR0_FST	(1 << 5)	/* Force Stall */
+#define UDCCSR0_SST	(1 << 4)	/* Sent Stall */
+#define UDCCSR0_DME	(1 << 3)	/* DMA Enable */
+#define UDCCSR0_FTF	(1 << 2)	/* Flush Transmit FIFO */
+#define UDCCSR0_IPR	(1 << 1)	/* IN Packet Ready */
+#define UDCCSR0_OPC	(1 << 0)	/* OUT Packet Complete */
+
+#define UDCCSRA         __REG(0x40600104) /* UDC Control/Status register - Endpoint A */
+#define UDCCSRB         __REG(0x40600108) /* UDC Control/Status register - Endpoint B */
+#define UDCCSRC         __REG(0x4060010C) /* UDC Control/Status register - Endpoint C */
+#define UDCCSRD         __REG(0x40600110) /* UDC Control/Status register - Endpoint D */
+#define UDCCSRE         __REG(0x40600114) /* UDC Control/Status register - Endpoint E */
+#define UDCCSRF         __REG(0x40600118) /* UDC Control/Status register - Endpoint F */
+#define UDCCSRG         __REG(0x4060011C) /* UDC Control/Status register - Endpoint G */
+#define UDCCSRH         __REG(0x40600120) /* UDC Control/Status register - Endpoint H */
+#define UDCCSRI         __REG(0x40600124) /* UDC Control/Status register - Endpoint I */
+#define UDCCSRJ         __REG(0x40600128) /* UDC Control/Status register - Endpoint J */
+#define UDCCSRK         __REG(0x4060012C) /* UDC Control/Status register - Endpoint K */
+#define UDCCSRL         __REG(0x40600130) /* UDC Control/Status register - Endpoint L */
+#define UDCCSRM         __REG(0x40600134) /* UDC Control/Status register - Endpoint M */
+#define UDCCSRN         __REG(0x40600138) /* UDC Control/Status register - Endpoint N */
+#define UDCCSRP         __REG(0x4060013C) /* UDC Control/Status register - Endpoint P */
+#define UDCCSRQ         __REG(0x40600140) /* UDC Control/Status register - Endpoint Q */
+#define UDCCSRR         __REG(0x40600144) /* UDC Control/Status register - Endpoint R */
+#define UDCCSRS         __REG(0x40600148) /* UDC Control/Status register - Endpoint S */
+#define UDCCSRT         __REG(0x4060014C) /* UDC Control/Status register - Endpoint T */
+#define UDCCSRU         __REG(0x40600150) /* UDC Control/Status register - Endpoint U */
+#define UDCCSRV         __REG(0x40600154) /* UDC Control/Status register - Endpoint V */
+#define UDCCSRW         __REG(0x40600158) /* UDC Control/Status register - Endpoint W */
+#define UDCCSRX         __REG(0x4060015C) /* UDC Control/Status register - Endpoint X */
+
+#define UDCCSR_DPE	(1 << 9)	/* Data Packet Error */
+#define UDCCSR_FEF	(1 << 8)	/* Flush Endpoint FIFO */
+#define UDCCSR_SP	(1 << 7)	/* Short Packet Control/Status */
+#define UDCCSR_BNE	(1 << 6)	/* Buffer Not Empty (IN endpoints) */
+#define UDCCSR_BNF	(1 << 6)	/* Buffer Not Full (OUT endpoints) */
+#define UDCCSR_FST	(1 << 5)	/* Force STALL */
+#define UDCCSR_SST	(1 << 4)	/* Sent STALL */
+#define UDCCSR_DME	(1 << 3)	/* DMA Enable */
+#define UDCCSR_TRN	(1 << 2)	/* Tx/Rx NAK */
+#define UDCCSR_PC	(1 << 1)	/* Packet Complete */
+#define UDCCSR_FS	(1 << 0)	/* FIFO needs service */
+
+#define UDCBCN(x)	__REG2(0x40600200, (x)<<2)
+#define UDCBCR0         __REG(0x40600200) /* Byte Count Register - EP0 */
+#define UDCBCRA         __REG(0x40600204) /* Byte Count Register - EPA */
+#define UDCBCRB         __REG(0x40600208) /* Byte Count Register - EPB */
+#define UDCBCRC         __REG(0x4060020C) /* Byte Count Register - EPC */
+#define UDCBCRD         __REG(0x40600210) /* Byte Count Register - EPD */
+#define UDCBCRE         __REG(0x40600214) /* Byte Count Register - EPE */
+#define UDCBCRF         __REG(0x40600218) /* Byte Count Register - EPF */
+#define UDCBCRG         __REG(0x4060021C) /* Byte Count Register - EPG */
+#define UDCBCRH         __REG(0x40600220) /* Byte Count Register - EPH */
+#define UDCBCRI         __REG(0x40600224) /* Byte Count Register - EPI */
+#define UDCBCRJ         __REG(0x40600228) /* Byte Count Register - EPJ */
+#define UDCBCRK         __REG(0x4060022C) /* Byte Count Register - EPK */
+#define UDCBCRL         __REG(0x40600230) /* Byte Count Register - EPL */
+#define UDCBCRM         __REG(0x40600234) /* Byte Count Register - EPM */
+#define UDCBCRN         __REG(0x40600238) /* Byte Count Register - EPN */
+#define UDCBCRP         __REG(0x4060023C) /* Byte Count Register - EPP */
+#define UDCBCRQ         __REG(0x40600240) /* Byte Count Register - EPQ */
+#define UDCBCRR         __REG(0x40600244) /* Byte Count Register - EPR */
+#define UDCBCRS         __REG(0x40600248) /* Byte Count Register - EPS */
+#define UDCBCRT         __REG(0x4060024C) /* Byte Count Register - EPT */
+#define UDCBCRU         __REG(0x40600250) /* Byte Count Register - EPU */
+#define UDCBCRV         __REG(0x40600254) /* Byte Count Register - EPV */
+#define UDCBCRW         __REG(0x40600258) /* Byte Count Register - EPW */
+#define UDCBCRX         __REG(0x4060025C) /* Byte Count Register - EPX */
+
+#define UDCDN(x)	__REG2(0x40600300, (x)<<2)
+#define PHYS_UDCDN(x)	(0x40600300 + ((x)<<2))
+#define PUDCDN(x)	(volatile u32 *)(io_p2v(PHYS_UDCDN((x))))
+#define UDCDR0          __REG(0x40600300) /* Data Register - EP0 */
+#define UDCDRA          __REG(0x40600304) /* Data Register - EPA */
+#define UDCDRB          __REG(0x40600308) /* Data Register - EPB */
+#define UDCDRC          __REG(0x4060030C) /* Data Register - EPC */
+#define UDCDRD          __REG(0x40600310) /* Data Register - EPD */
+#define UDCDRE          __REG(0x40600314) /* Data Register - EPE */
+#define UDCDRF          __REG(0x40600318) /* Data Register - EPF */
+#define UDCDRG          __REG(0x4060031C) /* Data Register - EPG */
+#define UDCDRH          __REG(0x40600320) /* Data Register - EPH */
+#define UDCDRI          __REG(0x40600324) /* Data Register - EPI */
+#define UDCDRJ          __REG(0x40600328) /* Data Register - EPJ */
+#define UDCDRK          __REG(0x4060032C) /* Data Register - EPK */
+#define UDCDRL          __REG(0x40600330) /* Data Register - EPL */
+#define UDCDRM          __REG(0x40600334) /* Data Register - EPM */
+#define UDCDRN          __REG(0x40600338) /* Data Register - EPN */
+#define UDCDRP          __REG(0x4060033C) /* Data Register - EPP */
+#define UDCDRQ          __REG(0x40600340) /* Data Register - EPQ */
+#define UDCDRR          __REG(0x40600344) /* Data Register - EPR */
+#define UDCDRS          __REG(0x40600348) /* Data Register - EPS */
+#define UDCDRT          __REG(0x4060034C) /* Data Register - EPT */
+#define UDCDRU          __REG(0x40600350) /* Data Register - EPU */
+#define UDCDRV          __REG(0x40600354) /* Data Register - EPV */
+#define UDCDRW          __REG(0x40600358) /* Data Register - EPW */
+#define UDCDRX          __REG(0x4060035C) /* Data Register - EPX */
+
+#define UDCCN(x)       __REG2(0x40600400, (x)<<2)
+#define UDCCRA          __REG(0x40600404) /* Configuration register EPA */
+#define UDCCRB          __REG(0x40600408) /* Configuration register EPB */
+#define UDCCRC          __REG(0x4060040C) /* Configuration register EPC */
+#define UDCCRD          __REG(0x40600410) /* Configuration register EPD */
+#define UDCCRE          __REG(0x40600414) /* Configuration register EPE */
+#define UDCCRF          __REG(0x40600418) /* Configuration register EPF */
+#define UDCCRG          __REG(0x4060041C) /* Configuration register EPG */
+#define UDCCRH          __REG(0x40600420) /* Configuration register EPH */
+#define UDCCRI          __REG(0x40600424) /* Configuration register EPI */
+#define UDCCRJ          __REG(0x40600428) /* Configuration register EPJ */
+#define UDCCRK          __REG(0x4060042C) /* Configuration register EPK */
+#define UDCCRL          __REG(0x40600430) /* Configuration register EPL */
+#define UDCCRM          __REG(0x40600434) /* Configuration register EPM */
+#define UDCCRN          __REG(0x40600438) /* Configuration register EPN */
+#define UDCCRP          __REG(0x4060043C) /* Configuration register EPP */
+#define UDCCRQ          __REG(0x40600440) /* Configuration register EPQ */
+#define UDCCRR          __REG(0x40600444) /* Configuration register EPR */
+#define UDCCRS          __REG(0x40600448) /* Configuration register EPS */
+#define UDCCRT          __REG(0x4060044C) /* Configuration register EPT */
+#define UDCCRU          __REG(0x40600450) /* Configuration register EPU */
+#define UDCCRV          __REG(0x40600454) /* Configuration register EPV */
+#define UDCCRW          __REG(0x40600458) /* Configuration register EPW */
+#define UDCCRX          __REG(0x4060045C) /* Configuration register EPX */
+
+#define UDCCONR_CN	(0x03 << 25)	/* Configuration Number */
+#define UDCCONR_CN_S	(25)
+#define UDCCONR_IN	(0x07 << 22)	/* Interface Number */
+#define UDCCONR_IN_S	(22)
+#define UDCCONR_AISN	(0x07 << 19)	/* Alternate Interface Number */
+#define UDCCONR_AISN_S	(19)
+#define UDCCONR_EN	(0x0f << 15)	/* Endpoint Number */
+#define UDCCONR_EN_S	(15)
+#define UDCCONR_ET	(0x03 << 13)	/* Endpoint Type: */
+#define UDCCONR_ET_S	(13)
+#define UDCCONR_ET_INT	(0x03 << 13)	/*   Interrupt */
+#define UDCCONR_ET_BULK	(0x02 << 13)	/*   Bulk */
+#define UDCCONR_ET_ISO	(0x01 << 13)	/*   Isochronous */
+#define UDCCONR_ET_NU	(0x00 << 13)	/*   Not used */
+#define UDCCONR_ED	(1 << 12)	/* Endpoint Direction */
+#define UDCCONR_MPS	(0x3ff << 2)	/* Maximum Packet Size */
+#define UDCCONR_MPS_S	(2)
+#define UDCCONR_DE	(1 << 1)	/* Double Buffering Enable */
+#define UDCCONR_EE	(1 << 0)	/* Endpoint Enable */
+
+
+#define UDC_INT_FIFOERROR  (0x2)
+#define UDC_INT_PACKETCMP  (0x1)
+
+#define UDC_FNR_MASK     (0x7ff)
+
+#define UDCCSR_WR_MASK   (UDCCSR_DME|UDCCSR_FST)
+#define UDC_BCR_MASK    (0x3ff)
+#endif
+
+/*
+ * Fast Infrared Communication Port
+ */
+
+#define FICP		__REG(0x40800000)  /* Start of FICP area */
+#define ICCR0		__REG(0x40800000)  /* ICP Control Register 0 */
+#define ICCR1		__REG(0x40800004)  /* ICP Control Register 1 */
+#define ICCR2		__REG(0x40800008)  /* ICP Control Register 2 */
+#define ICDR		__REG(0x4080000c)  /* ICP Data Register */
+#define ICSR0		__REG(0x40800014)  /* ICP Status Register 0 */
+#define ICSR1		__REG(0x40800018)  /* ICP Status Register 1 */
+
+#define ICCR0_AME	(1 << 7)	/* Adress match enable */
+#define ICCR0_TIE	(1 << 6)	/* Transmit FIFO interrupt enable */
+#define ICCR0_RIE	(1 << 5)	/* Recieve FIFO interrupt enable */
+#define ICCR0_RXE	(1 << 4)	/* Receive enable */
+#define ICCR0_TXE	(1 << 3)	/* Transmit enable */
+#define ICCR0_TUS	(1 << 2)	/* Transmit FIFO underrun select */
+#define ICCR0_LBM	(1 << 1)	/* Loopback mode */
+#define ICCR0_ITR	(1 << 0)	/* IrDA transmission */
+
+#define ICCR2_RXP       (1 << 3)	/* Receive Pin Polarity select */
+#define ICCR2_TXP       (1 << 2)	/* Transmit Pin Polarity select */
+#define ICCR2_TRIG	(3 << 0)	/* Receive FIFO Trigger threshold */
+#define ICCR2_TRIG_8    (0 << 0)	/* 	>= 8 bytes */
+#define ICCR2_TRIG_16   (1 << 0)	/*	>= 16 bytes */
+#define ICCR2_TRIG_32   (2 << 0)	/*	>= 32 bytes */
+
+#ifdef CONFIG_PXA27x
+#define ICSR0_EOC	(1 << 6)	/* DMA End of Descriptor Chain */
+#endif
+#define ICSR0_FRE	(1 << 5)	/* Framing error */
+#define ICSR0_RFS	(1 << 4)	/* Receive FIFO service request */
+#define ICSR0_TFS	(1 << 3)	/* Transnit FIFO service request */
+#define ICSR0_RAB	(1 << 2)	/* Receiver abort */
+#define ICSR0_TUR	(1 << 1)	/* Trunsmit FIFO underun */
+#define ICSR0_EIF	(1 << 0)	/* End/Error in FIFO */
+
+#define ICSR1_ROR	(1 << 6)	/* Receiver FIFO underrun  */
+#define ICSR1_CRE	(1 << 5)	/* CRC error */
+#define ICSR1_EOF	(1 << 4)	/* End of frame */
+#define ICSR1_TNF	(1 << 3)	/* Transmit FIFO not full */
+#define ICSR1_RNE	(1 << 2)	/* Receive FIFO not empty */
+#define ICSR1_TBY	(1 << 1)	/* Tramsmiter busy flag */
+#define ICSR1_RSY	(1 << 0)	/* Recevier synchronized flag */
+
+
+/*
+ * Real Time Clock
+ */
+
+#define RCNR		__REG(0x40900000)  /* RTC Count Register */
+#define RTAR		__REG(0x40900004)  /* RTC Alarm Register */
+#define RTSR		__REG(0x40900008)  /* RTC Status Register */
+#define RTTR		__REG(0x4090000C)  /* RTC Timer Trim Register */
+#define PIAR		__REG(0x40900038)  /* Periodic Interrupt Alarm Register */
+
+#define RTSR_PICE	(1 << 15)	/* Periodic interrupt count enable */
+#define RTSR_PIALE	(1 << 14)	/* Periodic interrupt Alarm enable */
+#define RTSR_HZE	(1 << 3)	/* HZ interrupt enable */
+#define RTSR_ALE	(1 << 2)	/* RTC alarm interrupt enable */
+#define RTSR_HZ		(1 << 1)	/* HZ rising-edge detected */
+#define RTSR_AL		(1 << 0)	/* RTC alarm detected */
+
+
+/*
+ * OS Timer & Match Registers
+ */
+
+#define OSMR0		__REG(0x40A00000)  /* */
+#define OSMR1		__REG(0x40A00004)  /* */
+#define OSMR2		__REG(0x40A00008)  /* */
+#define OSMR3		__REG(0x40A0000C)  /* */
+#define OSMR4		__REG(0x40A00080)  /* */
+#define OSCR		__REG(0x40A00010)  /* OS Timer Counter Register */
+#define OSCR4		__REG(0x40A00040)  /* OS Timer Counter Register */
+#define OMCR4		__REG(0x40A000C0)  /* */
+#define OSSR		__REG(0x40A00014)  /* OS Timer Status Register */
+#define OWER		__REG(0x40A00018)  /* OS Timer Watchdog Enable Register */
+#define OIER		__REG(0x40A0001C)  /* OS Timer Interrupt Enable Register */
+
+#define OSSR_M3		(1 << 3)	/* Match status channel 3 */
+#define OSSR_M2		(1 << 2)	/* Match status channel 2 */
+#define OSSR_M1		(1 << 1)	/* Match status channel 1 */
+#define OSSR_M0		(1 << 0)	/* Match status channel 0 */
+
+#define OWER_WME	(1 << 0)	/* Watchdog Match Enable */
+
+#define OIER_E3		(1 << 3)	/* Interrupt enable channel 3 */
+#define OIER_E2		(1 << 2)	/* Interrupt enable channel 2 */
+#define OIER_E1		(1 << 1)	/* Interrupt enable channel 1 */
+#define OIER_E0		(1 << 0)	/* Interrupt enable channel 0 */
+
+
+/*
+ * Pulse Width Modulator
+ */
+
+#define PWM_CTRL0	__REG(0x40B00000)  /* PWM 0 Control Register */
+#define PWM_PWDUTY0	__REG(0x40B00004)  /* PWM 0 Duty Cycle Register */
+#define PWM_PERVAL0	__REG(0x40B00008)  /* PWM 0 Period Control Register */
+
+#define PWM_CTRL1	__REG(0x40C00000)  /* PWM 1Control Register */
+#define PWM_PWDUTY1	__REG(0x40C00004)  /* PWM 1 Duty Cycle Register */
+#define PWM_PERVAL1	__REG(0x40C00008)  /* PWM 1 Period Control Register */
+
+/* AERONIX added for Zipit2*/
+#define PWM_CTRL2       __REG(0x40B00010)
+#define PWM_PWDUTY2     __REG(0x40B00014)
+#define PWM_PERVAL2     __REG(0x40B00018)
+
+/*
+ * Interrupt Controller
+ */
+
+#define ICIP		__REG(0x40D00000)  /* Interrupt Controller IRQ Pending Register */
+#define ICMR		__REG(0x40D00004)  /* Interrupt Controller Mask Register */
+#define ICLR		__REG(0x40D00008)  /* Interrupt Controller Level Register */
+#define ICFP		__REG(0x40D0000C)  /* Interrupt Controller FIQ Pending Register */
+#define ICPR		__REG(0x40D00010)  /* Interrupt Controller Pending Register */
+#define ICCR		__REG(0x40D00014)  /* Interrupt Controller Control Register */
+
+
+/*
+ * General Purpose I/O
+ */
+
+#define GPLR0		__REG(0x40E00000)  /* GPIO Pin-Level Register GPIO<31:0> */
+#define GPLR1		__REG(0x40E00004)  /* GPIO Pin-Level Register GPIO<63:32> */
+#define GPLR2		__REG(0x40E00008)  /* GPIO Pin-Level Register GPIO<80:64> */
+
+#define GPDR0		__REG(0x40E0000C)  /* GPIO Pin Direction Register GPIO<31:0> */
+#define GPDR1		__REG(0x40E00010)  /* GPIO Pin Direction Register GPIO<63:32> */
+#define GPDR2		__REG(0x40E00014)  /* GPIO Pin Direction Register GPIO<80:64> */
+
+#define GPSR0		__REG(0x40E00018)  /* GPIO Pin Output Set Register GPIO<31:0> */
+#define GPSR1		__REG(0x40E0001C)  /* GPIO Pin Output Set Register GPIO<63:32> */
+#define GPSR2		__REG(0x40E00020)  /* GPIO Pin Output Set Register GPIO<80:64> */
+
+#define GPCR0		__REG(0x40E00024)  /* GPIO Pin Output Clear Register GPIO<31:0> */
+#define GPCR1		__REG(0x40E00028)  /* GPIO Pin Output Clear Register GPIO <63:32> */
+#define GPCR2		__REG(0x40E0002C)  /* GPIO Pin Output Clear Register GPIO <80:64> */
+
+#define GRER0		__REG(0x40E00030)  /* GPIO Rising-Edge Detect Register GPIO<31:0> */
+#define GRER1		__REG(0x40E00034)  /* GPIO Rising-Edge Detect Register GPIO<63:32> */
+#define GRER2		__REG(0x40E00038)  /* GPIO Rising-Edge Detect Register GPIO<80:64> */
+
+#define GFER0		__REG(0x40E0003C)  /* GPIO Falling-Edge Detect Register GPIO<31:0> */
+#define GFER1		__REG(0x40E00040)  /* GPIO Falling-Edge Detect Register GPIO<63:32> */
+#define GFER2		__REG(0x40E00044)  /* GPIO Falling-Edge Detect Register GPIO<80:64> */
+
+#define GEDR0		__REG(0x40E00048)  /* GPIO Edge Detect Status Register GPIO<31:0> */
+#define GEDR1		__REG(0x40E0004C)  /* GPIO Edge Detect Status Register GPIO<63:32> */
+#define GEDR2		__REG(0x40E00050)  /* GPIO Edge Detect Status Register GPIO<80:64> */
+
+#define GAFR0_L		__REG(0x40E00054)  /* GPIO Alternate Function Select Register GPIO<15:0> */
+#define GAFR0_U		__REG(0x40E00058)  /* GPIO Alternate Function Select Register GPIO<31:16> */
+#define GAFR1_L		__REG(0x40E0005C)  /* GPIO Alternate Function Select Register GPIO<47:32> */
+#define GAFR1_U		__REG(0x40E00060)  /* GPIO Alternate Function Select Register GPIO<63:48> */
+#define GAFR2_L		__REG(0x40E00064)  /* GPIO Alternate Function Select Register GPIO<79:64> */
+#define GAFR2_U		__REG(0x40E00068)  /* GPIO Alternate Function Select Register GPIO<95-80> */
+#define GAFR3_L		__REG(0x40E0006C)  /* GPIO Alternate Function Select Register GPIO<111:96> */
+#define GAFR3_U		__REG(0x40E00070)  /* GPIO Alternate Function Select Register GPIO<127:112> */
+
+#define GPLR3		__REG(0x40E00100)  /* GPIO Pin-Level Register GPIO<127:96> */
+#define GPDR3		__REG(0x40E0010C)  /* GPIO Pin Direction Register GPIO<127:96> */
+#define GPSR3		__REG(0x40E00118)  /* GPIO Pin Output Set Register GPIO<127:96> */
+#define GPCR3		__REG(0x40E00124)  /* GPIO Pin Output Clear Register GPIO<127:96> */
+#define GRER3		__REG(0x40E00130)  /* GPIO Rising-Edge Detect Register GPIO<127:96> */
+#define GFER3		__REG(0x40E0013C)  /* GPIO Falling-Edge Detect Register GPIO<127:96> */
+#define GEDR3		__REG(0x40E00148)  /* GPIO Edge Detect Status Register GPIO<127:96> */
+
+/* More handy macros.  The argument is a literal GPIO number. */
+
+#define GPIO_bit(x)	(1 << ((x) & 0x1f))
+
+#ifdef CONFIG_PXA27x
+
+/* Interrupt Controller */
+
+#define ICIP2		__REG(0x40D0009C)  /* Interrupt Controller IRQ Pending Register 2 */
+#define ICMR2		__REG(0x40D000A0)  /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40D000A4)  /* Interrupt Controller Level Register 2 */
+#define ICFP2		__REG(0x40D000A8)  /* Interrupt Controller FIQ Pending Register 2 */
+#define ICPR2		__REG(0x40D000AC)  /* Interrupt Controller Pending Register 2 */
+
+#define _GPLR(x)	__REG2(0x40E00000, ((x) & 0x60) >> 3)
+#define _GPDR(x)	__REG2(0x40E0000C, ((x) & 0x60) >> 3)
+#define _GPSR(x)	__REG2(0x40E00018, ((x) & 0x60) >> 3)
+#define _GPCR(x)	__REG2(0x40E00024, ((x) & 0x60) >> 3)
+#define _GRER(x)	__REG2(0x40E00030, ((x) & 0x60) >> 3)
+#define _GFER(x)	__REG2(0x40E0003C, ((x) & 0x60) >> 3)
+#define _GEDR(x)	__REG2(0x40E00048, ((x) & 0x60) >> 3)
+#define _GAFR(x)	__REG2(0x40E00054, ((x) & 0x70) >> 2)
+
+#define GPLR(x) 	(*((((x) & 0x7f) < 96) ? &_GPLR(x) : &GPLR3))
+#define GPDR(x)		(*((((x) & 0x7f) < 96) ? &_GPDR(x) : &GPDR3))
+#define GPSR(x)		(*((((x) & 0x7f) < 96) ? &_GPSR(x) : &GPSR3))
+#define GPCR(x)		(*((((x) & 0x7f) < 96) ? &_GPCR(x) : &GPCR3))
+#define GRER(x)		(*((((x) & 0x7f) < 96) ? &_GRER(x) : &GRER3))
+#define GFER(x)		(*((((x) & 0x7f) < 96) ? &_GFER(x) : &GFER3))
+#define GEDR(x)		(*((((x) & 0x7f) < 96) ? &_GEDR(x) : &GEDR3))
+#define GAFR(x)		(*((((x) & 0x7f) < 96) ? &_GAFR(x) : \
+			 ((((x) & 0x7f) < 112) ? &GAFR3_L : &GAFR3_U)))
+#else
+
+#define GPLR(x)		__REG2(0x40E00000, ((x) & 0x60) >> 3)
+#define GPDR(x)		__REG2(0x40E0000C, ((x) & 0x60) >> 3)
+#define GPSR(x)		__REG2(0x40E00018, ((x) & 0x60) >> 3)
+#define GPCR(x)		__REG2(0x40E00024, ((x) & 0x60) >> 3)
+#define GRER(x)		__REG2(0x40E00030, ((x) & 0x60) >> 3)
+#define GFER(x)		__REG2(0x40E0003C, ((x) & 0x60) >> 3)
+#define GEDR(x)		__REG2(0x40E00048, ((x) & 0x60) >> 3)
+#define GAFR(x)		__REG2(0x40E00054, ((x) & 0x70) >> 2)
+
+#endif
+
+
+/* GPIO alternate function assignments */
+
+#define GPIO1_RST		1	/* reset */
+#define GPIO6_MMCCLK		6	/* MMC Clock */
+#define GPIO7_48MHz		7	/* 48 MHz clock output */
+#define GPIO8_MMCCS0		8	/* MMC Chip Select 0 */
+#define GPIO9_MMCCS1		9	/* MMC Chip Select 1 */
+#define GPIO10_RTCCLK		10	/* real time clock (1 Hz) */
+#define GPIO11_3_6MHz		11	/* 3.6 MHz oscillator out */
+#define GPIO12_32KHz		12	/* 32 kHz out */
+#define GPIO13_MBGNT		13	/* memory controller grant */
+#define GPIO14_MBREQ		14	/* alternate bus master request */
+#define GPIO15_nCS_1		15	/* chip select 1 */
+#define GPIO16_PWM0		16	/* PWM0 output */
+#define GPIO17_PWM1		17	/* PWM1 output */
+#define GPIO18_RDY		18	/* Ext. Bus Ready */
+#define GPIO19_DREQ1		19	/* External DMA Request */
+#define GPIO20_DREQ0		20	/* External DMA Request */
+#define GPIO23_SCLK		23	/* SSP clock */
+#define GPIO24_SFRM		24	/* SSP Frame */
+#define GPIO25_STXD		25	/* SSP transmit */
+#define GPIO26_SRXD		26	/* SSP receive */
+#define GPIO27_SEXTCLK		27	/* SSP ext_clk */
+#define GPIO28_BITCLK		28	/* AC97/I2S bit_clk */
+#define GPIO29_SDATA_IN		29	/* AC97 Sdata_in0 / I2S Sdata_in */
+#define GPIO30_SDATA_OUT	30	/* AC97/I2S Sdata_out */
+#define GPIO31_SYNC		31	/* AC97/I2S sync */
+#define GPIO32_SDATA_IN1	32	/* AC97 Sdata_in1 */
+#define GPIO32_SYSCLK		32	/* I2S System Clock */
+#define GPIO32_MMCCLK		32	/* MMC Clock (PXA270) */
+#define GPIO33_nCS_5		33	/* chip select 5 */
+#define GPIO34_FFRXD		34	/* FFUART receive */
+#define GPIO34_MMCCS0		34	/* MMC Chip Select 0 */
+#define GPIO35_FFCTS		35	/* FFUART Clear to send */
+#define GPIO36_FFDCD		36	/* FFUART Data carrier detect */
+#define GPIO37_FFDSR		37	/* FFUART data set ready */
+#define GPIO38_FFRI		38	/* FFUART Ring Indicator */
+#define GPIO39_MMCCS1		39	/* MMC Chip Select 1 */
+#define GPIO39_FFTXD		39	/* FFUART transmit data */
+#define GPIO40_FFDTR		40	/* FFUART data terminal Ready */
+#define GPIO41_FFRTS		41	/* FFUART request to send */
+#define GPIO42_BTRXD		42	/* BTUART receive data */
+#define GPIO42_HWRXD		42	/* HWUART receive data */
+#define GPIO43_BTTXD		43	/* BTUART transmit data */
+#define GPIO43_HWTXD		43	/* HWUART transmit data */
+#define GPIO44_BTCTS		44	/* BTUART clear to send */
+#define GPIO44_HWCTS		44	/* HWUART clear to send */
+#define GPIO45_BTRTS		45	/* BTUART request to send */
+#define GPIO45_HWRTS		45	/* HWUART request to send */
+#define GPIO45_AC97_SYSCLK	45	/* AC97 System Clock */
+#define GPIO46_ICPRXD		46	/* ICP receive data */
+#define GPIO46_STRXD		46	/* STD_UART receive data */
+#define GPIO47_ICPTXD		47	/* ICP transmit data */
+#define GPIO47_STTXD		47	/* STD_UART transmit data */
+#define GPIO48_nPOE		48	/* Output Enable for Card Space */
+#define GPIO49_nPWE		49	/* Write Enable for Card Space */
+#define GPIO50_nPIOR		50	/* I/O Read for Card Space */
+#define GPIO51_nPIOW		51	/* I/O Write for Card Space */
+#define GPIO52_nPCE_1		52	/* Card Enable for Card Space */
+#define GPIO53_nPCE_2		53	/* Card Enable for Card Space */
+#define GPIO53_MMCCLK		53	/* MMC Clock */
+#define GPIO54_MMCCLK		54	/* MMC Clock */
+#define GPIO54_pSKTSEL		54	/* Socket Select for Card Space */
+#define GPIO54_nPCE_2		54	/* Card Enable for Card Space (PXA27x) */
+#define GPIO55_nPREG		55	/* Card Address bit 26 */
+#define GPIO56_nPWAIT		56	/* Wait signal for Card Space */
+#define GPIO57_nIOIS16		57	/* Bus Width select for I/O Card Space */
+#define GPIO58_LDD_0		58	/* LCD data pin 0 */
+#define GPIO59_LDD_1		59	/* LCD data pin 1 */
+#define GPIO60_LDD_2		60	/* LCD data pin 2 */
+#define GPIO61_LDD_3		61	/* LCD data pin 3 */
+#define GPIO62_LDD_4		62	/* LCD data pin 4 */
+#define GPIO63_LDD_5		63	/* LCD data pin 5 */
+#define GPIO64_LDD_6		64	/* LCD data pin 6 */
+#define GPIO65_LDD_7		65	/* LCD data pin 7 */
+#define GPIO66_LDD_8		66	/* LCD data pin 8 */
+#define GPIO66_MBREQ		66	/* alternate bus master req */
+#define GPIO67_LDD_9		67	/* LCD data pin 9 */
+#define GPIO67_MMCCS0		67	/* MMC Chip Select 0 */
+#define GPIO68_LDD_10		68	/* LCD data pin 10 */
+#define GPIO68_MMCCS1		68	/* MMC Chip Select 1 */
+#define GPIO69_LDD_11		69	/* LCD data pin 11 */
+#define GPIO69_MMCCLK		69	/* MMC_CLK */
+#define GPIO70_LDD_12		70	/* LCD data pin 12 */
+#define GPIO70_RTCCLK		70	/* Real Time clock (1 Hz) */
+#define GPIO71_LDD_13		71	/* LCD data pin 13 */
+#define GPIO71_3_6MHz		71	/* 3.6 MHz Oscillator clock */
+#define GPIO72_LDD_14		72	/* LCD data pin 14 */
+#define GPIO72_32kHz		72	/* 32 kHz clock */
+#define GPIO73_LDD_15		73	/* LCD data pin 15 */
+#define GPIO73_MBGNT		73	/* Memory controller grant */
+#define GPIO74_LCD_FCLK		74	/* LCD Frame clock */
+#define GPIO75_LCD_LCLK		75	/* LCD line clock */
+#define GPIO76_LCD_PCLK		76	/* LCD Pixel clock */
+#define GPIO77_LCD_ACBIAS	77	/* LCD AC Bias */
+#define GPIO78_nCS_2		78	/* chip select 2 */
+#define GPIO79_nCS_3		79	/* chip select 3 */
+#define GPIO80_nCS_4		80	/* chip select 4 */
+#define GPIO81_NSCLK		81	/* NSSP clock */
+#define GPIO82_NSFRM		82	/* NSSP Frame */
+#define GPIO83_NSTXD		83	/* NSSP transmit */
+#define GPIO84_NSRXD		84	/* NSSP receive */
+#define GPIO85_nPCE_1		85	/* Card Enable for Card Space (PXA27x) */
+#define GPIO92_MMCDAT0		92	/* MMC DAT0 (PXA27x) */
+#define GPIO102_nPCE_1		102	/* PCMCIA (PXA27x) */
+#define GPIO109_MMCDAT1		109	/* MMC DAT1 (PXA27x) */
+#define GPIO110_MMCDAT2		110	/* MMC DAT2 (PXA27x) */
+#define GPIO110_MMCCS0		110	/* MMC Chip Select 0 (PXA27x) */
+#define GPIO111_MMCDAT3		111	/* MMC DAT3 (PXA27x) */
+#define GPIO111_MMCCS1		111	/* MMC Chip Select 1 (PXA27x) */
+#define GPIO112_MMCCMD		112	/* MMC CMD (PXA27x) */
+#define GPIO113_I2S_SYSCLK	113	/* I2S System Clock (PXA27x) */
+#define GPIO113_AC97_RESET_N	113	/* AC97 NRESET on (PXA27x) */
+
+/* GPIO alternate function mode & direction */
+
+#define GPIO_IN			0x000
+#define GPIO_OUT		0x080
+#define GPIO_ALT_FN_1_IN	0x100
+#define GPIO_ALT_FN_1_OUT	0x180
+#define GPIO_ALT_FN_2_IN	0x200
+#define GPIO_ALT_FN_2_OUT	0x280
+#define GPIO_ALT_FN_3_IN	0x300
+#define GPIO_ALT_FN_3_OUT	0x380
+#define GPIO_MD_MASK_NR		0x07f
+#define GPIO_MD_MASK_DIR	0x080
+#define GPIO_MD_MASK_FN		0x300
+#define GPIO_DFLT_LOW		0x400
+#define GPIO_DFLT_HIGH		0x800
+
+#define GPIO1_RTS_MD		( 1 | GPIO_ALT_FN_1_IN)
+#define GPIO6_MMCCLK_MD		( 6 | GPIO_ALT_FN_1_OUT)
+#define GPIO7_48MHz_MD		( 7 | GPIO_ALT_FN_1_OUT)
+#define GPIO8_MMCCS0_MD		( 8 | GPIO_ALT_FN_1_OUT)
+#define GPIO9_MMCCS1_MD		( 9 | GPIO_ALT_FN_1_OUT)
+#define GPIO10_RTCCLK_MD	(10 | GPIO_ALT_FN_1_OUT)
+#define GPIO11_3_6MHz_MD	(11 | GPIO_ALT_FN_1_OUT)
+#define GPIO12_32KHz_MD		(12 | GPIO_ALT_FN_1_OUT)
+#define GPIO13_MBGNT_MD		(13 | GPIO_ALT_FN_2_OUT)
+#define GPIO14_MBREQ_MD		(14 | GPIO_ALT_FN_1_IN)
+#define GPIO15_nCS_1_MD		(15 | GPIO_ALT_FN_2_OUT)
+#define GPIO16_PWM0_MD		(16 | GPIO_ALT_FN_2_OUT)
+#define GPIO17_PWM1_MD		(17 | GPIO_ALT_FN_2_OUT)
+#define GPIO18_RDY_MD		(18 | GPIO_ALT_FN_1_IN)
+#define GPIO19_DREQ1_MD		(19 | GPIO_ALT_FN_1_IN)
+#define GPIO20_DREQ0_MD		(20 | GPIO_ALT_FN_1_IN)
+#define GPIO23_SCLK_MD		(23 | GPIO_ALT_FN_2_OUT)
+#define GPIO24_SFRM_MD		(24 | GPIO_ALT_FN_2_OUT)
+#define GPIO25_STXD_MD		(25 | GPIO_ALT_FN_2_OUT)
+#define GPIO26_SRXD_MD		(26 | GPIO_ALT_FN_1_IN)
+#define GPIO27_SEXTCLK_MD	(27 | GPIO_ALT_FN_1_IN)
+#define GPIO28_BITCLK_AC97_MD	(28 | GPIO_ALT_FN_1_IN)
+#define GPIO28_BITCLK_IN_I2S_MD	(28 | GPIO_ALT_FN_2_IN)
+#define GPIO28_BITCLK_OUT_I2S_MD	(28 | GPIO_ALT_FN_1_OUT)
+#define GPIO29_SDATA_IN_AC97_MD	(29 | GPIO_ALT_FN_1_IN)
+#define GPIO29_SDATA_IN_I2S_MD	(29 | GPIO_ALT_FN_2_IN)
+#define GPIO30_SDATA_OUT_AC97_MD	(30 | GPIO_ALT_FN_2_OUT)
+#define GPIO30_SDATA_OUT_I2S_MD	(30 | GPIO_ALT_FN_1_OUT)
+#define GPIO31_SYNC_I2S_MD	(31 | GPIO_ALT_FN_1_OUT)
+#define GPIO31_SYNC_AC97_MD	(31 | GPIO_ALT_FN_2_OUT)
+#define GPIO32_SDATA_IN1_AC97_MD	(32 | GPIO_ALT_FN_1_IN)
+#define GPIO32_SYSCLK_I2S_MD	(32 | GPIO_ALT_FN_1_OUT)
+#define GPIO32_MMCCLK_MD		( 32 | GPIO_ALT_FN_2_OUT)
+#define GPIO33_nCS_5_MD		(33 | GPIO_ALT_FN_2_OUT)
+#define GPIO34_FFRXD_MD		(34 | GPIO_ALT_FN_1_IN)
+#define GPIO34_MMCCS0_MD	(34 | GPIO_ALT_FN_2_OUT)
+#define GPIO35_FFCTS_MD		(35 | GPIO_ALT_FN_1_IN)
+#define GPIO36_FFDCD_MD		(36 | GPIO_ALT_FN_1_IN)
+#define GPIO37_FFDSR_MD		(37 | GPIO_ALT_FN_1_IN)
+#define GPIO38_FFRI_MD		(38 | GPIO_ALT_FN_1_IN)
+#define GPIO39_MMCCS1_MD	(39 | GPIO_ALT_FN_1_OUT)
+#define GPIO39_FFTXD_MD		(39 | GPIO_ALT_FN_2_OUT)
+#define GPIO40_FFDTR_MD		(40 | GPIO_ALT_FN_2_OUT)
+#define GPIO41_FFRTS_MD		(41 | GPIO_ALT_FN_2_OUT)
+#define GPIO42_BTRXD_MD		(42 | GPIO_ALT_FN_1_IN)
+#define GPIO42_HWRXD_MD		(42 | GPIO_ALT_FN_3_IN)
+#define GPIO43_BTTXD_MD		(43 | GPIO_ALT_FN_2_OUT)
+#define GPIO43_HWTXD_MD		(43 | GPIO_ALT_FN_3_OUT)
+#define GPIO44_BTCTS_MD		(44 | GPIO_ALT_FN_1_IN)
+#define GPIO44_HWCTS_MD		(44 | GPIO_ALT_FN_3_IN)
+#define GPIO45_BTRTS_MD		(45 | GPIO_ALT_FN_2_OUT)
+#define GPIO45_HWRTS_MD		(45 | GPIO_ALT_FN_3_OUT)
+#define GPIO45_SYSCLK_AC97_MD		(45 | GPIO_ALT_FN_1_OUT)
+#define GPIO46_ICPRXD_MD	(46 | GPIO_ALT_FN_1_IN)
+#define GPIO46_STRXD_MD		(46 | GPIO_ALT_FN_2_IN)
+#define GPIO47_ICPTXD_MD	(47 | GPIO_ALT_FN_2_OUT)
+#define GPIO47_STTXD_MD		(47 | GPIO_ALT_FN_1_OUT)
+#define GPIO48_nPOE_MD		(48 | GPIO_ALT_FN_2_OUT)
+#define GPIO48_HWTXD_MD         (48 | GPIO_ALT_FN_1_OUT)
+#define GPIO48_nPOE_MD          (48 | GPIO_ALT_FN_2_OUT)
+#define GPIO49_HWRXD_MD		(49 | GPIO_ALT_FN_1_IN)
+#define GPIO49_nPWE_MD		(49 | GPIO_ALT_FN_2_OUT)
+#define GPIO50_nPIOR_MD		(50 | GPIO_ALT_FN_2_OUT)
+#define GPIO50_HWCTS_MD         (50 | GPIO_ALT_FN_1_IN)
+#define GPIO51_HWRTS_MD         (51 | GPIO_ALT_FN_1_OUT)
+#define GPIO51_nPIOW_MD		(51 | GPIO_ALT_FN_2_OUT)
+#define GPIO52_nPCE_1_MD	(52 | GPIO_ALT_FN_2_OUT)
+#define GPIO53_nPCE_2_MD	(53 | GPIO_ALT_FN_2_OUT)
+#define GPIO53_MMCCLK_MD	(53 | GPIO_ALT_FN_1_OUT)
+#define GPIO54_MMCCLK_MD	(54 | GPIO_ALT_FN_1_OUT)
+#define GPIO54_nPCE_2_MD	(54 | GPIO_ALT_FN_2_OUT)
+#define GPIO54_pSKTSEL_MD	(54 | GPIO_ALT_FN_2_OUT)
+#define GPIO55_nPREG_MD		(55 | GPIO_ALT_FN_2_OUT)
+#define GPIO56_nPWAIT_MD	(56 | GPIO_ALT_FN_1_IN)
+#define GPIO57_nIOIS16_MD	(57 | GPIO_ALT_FN_1_IN)
+#define GPIO58_LDD_0_MD		(58 | GPIO_ALT_FN_2_OUT)
+#define GPIO59_LDD_1_MD		(59 | GPIO_ALT_FN_2_OUT)
+#define GPIO60_LDD_2_MD		(60 | GPIO_ALT_FN_2_OUT)
+#define GPIO61_LDD_3_MD		(61 | GPIO_ALT_FN_2_OUT)
+#define GPIO62_LDD_4_MD		(62 | GPIO_ALT_FN_2_OUT)
+#define GPIO63_LDD_5_MD		(63 | GPIO_ALT_FN_2_OUT)
+#define GPIO64_LDD_6_MD		(64 | GPIO_ALT_FN_2_OUT)
+#define GPIO65_LDD_7_MD		(65 | GPIO_ALT_FN_2_OUT)
+#define GPIO66_LDD_8_MD		(66 | GPIO_ALT_FN_2_OUT)
+#define GPIO66_MBREQ_MD		(66 | GPIO_ALT_FN_1_IN)
+#define GPIO67_LDD_9_MD		(67 | GPIO_ALT_FN_2_OUT)
+#define GPIO67_MMCCS0_MD	(67 | GPIO_ALT_FN_1_OUT)
+#define GPIO68_LDD_10_MD	(68 | GPIO_ALT_FN_2_OUT)
+#define GPIO68_MMCCS1_MD	(68 | GPIO_ALT_FN_1_OUT)
+#define GPIO69_LDD_11_MD	(69 | GPIO_ALT_FN_2_OUT)
+#define GPIO69_MMCCLK_MD	(69 | GPIO_ALT_FN_1_OUT)
+#define GPIO70_LDD_12_MD	(70 | GPIO_ALT_FN_2_OUT)
+#define GPIO70_RTCCLK_MD	(70 | GPIO_ALT_FN_1_OUT)
+#define GPIO71_LDD_13_MD	(71 | GPIO_ALT_FN_2_OUT)
+#define GPIO71_3_6MHz_MD	(71 | GPIO_ALT_FN_1_OUT)
+#define GPIO72_LDD_14_MD	(72 | GPIO_ALT_FN_2_OUT)
+#define GPIO72_32kHz_MD		(72 | GPIO_ALT_FN_1_OUT)
+#define GPIO73_LDD_15_MD	(73 | GPIO_ALT_FN_2_OUT)
+#define GPIO73_MBGNT_MD		(73 | GPIO_ALT_FN_1_OUT)
+#define GPIO74_LCD_FCLK_MD	(74 | GPIO_ALT_FN_2_OUT)
+#define GPIO75_LCD_LCLK_MD	(75 | GPIO_ALT_FN_2_OUT)
+#define GPIO76_LCD_PCLK_MD	(76 | GPIO_ALT_FN_2_OUT)
+#define GPIO77_LCD_ACBIAS_MD	(77 | GPIO_ALT_FN_2_OUT)
+#define GPIO78_nCS_2_MD		(78 | GPIO_ALT_FN_2_OUT)
+#define GPIO79_nCS_3_MD		(79 | GPIO_ALT_FN_2_OUT)
+#define GPIO79_pSKTSEL_MD	(79 | GPIO_ALT_FN_1_OUT)
+#define GPIO80_nCS_4_MD		(80 | GPIO_ALT_FN_2_OUT)
+#define GPIO81_NSSP_CLK_OUT 	(81 | GPIO_ALT_FN_1_OUT)
+#define GPIO81_NSSP_CLK_IN  	(81 | GPIO_ALT_FN_1_IN)
+#define GPIO82_NSSP_FRM_OUT 	(82 | GPIO_ALT_FN_1_OUT)
+#define GPIO82_NSSP_FRM_IN  	(82 | GPIO_ALT_FN_1_IN)
+#define GPIO83_NSSP_TX      	(83 | GPIO_ALT_FN_1_OUT)
+#define GPIO83_NSSP_RX      	(83 | GPIO_ALT_FN_2_IN)
+#define GPIO84_NSSP_TX      	(84 | GPIO_ALT_FN_1_OUT)
+#define GPIO84_NSSP_RX      	(84 | GPIO_ALT_FN_2_IN)
+#define GPIO85_nPCE_1_MD	(85 | GPIO_ALT_FN_1_OUT)
+#define GPIO92_MMCDAT0_MD	(92 | GPIO_ALT_FN_1_OUT)
+#define GPIO102_nPCE_1_MD	(102 | GPIO_ALT_FN_1_OUT)
+#define GPIO104_pSKTSEL_MD	(104 | GPIO_ALT_FN_1_OUT)
+#define GPIO109_MMCDAT1_MD	(109 | GPIO_ALT_FN_1_OUT)
+#define GPIO110_MMCDAT2_MD	(110 | GPIO_ALT_FN_1_OUT)
+#define GPIO110_MMCCS0_MD	(110 | GPIO_ALT_FN_1_OUT)
+#define GPIO111_MMCDAT3_MD	(111 | GPIO_ALT_FN_1_OUT)
+#define GPIO110_MMCCS1_MD	(111 | GPIO_ALT_FN_1_OUT)
+#define GPIO112_MMCCMD_MD	(112 | GPIO_ALT_FN_1_OUT)
+#define GPIO113_I2S_SYSCLK_MD	(113 | GPIO_ALT_FN_1_OUT)
+#define GPIO113_AC97_RESET_N_MD	(113 | GPIO_ALT_FN_2_OUT)
+#define GPIO117_I2CSCL_MD	(117 | GPIO_ALT_FN_1_IN)
+#define GPIO118_I2CSDA_MD	(118 | GPIO_ALT_FN_1_IN)
+
+/*
+ * Power Manager
+ */
+
+#define PMCR		__REG(0x40F00000)  /* Power Manager Control Register */
+#define PSSR		__REG(0x40F00004)  /* Power Manager Sleep Status Register */
+#define PSPR		__REG(0x40F00008)  /* Power Manager Scratch Pad Register */
+#define PWER		__REG(0x40F0000C)  /* Power Manager Wake-up Enable Register */
+#define PRER		__REG(0x40F00010)  /* Power Manager GPIO Rising-Edge Detect Enable Register */
+#define PFER		__REG(0x40F00014)  /* Power Manager GPIO Falling-Edge Detect Enable Register */
+#define PEDR		__REG(0x40F00018)  /* Power Manager GPIO Edge Detect Status Register */
+#define PCFR		__REG(0x40F0001C)  /* Power Manager General Configuration Register */
+#define PGSR0		__REG(0x40F00020)  /* Power Manager GPIO Sleep State Register for GP[31-0] */
+#define PGSR1		__REG(0x40F00024)  /* Power Manager GPIO Sleep State Register for GP[63-32] */
+#define PGSR2		__REG(0x40F00028)  /* Power Manager GPIO Sleep State Register for GP[84-64] */
+#define PGSR3		__REG(0x40F0002C)  /* Power Manager GPIO Sleep State Register for GP[118-96] */
+#define RCSR		__REG(0x40F00030)  /* Reset Controller Status Register */
+
+#define PSLR		__REG(0x40F00034)	/* Power Manager Sleep Config Register */
+#define PSTR		__REG(0x40F00038)	/*Power Manager Standby Config Register */
+#define PSNR		__REG(0x40F0003C)	/*Power Manager Sense Config Register */
+#define PVCR		__REG(0x40F00040)	/*Power Manager VoltageControl Register */
+#define PKWR		__REG(0x40F00050)	/* Power Manager KB Wake-up Enable Reg */
+#define PKSR		__REG(0x40F00054)	/* Power Manager KB Level-Detect Register */
+#define PCMD(x)	__REG2(0x40F00080, (x)<<2)
+#define PCMD0	__REG(0x40F00080 + 0 * 4)
+#define PCMD1	__REG(0x40F00080 + 1 * 4)
+#define PCMD2	__REG(0x40F00080 + 2 * 4)
+#define PCMD3	__REG(0x40F00080 + 3 * 4)
+#define PCMD4	__REG(0x40F00080 + 4 * 4)
+#define PCMD5	__REG(0x40F00080 + 5 * 4)
+#define PCMD6	__REG(0x40F00080 + 6 * 4)
+#define PCMD7	__REG(0x40F00080 + 7 * 4)
+#define PCMD8	__REG(0x40F00080 + 8 * 4)
+#define PCMD9	__REG(0x40F00080 + 9 * 4)
+#define PCMD10	__REG(0x40F00080 + 10 * 4)
+#define PCMD11	__REG(0x40F00080 + 11 * 4)
+#define PCMD12	__REG(0x40F00080 + 12 * 4)
+#define PCMD13	__REG(0x40F00080 + 13 * 4)
+#define PCMD14	__REG(0x40F00080 + 14 * 4)
+#define PCMD15	__REG(0x40F00080 + 15 * 4)
+#define PCMD16	__REG(0x40F00080 + 16 * 4)
+#define PCMD17	__REG(0x40F00080 + 17 * 4)
+#define PCMD18	__REG(0x40F00080 + 18 * 4)
+#define PCMD19	__REG(0x40F00080 + 19 * 4)
+#define PCMD20	__REG(0x40F00080 + 20 * 4)
+#define PCMD21	__REG(0x40F00080 + 21 * 4)
+#define PCMD22	__REG(0x40F00080 + 22 * 4)
+#define PCMD23	__REG(0x40F00080 + 23 * 4)
+#define PCMD24	__REG(0x40F00080 + 24 * 4)
+#define PCMD25	__REG(0x40F00080 + 25 * 4)
+#define PCMD26	__REG(0x40F00080 + 26 * 4)
+#define PCMD27	__REG(0x40F00080 + 27 * 4)
+#define PCMD28	__REG(0x40F00080 + 28 * 4)
+#define PCMD29	__REG(0x40F00080 + 29 * 4)
+#define PCMD30	__REG(0x40F00080 + 30 * 4)
+#define PCMD31	__REG(0x40F00080 + 31 * 4)
+
+#define PCMD_MBC	(1<<12)
+#define PCMD_DCE	(1<<11)
+#define PCMD_LC	(1<<10)
+/* FIXME:  PCMD_SQC need be checked.   */
+#define PCMD_SQC	(3<<8)	/* currently only bit 8 is changeable,
+				   bit 9 should be 0 all day. */
+#define PVCR_VCSA	(0x1<<14)
+#define PVCR_CommandDelay (0xf80)
+#define PCFR_PI2C_EN	(0x1 << 6)
+
+#define PSSR_OTGPH	(1 << 6)	/* OTG Peripheral control Hold */
+#define PSSR_RDH	(1 << 5)	/* Read Disable Hold */
+#define PSSR_PH		(1 << 4)	/* Peripheral Control Hold */
+#define PSSR_STS	(1 << 3)	/* Standby Mode Status */
+#define PSSR_VFS	(1 << 2)	/* VDD Fault Status */
+#define PSSR_BFS	(1 << 1)	/* Battery Fault Status */
+#define PSSR_SSS	(1 << 0)	/* Software Sleep Status */
+
+#define PSLR_SL_ROD	(1 << 20)	/* Sleep-Mode/Depp-Sleep Mode nRESET_OUT Disable */
+
+#define PCFR_RO		(1 << 15)	/* RDH Override */
+#define PCFR_PO		(1 << 14)	/* PH Override */
+#define PCFR_GPROD	(1 << 12)	/* GPIO nRESET_OUT Disable */
+#define PCFR_L1_EN	(1 << 11)	/* Sleep Mode L1 converter Enable */
+#define PCFR_FVC	(1 << 10)	/* Frequency/Voltage Change */
+#define PCFR_DC_EN	(1 << 7)	/* Sleep/deep-sleep DC-DC Converter Enable */
+#define PCFR_PI2CEN	(1 << 6)	/* Enable PI2C controller */
+#define PCFR_GPR_EN	(1 << 4)	/* nRESET_GPIO Pin Enable */
+#define PCFR_DS		(1 << 3)	/* Deep Sleep Mode */
+#define PCFR_FS		(1 << 2)	/* Float Static Chip Selects */
+#define PCFR_FP		(1 << 1)	/* Float PCMCIA controls */
+#define PCFR_OPDE	(1 << 0)	/* 3.6864 MHz oscillator power-down enable */
+
+#define RCSR_GPR	(1 << 3)	/* GPIO Reset */
+#define RCSR_SMR	(1 << 2)	/* Sleep Mode */
+#define RCSR_WDR	(1 << 1)	/* Watchdog Reset */
+#define RCSR_HWR	(1 << 0)	/* Hardware Reset */
+
+#define PWER_GPIO(Nb)	(1 << Nb)	/* GPIO [0..15] wake-up enable     */
+#define PWER_GPIO0	PWER_GPIO (0)	/* GPIO  [0] wake-up enable        */
+#define PWER_GPIO1	PWER_GPIO (1)	/* GPIO  [1] wake-up enable        */
+#define PWER_GPIO2	PWER_GPIO (2)	/* GPIO  [2] wake-up enable        */
+#define PWER_GPIO3	PWER_GPIO (3)	/* GPIO  [3] wake-up enable        */
+#define PWER_GPIO4	PWER_GPIO (4)	/* GPIO  [4] wake-up enable        */
+#define PWER_GPIO5	PWER_GPIO (5)	/* GPIO  [5] wake-up enable        */
+#define PWER_GPIO6	PWER_GPIO (6)	/* GPIO  [6] wake-up enable        */
+#define PWER_GPIO7	PWER_GPIO (7)	/* GPIO  [7] wake-up enable        */
+#define PWER_GPIO8	PWER_GPIO (8)	/* GPIO  [8] wake-up enable        */
+#define PWER_GPIO9	PWER_GPIO (9)	/* GPIO  [9] wake-up enable        */
+#define PWER_GPIO10	PWER_GPIO (10)	/* GPIO [10] wake-up enable        */
+#define PWER_GPIO11	PWER_GPIO (11)	/* GPIO [11] wake-up enable        */
+#define PWER_GPIO12	PWER_GPIO (12)	/* GPIO [12] wake-up enable        */
+#define PWER_GPIO13	PWER_GPIO (13)	/* GPIO [13] wake-up enable        */
+#define PWER_GPIO14	PWER_GPIO (14)	/* GPIO [14] wake-up enable        */
+#define PWER_GPIO15	PWER_GPIO (15)	/* GPIO [15] wake-up enable        */
+#define PWER_RTC	0x80000000	/* RTC alarm wake-up enable        */
+
+
+/*
+ * SSP Serial Port Registers
+ * PXA250, PXA255, PXA26x and PXA27x SSP controllers are all slightly different.
+ * PXA255, PXA26x and PXA27x have extra ports, registers and bits.
+ */
+
+ /* Common PXA2xx bits first */
+#define SSCR0_DSS	(0x0000000f)	/* Data Size Select (mask) */
+#define SSCR0_DataSize(x)  ((x) - 1)	/* Data Size Select [4..16] */
+#define SSCR0_FRF	(0x00000030)	/* FRame Format (mask) */
+#define SSCR0_Motorola	(0x0 << 4)	/* Motorola's Serial Peripheral Interface (SPI) */
+#define SSCR0_TI	(0x1 << 4)	/* Texas Instruments' Synchronous Serial Protocol (SSP) */
+#define SSCR0_National	(0x2 << 4)	/* National Microwire */
+#define SSCR0_ECS	(1 << 6)	/* External clock select */
+#define SSCR0_SSE	(1 << 7)	/* Synchronous Serial Port Enable */
+#if defined(CONFIG_PXA25x)
+#define SSCR0_SCR	(0x0000ff00)	/* Serial Clock Rate (mask) */
+#define SSCR0_SerClkDiv(x) ((((x) - 2)/2) << 8) /* Divisor [2..512] */
+#elif defined(CONFIG_PXA27x)
+#define SSCR0_SCR	(0x000fff00)	/* Serial Clock Rate (mask) */
+#define SSCR0_SerClkDiv(x) (((x) - 1) << 8) /* Divisor [1..4096] */
+#define SSCR0_EDSS	(1 << 20)	/* Extended data size select */
+#define SSCR0_NCS	(1 << 21)	/* Network clock select */
+#define SSCR0_RIM	(1 << 22)	/* Receive FIFO overrrun interrupt mask */
+#define SSCR0_TUM	(1 << 23)	/* Transmit FIFO underrun interrupt mask */
+#define SSCR0_FRDC	(0x07000000)	/* Frame rate divider control (mask) */
+#define SSCR0_SlotsPerFrm(x) (((x) - 1) << 24)	/* Time slots per frame [1..8] */
+#define SSCR0_ADC	(1 << 30)	/* Audio clock select */
+#define SSCR0_MOD	(1 << 31)	/* Mode (normal or network) */
+#endif
+
+#define SSCR1_RIE	(1 << 0)	/* Receive FIFO Interrupt Enable */
+#define SSCR1_TIE	(1 << 1)	/* Transmit FIFO Interrupt Enable */
+#define SSCR1_LBM	(1 << 2)	/* Loop-Back Mode */
+#define SSCR1_SPO	(1 << 3)	/* Motorola SPI SSPSCLK polarity setting */
+#define SSCR1_SPH	(1 << 4)	/* Motorola SPI SSPSCLK phase setting */
+#define SSCR1_MWDS	(1 << 5)	/* Microwire Transmit Data Size */
+#define SSCR1_TFT	(0x000003c0)	/* Transmit FIFO Threshold (mask) */
+#define SSCR1_TxTresh(x) (((x) - 1) << 6) /* level [1..16] */
+#define SSCR1_RFT	(0x00003c00)	/* Receive FIFO Threshold (mask) */
+#define SSCR1_RxTresh(x) (((x) - 1) << 10) /* level [1..16] */
+
+#define SSSR_TNF	(1 << 2)	/* Transmit FIFO Not Full */
+#define SSSR_RNE	(1 << 3)	/* Receive FIFO Not Empty */
+#define SSSR_BSY	(1 << 4)	/* SSP Busy */
+#define SSSR_TFS	(1 << 5)	/* Transmit FIFO Service Request */
+#define SSSR_RFS	(1 << 6)	/* Receive FIFO Service Request */
+#define SSSR_ROR	(1 << 7)	/* Receive FIFO Overrun */
+
+#define SSCR0_TIM		(1 << 23)	/* Transmit FIFO Under Run Interrupt Mask */
+#define SSCR0_RIM		(1 << 22)	/* Receive FIFO Over Run interrupt Mask */
+#define SSCR0_NCS		(1 << 21)	/* Network Clock Select */
+#define SSCR0_EDSS		(1 << 20)	/* Extended Data Size Select */
+
+/* extra bits in PXA255, PXA26x and PXA27x SSP ports */
+#define SSCR0_TISSP		(1 << 4)	/* TI Sync Serial Protocol */
+#define SSCR0_PSP		(3 << 4)	/* PSP - Programmable Serial Protocol */
+#define SSCR1_TTELP		(1 << 31)	/* TXD Tristate Enable Last Phase */
+#define SSCR1_TTE		(1 << 30)	/* TXD Tristate Enable */
+#define SSCR1_EBCEI		(1 << 29)	/* Enable Bit Count Error interrupt */
+#define SSCR1_SCFR		(1 << 28)	/* Slave Clock free Running */
+#define SSCR1_ECRA		(1 << 27)	/* Enable Clock Request A */
+#define SSCR1_ECRB		(1 << 26)	/* Enable Clock request B */
+#define SSCR1_SCLKDIR	(1 << 25)	/* Serial Bit Rate Clock Direction */
+#define SSCR1_SFRMDIR	(1 << 24)	/* Frame Direction */
+#define SSCR1_RWOT		(1 << 23)	/* Receive Without Transmit */
+#define SSCR1_TRAIL		(1 << 22)	/* Trailing Byte */
+#define SSCR1_TSRE		(1 << 21)	/* Transmit Service Request Enable */
+#define SSCR1_RSRE		(1 << 20)	/* Receive Service Request Enable */
+#define SSCR1_TINTE		(1 << 19)	/* Receiver Time-out Interrupt enable */
+#define SSCR1_PINTE		(1 << 18)	/* Peripheral Trailing Byte Interupt Enable */
+#define SSCR1_STRF		(1 << 15)	/* Select FIFO or EFWR */
+#define SSCR1_EFWR		(1 << 14)	/* Enable FIFO Write/Read */
+
+#define SSSR_BCE		(1 << 23)	/* Bit Count Error */
+#define SSSR_CSS		(1 << 22)	/* Clock Synchronisation Status */
+#define SSSR_TUR		(1 << 21)	/* Transmit FIFO Under Run */
+#define SSSR_EOC		(1 << 20)	/* End Of Chain */
+#define SSSR_TINT		(1 << 19)	/* Receiver Time-out Interrupt */
+#define SSSR_PINT		(1 << 18)	/* Peripheral Trailing Byte Interrupt */
+
+#define SSPSP_FSRT		(1 << 25)	/* Frame Sync Relative Timing */
+#define SSPSP_DMYSTOP(x)	((x) << 23)	/* Dummy Stop */
+#define SSPSP_SFRMWDTH(x)	((x) << 16)	/* Serial Frame Width */
+#define SSPSP_SFRMDLY(x)	((x) << 9)	/* Serial Frame Delay */
+#define SSPSP_DMYSTRT(x)	((x) << 7)	/* Dummy Start */
+#define SSPSP_STRTDLY(x)	((x) << 4)	/* Start Delay */
+#define SSPSP_ETDS			(1 << 3)	/* End of Transfer data State */
+#define SSPSP_SFRMP			(1 << 2)	/* Serial Frame Polarity */
+#define SSPSP_SCMODE(x)		((x) << 0)	/* Serial Bit Rate Clock Mode */
+
+#define SSACD_SCDB		(1 << 3)	/* SSPSYSCLK Divider Bypass */
+#define SSACD_ACPS(x)		((x) << 4)	/* Audio clock PLL select */
+#define SSACD_ACDS(x)		((x) << 0)	/* Audio clock divider select */
+
+#define SSCR0_P1	__REG(0x41000000)  /* SSP Port 1 Control Register 0 */
+#define SSCR1_P1	__REG(0x41000004)  /* SSP Port 1 Control Register 1 */
+#define SSSR_P1		__REG(0x41000008)  /* SSP Port 1 Status Register */
+#define SSITR_P1	__REG(0x4100000C)  /* SSP Port 1 Interrupt Test Register */
+#define SSDR_P1		__REG(0x41000010)  /* (Write / Read) SSP Port 1 Data Write Register/SSP Data Read Register */
+
+/* Support existing PXA25x drivers */
+#define SSCR0		SSCR0_P1  /* SSP Control Register 0 */
+#define SSCR1		SSCR1_P1  /* SSP Control Register 1 */
+#define SSSR		SSSR_P1	  /* SSP Status Register */
+#define SSITR		SSITR_P1  /* SSP Interrupt Test Register */
+#define SSDR		SSDR_P1	  /* (Write / Read) SSP Data Write Register/SSP Data Read Register */
+
+/* PXA27x ports */
+#if defined (CONFIG_PXA27x)
+#define SSTO_P1		__REG(0x41000028)  /* SSP Port 1 Time Out Register */
+#define SSPSP_P1	__REG(0x4100002C)  /* SSP Port 1 Programmable Serial Protocol */
+#define SSTSA_P1	__REG(0x41000030)  /* SSP Port 1 Tx Timeslot Active */
+#define SSRSA_P1	__REG(0x41000034)  /* SSP Port 1 Rx Timeslot Active */
+#define SSTSS_P1	__REG(0x41000038)  /* SSP Port 1 Timeslot Status */
+#define SSACD_P1	__REG(0x4100003C)  /* SSP Port 1 Audio Clock Divider */
+#define SSCR0_P2	__REG(0x41700000)  /* SSP Port 2 Control Register 0 */
+#define SSCR1_P2	__REG(0x41700004)  /* SSP Port 2 Control Register 1 */
+#define SSSR_P2		__REG(0x41700008)  /* SSP Port 2 Status Register */
+#define SSITR_P2	__REG(0x4170000C)  /* SSP Port 2 Interrupt Test Register */
+#define SSDR_P2		__REG(0x41700010)  /* (Write / Read) SSP Port 2 Data Write Register/SSP Data Read Register */
+#define SSTO_P2		__REG(0x41700028)  /* SSP Port 2 Time Out Register */
+#define SSPSP_P2	__REG(0x4170002C)  /* SSP Port 2 Programmable Serial Protocol */
+#define SSTSA_P2	__REG(0x41700030)  /* SSP Port 2 Tx Timeslot Active */
+#define SSRSA_P2	__REG(0x41700034)  /* SSP Port 2 Rx Timeslot Active */
+#define SSTSS_P2	__REG(0x41700038)  /* SSP Port 2 Timeslot Status */
+#define SSACD_P2	__REG(0x4170003C)  /* SSP Port 2 Audio Clock Divider */
+#define SSCR0_P3	__REG(0x41900000)  /* SSP Port 3 Control Register 0 */
+#define SSCR1_P3	__REG(0x41900004)  /* SSP Port 3 Control Register 1 */
+#define SSSR_P3		__REG(0x41900008)  /* SSP Port 3 Status Register */
+#define SSITR_P3	__REG(0x4190000C)  /* SSP Port 3 Interrupt Test Register */
+#define SSDR_P3		__REG(0x41900010)  /* (Write / Read) SSP Port 3 Data Write Register/SSP Data Read Register */
+#define SSTO_P3		__REG(0x41900028)  /* SSP Port 3 Time Out Register */
+#define SSPSP_P3	__REG(0x4190002C)  /* SSP Port 3 Programmable Serial Protocol */
+#define SSTSA_P3	__REG(0x41900030)  /* SSP Port 3 Tx Timeslot Active */
+#define SSRSA_P3	__REG(0x41900034)  /* SSP Port 3 Rx Timeslot Active */
+#define SSTSS_P3	__REG(0x41900038)  /* SSP Port 3 Timeslot Status */
+#define SSACD_P3	__REG(0x4190003C)  /* SSP Port 3 Audio Clock Divider */
+#else /* PXA255 (only port 2) and PXA26x ports*/
+#define SSTO_P1		__REG(0x41000028)  /* SSP Port 1 Time Out Register */
+#define SSPSP_P1	__REG(0x4100002C)  /* SSP Port 1 Programmable Serial Protocol */
+#define SSCR0_P2	__REG(0x41400000)  /* SSP Port 2 Control Register 0 */
+#define SSCR1_P2	__REG(0x41400004)  /* SSP Port 2 Control Register 1 */
+#define SSSR_P2		__REG(0x41400008)  /* SSP Port 2 Status Register */
+#define SSITR_P2	__REG(0x4140000C)  /* SSP Port 2 Interrupt Test Register */
+#define SSDR_P2		__REG(0x41400010)  /* (Write / Read) SSP Port 2 Data Write Register/SSP Data Read Register */
+#define SSTO_P2		__REG(0x41400028)  /* SSP Port 2 Time Out Register */
+#define SSPSP_P2	__REG(0x4140002C)  /* SSP Port 2 Programmable Serial Protocol */
+#define SSCR0_P3	__REG(0x41500000)  /* SSP Port 3 Control Register 0 */
+#define SSCR1_P3	__REG(0x41500004)  /* SSP Port 3 Control Register 1 */
+#define SSSR_P3		__REG(0x41500008)  /* SSP Port 3 Status Register */
+#define SSITR_P3	__REG(0x4150000C)  /* SSP Port 3 Interrupt Test Register */
+#define SSDR_P3		__REG(0x41500010)  /* (Write / Read) SSP Port 3 Data Write Register/SSP Data Read Register */
+#define SSTO_P3		__REG(0x41500028)  /* SSP Port 3 Time Out Register */
+#define SSPSP_P3	__REG(0x4150002C)  /* SSP Port 3 Programmable Serial Protocol */
+#endif
+
+#define SSCR0_P(x) (*(((x) == 1) ? &SSCR0_P1 : ((x) == 2) ? &SSCR0_P2 : ((x) == 3) ? &SSCR0_P3 : NULL))
+#define SSCR1_P(x) (*(((x) == 1) ? &SSCR1_P1 : ((x) == 2) ? &SSCR1_P2 : ((x) == 3) ? &SSCR1_P3 : NULL))
+#define SSSR_P(x) (*(((x) == 1) ? &SSSR_P1 : ((x) == 2) ? &SSSR_P2 : ((x) == 3) ? &SSSR_P3 : NULL))
+#define SSITR_P(x) (*(((x) == 1) ? &SSITR_P1 : ((x) == 2) ? &SSITR_P2 : ((x) == 3) ? &SSITR_P3 : NULL))
+#define SSDR_P(x) (*(((x) == 1) ? &SSDR_P1 : ((x) == 2) ? &SSDR_P2 : ((x) == 3) ? &SSDR_P3 : NULL))
+#define SSTO_P(x) (*(((x) == 1) ? &SSTO_P1 : ((x) == 2) ? &SSTO_P2 : ((x) == 3) ? &SSTO_P3 : NULL))
+#define SSPSP_P(x) (*(((x) == 1) ? &SSPSP_P1 : ((x) == 2) ? &SSPSP_P2 : ((x) == 3) ? &SSPSP_P3 : NULL))
+#define SSTSA_P(x) (*(((x) == 1) ? &SSTSA_P1 : ((x) == 2) ? &SSTSA_P2 : ((x) == 3) ? &SSTSA_P3 : NULL))
+#define SSRSA_P(x) (*(((x) == 1) ? &SSRSA_P1 : ((x) == 2) ? &SSRSA_P2 : ((x) == 3) ? &SSRSA_P3 : NULL))
+#define SSTSS_P(x) (*(((x) == 1) ? &SSTSS_P1 : ((x) == 2) ? &SSTSS_P2 : ((x) == 3) ? &SSTSS_P3 : NULL))
+#define SSACD_P(x) (*(((x) == 1) ? &SSACD_P1 : ((x) == 2) ? &SSACD_P2 : ((x) == 3) ? &SSACD_P3 : NULL))
+
+/*
+ * MultiMediaCard (MMC) controller
+ */
+
+#define MMC_STRPCL	__REG(0x41100000)  /* Control to start and stop MMC clock */
+#define MMC_STAT	__REG(0x41100004)  /* MMC Status Register (read only) */
+#define MMC_CLKRT	__REG(0x41100008)  /* MMC clock rate */
+#define MMC_SPI		__REG(0x4110000c)  /* SPI mode control bits */
+#define MMC_CMDAT	__REG(0x41100010)  /* Command/response/data sequence control */
+#define MMC_RESTO	__REG(0x41100014)  /* Expected response time out */
+#define MMC_RDTO	__REG(0x41100018)  /* Expected data read time out */
+#define MMC_BLKLEN	__REG(0x4110001c)  /* Block length of data transaction */
+#define MMC_NOB		__REG(0x41100020)  /* Number of blocks, for block mode */
+#define MMC_PRTBUF	__REG(0x41100024)  /* Partial MMC_TXFIFO FIFO written */
+#define MMC_I_MASK	__REG(0x41100028)  /* Interrupt Mask */
+#define MMC_I_REG	__REG(0x4110002c)  /* Interrupt Register (read only) */
+#define MMC_CMD		__REG(0x41100030)  /* Index of current command */
+#define MMC_ARGH	__REG(0x41100034)  /* MSW part of the current command argument */
+#define MMC_ARGL	__REG(0x41100038)  /* LSW part of the current command argument */
+#define MMC_RES		__REG(0x4110003c)  /* Response FIFO (read only) */
+#define MMC_RXFIFO	__REG(0x41100040)  /* Receive FIFO (read only) */
+#define MMC_TXFIFO	__REG(0x41100044)  /* Transmit FIFO (write only) */
+
+
+/*
+ * Core Clock
+ */
+
+#define CCCR		__REG(0x41300000)  /* Core Clock Configuration Register */
+#define CKEN		__REG(0x41300004)  /* Clock Enable Register */
+#define OSCC		__REG(0x41300008)  /* Oscillator Configuration Register */
+#define CCSR		__REG(0x4130000C)  /* Core Clock Status Register */
+
+#define CCCR_N_MASK	0x0380		/* Run Mode Frequency to Turbo Mode Frequency Multiplier */
+#define CCCR_M_MASK	0x0060		/* Memory Frequency to Run Mode Frequency Multiplier */
+#define CCCR_L_MASK	0x001f		/* Crystal Frequency to Memory Frequency Multiplier */
+
+#define CKEN24_CAMERA	(1 << 24)	/* Camera Interface Clock Enable */
+#define CKEN23_SSP1	(1 << 23)	/* SSP1 Unit Clock Enable */
+#define CKEN22_MEMC	(1 << 22)	/* Memory Controller Clock Enable */
+#define CKEN21_MEMSTK	(1 << 21)	/* Memory Stick Host Controller */
+#define CKEN20_IM	(1 << 20)	/* Internal Memory Clock Enable */
+#define CKEN19_KEYPAD	(1 << 19)	/* Keypad Interface Clock Enable */
+#define CKEN18_USIM	(1 << 18)	/* USIM Unit Clock Enable */
+#define CKEN17_MSL	(1 << 17)	/* MSL Unit Clock Enable */
+#define CKEN16_LCD	(1 << 16)	/* LCD Unit Clock Enable */
+#define CKEN15_PWRI2C	(1 << 15)	/* PWR I2C Unit Clock Enable */
+#define CKEN14_I2C	(1 << 14)	/* I2C Unit Clock Enable */
+#define CKEN13_FICP	(1 << 13)	/* FICP Unit Clock Enable */
+#define CKEN12_MMC	(1 << 12)	/* MMC Unit Clock Enable */
+#define CKEN11_USB	(1 << 11)	/* USB Unit Clock Enable */
+#define CKEN10_ASSP	(1 << 10)	/* ASSP (SSP3) Clock Enable */
+#define CKEN10_USBHOST	(1 << 10)	/* USB Host Unit Clock Enable */
+#define CKEN9_OSTIMER	(1 << 9)	/* OS Timer Unit Clock Enable */
+#define CKEN9_NSSP	(1 << 9)	/* NSSP (SSP2) Clock Enable */
+#define CKEN8_I2S	(1 << 8)	/* I2S Unit Clock Enable */
+#define CKEN7_BTUART	(1 << 7)	/* BTUART Unit Clock Enable */
+#define CKEN6_FFUART	(1 << 6)	/* FFUART Unit Clock Enable */
+#define CKEN5_STUART	(1 << 5)	/* STUART Unit Clock Enable */
+#define CKEN4_HWUART	(1 << 4)	/* HWUART Unit Clock Enable */
+#define CKEN4_SSP3	(1 << 4)	/* SSP3 Unit Clock Enable */
+#define CKEN3_SSP	(1 << 3)	/* SSP Unit Clock Enable */
+#define CKEN3_SSP2	(1 << 3)	/* SSP2 Unit Clock Enable */
+#define CKEN2_AC97	(1 << 2)	/* AC97 Unit Clock Enable */
+#define CKEN1_PWM1	(1 << 1)	/* PWM1 Clock Enable */
+#define CKEN0_PWM0	(1 << 0)	/* PWM0 Clock Enable */
+
+#define OSCC_OON	(1 << 1)	/* 32.768kHz OON (write-once only bit) */
+#define OSCC_OOK	(1 << 0)	/* 32.768kHz OOK (read-only bit) */
+
+
+/*
+ * LCD
+ */
+
+#define LCCR0		__REG(0x44000000)  /* LCD Controller Control Register 0 */
+#define LCCR1		__REG(0x44000004)  /* LCD Controller Control Register 1 */
+#define LCCR2		__REG(0x44000008)  /* LCD Controller Control Register 2 */
+#define LCCR3		__REG(0x4400000C)  /* LCD Controller Control Register 3 */
+#define DFBR0		__REG(0x44000020)  /* DMA Channel 0 Frame Branch Register */
+#define DFBR1		__REG(0x44000024)  /* DMA Channel 1 Frame Branch Register */
+#define LCSR		__REG(0x44000038)  /* LCD Controller Status Register */
+#define LIIDR		__REG(0x4400003C)  /* LCD Controller Interrupt ID Register */
+#define TMEDRGBR	__REG(0x44000040)  /* TMED RGB Seed Register */
+#define TMEDCR		__REG(0x44000044)  /* TMED Control Register */
+
+#define LCCR3_1BPP (0 << 24)
+#define LCCR3_2BPP (1 << 24)
+#define LCCR3_4BPP (2 << 24)
+#define LCCR3_8BPP (3 << 24)
+#define LCCR3_16BPP (4 << 24)
+
+#define FDADR0		__REG(0x44000200)  /* DMA Channel 0 Frame Descriptor Address Register */
+#define FSADR0		__REG(0x44000204)  /* DMA Channel 0 Frame Source Address Register */
+#define FIDR0		__REG(0x44000208)  /* DMA Channel 0 Frame ID Register */
+#define LDCMD0		__REG(0x4400020C)  /* DMA Channel 0 Command Register */
+#define FDADR1		__REG(0x44000210)  /* DMA Channel 1 Frame Descriptor Address Register */
+#define FSADR1		__REG(0x44000214)  /* DMA Channel 1 Frame Source Address Register */
+#define FIDR1		__REG(0x44000218)  /* DMA Channel 1 Frame ID Register */
+#define LDCMD1		__REG(0x4400021C)  /* DMA Channel 1 Command Register */
+
+#define LCCR0_ENB	(1 << 0)	/* LCD Controller enable */
+#define LCCR0_CMS	(1 << 1)	/* Color/Monochrome Display Select */
+#define LCCR0_Color     (LCCR0_CMS*0)   /*  Color display                  */
+#define LCCR0_Mono      (LCCR0_CMS*1)   /*  Monochrome display             */
+#define LCCR0_SDS	(1 << 2)	/* Single/Dual Panel Display       */
+                                        /* Select                          */
+#define LCCR0_Sngl      (LCCR0_SDS*0)   /*  Single panel display           */
+#define LCCR0_Dual      (LCCR0_SDS*1)   /*  Dual panel display             */
+
+#define LCCR0_LDM	(1 << 3)	/* LCD Disable Done Mask */
+#define LCCR0_SFM	(1 << 4)	/* Start of frame mask */
+#define LCCR0_IUM	(1 << 5)	/* Input FIFO underrun mask */
+#define LCCR0_EFM	(1 << 6)	/* End of Frame mask */
+#define LCCR0_PAS	(1 << 7)	/* Passive/Active display Select   */
+#define LCCR0_Pas       (LCCR0_PAS*0)   /*  Passive display (STN)          */
+#define LCCR0_Act       (LCCR0_PAS*1)   /*  Active display (TFT)           */
+#define LCCR0_DPD	(1 << 9)	/* Double Pixel Data (monochrome   */
+                                        /* display mode)                   */
+#define LCCR0_4PixMono  (LCCR0_DPD*0)   /*  4-Pixel/clock Monochrome       */
+                                        /*  display                        */
+#define LCCR0_8PixMono  (LCCR0_DPD*1)   /*  8-Pixel/clock Monochrome       */
+                                        /*  display                        */
+#define LCCR0_DIS	(1 << 10)	/* LCD Disable */
+#define LCCR0_QDM	(1 << 11)	/* LCD Quick Disable mask */
+#define LCCR0_PDD	(0xff << 12)	/* Palette DMA request delay */
+#define LCCR0_PDD_S	12
+#define LCCR0_BM	(1 << 20) 	/* Branch mask */
+#define LCCR0_OUM	(1 << 21)	/* Output FIFO underrun mask */
+#define LCCR0_LCDT      (1 << 22)       /* LCD panel type */
+#define LCCR0_RDSTM     (1 << 23)       /* Read status interrupt mask */
+#define LCCR0_CMDIM     (1 << 24)       /* Command interrupt mask */
+#define LCCR0_OUC       (1 << 25)       /* Overlay Underlay control bit */
+#define LCCR0_LDDALT    (1 << 26)       /* LDD alternate mapping control */
+
+#define LCCR1_PPL       Fld (10, 0)      /* Pixels Per Line - 1 */
+#define LCCR1_DisWdth(Pixel)            /* Display Width [1..800 pix.]  */ \
+                        (((Pixel) - 1) << FShft (LCCR1_PPL))
+
+#define LCCR1_HSW       Fld (6, 10)     /* Horizontal Synchronization     */
+#define LCCR1_HorSnchWdth(Tpix)         /* Horizontal Synchronization     */ \
+                                        /* pulse Width [1..64 Tpix]       */ \
+                        (((Tpix) - 1) << FShft (LCCR1_HSW))
+
+#define LCCR1_ELW       Fld (8, 16)     /* End-of-Line pixel clock Wait    */
+                                        /* count - 1 [Tpix]                */
+#define LCCR1_EndLnDel(Tpix)            /*  End-of-Line Delay              */ \
+                                        /*  [1..256 Tpix]                  */ \
+                        (((Tpix) - 1) << FShft (LCCR1_ELW))
+
+#define LCCR1_BLW       Fld (8, 24)     /* Beginning-of-Line pixel clock   */
+                                        /* Wait count - 1 [Tpix]           */
+#define LCCR1_BegLnDel(Tpix)            /*  Beginning-of-Line Delay        */ \
+                                        /*  [1..256 Tpix]                  */ \
+                        (((Tpix) - 1) << FShft (LCCR1_BLW))
+
+
+#define LCCR2_LPP       Fld (10, 0)     /* Line Per Panel - 1              */
+#define LCCR2_DisHght(Line)             /*  Display Height [1..1024 lines] */ \
+                        (((Line) - 1) << FShft (LCCR2_LPP))
+
+#define LCCR2_VSW       Fld (6, 10)     /* Vertical Synchronization pulse  */
+                                        /* Width - 1 [Tln] (L_FCLK)        */
+#define LCCR2_VrtSnchWdth(Tln)          /*  Vertical Synchronization pulse */ \
+                                        /*  Width [1..64 Tln]              */ \
+                        (((Tln) - 1) << FShft (LCCR2_VSW))
+
+#define LCCR2_EFW       Fld (8, 16)     /* End-of-Frame line clock Wait    */
+                                        /* count [Tln]                     */
+#define LCCR2_EndFrmDel(Tln)            /*  End-of-Frame Delay             */ \
+                                        /*  [0..255 Tln]                   */ \
+                        ((Tln) << FShft (LCCR2_EFW))
+
+#define LCCR2_BFW       Fld (8, 24)     /* Beginning-of-Frame line clock   */
+                                        /* Wait count [Tln]                */
+#define LCCR2_BegFrmDel(Tln)            /*  Beginning-of-Frame Delay       */ \
+                                        /*  [0..255 Tln]                   */ \
+                        ((Tln) << FShft (LCCR2_BFW))
+
+#if 0
+#define LCCR3_PCD	(0xff)		/* Pixel clock divisor */
+#define LCCR3_ACB	(0xff << 8)	/* AC Bias pin frequency */
+#define LCCR3_ACB_S	8
+#endif
+
+#define LCCR3_API	(0xf << 16)	/* AC Bias pin trasitions per interrupt */
+#define LCCR3_API_S	16
+#define LCCR3_VSP	(1 << 20)	/* vertical sync polarity */
+#define LCCR3_HSP	(1 << 21)	/* horizontal sync polarity */
+#define LCCR3_PCP	(1 << 22)	/* Pixel Clock Polarity (L_PCLK)   */
+#define LCCR3_PixRsEdg  (LCCR3_PCP*0)   /*  Pixel clock Rising-Edge        */
+#define LCCR3_PixFlEdg  (LCCR3_PCP*1)   /*  Pixel clock Falling-Edge       */
+
+#define LCCR3_OEP       (1 << 23)       /* Output Enable Polarity (L_BIAS, */
+                                        /* active display mode)            */
+#define LCCR3_OutEnH    (LCCR3_OEP*0)   /*  Output Enable active High      */
+#define LCCR3_OutEnL    (LCCR3_OEP*1)   /*  Output Enable active Low       */
+
+#if 0
+#define LCCR3_BPP	(7 << 24)	/* bits per pixel */
+#define LCCR3_BPP_S	24
+#endif
+#define LCCR3_DPC	(1 << 27)	/* double pixel clock mode */
+
+
+#define LCCR3_PCD       Fld (8, 0)      /* Pixel Clock Divisor */
+#define LCCR3_PixClkDiv(Div)            /* Pixel Clock Divisor */ \
+                        (((Div) << FShft (LCCR3_PCD)))
+
+
+#define LCCR3_BPP       Fld (3, 24)     /* Bit Per Pixel */
+#define LCCR3_Bpp(Bpp)                  /* Bit Per Pixel */ \
+                        (((Bpp) << FShft (LCCR3_BPP)))
+
+#define LCCR3_ACB       Fld (8, 8)      /* AC Bias */
+#define LCCR3_Acb(Acb)                  /* BAC Bias */ \
+                        (((Acb) << FShft (LCCR3_ACB)))
+
+#define LCCR3_HorSnchH  (LCCR3_HSP*0)   /*  Horizontal Synchronization     */
+                                        /*  pulse active High              */
+#define LCCR3_HorSnchL  (LCCR3_HSP*1)   /*  Horizontal Synchronization     */
+
+#define LCCR3_VrtSnchH  (LCCR3_VSP*0)   /*  Vertical Synchronization pulse */
+                                        /*  active High                    */
+#define LCCR3_VrtSnchL  (LCCR3_VSP*1)   /*  Vertical Synchronization pulse */
+                                        /*  active Low                     */
+
+#define LCSR_LDD	(1 << 0)	/* LCD Disable Done */
+#define LCSR_SOF	(1 << 1)	/* Start of frame */
+#define LCSR_BER	(1 << 2)	/* Bus error */
+#define LCSR_ABC	(1 << 3)	/* AC Bias count */
+#define LCSR_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
+#define LCSR_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
+#define LCSR_OU		(1 << 6)	/* output FIFO underrun */
+#define LCSR_QD		(1 << 7)	/* quick disable */
+#define LCSR_EOF	(1 << 8)	/* end of frame */
+#define LCSR_BS		(1 << 9)	/* branch status */
+#define LCSR_SINT	(1 << 10)	/* subsequent interrupt */
+
+#define LDCMD_PAL	(1 << 26)	/* instructs DMA to load palette buffer */
+
+#define LCSR_LDD	(1 << 0)	/* LCD Disable Done */
+#define LCSR_SOF	(1 << 1)	/* Start of frame */
+#define LCSR_BER	(1 << 2)	/* Bus error */
+#define LCSR_ABC	(1 << 3)	/* AC Bias count */
+#define LCSR_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
+#define LCSR_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
+#define LCSR_OU		(1 << 6)	/* output FIFO underrun */
+#define LCSR_QD		(1 << 7)	/* quick disable */
+#define LCSR_EOF	(1 << 8)	/* end of frame */
+#define LCSR_BS		(1 << 9)	/* branch status */
+#define LCSR_SINT	(1 << 10)	/* subsequent interrupt */
+
+#define LDCMD_PAL	(1 << 26)	/* instructs DMA to load palette buffer */
+
+/*
+ * Memory controller
+ */
+
+#define MDCNFG		__REG(0x48000000)  /* SDRAM Configuration Register 0 */
+#define MDREFR		__REG(0x48000004)  /* SDRAM Refresh Control Register */
+#define MSC0		__REG(0x48000008)  /* Static Memory Control Register 0 */
+#define MSC1		__REG(0x4800000C)  /* Static Memory Control Register 1 */
+#define MSC2		__REG(0x48000010)  /* Static Memory Control Register 2 */
+#define MECR		__REG(0x48000014)  /* Expansion Memory (PCMCIA/Compact Flash) Bus Configuration */
+#define SXLCR		__REG(0x48000018)  /* LCR value to be written to SDRAM-Timing Synchronous Flash */
+#define SXCNFG		__REG(0x4800001C)  /* Synchronous Static Memory Control Register */
+#define SXMRS		__REG(0x48000024)  /* MRS value to be written to Synchronous Flash or SMROM */
+#define MCMEM0		__REG(0x48000028)  /* Card interface Common Memory Space Socket 0 Timing */
+#define MCMEM1		__REG(0x4800002C)  /* Card interface Common Memory Space Socket 1 Timing */
+#define MCATT0		__REG(0x48000030)  /* Card interface Attribute Space Socket 0 Timing Configuration */
+#define MCATT1		__REG(0x48000034)  /* Card interface Attribute Space Socket 1 Timing Configuration */
+#define MCIO0		__REG(0x48000038)  /* Card interface I/O Space Socket 0 Timing Configuration */
+#define MCIO1		__REG(0x4800003C)  /* Card interface I/O Space Socket 1 Timing Configuration */
+#define MDMRS		__REG(0x48000040)  /* MRS value to be written to SDRAM */
+#define BOOT_DEF	__REG(0x48000044)  /* Read-Only Boot-Time Register. Contains BOOT_SEL and PKG_SEL */
+
+/*
+ * More handy macros for PCMCIA
+ *
+ * Arg is socket number
+ */
+#define MCMEM(s)	__REG2(0x48000028, (s)<<2 )  /* Card interface Common Memory Space Socket s Timing */
+#define MCATT(s)	__REG2(0x48000030, (s)<<2 )  /* Card interface Attribute Space Socket s Timing Configuration */
+#define MCIO(s)		__REG2(0x48000038, (s)<<2 )  /* Card interface I/O Space Socket s Timing Configuration */
+
+/* MECR register defines */
+#define MECR_NOS	(1 << 0)	/* Number Of Sockets: 0 -> 1 sock, 1 -> 2 sock */
+#define MECR_CIT	(1 << 1)	/* Card Is There: 0 -> no card, 1 -> card inserted */
+
+#define MDREFR_K0DB4	(1 << 29)	/* SDCLK0 Divide by 4 Control/Status */
+#define MDREFR_K2FREE	(1 << 25)	/* SDRAM Free-Running Control */
+#define MDREFR_K1FREE	(1 << 24)	/* SDRAM Free-Running Control */
+#define MDREFR_K0FREE	(1 << 23)	/* SDRAM Free-Running Control */
+#define MDREFR_SLFRSH	(1 << 22)	/* SDRAM Self-Refresh Control/Status */
+#define MDREFR_APD	(1 << 20)	/* SDRAM/SSRAM Auto-Power-Down Enable */
+#define MDREFR_K2DB2	(1 << 19)	/* SDCLK2 Divide by 2 Control/Status */
+#define MDREFR_K2RUN	(1 << 18)	/* SDCLK2 Run Control/Status */
+#define MDREFR_K1DB2	(1 << 17)	/* SDCLK1 Divide by 2 Control/Status */
+#define MDREFR_K1RUN	(1 << 16)	/* SDCLK1 Run Control/Status */
+#define MDREFR_E1PIN	(1 << 15)	/* SDCKE1 Level Control/Status */
+#define MDREFR_K0DB2	(1 << 14)	/* SDCLK0 Divide by 2 Control/Status */
+#define MDREFR_K0RUN	(1 << 13)	/* SDCLK0 Run Control/Status */
+#define MDREFR_E0PIN	(1 << 12)	/* SDCKE0 Level Control/Status */
+
+
+#ifdef CONFIG_PXA27x
+
+#define ARB_CNTRL	__REG(0x48000048)  /* Arbiter Control Register */
+
+#define ARB_DMA_SLV_PARK	(1<<31)	   /* Be parked with DMA slave when idle */
+#define ARB_CI_PARK		(1<<30)	   /* Be parked with Camera Interface when idle */
+#define ARB_EX_MEM_PARK 	(1<<29)	   /* Be parked with external MEMC when idle */
+#define ARB_INT_MEM_PARK	(1<<28)	   /* Be parked with internal MEMC when idle */
+#define ARB_USB_PARK		(1<<27)	   /* Be parked with USB when idle */
+#define ARB_LCD_PARK		(1<<26)	   /* Be parked with LCD when idle */
+#define ARB_DMA_PARK		(1<<25)	   /* Be parked with DMA when idle */
+#define ARB_CORE_PARK		(1<<24)	   /* Be parked with core when idle */
+#define ARB_LOCK_FLAG		(1<<23)	   /* Only Locking masters gain access to the bus */
+
+/*
+ * Keypad
+ */
+#define KPC             __REG(0x41500000) /* Keypad Interface Control register */
+#define KPDK            __REG(0x41500008) /* Keypad Interface Direct Key register */
+#define KPREC           __REG(0x41500010) /* Keypad Interface Rotary Encoder register */
+#define KPMK            __REG(0x41500018) /* Keypad Interface Matrix Key register */
+#define KPAS            __REG(0x41500020) /* Keypad Interface Automatic Scan register */
+#define KPASMKP0        __REG(0x41500028) /* Keypad Interface Automatic Scan Multiple Key Presser register 0 */
+#define KPASMKP1        __REG(0x41500030) /* Keypad Interface Automatic Scan Multiple Key Presser register 1 */
+#define KPASMKP2        __REG(0x41500038) /* Keypad Interface Automatic Scan Multiple Key Presser register 2 */
+#define KPASMKP3        __REG(0x41500040) /* Keypad Interface Automatic Scan Multiple Key Presser register 3 */
+#define KPKDI           __REG(0x41500048) /* Keypad Interface Key Debounce Interval register */
+
+#define KPC_AS          (0x1 << 30)  /* Automatic Scan bit */
+#define KPC_ASACT       (0x1 << 29)  /* Automatic Scan on Activity */
+#define KPC_MI          (0x1 << 22)  /* Matrix interrupt bit */
+#define KPC_IMKP        (0x1 << 21)  /* Ignore Multiple Key Press */
+#define KPC_MS7         (0x1 << 20)  /* Matrix scan line 7 */
+#define KPC_MS6         (0x1 << 19)  /* Matrix scan line 6 */
+#define KPC_MS5         (0x1 << 18)  /* Matrix scan line 5 */
+#define KPC_MS4         (0x1 << 17)  /* Matrix scan line 4 */
+#define KPC_MS3         (0x1 << 16)  /* Matrix scan line 3 */
+#define KPC_MS2         (0x1 << 15)  /* Matrix scan line 2 */
+#define KPC_MS1         (0x1 << 14)  /* Matrix scan line 1 */
+#define KPC_MS0         (0x1 << 13)  /* Matrix scan line 0 */
+#define KPC_MS_ALL      (KPC_MS0 | KPC_MS1 | KPC_MS2 | KPC_MS3 | KPC_MS4 | KPC_MS5 | KPC_MS6 | KPC_MS7)
+#define KPC_ME          (0x1 << 12)  /* Matrix Keypad Enable */
+#define KPC_MIE         (0x1 << 11)  /* Matrix Interrupt Enable */
+#define KPC_DK_DEB_SEL	(0x1 <<  9)  /* Direct Keypad Debounce Select */
+#define KPC_DI          (0x1 <<  5)  /* Direct key interrupt bit */
+#define KPC_RE_ZERO_DEB (0x1 <<  4)  /* Rotary Encoder Zero Debounce */
+#define KPC_REE1        (0x1 <<  3)  /* Rotary Encoder1 Enable */
+#define KPC_REE0        (0x1 <<  2)  /* Rotary Encoder0 Enable */
+#define KPC_DE          (0x1 <<  1)  /* Direct Keypad Enable */
+#define KPC_DIE         (0x1 <<  0)  /* Direct Keypad interrupt Enable */
+
+#define KPDK_DKP        (0x1 << 31)
+#define KPDK_DK7        (0x1 <<  7)
+#define KPDK_DK6        (0x1 <<  6)
+#define KPDK_DK5        (0x1 <<  5)
+#define KPDK_DK4        (0x1 <<  4)
+#define KPDK_DK3        (0x1 <<  3)
+#define KPDK_DK2        (0x1 <<  2)
+#define KPDK_DK1        (0x1 <<  1)
+#define KPDK_DK0        (0x1 <<  0)
+
+#define KPREC_OF1       (0x1 << 31)
+#define kPREC_UF1       (0x1 << 30)
+#define KPREC_OF0       (0x1 << 15)
+#define KPREC_UF0       (0x1 << 14)
+
+#define KPMK_MKP        (0x1 << 31)
+#define KPAS_SO         (0x1 << 31)
+#define KPASMKPx_SO     (0x1 << 31)
+
+/*
+ * UHC: USB Host Controller (OHCI-like) register definitions
+ */
+#define UHC_BASE_PHYS	(0x4C000000)
+#define UHCREV		__REG(0x4C000000) /* UHC HCI Spec Revision */
+#define UHCHCON		__REG(0x4C000004) /* UHC Host Control Register */
+#define UHCCOMS		__REG(0x4C000008) /* UHC Command Status Register */
+#define UHCINTS		__REG(0x4C00000C) /* UHC Interrupt Status Register */
+#define UHCINTE		__REG(0x4C000010) /* UHC Interrupt Enable */
+#define UHCINTD		__REG(0x4C000014) /* UHC Interrupt Disable */
+#define UHCHCCA		__REG(0x4C000018) /* UHC Host Controller Comm. Area */
+#define UHCPCED		__REG(0x4C00001C) /* UHC Period Current Endpt Descr */
+#define UHCCHED		__REG(0x4C000020) /* UHC Control Head Endpt Descr */
+#define UHCCCED		__REG(0x4C000024) /* UHC Control Current Endpt Descr */
+#define UHCBHED		__REG(0x4C000028) /* UHC Bulk Head Endpt Descr */
+#define UHCBCED		__REG(0x4C00002C) /* UHC Bulk Current Endpt Descr */
+#define UHCDHEAD	__REG(0x4C000030) /* UHC Done Head */
+#define UHCFMI		__REG(0x4C000034) /* UHC Frame Interval */
+#define UHCFMR		__REG(0x4C000038) /* UHC Frame Remaining */
+#define UHCFMN		__REG(0x4C00003C) /* UHC Frame Number */
+#define UHCPERS		__REG(0x4C000040) /* UHC Periodic Start */
+#define UHCLS		__REG(0x4C000044) /* UHC Low Speed Threshold */
+
+#define UHCRHDA		__REG(0x4C000048) /* UHC Root Hub Descriptor A */
+#define UHCRHDA_NOCP	(1 << 12)	/* No over current protection */
+
+#define UHCRHDB		__REG(0x4C00004C) /* UHC Root Hub Descriptor B */
+#define UHCRHS		__REG(0x4C000050) /* UHC Root Hub Status */
+#define UHCRHPS1	__REG(0x4C000054) /* UHC Root Hub Port 1 Status */
+#define UHCRHPS2	__REG(0x4C000058) /* UHC Root Hub Port 2 Status */
+#define UHCRHPS3	__REG(0x4C00005C) /* UHC Root Hub Port 3 Status */
+
+#define UHCSTAT		__REG(0x4C000060) /* UHC Status Register */
+#define UHCSTAT_UPS3	(1 << 16)	/* USB Power Sense Port3 */
+#define UHCSTAT_SBMAI	(1 << 15)	/* System Bus Master Abort Interrupt*/
+#define UHCSTAT_SBTAI	(1 << 14)	/* System Bus Target Abort Interrupt*/
+#define UHCSTAT_UPRI	(1 << 13)	/* USB Port Resume Interrupt */
+#define UHCSTAT_UPS2	(1 << 12)	/* USB Power Sense Port 2 */
+#define UHCSTAT_UPS1	(1 << 11)	/* USB Power Sense Port 1 */
+#define UHCSTAT_HTA	(1 << 10)	/* HCI Target Abort */
+#define UHCSTAT_HBA	(1 << 8)	/* HCI Buffer Active */
+#define UHCSTAT_RWUE	(1 << 7)	/* HCI Remote Wake Up Event */
+
+#define UHCHR           __REG(0x4C000064) /* UHC Reset Register */
+#define UHCHR_SSEP3	(1 << 11)	/* Sleep Standby Enable for Port3 */
+#define UHCHR_SSEP2	(1 << 10)	/* Sleep Standby Enable for Port2 */
+#define UHCHR_SSEP1	(1 << 9)	/* Sleep Standby Enable for Port1 */
+#define UHCHR_PCPL	(1 << 7)	/* Power control polarity low */
+#define UHCHR_PSPL	(1 << 6)	/* Power sense polarity low */
+#define UHCHR_SSE	(1 << 5)	/* Sleep Standby Enable */
+#define UHCHR_UIT	(1 << 4)	/* USB Interrupt Test */
+#define UHCHR_SSDC	(1 << 3)	/* Simulation Scale Down Clock */
+#define UHCHR_CGR	(1 << 2)	/* Clock Generation Reset */
+#define UHCHR_FHR	(1 << 1)	/* Force Host Controller Reset */
+#define UHCHR_FSBIR	(1 << 0)	/* Force System Bus Iface Reset */
+
+#define UHCHIE          __REG(0x4C000068) /* UHC Interrupt Enable Register*/
+#define UHCHIE_UPS3IE	(1 << 14)	/* Power Sense Port3 IntEn */
+#define UHCHIE_UPRIE	(1 << 13)	/* Port Resume IntEn */
+#define UHCHIE_UPS2IE	(1 << 12)	/* Power Sense Port2 IntEn */
+#define UHCHIE_UPS1IE	(1 << 11)	/* Power Sense Port1 IntEn */
+#define UHCHIE_TAIE	(1 << 10)	/* HCI Interface Transfer Abort
+					   Interrupt Enable*/
+#define UHCHIE_HBAIE	(1 << 8)	/* HCI Buffer Active IntEn */
+#define UHCHIE_RWIE	(1 << 7)	/* Remote Wake-up IntEn */
+
+#define UHCHIT          __REG(0x4C00006C) /* UHC Interrupt Test register */
+
+/* Camera Interface */
+#define CICR0		__REG(0x50000000)
+#define CICR1		__REG(0x50000004)
+#define CICR2		__REG(0x50000008)
+#define CICR3		__REG(0x5000000C)
+#define CICR4		__REG(0x50000010)
+#define CISR		__REG(0x50000014)
+#define CIFR		__REG(0x50000018)
+#define CITOR		__REG(0x5000001C)
+#define CIBR0		__REG(0x50000028)
+#define CIBR1		__REG(0x50000030)
+#define CIBR2		__REG(0x50000038)
+
+#define CICR0_DMAEN	(1 << 31)	/* DMA request enable */
+#define CICR0_PAR_EN	(1 << 30)	/* Parity enable */
+#define CICR0_SL_CAP_EN	(1 << 29)	/* Capture enable for slave mode */
+#define CICR0_ENB	(1 << 28)	/* Camera interface enable */
+#define CICR0_DIS	(1 << 27)	/* Camera interface disable */
+#define CICR0_SIM	(0x7 << 24)	/* Sensor interface mode mask */
+#define CICR0_TOM	(1 << 9)	/* Time-out mask */
+#define CICR0_RDAVM	(1 << 8)	/* Receive-data-available mask */
+#define CICR0_FEM	(1 << 7)	/* FIFO-empty mask */
+#define CICR0_EOLM	(1 << 6)	/* End-of-line mask */
+#define CICR0_PERRM	(1 << 5)	/* Parity-error mask */
+#define CICR0_QDM	(1 << 4)	/* Quick-disable mask */
+#define CICR0_CDM	(1 << 3)	/* Disable-done mask */
+#define CICR0_SOFM	(1 << 2)	/* Start-of-frame mask */
+#define CICR0_EOFM	(1 << 1)	/* End-of-frame mask */
+#define CICR0_FOM	(1 << 0)	/* FIFO-overrun mask */
+
+#define CICR1_TBIT	(1 << 31)	/* Transparency bit */
+#define CICR1_RGBT_CONV	(0x3 << 30)	/* RGBT conversion mask */
+#define CICR1_PPL	(0x7ff << 15)	/* Pixels per line mask */
+#define CICR1_RGB_CONV	(0x7 << 12)	/* RGB conversion mask */
+#define CICR1_RGB_F	(1 << 11)	/* RGB format */
+#define CICR1_YCBCR_F	(1 << 10)	/* YCbCr format */
+#define CICR1_RGB_BPP	(0x7 << 7)	/* RGB bis per pixel mask */
+#define CICR1_RAW_BPP	(0x3 << 5)	/* Raw bis per pixel mask */
+#define CICR1_COLOR_SP	(0x3 << 3)	/* Color space mask */
+#define CICR1_DW	(0x7 << 0)	/* Data width mask */
+
+#define CICR2_BLW	(0xff << 24)	/* Beginning-of-line pixel clock
+					   wait count mask */
+#define CICR2_ELW	(0xff << 16)	/* End-of-line pixel clock
+					   wait count mask */
+#define CICR2_HSW	(0x3f << 10)	/* Horizontal sync pulse width mask */
+#define CICR2_BFPW	(0x3f << 3)	/* Beginning-of-frame pixel clock
+					   wait count mask */
+#define CICR2_FSW	(0x7 << 0)	/* Frame stabilization
+					   wait count mask */
+
+#define CICR3_BFW	(0xff << 24)	/* Beginning-of-frame line clock
+					   wait count mask */
+#define CICR3_EFW	(0xff << 16)	/* End-of-frame line clock
+					   wait count mask */
+#define CICR3_VSW	(0x3f << 10)	/* Vertical sync pulse width mask */
+#define CICR3_BFPW	(0x3f << 3)	/* Beginning-of-frame pixel clock
+					   wait count mask */
+#define CICR3_LPF	(0x7ff << 0)	/* Lines per frame mask */
+
+#define CICR4_MCLK_DLY	(0x3 << 24)	/* MCLK Data Capture Delay mask */
+#define CICR4_PCLK_EN	(1 << 23)	/* Pixel clock enable */
+#define CICR4_PCP	(1 << 22)	/* Pixel clock polarity */
+#define CICR4_HSP	(1 << 21)	/* Horizontal sync polarity */
+#define CICR4_VSP	(1 << 20)	/* Vertical sync polarity */
+#define CICR4_MCLK_EN	(1 << 19)	/* MCLK enable */
+#define CICR4_FR_RATE	(0x7 << 8)	/* Frame rate mask */
+#define CICR4_DIV	(0xff << 0)	/* Clock divisor mask */
+
+#define CISR_FTO	(1 << 15)	/* FIFO time-out */
+#define CISR_RDAV_2	(1 << 14)	/* Channel 2 receive data available */
+#define CISR_RDAV_1	(1 << 13)	/* Channel 1 receive data available */
+#define CISR_RDAV_0	(1 << 12)	/* Channel 0 receive data available */
+#define CISR_FEMPTY_2	(1 << 11)	/* Channel 2 FIFO empty */
+#define CISR_FEMPTY_1	(1 << 10)	/* Channel 1 FIFO empty */
+#define CISR_FEMPTY_0	(1 << 9)	/* Channel 0 FIFO empty */
+#define CISR_EOL	(1 << 8)	/* End of line */
+#define CISR_PAR_ERR	(1 << 7)	/* Parity error */
+#define CISR_CQD	(1 << 6)	/* Camera interface quick disable */
+#define CISR_CDD	(1 << 5)	/* Camera interface disable done */
+#define CISR_SOF	(1 << 4)	/* Start of frame */
+#define CISR_EOF	(1 << 3)	/* End of frame */
+#define CISR_IFO_2	(1 << 2)	/* FIFO overrun for Channel 2 */
+#define CISR_IFO_1	(1 << 1)	/* FIFO overrun for Channel 1 */
+#define CISR_IFO_0	(1 << 0)	/* FIFO overrun for Channel 0 */
+
+#define CIFR_FLVL2	(0x7f << 23)	/* FIFO 2 level mask */
+#define CIFR_FLVL1	(0x7f << 16)	/* FIFO 1 level mask */
+#define CIFR_FLVL0	(0xff << 8)	/* FIFO 0 level mask */
+#define CIFR_THL_0	(0x3 << 4)	/* Threshold Level for Channel 0 FIFO */
+#define CIFR_RESET_F	(1 << 3)	/* Reset input FIFOs */
+#define CIFR_FEN2	(1 << 2)	/* FIFO enable for channel 2 */
+#define CIFR_FEN1	(1 << 1)	/* FIFO enable for channel 1 */
+#define CIFR_FEN0	(1 << 0)	/* FIFO enable for channel 0 */
+
+#define SRAM_SIZE		0x40000 /* 4x64K  */
+
+#define SRAM_MEM_PHYS		0x5C000000
+
+#define IMPMCR		__REG(0x58000000) /* IM Power Management Control Reg */
+#define IMPMSR		__REG(0x58000008) /* IM Power Management Status Reg */
+
+#define IMPMCR_PC3		(0x3 << 22) /* Bank 3 Power Control */
+#define IMPMCR_PC3_RUN_MODE	(0x0 << 22) /*   Run mode */
+#define IMPMCR_PC3_STANDBY_MODE	(0x1 << 22) /*   Standby mode */
+#define IMPMCR_PC3_AUTO_MODE	(0x3 << 22) /*   Automatically controlled */
+
+#define IMPMCR_PC2		(0x3 << 20) /* Bank 2 Power Control */
+#define IMPMCR_PC2_RUN_MODE	(0x0 << 20) /*   Run mode */
+#define IMPMCR_PC2_STANDBY_MODE	(0x1 << 20) /*   Standby mode */
+#define IMPMCR_PC2_AUTO_MODE	(0x3 << 20) /*   Automatically controlled */
+
+#define IMPMCR_PC1		(0x3 << 18) /* Bank 1 Power Control */
+#define IMPMCR_PC1_RUN_MODE	(0x0 << 18) /*   Run mode */
+#define IMPMCR_PC1_STANDBY_MODE	(0x1 << 18) /*   Standby mode */
+#define IMPMCR_PC1_AUTO_MODE	(0x3 << 18) /*   Automatically controlled */
+
+#define IMPMCR_PC0		(0x3 << 16) /* Bank 0 Power Control */
+#define IMPMCR_PC0_RUN_MODE	(0x0 << 16) /*   Run mode */
+#define IMPMCR_PC0_STANDBY_MODE	(0x1 << 16) /*   Standby mode */
+#define IMPMCR_PC0_AUTO_MODE	(0x3 << 16) /*   Automatically controlled */
+
+#define IMPMCR_AW3		(1 << 11) /* Bank 3 Automatic Wake-up enable */
+#define IMPMCR_AW2		(1 << 10) /* Bank 2 Automatic Wake-up enable */
+#define IMPMCR_AW1		(1 << 9)  /* Bank 1 Automatic Wake-up enable */
+#define IMPMCR_AW0		(1 << 8)  /* Bank 0 Automatic Wake-up enable */
+
+#define IMPMCR_DST		(0xFF << 0) /* Delay Standby Time, ms */
+
+#define IMPMSR_PS3		(0x3 << 6) /* Bank 3 Power Status: */
+#define IMPMSR_PS3_RUN_MODE	(0x0 << 6) /*    Run mode */
+#define IMPMSR_PS3_STANDBY_MODE	(0x1 << 6) /*    Standby mode */
+
+#define IMPMSR_PS2		(0x3 << 4) /* Bank 2 Power Status: */
+#define IMPMSR_PS2_RUN_MODE	(0x0 << 4) /*    Run mode */
+#define IMPMSR_PS2_STANDBY_MODE	(0x1 << 4) /*    Standby mode */
+
+#define IMPMSR_PS1		(0x3 << 2) /* Bank 1 Power Status: */
+#define IMPMSR_PS1_RUN_MODE	(0x0 << 2) /*    Run mode */
+#define IMPMSR_PS1_STANDBY_MODE	(0x1 << 2) /*    Standby mode */
+
+#define IMPMSR_PS0		(0x3 << 0) /* Bank 0 Power Status: */
+#define IMPMSR_PS0_RUN_MODE	(0x0 << 0) /*    Run mode */
+#define IMPMSR_PS0_STANDBY_MODE	(0x1 << 0) /*    Standby mode */
+
+#endif
+
+/* PWRMODE register M field values */
+
+#define PWRMODE_IDLE		0x1
+#define PWRMODE_STANDBY		0x2
+#define PWRMODE_SLEEP		0x3
+#define PWRMODE_DEEPSLEEP	0x7
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/pxa2xx_spi.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/pxa2xx_spi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/pxa2xx_spi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2005 Stephen Street / StreetFire Sound Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef PXA2XX_SPI_H_
+#define PXA2XX_SPI_H_
+
+#define PXA2XX_CS_ASSERT (0x01)
+#define PXA2XX_CS_DEASSERT (0x02)
+
+#if defined(CONFIG_PXA25x)
+#define CLOCK_SPEED_HZ 3686400
+#define SSP1_SerClkDiv(x) (((CLOCK_SPEED_HZ/2/(x+1))<<8)&0x0000ff00)
+#define SSP2_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#define SSP3_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#elif defined(CONFIG_PXA27x)
+#define CLOCK_SPEED_HZ 13000000
+#define SSP1_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#define SSP2_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#define SSP3_SerClkDiv(x) (((CLOCK_SPEED_HZ/(x+1))<<8)&0x000fff00)
+#endif
+
+#define SSP1_VIRT ((void *)(io_p2v(__PREG(SSCR0_P(1)))))
+#define SSP2_VIRT ((void *)(io_p2v(__PREG(SSCR0_P(2)))))
+#define SSP3_VIRT ((void *)(io_p2v(__PREG(SSCR0_P(3)))))
+
+enum pxa_ssp_type {
+	SSP_UNDEFINED = 0,
+	PXA25x_SSP,  /* pxa 210, 250, 255, 26x */
+	PXA25x_NSSP, /* pxa 255, 26x (including ASSP) */
+	PXA27x_SSP,
+};
+
+/* device.platform_data for SSP controller devices */
+struct pxa2xx_spi_master {
+	enum pxa_ssp_type ssp_type;
+	u32 clock_enable;
+	u16 num_chipselect;
+	u8 enable_dma;
+};
+
+/* spi_board_info.controller_data for SPI slave devices,
+ * copied to spi_device.platform_data ... mostly for dma tuning
+ */
+struct pxa2xx_spi_chip {
+	u8 tx_threshold;
+	u8 rx_threshold;
+	u8 dma_burst_size;
+	u32 timeout;
+	u8 enable_loopback;
+	void (*cs_control)(u32 command);
+};
+
+#endif /*PXA2XX_SPI_H_*/
Index: build_tree/linux/include/asm/arch-pxa/pxafb.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/pxafb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/pxafb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,135 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/pxafb.h
+ *
+ *  Support for the xscale frame buffer.
+ *
+ *  Author:     Jean-Frederic Clere
+ *  Created:    Sep 22, 2003
+ *  Copyright:  jfclere@sinix.net
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/fb.h>
+
+/*
+ * This structure describes the machine which we are running on.
+ * It is set in linux/arch/arm/mach-pxa/machine_name.c and used in the probe routine
+ * of linux/drivers/video/pxafb.c
+ */
+struct pxafb_mode_info {
+	u_long		pixclock;
+
+	u_short		xres;
+	u_short		yres;
+
+	u_char		bpp;
+	u_char		hsync_len;
+	u_char		left_margin;
+	u_char		right_margin;
+
+	u_char		vsync_len;
+	u_char		upper_margin;
+	u_char		lower_margin;
+	u_char		sync;
+
+	u_int		cmap_greyscale:1,
+			unused:31;
+};
+
+struct pxafb_mach_info {
+	struct pxafb_mode_info *modes;
+	unsigned int num_modes;
+
+	u_int		fixed_modes:1,
+			cmap_inverse:1,
+			cmap_static:1,
+			unused:29;
+
+	/* The following should be defined in LCCR0
+	 *      LCCR0_Act or LCCR0_Pas          Active or Passive
+	 *      LCCR0_Sngl or LCCR0_Dual        Single/Dual panel
+	 *      LCCR0_Mono or LCCR0_Color       Mono/Color
+	 *      LCCR0_4PixMono or LCCR0_8PixMono (in mono single mode)
+	 *      LCCR0_DMADel(Tcpu) (optional)   DMA request delay
+	 *
+	 * The following should not be defined in LCCR0:
+	 *      LCCR0_OUM, LCCR0_BM, LCCR0_QDM, LCCR0_DIS, LCCR0_EFM
+	 *      LCCR0_IUM, LCCR0_SFM, LCCR0_LDM, LCCR0_ENB
+	 */
+	u_int		lccr0;
+	/* The following should be defined in LCCR3
+	 *      LCCR3_OutEnH or LCCR3_OutEnL    Output enable polarity
+	 *      LCCR3_PixRsEdg or LCCR3_PixFlEdg Pixel clock edge type
+	 *      LCCR3_Acb(X)                    AB Bias pin frequency
+	 *      LCCR3_DPC (optional)            Double Pixel Clock mode (untested)
+	 *
+	 * The following should not be defined in LCCR3
+	 *      LCCR3_HSP, LCCR3_VSP, LCCR0_Pcd(x), LCCR3_Bpp
+	 */
+	u_int		lccr3;
+
+	void (*pxafb_backlight_power)(int);
+	void (*pxafb_lcd_power)(int, struct fb_var_screeninfo *);
+
+};
+void set_pxa_fb_info(struct pxafb_mach_info *hard_pxa_fb_info);
+void set_pxa_fb_parent(struct device *parent_dev);
+unsigned long pxafb_get_hsync_time(struct device *dev);
+
+
+/* PIXCLOCK --- unit 10khz*/
+/* Modified for Z2 Optrex */
+#define ZIPIT2
+
+#if 1   /*Z2 rev 2 LCD*/
+#define LCD_PIXCLOCK	688	
+/*JWK test new Z2 LCD 041607 #define LCD_PIXCLOCK		576 */
+#define LCD_BPP				16
+#define LCD_XRES			240
+#define LCD_YRES			320
+#define LCD_HORIZONTAL_SYNC_PULSE_WIDTH	4
+#define LCD_VERTICAL_SYNC_PULSE_WIDTH	4
+#define LCD_BEGIN_OF_LINE_WAIT_COUNT	4
+#define LCD_BEGIN_FRAME_WAIT_COUNT 	4
+#define LCD_END_OF_LINE_WAIT_COUNT	8
+#define LCD_END_OF_FRAME_WAIT_COUNT	8
+#define LCD_SYNC			(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT)
+#else /*Z2 rev 1 LCD*/
+#define LCD_PIXCLOCK	 		576	
+#define LCD_BPP				16
+#define LCD_XRES			240
+#define LCD_YRES			320
+#define LCD_HORIZONTAL_SYNC_PULSE_WIDTH	2
+#define LCD_VERTICAL_SYNC_PULSE_WIDTH	2
+#define LCD_BEGIN_OF_LINE_WAIT_COUNT	1
+#define LCD_BEGIN_FRAME_WAIT_COUNT 	1
+#define LCD_END_OF_LINE_WAIT_COUNT	10
+#define LCD_END_OF_FRAME_WAIT_COUNT	1
+#define LCD_SYNC			(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT)
+#endif 
+
+
+//#define LCD_LCCR0		0x1B00A78
+//#define LCD_LCCR3		0x4008000
+
+//#define LCD_LCCR0		(LCCR0_OUC | LCCR0_CMDIM | LCCR0_RDSTM | \
+                         LCCR0_OUM | LCCR0_BM | LCCR0_QDM | LCCR0_PAS | \
+                         LCCR0_EFM | LCCR0_IUM | LCCR0_SFM | LCCR0_LDM)
+
+/* Z2 -- Removed Active setting */
+/*#define LCD_LCCR0		(LCCR0_OUC | LCCR0_CMDIM | LCCR0_RDSTM | \
+                         LCCR0_OUM | LCCR0_BM | LCCR0_QDM | \
+                         LCCR0_EFM | LCCR0_IUM | LCCR0_SFM | LCCR0_LDM)
+*/
+#define LCD_LCCR0 0x05B00AF8 // per Frank W."older than IEEE"  Tinklepaugh
+
+/*#define LCD_LCCR3 	    (LCCR3_PCP | LCCR3_HSP | LCCR3_VSP )
+*/
+#if 0 /*Z2 rev 1 LCD*/
+#define LCD_LCCR3 0x04f00009
+#else  /*Z2 rev 2 LCD*/
+#define LCD_LCCR3 0x04b00006
+#endif
Index: build_tree/linux/include/asm/arch-pxa/sharpsl.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/sharpsl.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/sharpsl.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ * SharpSL SSP Driver
+ */
+
+unsigned long corgi_ssp_ads7846_putget(unsigned long);
+unsigned long corgi_ssp_ads7846_get(void);
+void corgi_ssp_ads7846_put(unsigned long data);
+void corgi_ssp_ads7846_lock(void);
+void corgi_ssp_ads7846_unlock(void);
+void corgi_ssp_lcdtg_send (unsigned char adrs, unsigned char data);
+void corgi_ssp_blduty_set(int duty);
+int corgi_ssp_max1111_get(unsigned long data);
+
+/*
+ * SharpSL Touchscreen Driver
+ */
+
+struct corgits_machinfo {
+	unsigned long (*get_hsync_len)(void);
+	void (*put_hsync)(void);
+	void (*wait_hsync)(void);
+};
+
+
+/*
+ * SharpSL Backlight
+ */
+struct corgibl_machinfo {
+	int max_intensity;
+	int default_intensity;
+	int limit_mask;
+	void (*set_bl_intensity)(int intensity);
+};
+extern void corgibl_limit_intensity(int limit);
+
+
+/*
+ * SharpSL Battery/PM Driver
+ */
+extern void sharpsl_battery_kick(void);
Index: build_tree/linux/include/asm/arch-pxa/spitz.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/spitz.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/spitz.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,160 @@
+/*
+ * Hardware specific definitions for SL-Cx000 series of PDAs
+ *
+ * Copyright (c) 2005 Alexander Wykes
+ * Copyright (c) 2005 Richard Purdie
+ *
+ * Based on Sharp's 2.4 kernel patches
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ASM_ARCH_SPITZ_H
+#define __ASM_ARCH_SPITZ_H  1
+#endif
+
+#include <linux/fb.h>
+
+/* Spitz/Akita GPIOs */
+
+#define SPITZ_GPIO_KEY_INT         (0) /* Key Interrupt */
+#define SPITZ_GPIO_RESET           (1)
+#define SPITZ_GPIO_nSD_DETECT      (9)
+#define SPITZ_GPIO_TP_INT          (11) /* Touch Panel interrupt */
+#define SPITZ_GPIO_AK_INT          (13) /* Remote Control */
+#define SPITZ_GPIO_ADS7846_CS      (14)
+#define SPITZ_GPIO_SYNC            (16)
+#define SPITZ_GPIO_MAX1111_CS      (20)
+#define SPITZ_GPIO_FATAL_BAT       (21)
+#define SPITZ_GPIO_HSYNC           (22)
+#define SPITZ_GPIO_nSD_CLK         (32)
+#define SPITZ_GPIO_USB_DEVICE      (35)
+#define SPITZ_GPIO_USB_HOST        (37)
+#define SPITZ_GPIO_USB_CONNECT     (41)
+#define SPITZ_GPIO_LCDCON_CS       (53)
+#define SPITZ_GPIO_nPCE            (54)
+#define SPITZ_GPIO_nSD_WP          (81)
+#define SPITZ_GPIO_ON_RESET        (89)
+#define SPITZ_GPIO_BAT_COVER       (90)
+#define SPITZ_GPIO_CF_CD           (94)
+#define SPITZ_GPIO_ON_KEY          (95)
+#define SPITZ_GPIO_SWA             (97)
+#define SPITZ_GPIO_SWB             (96)
+#define SPITZ_GPIO_CHRG_FULL       (101)
+#define SPITZ_GPIO_CO              (101)
+#define SPITZ_GPIO_CF_IRQ          (105)
+#define SPITZ_GPIO_AC_IN           (115)
+#define SPITZ_GPIO_HP_IN           (116)
+
+/* Spitz Only GPIOs */
+
+#define SPITZ_GPIO_CF2_IRQ         (106) /* CF slot1 Ready */
+#define SPITZ_GPIO_CF2_CD          (93)
+
+
+/* Spitz/Akita Keyboard Definitions */
+
+#define SPITZ_KEY_STROBE_NUM         (11)
+#define SPITZ_KEY_SENSE_NUM          (7)
+#define SPITZ_GPIO_G0_STROBE_BIT     0x0f800000
+#define SPITZ_GPIO_G1_STROBE_BIT     0x00100000
+#define SPITZ_GPIO_G2_STROBE_BIT     0x01000000
+#define SPITZ_GPIO_G3_STROBE_BIT     0x00041880
+#define SPITZ_GPIO_G0_SENSE_BIT      0x00021000
+#define SPITZ_GPIO_G1_SENSE_BIT      0x000000d4
+#define SPITZ_GPIO_G2_SENSE_BIT      0x08000000
+#define SPITZ_GPIO_G3_SENSE_BIT      0x00000000
+
+#define SPITZ_GPIO_KEY_STROBE0       88
+#define SPITZ_GPIO_KEY_STROBE1       23
+#define SPITZ_GPIO_KEY_STROBE2       24
+#define SPITZ_GPIO_KEY_STROBE3       25
+#define SPITZ_GPIO_KEY_STROBE4       26
+#define SPITZ_GPIO_KEY_STROBE5       27
+#define SPITZ_GPIO_KEY_STROBE6       52
+#define SPITZ_GPIO_KEY_STROBE7       103
+#define SPITZ_GPIO_KEY_STROBE8       107
+#define SPITZ_GPIO_KEY_STROBE9       108
+#define SPITZ_GPIO_KEY_STROBE10      114
+
+#define SPITZ_GPIO_KEY_SENSE0        12
+#define SPITZ_GPIO_KEY_SENSE1        17
+#define SPITZ_GPIO_KEY_SENSE2        91
+#define SPITZ_GPIO_KEY_SENSE3        34
+#define SPITZ_GPIO_KEY_SENSE4        36
+#define SPITZ_GPIO_KEY_SENSE5        38
+#define SPITZ_GPIO_KEY_SENSE6        39
+
+
+/* Spitz Scoop Device (No. 1) GPIOs */
+/* Suspend States in comments */
+#define SPITZ_SCP_LED_GREEN     SCOOP_GPCR_PA11  /* Keep */
+#define SPITZ_SCP_JK_B          SCOOP_GPCR_PA12  /* Keep */
+#define SPITZ_SCP_CHRG_ON       SCOOP_GPCR_PA13  /* Keep */
+#define SPITZ_SCP_MUTE_L        SCOOP_GPCR_PA14  /* Low */
+#define SPITZ_SCP_MUTE_R        SCOOP_GPCR_PA15  /* Low */
+#define SPITZ_SCP_CF_POWER      SCOOP_GPCR_PA16  /* Keep */
+#define SPITZ_SCP_LED_ORANGE    SCOOP_GPCR_PA17  /* Keep */
+#define SPITZ_SCP_JK_A          SCOOP_GPCR_PA18  /* Low */
+#define SPITZ_SCP_ADC_TEMP_ON   SCOOP_GPCR_PA19  /* Low */
+
+#define SPITZ_SCP_IO_DIR      (SPITZ_SCP_LED_GREEN | SPITZ_SCP_JK_B | SPITZ_SCP_CHRG_ON | \
+                               SPITZ_SCP_MUTE_L | SPITZ_SCP_MUTE_R | SPITZ_SCP_LED_ORANGE | \
+                               SPITZ_SCP_CF_POWER | SPITZ_SCP_JK_A | SPITZ_SCP_ADC_TEMP_ON)
+#define SPITZ_SCP_IO_OUT      (SPITZ_SCP_CHRG_ON | SPITZ_SCP_MUTE_L | SPITZ_SCP_MUTE_R)
+#define SPITZ_SCP_SUS_CLR     (SPITZ_SCP_MUTE_L | SPITZ_SCP_MUTE_R | SPITZ_SCP_JK_A | SPITZ_SCP_ADC_TEMP_ON)
+#define SPITZ_SCP_SUS_SET     0
+
+/* Spitz Scoop Device (No. 2) GPIOs */
+/* Suspend States in comments */
+#define SPITZ_SCP2_IR_ON           SCOOP_GPCR_PA11  /* High */
+#define SPITZ_SCP2_AKIN_PULLUP     SCOOP_GPCR_PA12  /* Keep */
+#define SPITZ_SCP2_RESERVED_1      SCOOP_GPCR_PA13  /* High */
+#define SPITZ_SCP2_RESERVED_2      SCOOP_GPCR_PA14  /* Low */
+#define SPITZ_SCP2_RESERVED_3      SCOOP_GPCR_PA15  /* Low */
+#define SPITZ_SCP2_RESERVED_4      SCOOP_GPCR_PA16  /* Low */
+#define SPITZ_SCP2_BACKLIGHT_CONT  SCOOP_GPCR_PA17  /* Low */
+#define SPITZ_SCP2_BACKLIGHT_ON    SCOOP_GPCR_PA18  /* Low */
+#define SPITZ_SCP2_MIC_BIAS        SCOOP_GPCR_PA19  /* Low */
+
+#define SPITZ_SCP2_IO_DIR (SPITZ_SCP2_IR_ON | SPITZ_SCP2_AKIN_PULLUP | SPITZ_SCP2_RESERVED_1 | \
+                           SPITZ_SCP2_RESERVED_2 | SPITZ_SCP2_RESERVED_3 | SPITZ_SCP2_RESERVED_4 | \
+                           SPITZ_SCP2_BACKLIGHT_CONT | SPITZ_SCP2_BACKLIGHT_ON | SPITZ_SCP2_MIC_BIAS)
+
+#define SPITZ_SCP2_IO_OUT   (SPITZ_SCP2_IR_ON | SPITZ_SCP2_AKIN_PULLUP | SPITZ_SCP2_RESERVED_1)
+#define SPITZ_SCP2_SUS_CLR  (SPITZ_SCP2_RESERVED_2 | SPITZ_SCP2_RESERVED_3 | SPITZ_SCP2_RESERVED_4 | \
+                             SPITZ_SCP2_BACKLIGHT_CONT | SPITZ_SCP2_BACKLIGHT_ON | SPITZ_SCP2_MIC_BIAS)
+#define SPITZ_SCP2_SUS_SET  (SPITZ_SCP2_IR_ON | SPITZ_SCP2_RESERVED_1)
+
+
+/* Spitz IRQ Definitions */
+
+#define SPITZ_IRQ_GPIO_KEY_INT        IRQ_GPIO(SPITZ_GPIO_KEY_INT)
+#define SPITZ_IRQ_GPIO_AC_IN          IRQ_GPIO(SPITZ_GPIO_AC_IN)
+#define SPITZ_IRQ_GPIO_AK_INT         IRQ_GPIO(SPITZ_GPIO_AK_INT)
+#define SPITZ_IRQ_GPIO_HP_IN          IRQ_GPIO(SPITZ_GPIO_HP_IN)
+#define SPITZ_IRQ_GPIO_TP_INT         IRQ_GPIO(SPITZ_GPIO_TP_INT)
+#define SPITZ_IRQ_GPIO_SYNC           IRQ_GPIO(SPITZ_GPIO_SYNC)
+#define SPITZ_IRQ_GPIO_ON_KEY         IRQ_GPIO(SPITZ_GPIO_ON_KEY)
+#define SPITZ_IRQ_GPIO_SWA            IRQ_GPIO(SPITZ_GPIO_SWA)
+#define SPITZ_IRQ_GPIO_SWB            IRQ_GPIO(SPITZ_GPIO_SWB)
+#define SPITZ_IRQ_GPIO_BAT_COVER      IRQ_GPIO(SPITZ_GPIO_BAT_COVER)
+#define SPITZ_IRQ_GPIO_FATAL_BAT      IRQ_GPIO(SPITZ_GPIO_FATAL_BAT)
+#define SPITZ_IRQ_GPIO_CO             IRQ_GPIO(SPITZ_GPIO_CO)
+#define SPITZ_IRQ_GPIO_CF_IRQ         IRQ_GPIO(SPITZ_GPIO_CF_IRQ)
+#define SPITZ_IRQ_GPIO_CF_CD          IRQ_GPIO(SPITZ_GPIO_CF_CD)
+#define SPITZ_IRQ_GPIO_CF2_IRQ        IRQ_GPIO(SPITZ_GPIO_CF2_IRQ)
+#define SPITZ_IRQ_GPIO_nSD_INT        IRQ_GPIO(SPITZ_GPIO_nSD_INT)
+#define SPITZ_IRQ_GPIO_nSD_DETECT     IRQ_GPIO(SPITZ_GPIO_nSD_DETECT)
+
+/*
+ * Shared data structures
+ */
+extern struct platform_device spitzscoop_device;
+extern struct platform_device spitzscoop2_device;
+extern struct platform_device spitzssp_device;
+extern struct sharpsl_charger_machinfo spitz_pm_machinfo;
+
+extern void spitz_lcd_power(int on, struct fb_var_screeninfo *var);
Index: build_tree/linux/include/asm/arch-pxa/ssp.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/ssp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/ssp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,53 @@
+/*
+ *  ssp.h
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This driver supports the following PXA CPU/SSP ports:-
+ *
+ *       PXA250     SSP
+ *       PXA255     SSP, NSSP
+ *       PXA26x     SSP, NSSP, ASSP
+ *       PXA27x     SSP1, SSP2, SSP3
+ */
+
+#ifndef SSP_H
+#define SSP_H
+
+/*
+ * SSP initialisation flags
+ */
+#define SSP_NO_IRQ	0x1		/* don't register an irq handler in SSP driver */
+
+struct ssp_state {
+	u32	cr0;
+	u32 cr1;
+	u32 to;
+	u32 psp;
+};
+
+struct ssp_dev {
+	u32 port;
+	u32 mode;
+	u32 flags;
+	u32 psp_flags;
+	u32 speed;
+	int irq;
+};
+
+int ssp_write_word(struct ssp_dev *dev, u32 data);
+int ssp_read_word(struct ssp_dev *dev, u32 *data);
+int ssp_flush(struct ssp_dev *dev);
+void ssp_enable(struct ssp_dev *dev);
+void ssp_disable(struct ssp_dev *dev);
+void ssp_save_state(struct ssp_dev *dev, struct ssp_state *ssp);
+void ssp_restore_state(struct ssp_dev *dev, struct ssp_state *ssp);
+int ssp_init(struct ssp_dev *dev, u32 port, u32 init_flags);
+int ssp_config(struct ssp_dev *dev, u32 mode, u32 flags, u32 psp_flags, u32 speed);
+void ssp_exit(struct ssp_dev *dev);
+
+#endif
Index: build_tree/linux/include/asm/arch-pxa/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,35 @@
+/*
+ * linux/include/asm-arm/arch-pxa/system.h
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Jun 15, 2001
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/proc-fns.h>
+#include "hardware.h"
+#include "pxa-regs.h"
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+
+static inline void arch_reset(char mode)
+{
+	if (mode == 's') {
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+	} else {
+		/* Initialize the watchdog and let it fire */
+		OWER = OWER_WME;
+		OSSR = OSSR_M3;
+		OSMR3 = OSCR + 368640;	/* ... in 100 ms */
+	}
+}
+
Index: build_tree/linux/include/asm/arch-pxa/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/*
+ * linux/include/asm-arm/arch-pxa/timex.h
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Jun 15, 2001
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#if defined(CONFIG_PXA25x)
+/* PXA250/210 timer base */
+#define CLOCK_TICK_RATE 3686400
+#elif defined(CONFIG_PXA27x)
+/* PXA27x timer base */
+#ifdef CONFIG_MACH_MAINSTONE
+#define CLOCK_TICK_RATE 3249600
+#else
+#define CLOCK_TICK_RATE 3250000
+#endif
+#endif
Index: build_tree/linux/include/asm/arch-pxa/tosa.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/tosa.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/tosa.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,166 @@
+/*
+ * Hardware specific definitions for Sharp SL-C6000x series of PDAs
+ *
+ * Copyright (c) 2005 Dirk Opfer
+ *
+ * Based on Sharp's 2.4 kernel patches
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _ASM_ARCH_TOSA_H_
+#define _ASM_ARCH_TOSA_H_ 1
+
+/*  TOSA Chip selects  */
+#define TOSA_LCDC_PHYS		PXA_CS4_PHYS
+/* Internel Scoop */
+#define TOSA_CF_PHYS		(PXA_CS2_PHYS + 0x00800000)
+/* Jacket Scoop */
+#define TOSA_SCOOP_PHYS  	(PXA_CS5_PHYS + 0x00800000)
+
+/*
+ * SCOOP2 internal GPIOs
+ */
+#define TOSA_SCOOP_PXA_VCORE1		SCOOP_GPCR_PA11
+#define TOSA_SCOOP_TC6393_REST_IN	SCOOP_GPCR_PA12
+#define TOSA_SCOOP_IR_POWERDWN		SCOOP_GPCR_PA13
+#define TOSA_SCOOP_SD_WP		SCOOP_GPCR_PA14
+#define TOSA_SCOOP_PWR_ON		SCOOP_GPCR_PA15
+#define TOSA_SCOOP_AUD_PWR_ON		SCOOP_GPCR_PA16
+#define TOSA_SCOOP_BT_RESET		SCOOP_GPCR_PA17
+#define TOSA_SCOOP_BT_PWR_EN		SCOOP_GPCR_PA18
+#define TOSA_SCOOP_AC_IN_OL		SCOOP_GPCR_PA19
+
+/* GPIO Direction   1 : output mode / 0:input mode */
+#define TOSA_SCOOP_IO_DIR     ( TOSA_SCOOP_PXA_VCORE1 | TOSA_SCOOP_TC6393_REST_IN | \
+		TOSA_SCOOP_IR_POWERDWN | TOSA_SCOOP_PWR_ON | TOSA_SCOOP_AUD_PWR_ON |\
+		TOSA_SCOOP_BT_RESET | TOSA_SCOOP_BT_PWR_EN )
+/* GPIO out put level when init   1: Hi */
+#define TOSA_SCOOP_IO_OUT     ( TOSA_SCOOP_TC6393_REST_IN )
+
+/*
+ * SCOOP2 jacket GPIOs
+ */
+#define TOSA_SCOOP_JC_BT_LED		SCOOP_GPCR_PA11
+#define TOSA_SCOOP_JC_NOTE_LED		SCOOP_GPCR_PA12
+#define TOSA_SCOOP_JC_CHRG_ERR_LED	SCOOP_GPCR_PA13
+#define TOSA_SCOOP_JC_USB_PULLUP	SCOOP_GPCR_PA14
+#define TOSA_SCOOP_JC_TC6393_SUSPEND	SCOOP_GPCR_PA15
+#define TOSA_SCOOP_JC_TC3693_L3V_ON	SCOOP_GPCR_PA16
+#define TOSA_SCOOP_JC_WLAN_DETECT	SCOOP_GPCR_PA17
+#define TOSA_SCOOP_JC_WLAN_LED		SCOOP_GPCR_PA18
+#define TOSA_SCOOP_JC_CARD_LIMIT_SEL	SCOOP_GPCR_PA19
+
+/* GPIO Direction   1 : output mode / 0:input mode */
+#define TOSA_SCOOP_JC_IO_DIR ( TOSA_SCOOP_JC_BT_LED | TOSA_SCOOP_JC_NOTE_LED | \
+		TOSA_SCOOP_JC_CHRG_ERR_LED | TOSA_SCOOP_JC_USB_PULLUP | \
+		TOSA_SCOOP_JC_TC6393_SUSPEND | TOSA_SCOOP_JC_TC3693_L3V_ON | \
+		TOSA_SCOOP_JC_WLAN_LED | TOSA_SCOOP_JC_CARD_LIMIT_SEL )
+/* GPIO out put level when init   1: Hi */
+#define TOSA_SCOOP_JC_IO_OUT ( 0 )
+
+/*
+ * Timing Generator
+ */
+#define TG_PNLCTL 			0x00
+#define TG_TPOSCTL 			0x01
+#define TG_DUTYCTL 			0x02
+#define TG_GPOSR 			0x03
+#define TG_GPODR1 			0x04
+#define TG_GPODR2 			0x05
+#define TG_PINICTL 			0x06
+#define TG_HPOSCTL 			0x07
+
+/*
+ * LED
+ */
+#define TOSA_SCOOP_LED_BLUE   		TOSA_SCOOP_GPCR_PA11
+#define TOSA_SCOOP_LED_GREEN  		TOSA_SCOOP_GPCR_PA12
+#define TOSA_SCOOP_LED_ORANGE		TOSA_SCOOP_GPCR_PA13
+#define TOSA_SCOOP_LED_WLAN		TOSA_SCOOP_GPCR_PA18
+
+
+/*
+ * PXA GPIOs
+ */
+#define TOSA_GPIO_POWERON		(0)
+#define TOSA_GPIO_RESET			(1)
+#define TOSA_GPIO_AC_IN			(2)
+#define TOSA_GPIO_RECORD_BTN		(3)
+#define TOSA_GPIO_SYNC			(4)	/* Cradle SYNC Button */
+#define TOSA_GPIO_USB_IN		(5)
+#define TOSA_GPIO_JACKET_DETECT		(7)
+#define TOSA_GPIO_nSD_DETECT		(9)
+#define TOSA_GPIO_nSD_INT		(10)
+#define TOSA_GPIO_TC6393_CLK		(11)
+#define TOSA_GPIO_BAT1_CRG		(12)
+#define TOSA_GPIO_CF_CD			(13)
+#define TOSA_GPIO_BAT0_CRG		(14)
+#define TOSA_GPIO_TC6393_INT		(15)
+#define TOSA_GPIO_BAT0_LOW		(17)
+#define TOSA_GPIO_TC6393_RDY		(18)
+#define TOSA_GPIO_ON_RESET		(19)
+#define TOSA_GPIO_EAR_IN		(20)
+#define TOSA_GPIO_CF_IRQ		(21)	/* CF slot0 Ready */
+#define TOSA_GPIO_ON_KEY		(22)
+#define TOSA_GPIO_VGA_LINE		(27)
+#define TOSA_GPIO_TP_INT		(32)	/* Touch Panel pen down interrupt */
+#define TOSA_GPIO_JC_CF_IRQ		(36)	/* CF slot1 Ready */
+#define TOSA_GPIO_BAT_LOCKED		(38)	/* Battery locked */
+#define TOSA_GPIO_TG_SPI_SCLK		(81)
+#define TOSA_GPIO_TG_SPI_CS		(82)
+#define TOSA_GPIO_TG_SPI_MOSI		(83)
+#define TOSA_GPIO_BAT1_LOW		(84)
+
+#define TOSA_GPIO_HP_IN			GPIO_EAR_IN
+
+#define TOSA_GPIO_MAIN_BAT_LOW		GPIO_BAT0_LOW
+
+#define TOSA_KEY_STROBE_NUM		(11)
+#define TOSA_KEY_SENSE_NUM		(7)
+
+#define TOSA_GPIO_HIGH_STROBE_BIT	(0xfc000000)
+#define TOSA_GPIO_LOW_STROBE_BIT	(0x0000001f)
+#define TOSA_GPIO_ALL_SENSE_BIT		(0x00000fe0)
+#define TOSA_GPIO_ALL_SENSE_RSHIFT	(5)
+#define TOSA_GPIO_STROBE_BIT(a)		GPIO_bit(58+(a))
+#define TOSA_GPIO_SENSE_BIT(a)		GPIO_bit(69+(a))
+#define TOSA_GAFR_HIGH_STROBE_BIT	(0xfff00000)
+#define TOSA_GAFR_LOW_STROBE_BIT	(0x000003ff)
+#define TOSA_GAFR_ALL_SENSE_BIT		(0x00fffc00)
+#define TOSA_GPIO_KEY_SENSE(a) 		(69+(a))
+#define TOSA_GPIO_KEY_STROBE(a)		(58+(a))
+
+/*
+ * Interrupts
+ */
+#define TOSA_IRQ_GPIO_WAKEUP        	IRQ_GPIO(TOSA_GPIO_WAKEUP)
+#define TOSA_IRQ_GPIO_AC_IN         	IRQ_GPIO(TOSA_GPIO_AC_IN)
+#define TOSA_IRQ_GPIO_RECORD_BTN    	IRQ_GPIO(TOSA_GPIO_RECORD_BTN)
+#define TOSA_IRQ_GPIO_SYNC          	IRQ_GPIO(TOSA_GPIO_SYNC)
+#define TOSA_IRQ_GPIO_USB_IN        	IRQ_GPIO(TOSA_GPIO_USB_IN)
+#define TOSA_IRQ_GPIO_JACKET_DETECT 	IRQ_GPIO(TOSA_GPIO_JACKET_DETECT)
+#define TOSA_IRQ_GPIO_nSD_INT       	IRQ_GPIO(TOSA_GPIO_nSD_INT)
+#define TOSA_IRQ_GPIO_nSD_DETECT    	IRQ_GPIO(TOSA_GPIO_nSD_DETECT)
+#define TOSA_IRQ_GPIO_BAT1_CRG      	IRQ_GPIO(TOSA_GPIO_BAT1_CRG)
+#define TOSA_IRQ_GPIO_CF_CD         	IRQ_GPIO(TOSA_GPIO_CF_CD)
+#define TOSA_IRQ_GPIO_BAT0_CRG      	IRQ_GPIO(TOSA_GPIO_BAT0_CRG)
+#define TOSA_IRQ_GPIO_TC6393_INT    	IRQ_GPIO(TOSA_GPIO_TC6393_INT)
+#define TOSA_IRQ_GPIO_BAT0_LOW      	IRQ_GPIO(TOSA_GPIO_BAT0_LOW)
+#define TOSA_IRQ_GPIO_EAR_IN        	IRQ_GPIO(TOSA_GPIO_EAR_IN)
+#define TOSA_IRQ_GPIO_CF_IRQ        	IRQ_GPIO(TOSA_GPIO_CF_IRQ)
+#define TOSA_IRQ_GPIO_ON_KEY        	IRQ_GPIO(TOSA_GPIO_ON_KEY)
+#define TOSA_IRQ_GPIO_VGA_LINE      	IRQ_GPIO(TOSA_GPIO_VGA_LINE)
+#define TOSA_IRQ_GPIO_TP_INT        	IRQ_GPIO(TOSA_GPIO_TP_INT)
+#define TOSA_IRQ_GPIO_JC_CF_IRQ     	IRQ_GPIO(TOSA_GPIO_JC_CF_IRQ)
+#define TOSA_IRQ_GPIO_BAT_LOCKED    	IRQ_GPIO(TOSA_GPIO_BAT_LOCKED)
+#define TOSA_IRQ_GPIO_BAT1_LOW      	IRQ_GPIO(TOSA_GPIO_BAT1_LOW)
+#define TOSA_IRQ_GPIO_KEY_SENSE(a)  	IRQ_GPIO(69+(a))
+
+#define TOSA_IRQ_GPIO_MAIN_BAT_LOW 	IRQ_GPIO(TOSA_GPIO_MAIN_BAT_LOW)
+
+extern struct platform_device tosascoop_jc_device;
+extern struct platform_device tosascoop_device;
+#endif /* _ASM_ARCH_TOSA_H_ */
Index: build_tree/linux/include/asm/arch-pxa/trizeps4.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/trizeps4.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/trizeps4.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,106 @@
+/************************************************************************
+ * Include file for TRIZEPS4 SoM and ConXS eval-board
+ * Copyright (c) Jrgen Schindele
+ * 2006
+ ************************************************************************/
+
+/*
+ * Includes/Defines
+ */
+#ifndef _TRIPEPS4_H_
+#define _TRIPEPS4_H_
+
+/* physical memory regions */
+#define TRIZEPS4_FLASH_PHYS	(PXA_CS0_PHYS)  /* Flash region */
+#define TRIZEPS4_DISK_PHYS	(PXA_CS1_PHYS)  /* Disk On Chip region */
+#define TRIZEPS4_ETH_PHYS	(PXA_CS2_PHYS)  /* Ethernet DM9000 region */
+#define TRIZEPS4_PIC_PHYS	(PXA_CS3_PHYS)	/* Logic chip on ConXS-Board */
+#define TRIZEPS4_SDRAM_BASE	0xa0000000      /* SDRAM region */
+
+#define TRIZEPS4_CFSR_PHYS	(PXA_CS3_PHYS)			/* Logic chip on ConXS-Board CSFR register */
+#define TRIZEPS4_BOCR_PHYS	(PXA_CS3_PHYS+0x02000000)	/* Logic chip on ConXS-Board BOCR register */
+#define TRIZEPS4_IRCR_PHYS	(PXA_CS3_PHYS+0x02400000)	/* Logic chip on ConXS-Board IRCR register*/
+#define TRIZEPS4_UPSR_PHYS	(PXA_CS3_PHYS+0x02800000)	/* Logic chip on ConXS-Board UPSR register*/
+#define TRIZEPS4_DICR_PHYS	(PXA_CS3_PHYS+0x03800000)	/* Logic chip on ConXS-Board DICR register*/
+
+/* virtual memory regions */
+#define TRIZEPS4_DISK_VIRT	0xF0000000	/* Disk On Chip region */
+
+#define TRIZEPS4_PIC_VIRT	0xF0100000	/* not used */
+#define TRIZEPS4_CFSR_VIRT	0xF0100000
+#define TRIZEPS4_BOCR_VIRT	0xF0200000
+#define TRIZEPS4_DICR_VIRT	0xF0300000
+#define TRIZEPS4_IRCR_VIRT	0xF0400000
+#define TRIZEPS4_UPSR_VIRT	0xF0500000
+
+/* size of flash */
+#define TRIZEPS4_FLASH_SIZE	0x02000000	/* Flash size 32 MB */
+
+/* Ethernet Controller Davicom DM9000 */
+#define GPIO_DM9000		101
+#define TRIZEPS4_ETH_IRQ	IRQ_GPIO(GPIO_DM9000)
+
+/* UCB1400 audio / TS-controller */
+#define GPIO_UCB1400		1
+#define TRIZEPS4_UCB1400_IRQ	IRQ_GPIO(GPIO_UCB1400)
+
+/* PCMCIA socket Compact Flash */
+#define GPIO_PCD		11		/* PCMCIA Card Detect */
+#define TRIZEPS4_CD_IRQ		IRQ_GPIO(GPIO_PCD)
+#define GPIO_PRDY		13		/* READY / nINT */
+#define TRIZEPS4_READY_NINT	IRQ_GPIO(GPIO_PRDY)
+
+/* MMC socket */
+#define GPIO_MMC_DET		12
+#define TRIZEPS4_MMC_IRQ	IRQ_GPIO(GPIO_MMC_DET)
+
+/* LEDS using tx2 / rx2 */
+#define GPIO_SYS_BUSY_LED	46
+#define GPIO_HEARTBEAT_LED	47
+
+/* Off-module PIC on ConXS board */
+#define GPIO_PIC		0
+#define TRIZEPS4_PIC_IRQ	IRQ_GPIO(GPIO_PIC)
+
+#define CFSR_P2V(x)		((x) - TRIZEPS4_CFSR_PHYS + TRIZEPS4_CFSR_VIRT)
+#define CFSR_V2P(x)		((x) - TRIZEPS4_CFSR_VIRT + TRIZEPS4_CFSR_PHYS)
+
+#define BCR_P2V(x)		((x) - TRIZEPS4_BOCR_PHYS + TRIZEPS4_BOCR_VIRT)
+#define BCR_V2P(x)		((x) - TRIZEPS4_BOCR_VIRT + TRIZEPS4_BOCR_PHYS)
+
+#define DCR_P2V(x)		((x) - TRIZEPS4_DICR_PHYS + TRIZEPS4_DICR_VIRT)
+#define DCR_V2P(x)		((x) - TRIZEPS4_DICR_VIRT + TRIZEPS4_DICR_PHYS)
+
+#ifndef __ASSEMBLY__
+#define ConXS_CFSR		(*((volatile unsigned short *)CFSR_P2V(0x0C000000)))
+#define ConXS_BCR		(*((volatile unsigned short *)BCR_P2V(0x0E000000)))
+#define ConXS_DCR		(*((volatile unsigned short *)DCR_P2V(0x0F800000)))
+#else
+#define ConXS_CFSR		CFSR_P2V(0x0C000000)
+#define ConXS_BCR		BCR_P2V(0x0E000000)
+#define ConXS_DCR		DCR_P2V(0x0F800000)
+#endif
+
+#define ConXS_CFSR_BVD_MASK	0x0003
+#define ConXS_CFSR_BVD1		(1 << 0)
+#define ConXS_CFSR_BVD2		(1 << 1)
+#define ConXS_CFSR_VS_MASK	0x000C
+#define ConXS_CFSR_VS1		(1 << 2)
+#define ConXS_CFSR_VS2		(1 << 3)
+#define ConXS_CFSR_VS_5V	(0x3 << 2)
+#define ConXS_CFSR_VS_3V3	0x0
+
+#define ConXS_BCR_S0_POW_EN0	(1 << 0)
+#define ConXS_BCR_S0_POW_EN1	(1 << 1)
+#define ConXS_BCR_L_DISP	(1 << 4)
+#define ConXS_BCR_CF_BUF_EN	(1 << 5)
+#define ConXS_BCR_CF_RESET	(1 << 7)
+#define ConXS_BCR_S0_VCC_3V3	0x1
+#define ConXS_BCR_S0_VCC_5V0	0x2
+#define ConXS_BCR_S0_VPP_12V	0x4
+#define ConXS_BCR_S0_VPP_3V3	0x8
+
+#define ConXS_IRCR_MODE		(1 << 0)
+#define ConXS_IRCR_SD		(1 << 1)
+
+#endif /* _TRIPEPS4_H_ */
Index: build_tree/linux/include/asm/arch-pxa/udc.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/udc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/udc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/*
+ * linux/include/asm-arm/arch-pxa/udc.h
+ *
+ * This supports machine-specific differences in how the PXA2xx
+ * USB Device Controller (UDC) is wired.
+ *
+ */
+#include <asm/mach/udc_pxa2xx.h>
+
+extern void pxa_set_udc_info(struct pxa2xx_udc_mach_info *info);
+
+static inline int udc_gpio_to_irq(unsigned gpio)
+{
+	return IRQ_GPIO(gpio & GPIO_MD_MASK_NR);
+}
+
+static inline void udc_gpio_init_vbus(unsigned gpio)
+{
+	pxa_gpio_mode((gpio & GPIO_MD_MASK_NR) | GPIO_IN);
+}
+
+static inline void udc_gpio_init_pullup(unsigned gpio)
+{
+	pxa_gpio_mode((gpio & GPIO_MD_MASK_NR) | GPIO_OUT | GPIO_DFLT_LOW);
+}
+
+static inline int udc_gpio_get(unsigned gpio)
+{
+	return (GPLR(gpio) & GPIO_bit(gpio)) != 0;
+}
+
+static inline void udc_gpio_set(unsigned gpio, int is_on)
+{
+	int mask = GPIO_bit(gpio);
+
+	if (is_on)
+		GPSR(gpio) = mask;
+	else
+		GPCR(gpio) = mask;
+}
+
Index: build_tree/linux/include/asm/arch-pxa/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ * linux/include/asm-arm/arch-pxa/uncompress.h
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define FFUART		((volatile unsigned long *)0x40100000)
+#define BTUART		((volatile unsigned long *)0x40200000)
+#define STUART		((volatile unsigned long *)0x40700000)
+#define HWUART		((volatile unsigned long *)0x41600000)
+
+#define UART		FFUART
+
+
+static inline void putc(char c)
+{
+	while (!(UART[5] & 0x20))
+		barrier();
+	UART[0] = c;
+}
+
+/*
+ * This does not append a newline
+ */
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-pxa/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-pxa/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-pxa/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,11 @@
+/*
+ * linux/include/asm-arm/arch-pxa/vmalloc.h
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define VMALLOC_END       (0xe8000000)
Index: build_tree/linux/include/asm/arch-realview/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-realview/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/* linux/include/asm-arm/arch-realview/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx,      #0x10000000
+		movne	\rx,      #0xf1000000	@ virtual base
+		orr	\rx, \rx, #0x00009000
+		.endm
+
+#include <asm/hardware/debug-pl01x.S>
Index: build_tree/linux/include/asm/arch-realview/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-realview/dma.h
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
Index: build_tree/linux/include/asm/arch-realview/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-realview/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,80 @@
+/*
+ * include/asm-arm/arch-realview/entry-macro.S
+ *
+ * Low-level IRQ helper macros for RealView platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/hardware/gic.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		/*
+		 * The interrupt numbering scheme is defined in the
+		 * interrupt controller spec.  To wit:
+		 *
+		 * Interrupts 0-15 are IPI
+		 * 16-28 are reserved
+		 * 29-31 are local.  We allow 30 to be used for the watchdog.
+		 * 32-1020 are global
+		 * 1021-1022 are reserved
+		 * 1023 is "spurious" (no interrupt)
+		 *
+		 * For now, we ignore all local interrupts so only return an interrupt if it's
+		 * between 30 and 1020.  The test_for_ipi routine below will pick up on IPIs.
+		 *
+		 * A simple read from the controller will tell us the number of the highest
+                 * priority enabled interrupt.  We then just need to check whether it is in the
+		 * valid range for an IRQ (30-1020 inclusive).
+		 */
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		ldr     \base, =IO_ADDRESS(REALVIEW_GIC_CPU_BASE)
+		ldr     \irqstat, [\base, #GIC_CPU_INTACK] /* bits 12-10 = src CPU, 9-0 = int # */
+
+		ldr	\tmp, =1021
+
+		bic     \irqnr, \irqstat, #0x1c00
+
+		cmp     \irqnr, #29
+		cmpcc	\irqnr, \irqnr
+		cmpne	\irqnr, \tmp
+		cmpcs	\irqnr, \irqnr
+
+		.endm
+
+		/* We assume that irqstat (the raw value of the IRQ acknowledge
+		 * register) is preserved from the macro above.
+		 * If there is an IPI, we immediately signal end of interrupt on the
+		 * controller, since this requires the original irqstat value which
+		 * we won't easily be able to recreate later.
+		 */
+
+		.macro test_for_ipi, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		cmp	\irqnr, #16
+		strcc	\irqstat, [\base, #GIC_CPU_EOI]
+		cmpcs	\irqnr, \irqnr
+		.endm
+
+		/* As above, this assumes that irqstat and base are preserved.. */
+
+		.macro test_for_ltirq, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		mov 	\tmp, #0
+		cmp	\irqnr, #29
+		moveq	\tmp, #1
+		streq	\irqstat, [\base, #GIC_CPU_EOI]
+		cmp	\tmp, #0
+		.endm
Index: build_tree/linux/include/asm/arch-realview/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-arm/arch-realview/hardware.h
+ *
+ *  This file contains the hardware definitions of the RealView boards.
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <asm/arch/platform.h>
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x)		((((x) & 0x0effffff) | (((x) >> 4) & 0x0f000000)) + 0xf0000000)
+#define __io_address(n)		__io(IO_ADDRESS(n))
+
+#endif
Index: build_tree/linux/include/asm/arch-realview/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ *  linux/include/asm-arm/arch-realview/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+
+#define __io(a)			__io(a)
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-realview/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,121 @@
+/*
+ *  linux/include/asm-arm/arch-realview/irqs.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/arch/platform.h>
+
+#define IRQ_LOCALTIMER			29
+#define IRQ_LOCALWDOG			30
+
+/* 
+ *  IRQ interrupts definitions are the same the INT definitions
+ *  held within platform.h
+ */
+#define IRQ_GIC_START		32
+#define IRQ_WDOGINT		(IRQ_GIC_START + INT_WDOGINT)
+#define IRQ_SOFTINT		(IRQ_GIC_START + INT_SOFTINT)
+#define IRQ_COMMRx		(IRQ_GIC_START + INT_COMMRx)
+#define IRQ_COMMTx		(IRQ_GIC_START + INT_COMMTx)
+#define IRQ_TIMERINT0_1		(IRQ_GIC_START + INT_TIMERINT0_1)
+#define IRQ_TIMERINT2_3		(IRQ_GIC_START + INT_TIMERINT2_3)
+#define IRQ_GPIOINT0		(IRQ_GIC_START + INT_GPIOINT0)
+#define IRQ_GPIOINT1		(IRQ_GIC_START + INT_GPIOINT1)
+#define IRQ_GPIOINT2		(IRQ_GIC_START + INT_GPIOINT2)
+#define IRQ_GPIOINT3		(IRQ_GIC_START + INT_GPIOINT3)
+#define IRQ_RTCINT		(IRQ_GIC_START + INT_RTCINT)
+#define IRQ_SSPINT		(IRQ_GIC_START + INT_SSPINT)
+#define IRQ_UARTINT0		(IRQ_GIC_START + INT_UARTINT0)
+#define IRQ_UARTINT1		(IRQ_GIC_START + INT_UARTINT1)
+#define IRQ_UARTINT2		(IRQ_GIC_START + INT_UARTINT2)
+#define IRQ_UART3		(IRQ_GIC_START + INT_UARTINT3)
+#define IRQ_SCIINT		(IRQ_GIC_START + INT_SCIINT)
+#define IRQ_CLCDINT		(IRQ_GIC_START + INT_CLCDINT)
+#define IRQ_DMAINT		(IRQ_GIC_START + INT_DMAINT)
+#define IRQ_PWRFAILINT 		(IRQ_GIC_START + INT_PWRFAILINT)
+#define IRQ_MBXINT		(IRQ_GIC_START + INT_MBXINT)
+#define IRQ_GNDINT		(IRQ_GIC_START + INT_GNDINT)
+#define IRQ_MMCI0B 		(IRQ_GIC_START + INT_MMCI0B)
+#define IRQ_MMCI1B 		(IRQ_GIC_START + INT_MMCI1B)
+#define IRQ_KMI0		(IRQ_GIC_START + INT_KMI0)
+#define IRQ_KMI1		(IRQ_GIC_START + INT_KMI1)
+#define IRQ_SCI3		(IRQ_GIC_START + INT_SCI3)
+#define IRQ_CLCD		(IRQ_GIC_START + INT_CLCD)
+#define IRQ_TOUCH		(IRQ_GIC_START + INT_TOUCH)
+#define IRQ_KEYPAD 		(IRQ_GIC_START + INT_KEYPAD)
+#define IRQ_DoC			(IRQ_GIC_START + INT_DoC)
+#define IRQ_MMCI0A 		(IRQ_GIC_START + INT_MMCI0A)
+#define IRQ_MMCI1A 		(IRQ_GIC_START + INT_MMCI1A)
+#define IRQ_AACI		(IRQ_GIC_START + INT_AACI)
+#define IRQ_ETH			(IRQ_GIC_START + INT_ETH)
+#define IRQ_USB			(IRQ_GIC_START + INT_USB)
+#define IRQ_PMU_CPU0		(IRQ_GIC_START + INT_PMU_CPU0)
+#define IRQ_PMU_CPU1		(IRQ_GIC_START + INT_PMU_CPU1)
+#define IRQ_PMU_CPU2		(IRQ_GIC_START + INT_PMU_CPU2)
+#define IRQ_PMU_CPU3		(IRQ_GIC_START + INT_PMU_CPU3)
+#define IRQ_PMU_SCU0		(IRQ_GIC_START + INT_PMU_SCU0)
+#define IRQ_PMU_SCU1		(IRQ_GIC_START + INT_PMU_SCU1)
+#define IRQ_PMU_SCU2		(IRQ_GIC_START + INT_PMU_SCU2)
+#define IRQ_PMU_SCU3		(IRQ_GIC_START + INT_PMU_SCU3)
+#define IRQ_PMU_SCU4		(IRQ_GIC_START + INT_PMU_SCU4)
+#define IRQ_PMU_SCU5		(IRQ_GIC_START + INT_PMU_SCU5)
+#define IRQ_PMU_SCU6		(IRQ_GIC_START + INT_PMU_SCU6)
+#define IRQ_PMU_SCU7		(IRQ_GIC_START + INT_PMU_SCU7)
+
+#define IRQ_EB_IRQ1		(IRQ_GIC_START + INT_EB_IRQ1)
+#define IRQ_EB_IRQ2		(IRQ_GIC_START + INT_EB_IRQ2)
+
+#define IRQMASK_WDOGINT		INTMASK_WDOGINT
+#define IRQMASK_SOFTINT		INTMASK_SOFTINT
+#define IRQMASK_COMMRx 		INTMASK_COMMRx
+#define IRQMASK_COMMTx 		INTMASK_COMMTx
+#define IRQMASK_TIMERINT0_1	INTMASK_TIMERINT0_1
+#define IRQMASK_TIMERINT2_3	INTMASK_TIMERINT2_3
+#define IRQMASK_GPIOINT0	INTMASK_GPIOINT0
+#define IRQMASK_GPIOINT1	INTMASK_GPIOINT1
+#define IRQMASK_GPIOINT2	INTMASK_GPIOINT2
+#define IRQMASK_GPIOINT3	INTMASK_GPIOINT3
+#define IRQMASK_RTCINT 		INTMASK_RTCINT
+#define IRQMASK_SSPINT 		INTMASK_SSPINT
+#define IRQMASK_UARTINT0	INTMASK_UARTINT0
+#define IRQMASK_UARTINT1	INTMASK_UARTINT1
+#define IRQMASK_UARTINT2	INTMASK_UARTINT2
+#define IRQMASK_SCIINT 		INTMASK_SCIINT
+#define IRQMASK_CLCDINT		INTMASK_CLCDINT
+#define IRQMASK_DMAINT 		INTMASK_DMAINT
+#define IRQMASK_PWRFAILINT	INTMASK_PWRFAILINT
+#define IRQMASK_MBXINT 		INTMASK_MBXINT
+#define IRQMASK_GNDINT 		INTMASK_GNDINT
+#define IRQMASK_MMCI0B		INTMASK_MMCI0B
+#define IRQMASK_MMCI1B		INTMASK_MMCI1B
+#define IRQMASK_KMI0		INTMASK_KMI0
+#define IRQMASK_KMI1		INTMASK_KMI1
+#define IRQMASK_SCI3		INTMASK_SCI3
+#define IRQMASK_UART3		INTMASK_UART3
+#define IRQMASK_CLCD		INTMASK_CLCD
+#define IRQMASK_TOUCH		INTMASK_TOUCH
+#define IRQMASK_KEYPAD		INTMASK_KEYPAD
+#define IRQMASK_DoC		INTMASK_DoC
+#define IRQMASK_MMCI0A		INTMASK_MMCI0A
+#define IRQMASK_MMCI1A		INTMASK_MMCI1A
+#define IRQMASK_AACI		INTMASK_AACI
+#define IRQMASK_ETH		INTMASK_ETH
+#define IRQMASK_USB		INTMASK_USB
+
+#define NR_IRQS			(IRQ_GIC_START + 96)
Index: build_tree/linux/include/asm/arch-realview/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ *  linux/include/asm-arm/arch-realview/memory.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET		UL(0x00000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
+#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+
+#endif
Index: build_tree/linux/include/asm/arch-realview/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/platform.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,468 @@
+/*
+ * linux/include/asm-arm/arch-realview/platform.h
+ *
+ * Copyright (c) ARM Limited 2003.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __address_h
+#define __address_h                     1
+
+/*
+ * Memory definitions
+ */
+#define REALVIEW_BOOT_ROM_LO          0x30000000		/* DoC Base (64Mb)...*/
+#define REALVIEW_BOOT_ROM_HI          0x30000000
+#define REALVIEW_BOOT_ROM_BASE        REALVIEW_BOOT_ROM_HI	 /*  Normal position */
+#define REALVIEW_BOOT_ROM_SIZE        SZ_64M
+
+#define REALVIEW_SSRAM_BASE           /* REALVIEW_SSMC_BASE ? */
+#define REALVIEW_SSRAM_SIZE           SZ_2M
+
+#define REALVIEW_FLASH_BASE           0x40000000
+#define REALVIEW_FLASH_SIZE           SZ_64M
+
+/* 
+ *  SDRAM
+ */
+#define REALVIEW_SDRAM_BASE           0x00000000
+
+/* 
+ *  Logic expansion modules
+ * 
+ */
+
+
+/* ------------------------------------------------------------------------
+ *  RealView Registers
+ * ------------------------------------------------------------------------
+ * 
+ */
+#define REALVIEW_SYS_ID_OFFSET               0x00
+#define REALVIEW_SYS_SW_OFFSET               0x04
+#define REALVIEW_SYS_LED_OFFSET              0x08
+#define REALVIEW_SYS_OSC0_OFFSET             0x0C
+
+#define REALVIEW_SYS_OSC1_OFFSET             0x10
+#define REALVIEW_SYS_OSC2_OFFSET             0x14
+#define REALVIEW_SYS_OSC3_OFFSET             0x18
+#define REALVIEW_SYS_OSC4_OFFSET             0x1C	/* OSC1 for RealView/AB */
+
+#define REALVIEW_SYS_LOCK_OFFSET             0x20
+#define REALVIEW_SYS_100HZ_OFFSET            0x24
+#define REALVIEW_SYS_CFGDATA1_OFFSET         0x28
+#define REALVIEW_SYS_CFGDATA2_OFFSET         0x2C
+#define REALVIEW_SYS_FLAGS_OFFSET            0x30
+#define REALVIEW_SYS_FLAGSSET_OFFSET         0x30
+#define REALVIEW_SYS_FLAGSCLR_OFFSET         0x34
+#define REALVIEW_SYS_NVFLAGS_OFFSET          0x38
+#define REALVIEW_SYS_NVFLAGSSET_OFFSET       0x38
+#define REALVIEW_SYS_NVFLAGSCLR_OFFSET       0x3C
+#define REALVIEW_SYS_RESETCTL_OFFSET         0x40
+#define REALVIEW_SYS_PCICTL_OFFSET           0x44
+#define REALVIEW_SYS_MCI_OFFSET              0x48
+#define REALVIEW_SYS_FLASH_OFFSET            0x4C
+#define REALVIEW_SYS_CLCD_OFFSET             0x50
+#define REALVIEW_SYS_CLCDSER_OFFSET          0x54
+#define REALVIEW_SYS_BOOTCS_OFFSET           0x58
+#define REALVIEW_SYS_24MHz_OFFSET            0x5C
+#define REALVIEW_SYS_MISC_OFFSET             0x60
+#define REALVIEW_SYS_IOSEL_OFFSET            0x70
+#define REALVIEW_SYS_TEST_OSC0_OFFSET        0x80
+#define REALVIEW_SYS_TEST_OSC1_OFFSET        0x84
+#define REALVIEW_SYS_TEST_OSC2_OFFSET        0x88
+#define REALVIEW_SYS_TEST_OSC3_OFFSET        0x8C
+#define REALVIEW_SYS_TEST_OSC4_OFFSET        0x90
+
+#define REALVIEW_SYS_BASE                    0x10000000
+#define REALVIEW_SYS_ID                      (REALVIEW_SYS_BASE + REALVIEW_SYS_ID_OFFSET)
+#define REALVIEW_SYS_SW                      (REALVIEW_SYS_BASE + REALVIEW_SYS_SW_OFFSET)
+#define REALVIEW_SYS_LED                     (REALVIEW_SYS_BASE + REALVIEW_SYS_LED_OFFSET)
+#define REALVIEW_SYS_OSC0                    (REALVIEW_SYS_BASE + REALVIEW_SYS_OSC0_OFFSET)
+#define REALVIEW_SYS_OSC1                    (REALVIEW_SYS_BASE + REALVIEW_SYS_OSC1_OFFSET)
+
+#define REALVIEW_SYS_LOCK                    (REALVIEW_SYS_BASE + REALVIEW_SYS_LOCK_OFFSET)
+#define REALVIEW_SYS_100HZ                   (REALVIEW_SYS_BASE + REALVIEW_SYS_100HZ_OFFSET)
+#define REALVIEW_SYS_CFGDATA1                (REALVIEW_SYS_BASE + REALVIEW_SYS_CFGDATA1_OFFSET)
+#define REALVIEW_SYS_CFGDATA2                (REALVIEW_SYS_BASE + REALVIEW_SYS_CFGDATA2_OFFSET)
+#define REALVIEW_SYS_FLAGS                   (REALVIEW_SYS_BASE + REALVIEW_SYS_FLAGS_OFFSET)
+#define REALVIEW_SYS_FLAGSSET                (REALVIEW_SYS_BASE + REALVIEW_SYS_FLAGSSET_OFFSET)
+#define REALVIEW_SYS_FLAGSCLR                (REALVIEW_SYS_BASE + REALVIEW_SYS_FLAGSCLR_OFFSET)
+#define REALVIEW_SYS_NVFLAGS                 (REALVIEW_SYS_BASE + REALVIEW_SYS_NVFLAGS_OFFSET)
+#define REALVIEW_SYS_NVFLAGSSET              (REALVIEW_SYS_BASE + REALVIEW_SYS_NVFLAGSSET_OFFSET)
+#define REALVIEW_SYS_NVFLAGSCLR              (REALVIEW_SYS_BASE + REALVIEW_SYS_NVFLAGSCLR_OFFSET)
+#define REALVIEW_SYS_RESETCTL                (REALVIEW_SYS_BASE + REALVIEW_SYS_RESETCTL_OFFSET)
+#define REALVIEW_SYS_PCICTL                  (REALVIEW_SYS_BASE + REALVIEW_SYS_PCICTL_OFFSET)
+#define REALVIEW_SYS_MCI                     (REALVIEW_SYS_BASE + REALVIEW_SYS_MCI_OFFSET)
+#define REALVIEW_SYS_FLASH                   (REALVIEW_SYS_BASE + REALVIEW_SYS_FLASH_OFFSET)
+#define REALVIEW_SYS_CLCD                    (REALVIEW_SYS_BASE + REALVIEW_SYS_CLCD_OFFSET)
+#define REALVIEW_SYS_CLCDSER                 (REALVIEW_SYS_BASE + REALVIEW_SYS_CLCDSER_OFFSET)
+#define REALVIEW_SYS_BOOTCS                  (REALVIEW_SYS_BASE + REALVIEW_SYS_BOOTCS_OFFSET)
+#define REALVIEW_SYS_24MHz                   (REALVIEW_SYS_BASE + REALVIEW_SYS_24MHz_OFFSET)
+#define REALVIEW_SYS_MISC                    (REALVIEW_SYS_BASE + REALVIEW_SYS_MISC_OFFSET)
+#define REALVIEW_SYS_IOSEL                   (REALVIEW_SYS_BASE + REALVIEW_SYS_IOSEL_OFFSET)
+#define REALVIEW_SYS_TEST_OSC0               (REALVIEW_SYS_BASE + REALVIEW_SYS_TEST_OSC0_OFFSET)
+#define REALVIEW_SYS_TEST_OSC1               (REALVIEW_SYS_BASE + REALVIEW_SYS_TEST_OSC1_OFFSET)
+#define REALVIEW_SYS_TEST_OSC2               (REALVIEW_SYS_BASE + REALVIEW_SYS_TEST_OSC2_OFFSET)
+#define REALVIEW_SYS_TEST_OSC3               (REALVIEW_SYS_BASE + REALVIEW_SYS_TEST_OSC3_OFFSET)
+#define REALVIEW_SYS_TEST_OSC4               (REALVIEW_SYS_BASE + REALVIEW_SYS_TEST_OSC4_OFFSET)
+
+/* 
+ * Values for REALVIEW_SYS_RESET_CTRL
+ */
+#define REALVIEW_SYS_CTRL_RESET_CONFIGCLR    0x01
+#define REALVIEW_SYS_CTRL_RESET_CONFIGINIT   0x02
+#define REALVIEW_SYS_CTRL_RESET_DLLRESET     0x03
+#define REALVIEW_SYS_CTRL_RESET_PLLRESET     0x04
+#define REALVIEW_SYS_CTRL_RESET_POR          0x05
+#define REALVIEW_SYS_CTRL_RESET_DoC          0x06
+
+#define REALVIEW_SYS_CTRL_LED         (1 << 0)
+
+
+/* ------------------------------------------------------------------------
+ *  RealView control registers
+ * ------------------------------------------------------------------------
+ */
+
+/* 
+ * REALVIEW_IDFIELD
+ *
+ * 31:24 = manufacturer (0x41 = ARM)
+ * 23:16 = architecture (0x08 = AHB system bus, ASB processor bus)
+ * 15:12 = FPGA (0x3 = XVC600 or XVC600E)
+ * 11:4  = build value
+ * 3:0   = revision number (0x1 = rev B (AHB))
+ */
+
+/*
+ * REALVIEW_SYS_LOCK
+ *     control access to SYS_OSCx, SYS_CFGDATAx, SYS_RESETCTL, 
+ *     SYS_CLD, SYS_BOOTCS
+ */
+#define REALVIEW_SYS_LOCK_LOCKED    (1 << 16)
+#define REALVIEW_SYS_LOCKVAL_MASK	0xFFFF		/* write 0xA05F to enable write access */
+
+/*
+ * REALVIEW_SYS_FLASH
+ */
+#define REALVIEW_FLASHPROG_FLVPPEN	(1 << 0)	/* Enable writing to flash */
+
+/*
+ * REALVIEW_INTREG
+ *     - used to acknowledge and control MMCI and UART interrupts 
+ */
+#define REALVIEW_INTREG_WPROT        0x00    /* MMC protection status (no interrupt generated) */
+#define REALVIEW_INTREG_RI0          0x01    /* Ring indicator UART0 is asserted,              */
+#define REALVIEW_INTREG_CARDIN       0x08    /* MMCI card in detect                            */
+                                                /* write 1 to acknowledge and clear               */
+#define REALVIEW_INTREG_RI1          0x02    /* Ring indicator UART1 is asserted,              */
+#define REALVIEW_INTREG_CARDINSERT   0x03    /* Signal insertion of MMC card                   */
+
+/*
+ * REALVIEW peripheral addresses
+ */
+#define REALVIEW_SCTL_BASE            0x10001000	/* System controller */
+#define REALVIEW_I2C_BASE             0x10002000	/* I2C control */
+	/* Reserved 0x10003000 */
+#define REALVIEW_AACI_BASE            0x10004000	/* Audio */
+#define REALVIEW_MMCI0_BASE           0x10005000	/* MMC interface */
+#define REALVIEW_KMI0_BASE            0x10006000	/* KMI interface */
+#define REALVIEW_KMI1_BASE            0x10007000	/* KMI 2nd interface */
+#define REALVIEW_CHAR_LCD_BASE        0x10008000	/* Character LCD */
+#define REALVIEW_UART0_BASE           0x10009000	/* UART 0 */
+#define REALVIEW_UART1_BASE           0x1000A000	/* UART 1 */
+#define REALVIEW_UART2_BASE           0x1000B000	/* UART 2 */
+#define REALVIEW_UART3_BASE           0x1000C000	/* UART 3 */
+#define REALVIEW_SSP_BASE             0x1000D000	/* Synchronous Serial Port */
+#define REALVIEW_SCI_BASE             0x1000E000	/* Smart card controller */
+	/* Reserved 0x1000F000 */
+#define REALVIEW_WATCHDOG_BASE        0x10010000	/* watchdog interface */
+#define REALVIEW_TIMER0_1_BASE        0x10011000	/* Timer 0 and 1 */
+#define REALVIEW_TIMER2_3_BASE        0x10012000	/* Timer 2 and 3 */
+#define REALVIEW_GPIO0_BASE           0x10013000	/* GPIO port 0 */
+#define REALVIEW_GPIO1_BASE           0x10014000	/* GPIO port 1 */
+#define REALVIEW_GPIO2_BASE           0x10015000	/* GPIO port 2 */
+	/* Reserved 0x10016000 */
+#define REALVIEW_RTC_BASE             0x10017000	/* Real Time Clock */
+#define REALVIEW_DMC_BASE             0x10018000	/* DMC configuration */
+#define REALVIEW_PCI_CORE_BASE        0x10019000	/* PCI configuration */
+	/* Reserved 0x1001A000 - 0x1001FFFF */
+#define REALVIEW_CLCD_BASE            0x10020000	/* CLCD */
+#define REALVIEW_DMAC_BASE            0x10030000	/* DMA controller */
+#ifndef CONFIG_REALVIEW_MPCORE
+#define REALVIEW_GIC_CPU_BASE         0x10040000	/* Generic interrupt controller CPU interface */
+#define REALVIEW_GIC_DIST_BASE        0x10041000	/* Generic interrupt controller distributor */
+#else
+#ifdef CONFIG_REALVIEW_MPCORE_REVB
+#define REALVIEW_MPCORE_SCU_BASE	0x10100000	/*  SCU registers */
+#define REALVIEW_GIC_CPU_BASE		0x10100100	/* Generic interrupt controller CPU interface */
+#define REALVIEW_TWD_BASE		0x10100700
+#define REALVIEW_TWD_SIZE		0x00000100
+#define REALVIEW_GIC_DIST_BASE		0x10101000	/* Generic interrupt controller distributor */
+#define REALVIEW_MPCORE_L220_BASE	0x10102000	/* L220 registers */
+#define REALVIEW_MPCORE_SYS_PLD_CTRL1 0xD8		/*  Register offset for MPCore sysctl */
+#else
+#define REALVIEW_MPCORE_SCU_BASE      0x1F000000	/*  SCU registers */
+#define REALVIEW_GIC_CPU_BASE         0x1F000100	/* Generic interrupt controller CPU interface */
+#define REALVIEW_TWD_BASE             0x1F000700
+#define REALVIEW_TWD_SIZE             0x00000100
+#define REALVIEW_GIC_DIST_BASE        0x1F001000	/* Generic interrupt controller distributor */
+#define REALVIEW_MPCORE_L220_BASE     0x1F002000	/* L220 registers */
+#define REALVIEW_MPCORE_SYS_PLD_CTRL1 0x74		/*  Register offset for MPCore sysctl */
+#endif
+#define REALVIEW_GIC1_CPU_BASE        0x10040000	/* Generic interrupt controller CPU interface */
+#define REALVIEW_GIC1_DIST_BASE       0x10041000	/* Generic interrupt controller distributor */
+#endif
+#define REALVIEW_SMC_BASE             0x10080000	/* SMC */
+	/* Reserved 0x10090000 - 0x100EFFFF */
+
+#define REALVIEW_ETH_BASE             0x4E000000	/* Ethernet */
+
+/* PCI space */
+#define REALVIEW_PCI_BASE             0x41000000	/* PCI Interface */
+#define REALVIEW_PCI_CFG_BASE	      0x42000000
+#define REALVIEW_PCI_MEM_BASE0        0x44000000
+#define REALVIEW_PCI_MEM_BASE1        0x50000000
+#define REALVIEW_PCI_MEM_BASE2        0x60000000
+/* Sizes of above maps */
+#define REALVIEW_PCI_BASE_SIZE	       0x01000000
+#define REALVIEW_PCI_CFG_BASE_SIZE    0x02000000
+#define REALVIEW_PCI_MEM_BASE0_SIZE   0x0c000000	/* 32Mb */
+#define REALVIEW_PCI_MEM_BASE1_SIZE   0x10000000	/* 256Mb */
+#define REALVIEW_PCI_MEM_BASE2_SIZE   0x10000000	/* 256Mb */
+
+#define REALVIEW_SDRAM67_BASE         0x70000000	/* SDRAM banks 6 and 7 */
+#define REALVIEW_LT_BASE              0x80000000	/* Logic Tile expansion */
+
+/*
+ * Disk on Chip
+ */
+#define REALVIEW_DOC_BASE             0x2C000000
+#define REALVIEW_DOC_SIZE             (16 << 20)
+#define REALVIEW_DOC_PAGE_SIZE        512
+#define REALVIEW_DOC_TOTAL_PAGES     (DOC_SIZE / PAGE_SIZE)
+
+#define ERASE_UNIT_PAGES    32
+#define START_PAGE          0x80
+
+/* 
+ *  LED settings, bits [7:0]
+ */
+#define REALVIEW_SYS_LED0             (1 << 0)
+#define REALVIEW_SYS_LED1             (1 << 1)
+#define REALVIEW_SYS_LED2             (1 << 2)
+#define REALVIEW_SYS_LED3             (1 << 3)
+#define REALVIEW_SYS_LED4             (1 << 4)
+#define REALVIEW_SYS_LED5             (1 << 5)
+#define REALVIEW_SYS_LED6             (1 << 6)
+#define REALVIEW_SYS_LED7             (1 << 7)
+
+#define ALL_LEDS                  0xFF
+
+#define LED_BANK                  REALVIEW_SYS_LED
+
+/* 
+ * Control registers
+ */
+#define REALVIEW_IDFIELD_OFFSET	0x0	/* RealView build information */
+#define REALVIEW_FLASHPROG_OFFSET	0x4	/* Flash devices */
+#define REALVIEW_INTREG_OFFSET		0x8	/* Interrupt control */
+#define REALVIEW_DECODE_OFFSET		0xC	/* Fitted logic modules */
+
+/* ------------------------------------------------------------------------
+ *  Interrupts - bit assignment (primary)
+ * ------------------------------------------------------------------------
+ */
+#ifndef CONFIG_REALVIEW_MPCORE
+#define INT_WDOGINT			0	/* Watchdog timer */
+#define INT_SOFTINT			1	/* Software interrupt */
+#define INT_COMMRx			2	/* Debug Comm Rx interrupt */
+#define INT_COMMTx			3	/* Debug Comm Tx interrupt */
+#define INT_TIMERINT0_1			4	/* Timer 0 and 1 */
+#define INT_TIMERINT2_3			5	/* Timer 2 and 3 */
+#define INT_GPIOINT0			6	/* GPIO 0 */
+#define INT_GPIOINT1			7	/* GPIO 1 */
+#define INT_GPIOINT2			8	/* GPIO 2 */
+/* 9 reserved */
+#define INT_RTCINT			10	/* Real Time Clock */
+#define INT_SSPINT			11	/* Synchronous Serial Port */
+#define INT_UARTINT0			12	/* UART 0 on development chip */
+#define INT_UARTINT1			13	/* UART 1 on development chip */
+#define INT_UARTINT2			14	/* UART 2 on development chip */
+#define INT_UARTINT3			15	/* UART 3 on development chip */
+#define INT_SCIINT			16	/* Smart Card Interface */
+#define INT_MMCI0A			17	/* Multimedia Card 0A */
+#define INT_MMCI0B			18	/* Multimedia Card 0B */
+#define INT_AACI			19	/* Audio Codec */
+#define INT_KMI0			20	/* Keyboard/Mouse port 0 */
+#define INT_KMI1			21	/* Keyboard/Mouse port 1 */
+#define INT_CHARLCD			22	/* Character LCD */
+#define INT_CLCDINT			23	/* CLCD controller */
+#define INT_DMAINT			24	/* DMA controller */
+#define INT_PWRFAILINT			25	/* Power failure */
+#define INT_PISMO			26
+#define INT_DoC				27	/* Disk on Chip memory controller */
+#define INT_ETH				28	/* Ethernet controller */
+#define INT_USB				29	/* USB controller */
+#define INT_TSPENINT			30	/* Touchscreen pen */
+#define INT_TSKPADINT			31	/* Touchscreen keypad */
+
+#else
+
+#define MAX_GIC_NR			2
+
+#define INT_AACI			0
+#define INT_TIMERINT0_1			1
+#define INT_TIMERINT2_3			2
+#define INT_USB				3
+#define INT_UARTINT0			4
+#define INT_UARTINT1			5
+#define INT_RTCINT			6
+#define INT_KMI0			7
+#define INT_KMI1			8
+#define INT_ETH				9
+#define INT_EB_IRQ1			10	/* main GIC */
+#define INT_EB_IRQ2			11	/* tile GIC */
+#define INT_EB_FIQ1			12	/* main GIC */
+#define INT_EB_FIQ2			13	/* tile GIC */
+#define INT_MMCI0A			14
+#define INT_MMCI0B			15
+
+#define INT_PMU_CPU0			17
+#define INT_PMU_CPU1			18
+#define INT_PMU_CPU2			19
+#define INT_PMU_CPU3			20
+#define INT_PMU_SCU0			21
+#define INT_PMU_SCU1			22
+#define INT_PMU_SCU2			23
+#define INT_PMU_SCU3			24
+#define INT_PMU_SCU4			25
+#define INT_PMU_SCU5			26
+#define INT_PMU_SCU6			27
+#define INT_PMU_SCU7			28
+
+#define INT_L220_EVENT			29
+#define INT_L220_SLAVE			30
+#define INT_L220_DECODE			31
+
+#define INT_UARTINT2			-1
+#define INT_UARTINT3			-1
+#define INT_CLCDINT			-1
+#define INT_DMAINT			-1
+#define INT_WDOGINT			-1
+#define INT_GPIOINT0			-1
+#define INT_GPIOINT1			-1
+#define INT_GPIOINT2			-1
+#define INT_SCIINT			-1
+#define INT_SSPINT			-1
+#endif
+
+/* 
+ *  Interrupt bit positions
+ * 
+ */
+#define INTMASK_WDOGINT			(1 << INT_WDOGINT)
+#define INTMASK_SOFTINT			(1 << INT_SOFTINT)
+#define INTMASK_COMMRx			(1 << INT_COMMRx)
+#define INTMASK_COMMTx			(1 << INT_COMMTx)
+#define INTMASK_TIMERINT0_1		(1 << INT_TIMERINT0_1)
+#define INTMASK_TIMERINT2_3		(1 << INT_TIMERINT2_3)
+#define INTMASK_GPIOINT0		(1 << INT_GPIOINT0)
+#define INTMASK_GPIOINT1		(1 << INT_GPIOINT1)
+#define INTMASK_GPIOINT2		(1 << INT_GPIOINT2)
+#define INTMASK_RTCINT			(1 << INT_RTCINT)
+#define INTMASK_SSPINT			(1 << INT_SSPINT)
+#define INTMASK_UARTINT0		(1 << INT_UARTINT0)
+#define INTMASK_UARTINT1		(1 << INT_UARTINT1)
+#define INTMASK_UARTINT2		(1 << INT_UARTINT2)
+#define INTMASK_UARTINT3		(1 << INT_UARTINT3)
+#define INTMASK_SCIINT			(1 << INT_SCIINT)
+#define INTMASK_MMCI0A			(1 << INT_MMCI0A)
+#define INTMASK_MMCI0B			(1 << INT_MMCI0B)
+#define INTMASK_AACI			(1 << INT_AACI)
+#define INTMASK_KMI0			(1 << INT_KMI0)
+#define INTMASK_KMI1			(1 << INT_KMI1)
+#define INTMASK_CHARLCD			(1 << INT_CHARLCD)
+#define INTMASK_CLCDINT			(1 << INT_CLCDINT)
+#define INTMASK_DMAINT			(1 << INT_DMAINT)
+#define INTMASK_PWRFAILINT		(1 << INT_PWRFAILINT)
+#define INTMASK_PISMO			(1 << INT_PISMO)
+#define INTMASK_DoC			(1 << INT_DoC)
+#define INTMASK_ETH			(1 << INT_ETH)
+#define INTMASK_USB			(1 << INT_USB)
+#define INTMASK_TSPENINT		(1 << INT_TSPENINT)
+#define INTMASK_TSKPADINT		(1 << INT_TSKPADINT)
+
+#define MAXIRQNUM                       31
+#define MAXFIQNUM                       31
+#define MAXSWINUM                       31
+
+/* 
+ *  Application Flash
+ * 
+ */
+#define FLASH_BASE                      REALVIEW_FLASH_BASE
+#define FLASH_SIZE                      REALVIEW_FLASH_SIZE
+#define FLASH_END                       (FLASH_BASE + FLASH_SIZE - 1)
+#define FLASH_BLOCK_SIZE                SZ_128K
+
+/* 
+ *  Boot Flash
+ * 
+ */
+#define EPROM_BASE                      REALVIEW_BOOT_ROM_HI
+#define EPROM_SIZE                      REALVIEW_BOOT_ROM_SIZE
+#define EPROM_END                       (EPROM_BASE + EPROM_SIZE - 1)
+
+/* 
+ *  Clean base - dummy
+ * 
+ */
+#define CLEAN_BASE                      EPROM_BASE
+
+/*
+ * System controller bit assignment
+ */
+#define REALVIEW_REFCLK	0
+#define REALVIEW_TIMCLK	1
+
+#define REALVIEW_TIMER1_EnSel	15
+#define REALVIEW_TIMER2_EnSel	17
+#define REALVIEW_TIMER3_EnSel	19
+#define REALVIEW_TIMER4_EnSel	21
+
+
+#define MAX_TIMER                       2
+#define MAX_PERIOD                      699050
+#define TICKS_PER_uSEC                  1
+
+/* 
+ *  These are useconds NOT ticks.  
+ * 
+ */
+#define mSEC_1                          1000
+#define mSEC_5                          (mSEC_1 * 5)
+#define mSEC_10                         (mSEC_1 * 10)
+#define mSEC_25                         (mSEC_1 * 25)
+#define SEC_1                           (mSEC_1 * 1000)
+
+#define REALVIEW_CSR_BASE             0x10000000
+#define REALVIEW_CSR_SIZE             0x10000000
+
+#endif
+
+/* 	END */
Index: build_tree/linux/include/asm/arch-realview/scu.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/scu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/scu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,8 @@
+#ifndef __ASMARM_ARCH_SCU_H
+#define __ASMARM_ARCH_SCU_H
+
+#include <asm/arch/platform.h>
+
+#define SCU_BASE	REALVIEW_MPCORE_SCU_BASE
+
+#endif
Index: build_tree/linux/include/asm/arch-realview/smp.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/smp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/smp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,30 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+
+#include <asm/hardware/gic.h>
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+/*
+ * We use IRQ1 as the IPI
+ */
+static inline void smp_cross_call(cpumask_t callmap)
+{
+	gic_raise_softirq(callmap, 1);
+}
+
+/*
+ * Do nothing on MPcore.
+ */
+static inline void smp_cross_call_done(cpumask_t callmap)
+{
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-realview/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,51 @@
+/*
+ *  linux/include/asm-arm/arch-realview/system.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	void __iomem *hdr_ctrl = __io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_RESETCTL_OFFSET;
+	unsigned int val;
+
+	/*
+	 * To reset, we hit the on-board reset register
+	 * in the system FPGA
+	 */
+	val = __raw_readl(hdr_ctrl);
+	val |= REALVIEW_SYS_CTRL_RESET_CONFIGCLR;
+	__raw_writel(val, hdr_ctrl);
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-realview/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-arm/arch-realview/timex.h
+ *
+ *  RealView architecture timex specifications
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE		(50000000 / 16)
Index: build_tree/linux/include/asm/arch-realview/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,48 @@
+/*
+ *  linux/include/asm-arm/arch-realview/uncompress.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/hardware.h>
+
+#define AMBA_UART_DR	(*(volatile unsigned char *) (REALVIEW_UART0_BASE + 0x00))
+#define AMBA_UART_LCRH	(*(volatile unsigned char *) (REALVIEW_UART0_BASE + 0x2c))
+#define AMBA_UART_CR	(*(volatile unsigned char *) (REALVIEW_UART0_BASE + 0x30))
+#define AMBA_UART_FR	(*(volatile unsigned char *) (REALVIEW_UART0_BASE + 0x18))
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	while (AMBA_UART_FR & (1 << 5))
+		barrier();
+
+	AMBA_UART_DR = c;
+}
+
+static inline void flush(void)
+{
+	while (AMBA_UART_FR & (1 << 3))
+		barrier();
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-realview/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-realview/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-realview/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/arch-realview/vmalloc.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(PAGE_OFFSET + 0x18000000)
Index: build_tree/linux/include/asm/arch-rpc/acornfb.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/acornfb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/acornfb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,140 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/acornfb.h
+ *
+ *  Copyright (C) 1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  AcornFB architecture specific code
+ */
+
+#define acornfb_bandwidth(var) ((var)->pixclock * 8 / (var)->bits_per_pixel)
+
+static inline int
+acornfb_valid_pixrate(struct fb_var_screeninfo *var)
+{
+	u_long limit;
+
+	if (!var->pixclock)
+		return 0;
+
+	/*
+	 * Limits below are taken from RISC OS bandwidthlimit file
+	 */
+	if (current_par.using_vram) {
+		if (current_par.vram_half_sam == 2048)
+			limit = 6578;
+		else
+			limit = 13157;
+	} else {
+		limit = 26315;
+	}
+
+	return acornfb_bandwidth(var) >= limit;
+}
+
+/*
+ * Try to find the best PLL parameters for the pixel clock.
+ * This algorithm seems to give best predictable results,
+ * and produces the same values as detailed in the VIDC20
+ * data sheet.
+ */
+static inline u_int
+acornfb_vidc20_find_pll(u_int pixclk)
+{
+	u_int r, best_r = 2, best_v = 2;
+	int best_d = 0x7fffffff;
+
+	for (r = 2; r <= 32; r++) {
+		u_int rr, v, p;
+		int d;
+
+		rr = 41667 * r;
+
+		v = (rr + pixclk / 2) / pixclk;
+
+		if (v > 32 || v < 2)
+			continue;
+
+		p = (rr + v / 2) / v;
+
+		d = pixclk - p;
+
+		if (d < 0)
+			d = -d;
+
+		if (d < best_d) {
+			best_d = d;
+			best_v = v - 1;
+			best_r = r - 1;
+		}
+
+		if (d == 0)
+			break;
+	}
+
+	return best_v << 8 | best_r;
+}
+
+static inline void
+acornfb_vidc20_find_rates(struct vidc_timing *vidc,
+			  struct fb_var_screeninfo *var)
+{
+	u_int div;
+
+	/* Select pixel-clock divisor to keep PLL in range */
+	div = var->pixclock / 9090; /*9921*/
+
+	/* Limit divisor */
+	if (div == 0)
+		div = 1;
+	if (div > 8)
+		div = 8;
+
+	/* Encode divisor to VIDC20 setting */
+	switch (div) {
+	case 1:	vidc->control |= VIDC20_CTRL_PIX_CK;  break;
+	case 2:	vidc->control |= VIDC20_CTRL_PIX_CK2; break;
+	case 3:	vidc->control |= VIDC20_CTRL_PIX_CK3; break;
+	case 4:	vidc->control |= VIDC20_CTRL_PIX_CK4; break;
+	case 5:	vidc->control |= VIDC20_CTRL_PIX_CK5; break;
+	case 6:	vidc->control |= VIDC20_CTRL_PIX_CK6; break;
+	case 7:	vidc->control |= VIDC20_CTRL_PIX_CK7; break;
+	case 8: vidc->control |= VIDC20_CTRL_PIX_CK8; break;
+	}
+
+	/*
+	 * With VRAM, the FIFO can be set to the highest possible setting
+	 * because there are no latency considerations for other memory
+	 * accesses. However, in 64 bit bus mode the FIFO preload value
+	 * must not be set to VIDC20_CTRL_FIFO_28 because this will let
+	 * the FIFO overflow. See VIDC20 manual page 33 (6.0 Setting the
+	 * FIFO preload value).
+	 */
+	if (current_par.using_vram) {
+		if (current_par.vram_half_sam == 2048)
+			vidc->control |= VIDC20_CTRL_FIFO_24;
+		else
+			vidc->control |= VIDC20_CTRL_FIFO_28;
+	} else {
+		unsigned long bandwidth = acornfb_bandwidth(var);
+
+		/* Encode bandwidth as VIDC20 setting */
+		if (bandwidth > 33334)		/* < 30.0MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_16;
+		else if (bandwidth > 26666)	/* < 37.5MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_20;
+		else if (bandwidth > 22222)	/* < 45.0MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_24;
+		else				/* > 45.0MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_28;
+	}
+
+	/* Find the PLL values */
+	vidc->pll_ctl = acornfb_vidc20_find_pll(var->pixclock / div);
+}
+
+#define acornfb_default_control()	(VIDC20_CTRL_PIX_VCLK)
+#define acornfb_default_econtrol()	(VIDC20_ECTL_DAC | VIDC20_ECTL_REG(3))
Index: build_tree/linux/include/asm/arch-rpc/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,25 @@
+/* linux/include/asm-arm/arch-rpc/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x03000000
+		movne	\rx, #0xe0000000
+		orr	\rx, \rx, #0x00010000
+		orr	\rx, \rx, #0x00000fe0
+		.endm
+
+#define UART_SHIFT	2
+#define FLOW_CONTROL
+#include <asm/hardware/debug-8250.S>
Index: build_tree/linux/include/asm/arch-rpc/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/dma.h
+ *
+ *  Copyright (C) 1997 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/*
+ * This is the maximum DMA address that can be DMAd to.
+ * There should not be more than (0xd0000000 - 0xc0000000)
+ * bytes of RAM.
+ */
+#define MAX_DMA_ADDRESS		0xd0000000
+#define MAX_DMA_CHANNELS	8
+
+#define DMA_0			0
+#define DMA_1			1
+#define DMA_2			2
+#define DMA_3			3
+#define DMA_S0			4
+#define DMA_S1			5
+#define DMA_VIRTUAL_FLOPPY	6
+#define DMA_VIRTUAL_SOUND	7
+
+#define DMA_FLOPPY		DMA_VIRTUAL_FLOPPY
+
+#endif /* _ASM_ARCH_DMA_H */
+
Index: build_tree/linux/include/asm/arch-rpc/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,8 @@
+#include <asm/hardware.h>
+#include <asm/hardware/entry-macro-iomd.S>
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
Index: build_tree/linux/include/asm/arch-rpc/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,83 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/hardware.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file contains the hardware definitions of the RiscPC series machines.
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/memory.h>
+
+#ifndef __ASSEMBLY__
+#define IOMEM(x) ((void __iomem *)(unsigned long)(x))
+#else
+#define IOMEM(x) x
+#endif /* __ASSEMBLY__ */
+
+/*
+ * What hardware must be present
+ */
+#define HAS_IOMD
+#define HAS_VIDC20
+
+/* Hardware addresses of major areas.
+ *  *_START is the physical address
+ *  *_SIZE  is the size of the region
+ *  *_BASE  is the virtual address
+ */
+#define RAM_SIZE		0x10000000
+#define RAM_START		0x10000000
+
+#define EASI_SIZE		0x08000000	/* EASI I/O */
+#define EASI_START		0x08000000
+#define EASI_BASE		0xe5000000
+
+#define IO_START		0x03000000	/* I/O */
+#define IO_SIZE			0x01000000
+#define IO_BASE			IOMEM(0xe0000000)
+
+#define SCREEN_START		0x02000000	/* VRAM */
+#define SCREEN_END		0xdfc00000
+#define SCREEN_BASE		0xdf800000
+
+#define UNCACHEABLE_ADDR	0xdf010000
+
+/*
+ * IO Addresses
+ */
+#define VIDC_BASE		IOMEM(0xe0400000)
+#define EXPMASK_BASE		0xe0360000
+#define IOMD_BASE		IOMEM(0xe0200000)
+#define IOC_BASE		IOMEM(0xe0200000)
+#define PCIO_BASE		IOMEM(0xe0010000)
+#define FLOPPYDMA_BASE		IOMEM(0xe002a000)
+
+#define vidc_writel(val)	__raw_writel(val, VIDC_BASE)
+
+#define IO_EC_EASI_BASE		0x81400000
+#define IO_EC_IOC4_BASE		0x8009c000
+#define IO_EC_IOC_BASE		0x80090000
+#define IO_EC_MEMC8_BASE	0x8000ac00
+#define IO_EC_MEMC_BASE		0x80000000
+
+#define NETSLOT_BASE		0x0302b000
+#define NETSLOT_SIZE		0x00001000
+
+#define PODSLOT_IOC0_BASE	0x03240000
+#define PODSLOT_IOC4_BASE	0x03270000
+#define PODSLOT_IOC_SIZE	(1 << 14)
+#define PODSLOT_MEMC_BASE	0x03000000
+#define PODSLOT_MEMC_SIZE	(1 << 14)
+#define PODSLOT_EASI_BASE	0x08000000
+#define PODSLOT_EASI_SIZE	(1 << 24)
+
+#define	EXPMASK_STATUS		(EXPMASK_BASE + 0x00)
+#define EXPMASK_ENABLE		(EXPMASK_BASE + 0x04)
+
+#endif
Index: build_tree/linux/include/asm/arch-rpc/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,259 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/io.h
+ *
+ *  Copyright (C) 1997 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Modifications:
+ *  06-Dec-1997	RMK	Created.
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * GCC is totally crap at loading/storing data.  We try to persuade it
+ * to do the right thing by using these whereever possible instead of
+ * the above.
+ */
+#define __arch_base_getb(b,o)			\
+ ({						\
+	unsigned int __v, __r = (b);		\
+	__asm__ __volatile__(			\
+		"ldrb	%0, [%1, %2]"		\
+		: "=r" (__v)			\
+		: "r" (__r), "Ir" (o));		\
+	__v;					\
+ })
+
+#define __arch_base_getl(b,o)			\
+ ({						\
+	unsigned int __v, __r = (b);		\
+	__asm__ __volatile__(			\
+		"ldr	%0, [%1, %2]"		\
+		: "=r" (__v)			\
+		: "r" (__r), "Ir" (o));		\
+	__v;					\
+ })
+
+#define __arch_base_putb(v,b,o)			\
+ ({						\
+	unsigned int __r = (b);			\
+	__asm__ __volatile__(			\
+		"strb	%0, [%1, %2]"		\
+		:				\
+		: "r" (v), "r" (__r), "Ir" (o));\
+ })
+
+#define __arch_base_putl(v,b,o)			\
+ ({						\
+	unsigned int __r = (b);			\
+	__asm__ __volatile__(			\
+		"str	%0, [%1, %2]"		\
+		:				\
+		: "r" (v), "r" (__r), "Ir" (o));\
+ })
+
+/*
+ * We use two different types of addressing - PC style addresses, and ARM
+ * addresses.  PC style accesses the PC hardware with the normal PC IO
+ * addresses, eg 0x3f8 for serial#1.  ARM addresses are 0x80000000+
+ * and are translated to the start of IO.  Note that all addresses are
+ * shifted left!
+ */
+#define __PORT_PCIO(x)	(!((x) & 0x80000000))
+
+/*
+ * Dynamic IO functions.
+ */
+static inline void __outb (unsigned int value, unsigned int port)
+{
+	unsigned long temp;
+	__asm__ __volatile__(
+	"tst	%2, #0x80000000\n\t"
+	"mov	%0, %4\n\t"
+	"addeq	%0, %0, %3\n\t"
+	"strb	%1, [%0, %2, lsl #2]	@ outb"
+	: "=&r" (temp)
+	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
+	: "cc");
+}
+
+static inline void __outw (unsigned int value, unsigned int port)
+{
+	unsigned long temp;
+	__asm__ __volatile__(
+	"tst	%2, #0x80000000\n\t"
+	"mov	%0, %4\n\t"
+	"addeq	%0, %0, %3\n\t"
+	"str	%1, [%0, %2, lsl #2]	@ outw"
+	: "=&r" (temp)
+	: "r" (value|value<<16), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
+	: "cc");
+}
+
+static inline void __outl (unsigned int value, unsigned int port)
+{
+	unsigned long temp;
+	__asm__ __volatile__(
+	"tst	%2, #0x80000000\n\t"
+	"mov	%0, %4\n\t"
+	"addeq	%0, %0, %3\n\t"
+	"str	%1, [%0, %2, lsl #2]	@ outl"
+	: "=&r" (temp)
+	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
+	: "cc");
+}
+
+#define DECLARE_DYN_IN(sz,fnsuffix,instr)					\
+static inline unsigned sz __in##fnsuffix (unsigned int port)		\
+{										\
+	unsigned long temp, value;						\
+	__asm__ __volatile__(							\
+	"tst	%2, #0x80000000\n\t"						\
+	"mov	%0, %4\n\t"							\
+	"addeq	%0, %0, %3\n\t"							\
+	"ldr" instr "	%1, [%0, %2, lsl #2]	@ in" #fnsuffix			\
+	: "=&r" (temp), "=r" (value)						\
+	: "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)		\
+	: "cc");								\
+	return (unsigned sz)value;						\
+}
+
+static inline void __iomem *__ioaddr(unsigned int port)
+{
+	void __iomem *ret;
+	if (__PORT_PCIO(port))
+		ret = PCIO_BASE;
+	else
+		ret = IO_BASE;
+	return ret + (port << 2);
+}
+
+#define DECLARE_IO(sz,fnsuffix,instr)	\
+	DECLARE_DYN_IN(sz,fnsuffix,instr)
+
+DECLARE_IO(char,b,"b")
+DECLARE_IO(short,w,"")
+DECLARE_IO(int,l,"")
+
+#undef DECLARE_IO
+#undef DECLARE_DYN_IN
+
+/*
+ * Constant address IO functions
+ *
+ * These have to be macros for the 'J' constraint to work -
+ * +/-4096 immediate operand.
+ */
+#define __outbc(value,port)							\
+({										\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"strb	%0, [%1, %2]	@ outbc"				\
+		: : "r" (value), "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"strb	%0, [%1, %2]	@ outbc"				\
+		: : "r" (value), "r" (IO_BASE), "r" ((port) << 2));		\
+})
+
+#define __inbc(port)								\
+({										\
+	unsigned char result;							\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"ldrb	%0, [%1, %2]	@ inbc"					\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"ldrb	%0, [%1, %2]	@ inbc"					\
+		: "=r" (result) : "r" (IO_BASE), "r" ((port) << 2));		\
+	result;									\
+})
+
+#define __outwc(value,port)							\
+({										\
+	unsigned long __v = value;						\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outwc"				\
+		: : "r" (__v|__v<<16), "r" (PCIO_BASE), "Jr" ((port) << 2));	\
+	else									\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outwc"				\
+		: : "r" (__v|__v<<16), "r" (IO_BASE), "r" ((port) << 2));		\
+})
+
+#define __inwc(port)								\
+({										\
+	unsigned short result;							\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inwc"					\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inwc"					\
+		: "=r" (result) : "r" (IO_BASE), "r" ((port) << 2));		\
+	result & 0xffff;							\
+})
+
+#define __outlc(value,port)							\
+({										\
+	unsigned long __v = value;						\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outlc"				\
+		: : "r" (__v), "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"str	%0, [%1, %2]	@ outlc"				\
+		: : "r" (__v), "r" (IO_BASE), "r" ((port) << 2));		\
+})
+
+#define __inlc(port)								\
+({										\
+	unsigned long result;							\
+	if (__PORT_PCIO((port)))						\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inlc"					\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port) << 2));		\
+	else									\
+		__asm__ __volatile__(						\
+		"ldr	%0, [%1, %2]	@ inlc"					\
+		: "=r" (result) : "r" (IO_BASE), "r" ((port) << 2));		\
+	result;									\
+})
+
+#define __ioaddrc(port)		\
+	((__PORT_PCIO(port) ? PCIO_BASE : IO_BASE) + ((port) << 2))
+
+#define inb(p)	 	(__builtin_constant_p((p)) ? __inbc(p)    : __inb(p))
+#define inw(p)	 	(__builtin_constant_p((p)) ? __inwc(p)    : __inw(p))
+#define inl(p)	 	(__builtin_constant_p((p)) ? __inlc(p)    : __inl(p))
+#define outb(v,p)	(__builtin_constant_p((p)) ? __outbc(v,p) : __outb(v,p))
+#define outw(v,p)	(__builtin_constant_p((p)) ? __outwc(v,p) : __outw(v,p))
+#define outl(v,p)	(__builtin_constant_p((p)) ? __outlc(v,p) : __outl(v,p))
+#define __ioaddr(p)	(__builtin_constant_p((p)) ? __ioaddr(p)  : __ioaddrc(p))
+/* the following macro is deprecated */
+#define ioaddr(port)	((unsigned long)__ioaddr((port)))
+
+#define insb(p,d,l)	__raw_readsb(__ioaddr(p),d,l)
+#define insw(p,d,l)	__raw_readsw(__ioaddr(p),d,l)
+
+#define outsb(p,d,l)	__raw_writesb(__ioaddr(p),d,l)
+#define outsw(p,d,l)	__raw_writesw(__ioaddr(p),d,l)
+
+/*
+ * 1:1 mapping for ioremapped regions.
+ */
+#define __mem_pci(x)	(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-rpc/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/irqs.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define IRQ_PRINTER		0
+#define IRQ_BATLOW		1
+#define IRQ_FLOPPYINDEX		2
+#define IRQ_VSYNCPULSE		3
+#define IRQ_POWERON		4
+#define IRQ_TIMER0		5
+#define IRQ_TIMER1		6
+#define IRQ_IMMEDIATE		7
+#define IRQ_EXPCARDFIQ		8
+#define IRQ_HARDDISK		9
+#define IRQ_SERIALPORT		10
+#define IRQ_FLOPPYDISK		12
+#define IRQ_EXPANSIONCARD	13
+#define IRQ_KEYBOARDTX		14
+#define IRQ_KEYBOARDRX		15
+
+#define IRQ_DMA0		16
+#define IRQ_DMA1		17
+#define IRQ_DMA2		18
+#define IRQ_DMA3		19
+#define IRQ_DMAS0		20
+#define IRQ_DMAS1		21
+
+#define FIQ_FLOPPYDATA		0
+#define FIQ_ECONET		2
+#define FIQ_SERIALPORT		4
+#define FIQ_EXPANSIONCARD	6
+#define FIQ_FORCE		7
+
+/*
+ * This is the offset of the FIQ "IRQ" numbers
+ */
+#define FIQ_START		64
+
+#define IRQ_TIMER		IRQ_TIMER0
+
Index: build_tree/linux/include/asm/arch-rpc/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/memory.h
+ *
+ *  Copyright (C) 1996,1997,1998 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-Oct-1996 RMK	Created
+ *   31-Dec-1997 RMK	Fixed definitions to reduce warnings
+ *   11-Jan-1998 RMK	Uninlined to reduce hits on cache
+ *   08-Feb-1998 RMK	Added __virt_to_bus and __bus_to_virt
+ *   21-Mar-1999 RMK	Renamed to memory.h
+ *		 RMK	Added TASK_SIZE and PAGE_OFFSET
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x10000000)
+
+/*
+ * These are exactly the same on the RiscPC as the
+ * physical memory view.
+ */
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+/*
+ * Cache flushing area - ROM
+ */
+#define FLUSH_BASE_PHYS		0x00000000
+#define FLUSH_BASE		0xdf000000
+
+#endif
Index: build_tree/linux/include/asm/arch-rpc/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/system.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm/hardware.h>
+#include <asm/hardware/iomd.h>
+#include <asm/io.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	iomd_writeb(0, IOMD_ROMCR0);
+
+	/*
+	 * Jump into the ROM
+	 */
+	cpu_reset(0);
+}
Index: build_tree/linux/include/asm/arch-rpc/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,17 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/timex.h
+ *
+ *  Copyright (C) 1997, 1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  RiscPC architecture timex specifications
+ */
+
+/*
+ * On the RiscPC, the clock ticks at 2MHz.
+ */
+#define CLOCK_TICK_RATE		2000000
+
Index: build_tree/linux/include/asm/arch-rpc/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,156 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/uncompress.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define VIDMEM ((char *)SCREEN_START)
+ 
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+int video_num_columns, video_num_lines, video_size_row;
+int white, bytes_per_char_h;
+extern unsigned long con_charconvtable[256];
+
+struct param_struct {
+	unsigned long page_size;
+	unsigned long nr_pages;
+	unsigned long ramdisk_size;
+	unsigned long mountrootrdonly;
+	unsigned long rootdev;
+	unsigned long video_num_cols;
+	unsigned long video_num_rows;
+	unsigned long video_x;
+	unsigned long video_y;
+	unsigned long memc_control_reg;
+	unsigned char sounddefault;
+	unsigned char adfsdrives;
+	unsigned char bytes_per_char_h;
+	unsigned char bytes_per_char_v;
+	unsigned long unused[256/4-11];
+};
+
+static const unsigned long palette_4[16] = {
+	0x00000000,
+	0x000000cc,
+	0x0000cc00,             /* Green   */
+	0x0000cccc,             /* Yellow  */
+	0x00cc0000,             /* Blue    */
+	0x00cc00cc,             /* Magenta */
+	0x00cccc00,             /* Cyan    */
+	0x00cccccc,             /* White   */
+	0x00000000,
+	0x000000ff,
+	0x0000ff00,
+	0x0000ffff,
+	0x00ff0000,
+	0x00ff00ff,
+	0x00ffff00,
+	0x00ffffff
+};
+
+#define palette_setpixel(p)	*(unsigned long *)(IO_START+0x00400000) = 0x10000000|((p) & 255)
+#define palette_write(v)	*(unsigned long *)(IO_START+0x00400000) = 0x00000000|((v) & 0x00ffffff)
+
+/*
+ * params_phys is a linker defined symbol - see
+ * arch/arm/boot/compressed/Makefile
+ */
+extern __attribute__((pure)) struct param_struct *params(void);
+#define params (params())
+
+#ifndef STANDALONE_DEBUG 
+/*
+ * This does not append a newline
+ */
+static void putc(int c)
+{
+	extern void ll_write_char(char *, char c, char white);
+	int x,y;
+	char *ptr;
+
+	x = params->video_x;
+	y = params->video_y;
+
+	if (c == '\n') {
+		if (++y >= video_num_lines)
+			y--;
+	} else if (c == '\r') {
+		x = 0;
+	} else {
+		ptr = VIDMEM + ((y*video_num_columns*params->bytes_per_char_v+x)*bytes_per_char_h);
+		ll_write_char(ptr, c, white);
+		if (++x >= video_num_columns) {
+			x = 0;
+			if ( ++y >= video_num_lines ) {
+				y--;
+			}
+		}
+	}
+
+	params->video_x = x;
+	params->video_y = y;
+}
+
+static inline void flush(void)
+{
+}
+
+static void error(char *x);
+
+/*
+ * Setup for decompression
+ */
+static void arch_decomp_setup(void)
+{
+	int i;
+	
+	video_num_lines = params->video_num_rows;
+	video_num_columns = params->video_num_cols;
+	bytes_per_char_h = params->bytes_per_char_h;
+	video_size_row = video_num_columns * bytes_per_char_h;
+	if (bytes_per_char_h == 4)
+		for (i = 0; i < 256; i++)
+			con_charconvtable[i] =
+				(i & 128 ? 1 << 0  : 0) |
+				(i & 64  ? 1 << 4  : 0) |
+				(i & 32  ? 1 << 8  : 0) |
+				(i & 16  ? 1 << 12 : 0) |
+				(i & 8   ? 1 << 16 : 0) |
+				(i & 4   ? 1 << 20 : 0) |
+				(i & 2   ? 1 << 24 : 0) |
+				(i & 1   ? 1 << 28 : 0);
+	else
+		for (i = 0; i < 16; i++)
+			con_charconvtable[i] =
+				(i & 8   ? 1 << 0  : 0) |
+				(i & 4   ? 1 << 8  : 0) |
+				(i & 2   ? 1 << 16 : 0) |
+				(i & 1   ? 1 << 24 : 0);
+
+
+	palette_setpixel(0);
+	if (bytes_per_char_h == 1) {
+		palette_write (0);
+		palette_write (0x00ffffff);
+		for (i = 2; i < 256; i++)
+			palette_write (0);
+		white = 1;
+	} else {
+		for (i = 0; i < 256; i++)
+			palette_write (i < 16 ? palette_4[i] : 0);
+		white = 7;
+	}
+
+	if (params->nr_pages * params->page_size < 4096*1024) error("<4M of mem\n");
+}
+#endif
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-rpc/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-rpc/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-rpc/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,10 @@
+/*
+ *  linux/include/asm-arm/arch-rpc/vmalloc.h
+ *
+ *  Copyright (C) 1997 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x1c000000)
Index: build_tree/linux/include/asm/arch-s3c2410/anubis-cpld.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/anubis-cpld.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/anubis-cpld.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/* linux/include/asm-arm/arch-s3c2410/anubis-cpld.h
+ *
+ * Copyright (c) 2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * ANUBIS - CPLD control constants
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_ANUBISCPLD_H
+#define __ASM_ARCH_ANUBISCPLD_H
+
+/* CTRL2 - NAND WP control, IDE Reset assert/check */
+
+#define ANUBIS_CTRL1_NANDSEL		(0x3)
+
+#endif /* __ASM_ARCH_ANUBISCPLD_H */
Index: build_tree/linux/include/asm/arch-s3c2410/anubis-irq.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/anubis-irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/anubis-irq.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/* linux/include/asm-arm/arch-s3c2410/anubis-irq.h
+ *
+ * Copyright (c) 2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ *  ANUBIS - IRQ Number definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_ANUBISIRQ_H
+#define __ASM_ARCH_ANUBISIRQ_H
+
+#define IRQ_IDE0       IRQ_EINT2
+#define IRQ_IDE1       IRQ_EINT3
+#define IRQ_ASIX       IRQ_EINT1
+
+#endif /* __ASM_ARCH_ANUBISIRQ_H */
Index: build_tree/linux/include/asm/arch-s3c2410/anubis-map.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/anubis-map.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/anubis-map.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,44 @@
+/* linux/include/asm-arm/arch-s3c2410/anubis-map.h
+ *
+ * Copyright (c) 2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * ANUBIS - Memory map definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* needs arch/map.h including with this */
+
+#ifndef __ASM_ARCH_ANUBISMAP_H
+#define __ASM_ARCH_ANUBISMAP_H
+
+/* start peripherals off after the S3C2410 */
+
+#define ANUBIS_IOADDR(x)	(S3C2410_ADDR((x) + 0x01800000))
+
+#define ANUBIS_PA_CPLD		(S3C2410_CS1 | (1<<26))
+
+/* we put the CPLD registers next, to get them out of the way */
+
+#define ANUBIS_VA_CTRL1	    ANUBIS_IOADDR(0x00000000)	 /* 0x01800000 */
+#define ANUBIS_PA_CTRL1	    (ANUBIS_PA_CPLD)
+
+#define ANUBIS_VA_CTRL2	    ANUBIS_IOADDR(0x00100000)	 /* 0x01900000 */
+#define ANUBIS_PA_CTRL2	    (ANUBIS_PA_CPLD)
+
+#define ANUBIS_VA_CTRL3	    ANUBIS_IOADDR(0x00200000)	 /* 0x01A00000 */
+#define ANUBIS_PA_CTRL3	    (ANUBIS_PA_CPLD)
+
+#define ANUBIS_VA_CTRL4	    ANUBIS_IOADDR(0x00300000)	 /* 0x01B00000 */
+#define ANUBIS_PA_CTRL4	    (ANUBIS_PA_CPLD)
+
+#define ANUBIS_IDEPRI	    ANUBIS_IOADDR(0x01000000)
+#define ANUBIS_IDEPRIAUX    ANUBIS_IOADDR(0x01100000)
+#define ANUBIS_IDESEC	    ANUBIS_IOADDR(0x01200000)
+#define ANUBIS_IDESECAUX    ANUBIS_IOADDR(0x01300000)
+
+#endif /* __ASM_ARCH_ANUBISMAP_H */
Index: build_tree/linux/include/asm/arch-s3c2410/audio.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/audio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/audio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,45 @@
+/* linux/include/asm-arm/arch-s3c2410/audio.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C24XX - Audio platfrom_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_AUDIO_H
+#define __ASM_ARCH_AUDIO_H __FILE__
+
+/* struct s3c24xx_iis_ops
+ *
+ * called from the s3c24xx audio core to deal with the architecture
+ * or the codec's setup and control.
+ *
+ * the pointer to itself is passed through in case the caller wants to
+ * embed this in an larger structure for easy reference to it's context.
+*/
+
+struct s3c24xx_iis_ops {
+	struct module *owner;
+
+	int	(*startup)(struct s3c24xx_iis_ops *me);
+	void	(*shutdown)(struct s3c24xx_iis_ops *me);
+	int	(*suspend)(struct s3c24xx_iis_ops *me);
+	int	(*resume)(struct s3c24xx_iis_ops *me);
+
+	int	(*open)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
+	int	(*close)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
+	int	(*prepare)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm, struct snd_pcm_runtime *rt);
+};
+
+struct s3c24xx_platdata_iis {
+	const char		*codec_clk;
+	struct s3c24xx_iis_ops	*ops;
+	int			(*match_dev)(struct device *dev);
+};
+
+#endif /* __ASM_ARCH_AUDIO_H */
Index: build_tree/linux/include/asm/arch-s3c2410/bast-cpld.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/bast-cpld.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/bast-cpld.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,53 @@
+/* linux/include/asm-arm/arch-s3c2410/bast-cpld.h
+ *
+ * Copyright (c) 2003,2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * BAST - CPLD control constants
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_BASTCPLD_H
+#define __ASM_ARCH_BASTCPLD_H
+
+/* CTRL1 - Audio LR routing */
+
+#define BAST_CPLD_CTRL1_LRCOFF	    (0x00)
+#define BAST_CPLD_CTRL1_LRCADC	    (0x01)
+#define BAST_CPLD_CTRL1_LRCDAC	    (0x02)
+#define BAST_CPLD_CTRL1_LRCARM	    (0x03)
+#define BAST_CPLD_CTRL1_LRMASK	    (0x03)
+
+/* CTRL2 - NAND WP control, IDE Reset assert/check */
+
+#define BAST_CPLD_CTRL2_WNAND       (0x04)
+#define BAST_CPLD_CTLR2_IDERST      (0x08)
+
+/* CTRL3 - rom write control, CPLD identity */
+
+#define BAST_CPLD_CTRL3_IDMASK      (0x0e)
+#define BAST_CPLD_CTRL3_ROMWEN      (0x01)
+
+/* CTRL4 - 8bit LCD interface control/status */
+
+#define BAST_CPLD_CTRL4_LLAT	    (0x01)
+#define BAST_CPLD_CTRL4_LCDRW	    (0x02)
+#define BAST_CPLD_CTRL4_LCDCMD	    (0x04)
+#define BAST_CPLD_CTRL4_LCDE2	    (0x01)
+
+/* CTRL5 - DMA routing */
+
+#define BAST_CPLD_DMA0_PRIIDE      (0<<0)
+#define BAST_CPLD_DMA0_SECIDE      (1<<0)
+#define BAST_CPLD_DMA0_ISA15       (2<<0)
+#define BAST_CPLD_DMA0_ISA36       (3<<0)
+
+#define BAST_CPLD_DMA1_PRIIDE      (0<<2)
+#define BAST_CPLD_DMA1_SECIDE      (1<<2)
+#define BAST_CPLD_DMA1_ISA15       (2<<2)
+#define BAST_CPLD_DMA1_ISA36       (3<<2)
+
+#endif /* __ASM_ARCH_BASTCPLD_H */
Index: build_tree/linux/include/asm/arch-s3c2410/bast-irq.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/bast-irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/bast-irq.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/* linux/include/asm-arm/arch-s3c2410/bast-irq.h
+ *
+ * Copyright (c) 2003,2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Machine BAST - IRQ Number definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_BASTIRQ_H
+#define __ASM_ARCH_BASTIRQ_H
+
+/* irq numbers to onboard peripherals */
+
+#define IRQ_USBOC      IRQ_EINT18
+#define IRQ_IDE0       IRQ_EINT16
+#define IRQ_IDE1       IRQ_EINT17
+#define IRQ_PCSERIAL1  IRQ_EINT15
+#define IRQ_PCSERIAL2  IRQ_EINT14
+#define IRQ_PCPARALLEL IRQ_EINT13
+#define IRQ_ASIX       IRQ_EINT11
+#define IRQ_DM9000     IRQ_EINT10
+#define IRQ_ISA	       IRQ_EINT9
+#define IRQ_SMALERT    IRQ_EINT8
+
+#endif /* __ASM_ARCH_BASTIRQ_H */
Index: build_tree/linux/include/asm/arch-s3c2410/bast-map.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/bast-map.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/bast-map.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,146 @@
+/* linux/include/asm-arm/arch-s3c2410/bast-map.h
+ *
+ * Copyright (c) 2003,2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Machine BAST - Memory map definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* needs arch/map.h including with this */
+
+/* ok, we've used up to 0x13000000, now we need to find space for the
+ * peripherals that live in the nGCS[x] areas, which are quite numerous
+ * in their space. We also have the board's CPLD to find register space
+ * for.
+ */
+
+#ifndef __ASM_ARCH_BASTMAP_H
+#define __ASM_ARCH_BASTMAP_H
+
+#define BAST_IOADDR(x)	   (S3C2410_ADDR((x) + 0x01300000))
+
+/* we put the CPLD registers next, to get them out of the way */
+
+#define BAST_VA_CTRL1	    BAST_IOADDR(0x00000000)	 /* 0x01300000 */
+#define BAST_PA_CTRL1	    (S3C2410_CS5 | 0x7800000)
+
+#define BAST_VA_CTRL2	    BAST_IOADDR(0x00100000)	 /* 0x01400000 */
+#define BAST_PA_CTRL2	    (S3C2410_CS1 | 0x6000000)
+
+#define BAST_VA_CTRL3	    BAST_IOADDR(0x00200000)	 /* 0x01500000 */
+#define BAST_PA_CTRL3	    (S3C2410_CS1 | 0x6800000)
+
+#define BAST_VA_CTRL4	    BAST_IOADDR(0x00300000)	 /* 0x01600000 */
+#define BAST_PA_CTRL4	    (S3C2410_CS1 | 0x7000000)
+
+/* next, we have the PC104 ISA interrupt registers */
+
+#define BAST_PA_PC104_IRQREQ  (S3C2410_CS5 | 0x6000000) /* 0x01700000 */
+#define BAST_VA_PC104_IRQREQ  BAST_IOADDR(0x00400000)
+
+#define BAST_PA_PC104_IRQRAW  (S3C2410_CS5 | 0x6800000) /* 0x01800000 */
+#define BAST_VA_PC104_IRQRAW  BAST_IOADDR(0x00500000)
+
+#define BAST_PA_PC104_IRQMASK (S3C2410_CS5 | 0x7000000) /* 0x01900000 */
+#define BAST_VA_PC104_IRQMASK BAST_IOADDR(0x00600000)
+
+#define BAST_PA_LCD_RCMD1     (0x8800000)
+#define BAST_VA_LCD_RCMD1     BAST_IOADDR(0x00700000)
+
+#define BAST_PA_LCD_WCMD1     (0x8000000)
+#define BAST_VA_LCD_WCMD1     BAST_IOADDR(0x00800000)
+
+#define BAST_PA_LCD_RDATA1    (0x9800000)
+#define BAST_VA_LCD_RDATA1    BAST_IOADDR(0x00900000)
+
+#define BAST_PA_LCD_WDATA1    (0x9000000)
+#define BAST_VA_LCD_WDATA1    BAST_IOADDR(0x00A00000)
+
+#define BAST_PA_LCD_RCMD2     (0xA800000)
+#define BAST_VA_LCD_RCMD2     BAST_IOADDR(0x00B00000)
+
+#define BAST_PA_LCD_WCMD2     (0xA000000)
+#define BAST_VA_LCD_WCMD2     BAST_IOADDR(0x00C00000)
+
+#define BAST_PA_LCD_RDATA2    (0xB800000)
+#define BAST_VA_LCD_RDATA2    BAST_IOADDR(0x00D00000)
+
+#define BAST_PA_LCD_WDATA2    (0xB000000)
+#define BAST_VA_LCD_WDATA2    BAST_IOADDR(0x00E00000)
+
+
+/* 0xE0000000 contains the IO space that is split by speed and
+ * wether the access is for 8 or 16bit IO... this ensures that
+ * the correct access is made
+ *
+ * 0x10000000 of space, partitioned as so:
+ *
+ * 0x00000000 to 0x04000000  8bit,  slow
+ * 0x04000000 to 0x08000000  16bit, slow
+ * 0x08000000 to 0x0C000000  16bit, net
+ * 0x0C000000 to 0x10000000  16bit, fast
+ *
+ * each of these spaces has the following in:
+ *
+ * 0x00000000 to 0x01000000 16MB ISA IO space
+ * 0x01000000 to 0x02000000 16MB ISA memory space
+ * 0x02000000 to 0x02100000 1MB  IDE primary channel
+ * 0x02100000 to 0x02200000 1MB  IDE primary channel aux
+ * 0x02200000 to 0x02400000 1MB  IDE secondary channel
+ * 0x02300000 to 0x02400000 1MB  IDE secondary channel aux
+ * 0x02400000 to 0x02500000 1MB  ASIX ethernet controller
+ * 0x02500000 to 0x02600000 1MB  Davicom DM9000 ethernet controller
+ * 0x02600000 to 0x02700000 1MB  PC SuperIO controller
+ *
+ * the phyiscal layout of the zones are:
+ *  nGCS2 - 8bit, slow
+ *  nGCS3 - 16bit, slow
+ *  nGCS4 - 16bit, net
+ *  nGCS5 - 16bit, fast
+ */
+
+#define BAST_VA_MULTISPACE (0xE0000000)
+
+#define BAST_VA_ISAIO	   (BAST_VA_MULTISPACE + 0x00000000)
+#define BAST_VA_ISAMEM	   (BAST_VA_MULTISPACE + 0x01000000)
+#define BAST_VA_IDEPRI	   (BAST_VA_MULTISPACE + 0x02000000)
+#define BAST_VA_IDEPRIAUX  (BAST_VA_MULTISPACE + 0x02100000)
+#define BAST_VA_IDESEC	   (BAST_VA_MULTISPACE + 0x02200000)
+#define BAST_VA_IDESECAUX  (BAST_VA_MULTISPACE + 0x02300000)
+#define BAST_VA_ASIXNET	   (BAST_VA_MULTISPACE + 0x02400000)
+#define BAST_VA_DM9000	   (BAST_VA_MULTISPACE + 0x02500000)
+#define BAST_VA_SUPERIO	   (BAST_VA_MULTISPACE + 0x02600000)
+
+#define BAST_VA_MULTISPACE (0xE0000000)
+
+#define BAST_VAM_CS2 (0x00000000)
+#define BAST_VAM_CS3 (0x04000000)
+#define BAST_VAM_CS4 (0x08000000)
+#define BAST_VAM_CS5 (0x0C000000)
+
+/* physical offset addresses for the peripherals */
+
+#define BAST_PA_ISAIO	  (0x00000000)
+#define BAST_PA_ASIXNET	  (0x01000000)
+#define BAST_PA_SUPERIO	  (0x01800000)
+#define BAST_PA_IDEPRI	  (0x02000000)
+#define BAST_PA_IDEPRIAUX (0x02800000)
+#define BAST_PA_IDESEC	  (0x03000000)
+#define BAST_PA_IDESECAUX (0x03800000)
+#define BAST_PA_ISAMEM	  (0x04000000)
+#define BAST_PA_DM9000	  (0x05000000)
+
+/* some configurations for the peripherals */
+
+#define BAST_PCSIO (BAST_VA_SUPERIO + BAST_VAM_CS2)
+/*  */
+
+#define BAST_ASIXNET_CS  BAST_VAM_CS5
+#define BAST_IDE_CS	 BAST_VAM_CS5
+#define BAST_DM9000_CS	 BAST_VAM_CS4
+
+#endif /* __ASM_ARCH_BASTMAP_H */
Index: build_tree/linux/include/asm/arch-s3c2410/bast-pmu.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/bast-pmu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/bast-pmu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/* linux/include/asm-arm/arch-s3c2410/bast-pmu.h
+ *
+ * Copyright (c) 2003,2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	Vincent Sanders <vince@simtec.co.uk>
+ *
+ * Machine BAST - Power Management chip
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_BASTPMU_H
+#define __ASM_ARCH_BASTPMU_H "08_OCT_2004"
+
+#define BASTPMU_REG_IDENT	(0x00)
+#define BASTPMU_REG_VERSION	(0x01)
+#define BASTPMU_REG_DDCCTRL	(0x02)
+#define BASTPMU_REG_POWER	(0x03)
+#define BASTPMU_REG_RESET	(0x04)
+#define BASTPMU_REG_GWO		(0x05)
+#define BASTPMU_REG_WOL		(0x06)
+#define BASTPMU_REG_WOR		(0x07)
+#define BASTPMU_REG_UID		(0x09)
+
+#define BASTPMU_EEPROM		(0xC0)
+
+#define BASTPMU_EEP_UID		(BASTPMU_EEPROM + 0)
+#define BASTPMU_EEP_WOL		(BASTPMU_EEPROM + 8)
+#define BASTPMU_EEP_WOR		(BASTPMU_EEPROM + 9)
+
+#define BASTPMU_IDENT_0		0x53
+#define BASTPMU_IDENT_1		0x42
+#define BASTPMU_IDENT_2		0x50
+#define BASTPMU_IDENT_3		0x4d
+
+#define BASTPMU_RESET_GUARD	(0x55)
+
+#endif /* __ASM_ARCH_BASTPMU_H */
Index: build_tree/linux/include/asm/arch-s3c2410/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,102 @@
+/* linux/include/asm-arm/arch-s3c2410/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Copyright (C) 2005 Simtec Electronics
+ *
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <asm/arch/map.h>
+#include <asm/arch/regs-serial.h>
+#include <asm/arch/regs-gpio.h>
+
+#define S3C2410_UART1_OFF (0x4000)
+#define SHIFT_2440TXF (14-9)
+
+		.macro addruart, rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1
+		ldreq	\rx, = S3C24XX_PA_UART
+		ldrne	\rx, = S3C24XX_VA_UART
+#if CONFIG_DEBUG_S3C2410_UART != 0
+		add	\rx, \rx, #(S3C2410_UART1_OFF * CONFIG_DEBUG_S3C2410_UART)
+#endif
+		.endm
+
+		.macro	senduart,rd,rx
+		strb 	\rd, [\rx, # S3C2410_UTXH ]
+		.endm
+
+		.macro	busyuart, rd, rx
+		ldr	\rd, [ \rx, # S3C2410_UFCON ]
+		tst	\rd, #S3C2410_UFCON_FIFOMODE	@ fifo enabled?
+		beq	1001f				@
+		@ FIFO enabled...
+1003:
+		@ check for arm920 vs arm926. currently assume all arm926
+		@ devices have an 64 byte FIFO identical to the s3c2440
+		mrc	p15, 0, \rd, c0, c0
+		and	\rd, \rd, #0xff0
+		teq	\rd, #0x260
+		beq	1004f
+		mrc	p15, 0, \rd, c1, c0
+		tst	\rd, #1
+		addeq	\rd, \rx, #(S3C24XX_PA_GPIO - S3C24XX_PA_UART)
+		addne	\rd, \rx, #(S3C24XX_VA_GPIO - S3C24XX_VA_UART)
+		bic	\rd, \rd, #0xff000
+		ldr	\rd, [ \rd, # S3C2410_GSTATUS1 - S3C2410_GPIOREG(0) ]
+		and	\rd, \rd, #0x00ff0000
+		teq	\rd, #0x00440000		@ is it 2440?
+1004:
+		ldr	\rd, [ \rx, # S3C2410_UFSTAT ]
+		moveq	\rd, \rd, lsr #SHIFT_2440TXF
+		tst	\rd, #S3C2410_UFSTAT_TXFULL
+		bne	1003b
+		b	1002f
+
+1001:
+		@ busy waiting for non fifo
+		ldr	\rd, [ \rx, # S3C2410_UTRSTAT ]
+		tst	\rd, #S3C2410_UTRSTAT_TXFE
+		beq	1001b
+
+1002:		@ exit busyuart
+		.endm
+
+		.macro	waituart,rd,rx
+
+		ldr	\rd, [ \rx, # S3C2410_UFCON ]
+		tst	\rd, #S3C2410_UFCON_FIFOMODE	@ fifo enabled?
+		beq	1001f				@
+		@ FIFO enabled...
+1003:
+		mrc	p15, 0, \rd, c1, c0
+		tst	\rd, #1
+		addeq	\rd, \rx, #(S3C24XX_PA_GPIO - S3C24XX_PA_UART)
+		addne	\rd, \rx, #(S3C24XX_VA_GPIO - S3C24XX_VA_UART)
+		bic	\rd, \rd, #0xff000
+		ldr	\rd, [ \rd, # S3C2410_GSTATUS1 - S3C2410_GPIOREG(0) ]
+		and	\rd, \rd, #0x00ff0000
+		teq	\rd, #0x00440000		@ is it 2440?
+
+		ldr	\rd, [ \rx, # S3C2410_UFSTAT ]
+		andne	\rd, \rd, #S3C2410_UFSTAT_TXMASK
+		andeq	\rd, \rd, #S3C2440_UFSTAT_TXMASK
+		teq	\rd, #0
+		bne	1003b
+		b	1002f
+
+1001:
+		@ idle waiting for non fifo
+		ldr	\rd, [ \rx, # S3C2410_UTRSTAT ]
+		tst	\rd, #S3C2410_UTRSTAT_TXFE
+		beq	1001b
+
+1002:		@ exit busyuart
+		.endm
Index: build_tree/linux/include/asm/arch-s3c2410/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,452 @@
+/* linux/include/asm-arm/arch-s3c2410/dma.h
+ *
+ * Copyright (C) 2003,2004,2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C241XX DMA support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H __FILE__
+
+#include <linux/sysdev.h>
+#include <asm/hardware.h>
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ *
+ */
+#define MAX_DMA_ADDRESS		0x40000000
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+/* We use `virtual` dma channels to hide the fact we have only a limited
+ * number of DMA channels, and not of all of them (dependant on the device)
+ * can be attached to any DMA source. We therefore let the DMA core handle
+ * the allocation of hardware channels to clients.
+*/
+
+enum dma_ch {
+	DMACH_XD0,
+	DMACH_XD1,
+	DMACH_SDI,
+	DMACH_SPI0,
+	DMACH_SPI1,
+	DMACH_UART0,
+	DMACH_UART1,
+	DMACH_UART2,
+	DMACH_TIMER,
+	DMACH_I2S_IN,
+	DMACH_I2S_OUT,
+	DMACH_PCM_IN,
+	DMACH_PCM_OUT,
+	DMACH_MIC_IN,
+	DMACH_USB_EP1,
+	DMACH_USB_EP2,
+	DMACH_USB_EP3,
+	DMACH_USB_EP4,
+	DMACH_UART0_SRC2,	/* s3c2412 second uart sources */
+	DMACH_UART1_SRC2,
+	DMACH_UART2_SRC2,
+	DMACH_UART3,		/* s3c2443 has extra uart */
+	DMACH_UART3_SRC2,
+	DMACH_MAX,		/* the end entry */
+};
+
+#define DMACH_LOW_LEVEL	(1<<28)	/* use this to specifiy hardware ch no */
+
+/* we have 4 dma channels */
+#ifndef CONFIG_CPU_S3C2443
+#define S3C2410_DMA_CHANNELS		(4)
+#else
+#define S3C2410_DMA_CHANNELS		(6)
+#endif
+
+/* types */
+
+enum s3c2410_dma_state {
+	S3C2410_DMA_IDLE,
+	S3C2410_DMA_RUNNING,
+	S3C2410_DMA_PAUSED
+};
+
+
+/* enum s3c2410_dma_loadst
+ *
+ * This represents the state of the DMA engine, wrt to the loaded / running
+ * transfers. Since we don't have any way of knowing exactly the state of
+ * the DMA transfers, we need to know the state to make decisions on wether
+ * we can
+ *
+ * S3C2410_DMA_NONE
+ *
+ * There are no buffers loaded (the channel should be inactive)
+ *
+ * S3C2410_DMA_1LOADED
+ *
+ * There is one buffer loaded, however it has not been confirmed to be
+ * loaded by the DMA engine. This may be because the channel is not
+ * yet running, or the DMA driver decided that it was too costly to
+ * sit and wait for it to happen.
+ *
+ * S3C2410_DMA_1RUNNING
+ *
+ * The buffer has been confirmed running, and not finisged
+ *
+ * S3C2410_DMA_1LOADED_1RUNNING
+ *
+ * There is a buffer waiting to be loaded by the DMA engine, and one
+ * currently running.
+*/
+
+enum s3c2410_dma_loadst {
+	S3C2410_DMALOAD_NONE,
+	S3C2410_DMALOAD_1LOADED,
+	S3C2410_DMALOAD_1RUNNING,
+	S3C2410_DMALOAD_1LOADED_1RUNNING,
+};
+
+enum s3c2410_dma_buffresult {
+	S3C2410_RES_OK,
+	S3C2410_RES_ERR,
+	S3C2410_RES_ABORT
+};
+
+enum s3c2410_dmasrc {
+	S3C2410_DMASRC_HW,		/* source is memory */
+	S3C2410_DMASRC_MEM		/* source is hardware */
+};
+
+/* enum s3c2410_chan_op
+ *
+ * operation codes passed to the DMA code by the user, and also used
+ * to inform the current channel owner of any changes to the system state
+*/
+
+enum s3c2410_chan_op {
+	S3C2410_DMAOP_START,
+	S3C2410_DMAOP_STOP,
+	S3C2410_DMAOP_PAUSE,
+	S3C2410_DMAOP_RESUME,
+	S3C2410_DMAOP_FLUSH,
+	S3C2410_DMAOP_TIMEOUT,		/* internal signal to handler */
+	S3C2410_DMAOP_STARTED,		/* indicate channel started */
+};
+
+/* flags */
+
+#define S3C2410_DMAF_SLOW         (1<<0)   /* slow, so don't worry about
+					    * waiting for reloads */
+#define S3C2410_DMAF_AUTOSTART    (1<<1)   /* auto-start if buffer queued */
+
+/* dma buffer */
+
+struct s3c2410_dma_client {
+	char                *name;
+};
+
+/* s3c2410_dma_buf_s
+ *
+ * internally used buffer structure to describe a queued or running
+ * buffer.
+*/
+
+struct s3c2410_dma_buf;
+struct s3c2410_dma_buf {
+	struct s3c2410_dma_buf	*next;
+	int			 magic;		/* magic */
+	int			 size;		/* buffer size in bytes */
+	dma_addr_t		 data;		/* start of DMA data */
+	dma_addr_t		 ptr;		/* where the DMA got to [1] */
+	void			*id;		/* client's id */
+};
+
+/* [1] is this updated for both recv/send modes? */
+
+struct s3c2410_dma_chan;
+
+/* s3c2410_dma_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*s3c2410_dma_cbfn_t)(struct s3c2410_dma_chan *,
+				   void *buf, int size,
+				   enum s3c2410_dma_buffresult result);
+
+typedef int  (*s3c2410_dma_opfn_t)(struct s3c2410_dma_chan *,
+				   enum s3c2410_chan_op );
+
+struct s3c2410_dma_stats {
+	unsigned long		loads;
+	unsigned long		timeout_longest;
+	unsigned long		timeout_shortest;
+	unsigned long		timeout_avg;
+	unsigned long		timeout_failed;
+};
+
+struct s3c2410_dma_map;
+
+/* struct s3c2410_dma_chan
+ *
+ * full state information for each DMA channel
+*/
+
+struct s3c2410_dma_chan {
+	/* channel state flags and information */
+	unsigned char		 number;      /* number of this dma channel */
+	unsigned char		 in_use;      /* channel allocated */
+	unsigned char		 irq_claimed; /* irq claimed for channel */
+	unsigned char		 irq_enabled; /* irq enabled for channel */
+	unsigned char		 xfer_unit;   /* size of an transfer */
+
+	/* channel state */
+
+	enum s3c2410_dma_state	 state;
+	enum s3c2410_dma_loadst	 load_state;
+	struct s3c2410_dma_client *client;
+
+	/* channel configuration */
+	enum s3c2410_dmasrc	 source;
+	unsigned long		 dev_addr;
+	unsigned long		 load_timeout;
+	unsigned int		 flags;		/* channel flags */
+
+	struct s3c24xx_dma_map	*map;		/* channel hw maps */
+
+	/* channel's hardware position and configuration */
+	void __iomem		*regs;		/* channels registers */
+	void __iomem		*addr_reg;	/* data address register */
+	unsigned int		 irq;		/* channel irq */
+	unsigned long		 dcon;		/* default value of DCON */
+
+	/* driver handles */
+	s3c2410_dma_cbfn_t	 callback_fn;	/* buffer done callback */
+	s3c2410_dma_opfn_t	 op_fn;		/* channel op callback */
+
+	/* stats gathering */
+	struct s3c2410_dma_stats *stats;
+	struct s3c2410_dma_stats  stats_store;
+
+	/* buffer list and information */
+	struct s3c2410_dma_buf	*curr;		/* current dma buffer */
+	struct s3c2410_dma_buf	*next;		/* next buffer to load */
+	struct s3c2410_dma_buf	*end;		/* end of queue */
+
+	/* system device */
+	struct sys_device	dev;
+};
+
+/* the currently allocated channel information */
+extern struct s3c2410_dma_chan s3c2410_chans[];
+
+/* note, we don't really use dma_device_t at the moment */
+typedef unsigned long dma_device_t;
+
+/* functions --------------------------------------------------------------- */
+
+/* s3c2410_dma_request
+ *
+ * request a dma channel exclusivley
+*/
+
+extern int s3c2410_dma_request(dmach_t channel,
+			       struct s3c2410_dma_client *, void *dev);
+
+
+/* s3c2410_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+extern int s3c2410_dma_ctrl(dmach_t channel, enum s3c2410_chan_op op);
+
+/* s3c2410_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+extern int s3c2410_dma_setflags(dmach_t channel,
+				unsigned int flags);
+
+/* s3c2410_dma_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int s3c2410_dma_free(dmach_t channel, struct s3c2410_dma_client *);
+
+/* s3c2410_dma_enqueue
+ *
+ * place the given buffer onto the queue of operations for the channel.
+ * The buffer must be allocated from dma coherent memory, or the Dcache/WB
+ * drained before the buffer is given to the DMA system.
+*/
+
+extern int s3c2410_dma_enqueue(dmach_t channel, void *id,
+			       dma_addr_t data, int size);
+
+/* s3c2410_dma_config
+ *
+ * configure the dma channel
+*/
+
+extern int s3c2410_dma_config(dmach_t channel, int xferunit, int dcon);
+
+/* s3c2410_dma_devconfig
+ *
+ * configure the device we're talking to
+*/
+
+extern int s3c2410_dma_devconfig(int channel, enum s3c2410_dmasrc source,
+				 int hwcfg, unsigned long devaddr);
+
+/* s3c2410_dma_getposition
+ *
+ * get the position that the dma transfer is currently at
+*/
+
+extern int s3c2410_dma_getposition(dmach_t channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+extern int s3c2410_dma_set_opfn(dmach_t, s3c2410_dma_opfn_t rtn);
+extern int s3c2410_dma_set_buffdone_fn(dmach_t, s3c2410_dma_cbfn_t rtn);
+
+/* DMA Register definitions */
+
+#define S3C2410_DMA_DISRC       (0x00)
+#define S3C2410_DMA_DISRCC      (0x04)
+#define S3C2410_DMA_DIDST       (0x08)
+#define S3C2410_DMA_DIDSTC      (0x0C)
+#define S3C2410_DMA_DCON        (0x10)
+#define S3C2410_DMA_DSTAT       (0x14)
+#define S3C2410_DMA_DCSRC       (0x18)
+#define S3C2410_DMA_DCDST       (0x1C)
+#define S3C2410_DMA_DMASKTRIG   (0x20)
+#define S3C2412_DMA_DMAREQSEL	(0x24)
+#define S3C2443_DMA_DMAREQSEL	(0x24)
+
+#define S3C2410_DISRCC_INC	(1<<0)
+#define S3C2410_DISRCC_APB	(1<<1)
+
+#define S3C2410_DMASKTRIG_STOP   (1<<2)
+#define S3C2410_DMASKTRIG_ON     (1<<1)
+#define S3C2410_DMASKTRIG_SWTRIG (1<<0)
+
+#define S3C2410_DCON_DEMAND     (0<<31)
+#define S3C2410_DCON_HANDSHAKE  (1<<31)
+#define S3C2410_DCON_SYNC_PCLK  (0<<30)
+#define S3C2410_DCON_SYNC_HCLK  (1<<30)
+
+#define S3C2410_DCON_INTREQ     (1<<29)
+
+#define S3C2410_DCON_CH0_XDREQ0	(0<<24)
+#define S3C2410_DCON_CH0_UART0	(1<<24)
+#define S3C2410_DCON_CH0_SDI	(2<<24)
+#define S3C2410_DCON_CH0_TIMER	(3<<24)
+#define S3C2410_DCON_CH0_USBEP1	(4<<24)
+
+#define S3C2410_DCON_CH1_XDREQ1	(0<<24)
+#define S3C2410_DCON_CH1_UART1	(1<<24)
+#define S3C2410_DCON_CH1_I2SSDI	(2<<24)
+#define S3C2410_DCON_CH1_SPI	(3<<24)
+#define S3C2410_DCON_CH1_USBEP2	(4<<24)
+
+#define S3C2410_DCON_CH2_I2SSDO	(0<<24)
+#define S3C2410_DCON_CH2_I2SSDI	(1<<24)
+#define S3C2410_DCON_CH2_SDI	(2<<24)
+#define S3C2410_DCON_CH2_TIMER	(3<<24)
+#define S3C2410_DCON_CH2_USBEP3	(4<<24)
+
+#define S3C2410_DCON_CH3_UART2	(0<<24)
+#define S3C2410_DCON_CH3_SDI	(1<<24)
+#define S3C2410_DCON_CH3_SPI	(2<<24)
+#define S3C2410_DCON_CH3_TIMER	(3<<24)
+#define S3C2410_DCON_CH3_USBEP4	(4<<24)
+
+#define S3C2410_DCON_SRCSHIFT   (24)
+#define S3C2410_DCON_SRCMASK	(7<<24)
+
+#define S3C2410_DCON_BYTE       (0<<20)
+#define S3C2410_DCON_HALFWORD   (1<<20)
+#define S3C2410_DCON_WORD       (2<<20)
+
+#define S3C2410_DCON_AUTORELOAD (0<<22)
+#define S3C2410_DCON_NORELOAD   (1<<22)
+#define S3C2410_DCON_HWTRIG     (1<<23)
+
+#ifdef CONFIG_CPU_S3C2440
+#define S3C2440_DIDSTC_CHKINT	(1<<2)
+
+#define S3C2440_DCON_CH0_I2SSDO	(5<<24)
+#define S3C2440_DCON_CH0_PCMIN	(6<<24)
+
+#define S3C2440_DCON_CH1_PCMOUT	(5<<24)
+#define S3C2440_DCON_CH1_SDI	(6<<24)
+
+#define S3C2440_DCON_CH2_PCMIN	(5<<24)
+#define S3C2440_DCON_CH2_MICIN	(6<<24)
+
+#define S3C2440_DCON_CH3_MICIN	(5<<24)
+#define S3C2440_DCON_CH3_PCMOUT	(6<<24)
+#endif
+
+#ifdef CONFIG_CPU_S3C2412
+
+#define S3C2412_DMAREQSEL_SRC(x)	((x)<<1)
+
+#define S3C2412_DMAREQSEL_HW		(1)
+
+#define S3C2412_DMAREQSEL_SPI0TX	S3C2412_DMAREQSEL_SRC(0)
+#define S3C2412_DMAREQSEL_SPI0RX	S3C2412_DMAREQSEL_SRC(1)
+#define S3C2412_DMAREQSEL_SPI1TX	S3C2412_DMAREQSEL_SRC(2)
+#define S3C2412_DMAREQSEL_SPI1RX	S3C2412_DMAREQSEL_SRC(3)
+#define S3C2412_DMAREQSEL_I2STX		S3C2412_DMAREQSEL_SRC(4)
+#define S3C2412_DMAREQSEL_I2SRX		S3C2412_DMAREQSEL_SRC(5)
+#define S3C2412_DMAREQSEL_TIMER		S3C2412_DMAREQSEL_SRC(9)
+#define S3C2412_DMAREQSEL_SDI		S3C2412_DMAREQSEL_SRC(10)
+#define S3C2412_DMAREQSEL_USBEP1	S3C2412_DMAREQSEL_SRC(13)
+#define S3C2412_DMAREQSEL_USBEP2	S3C2412_DMAREQSEL_SRC(14)
+#define S3C2412_DMAREQSEL_USBEP3	S3C2412_DMAREQSEL_SRC(15)
+#define S3C2412_DMAREQSEL_USBEP4	S3C2412_DMAREQSEL_SRC(16)
+#define S3C2412_DMAREQSEL_XDREQ0	S3C2412_DMAREQSEL_SRC(17)
+#define S3C2412_DMAREQSEL_XDREQ1	S3C2412_DMAREQSEL_SRC(18)
+#define S3C2412_DMAREQSEL_UART0_0	S3C2412_DMAREQSEL_SRC(19)
+#define S3C2412_DMAREQSEL_UART0_1	S3C2412_DMAREQSEL_SRC(20)
+#define S3C2412_DMAREQSEL_UART1_0	S3C2412_DMAREQSEL_SRC(21)
+#define S3C2412_DMAREQSEL_UART1_1	S3C2412_DMAREQSEL_SRC(22)
+#define S3C2412_DMAREQSEL_UART2_0	S3C2412_DMAREQSEL_SRC(23)
+#define S3C2412_DMAREQSEL_UART2_1	S3C2412_DMAREQSEL_SRC(24)
+
+#endif
+
+#define S3C2443_DMAREQSEL_SRC(x)	((x)<<1)
+
+#define S3C2443_DMAREQSEL_HW		(1)
+
+#define S3C2443_DMAREQSEL_SPI0TX	S3C2443_DMAREQSEL_SRC(0)
+#define S3C2443_DMAREQSEL_SPI0RX	S3C2443_DMAREQSEL_SRC(1)
+#define S3C2443_DMAREQSEL_SPI1TX	S3C2443_DMAREQSEL_SRC(2)
+#define S3C2443_DMAREQSEL_SPI1RX	S3C2443_DMAREQSEL_SRC(3)
+#define S3C2443_DMAREQSEL_I2STX		S3C2443_DMAREQSEL_SRC(4)
+#define S3C2443_DMAREQSEL_I2SRX		S3C2443_DMAREQSEL_SRC(5)
+#define S3C2443_DMAREQSEL_TIMER		S3C2443_DMAREQSEL_SRC(9)
+#define S3C2443_DMAREQSEL_SDI		S3C2443_DMAREQSEL_SRC(10)
+#define S3C2443_DMAREQSEL_XDREQ0	S3C2443_DMAREQSEL_SRC(17)
+#define S3C2443_DMAREQSEL_XDREQ1	S3C2443_DMAREQSEL_SRC(18)
+#define S3C2443_DMAREQSEL_UART0_0	S3C2443_DMAREQSEL_SRC(19)
+#define S3C2443_DMAREQSEL_UART0_1	S3C2443_DMAREQSEL_SRC(20)
+#define S3C2443_DMAREQSEL_UART1_0	S3C2443_DMAREQSEL_SRC(21)
+#define S3C2443_DMAREQSEL_UART1_1	S3C2443_DMAREQSEL_SRC(22)
+#define S3C2443_DMAREQSEL_UART2_0	S3C2443_DMAREQSEL_SRC(23)
+#define S3C2443_DMAREQSEL_UART2_1	S3C2443_DMAREQSEL_SRC(24)
+#define S3C2443_DMAREQSEL_UART3_0	S3C2443_DMAREQSEL_SRC(25)
+#define S3C2443_DMAREQSEL_UART3_1	S3C2443_DMAREQSEL_SRC(26)
+#define S3C2443_DMAREQSEL_PCMOUT	S3C2443_DMAREQSEL_SRC(27)
+#define S3C2443_DMAREQSEL_PCMIN 	S3C2443_DMAREQSEL_SRC(28)
+#define S3C2443_DMAREQSEL_MICIN		S3C2443_DMAREQSEL_SRC(29)
+
+#endif /* __ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-s3c2410/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,78 @@
+/*
+ * include/asm-arm/arch-s3c2410/entry-macro.S
+ *
+ * Low-level IRQ helper macros for S3C2410-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+*/
+
+/* We have a problem that the INTOFFSET register does not always
+ * show one interrupt. Occasionally we get two interrupts through
+ * the prioritiser, and this causes the INTOFFSET register to show
+ * what looks like the logical-or of the two interrupt numbers.
+ *
+ * Thanks to Klaus, Shannon, et al for helping to debug this problem
+*/
+
+#define INTPND		(0x10)
+#define INTOFFSET	(0x14)
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		mov	\base, #S3C24XX_VA_IRQ
+
+		@@ try the interrupt offset register, since it is there
+
+		ldr	\irqstat, [ \base, #INTPND ]
+		teq	\irqstat, #0
+		beq	1002f
+		ldr	\irqnr, [ \base, #INTOFFSET ]
+		mov	\tmp, #1
+		tst	\irqstat, \tmp, lsl \irqnr
+		bne	1001f
+
+		@@ the number specified is not a valid irq, so try
+		@@ and work it out for ourselves
+
+		mov	\irqnr, #0		@@ start here
+
+		@@ work out which irq (if any) we got
+
+		movs	\tmp, \irqstat, lsl#16
+		addeq	\irqnr, \irqnr, #16
+		moveq	\irqstat, \irqstat, lsr#16
+		tst	\irqstat, #0xff
+		addeq	\irqnr, \irqnr, #8
+		moveq	\irqstat, \irqstat, lsr#8
+		tst	\irqstat, #0xf
+		addeq	\irqnr, \irqnr, #4
+		moveq	\irqstat, \irqstat, lsr#4
+		tst	\irqstat, #0x3
+		addeq	\irqnr, \irqnr, #2
+		moveq	\irqstat, \irqstat, lsr#2
+		tst	\irqstat, #0x1
+		addeq	\irqnr, \irqnr, #1
+
+		@@ we have the value
+1001:
+		adds	\irqnr, \irqnr, #IRQ_EINT0
+1002:
+		@@ exit here, Z flag unset if IRQ
+
+	.endm
+
+		/* currently don't need an disable_fiq macro */
+
+		.macro	disable_fiq
+		.endm
Index: build_tree/linux/include/asm/arch-s3c2410/fb.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/fb.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/fb.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,66 @@
+/* linux/include/asm-arm/arch-s3c2410/fb.h
+ *
+ * Copyright (c) 2004 Arnaud Patard <arnaud.patard@rtp-net.org>
+ *
+ * Inspired by pxafb.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARM_FB_H
+#define __ASM_ARM_FB_H
+
+#include <asm/arch/regs-lcd.h>
+
+struct s3c2410fb_val {
+	unsigned int	defval;
+	unsigned int	min;
+	unsigned int	max;
+};
+
+struct s3c2410fb_hw {
+	unsigned long	lcdcon1;
+	unsigned long	lcdcon2;
+	unsigned long	lcdcon3;
+	unsigned long	lcdcon4;
+	unsigned long	lcdcon5;
+};
+
+struct s3c2410fb_mach_info {
+	unsigned char	fixed_syncs;	/* do not update sync/border */
+
+	/* LCD types */
+	int		type;
+
+	/* Screen size */
+	int		width;
+	int		height;
+
+	/* Screen info */
+	struct s3c2410fb_val xres;
+	struct s3c2410fb_val yres;
+	struct s3c2410fb_val bpp;
+
+	/* lcd configuration registers */
+	struct s3c2410fb_hw  regs;
+
+	/* GPIOs */
+
+	unsigned long	gpcup;
+	unsigned long	gpcup_mask;
+	unsigned long	gpccon;
+	unsigned long	gpccon_mask;
+	unsigned long	gpdup;
+	unsigned long	gpdup_mask;
+	unsigned long	gpdcon;
+	unsigned long	gpdcon_mask;
+
+	/* lpc3600 control register */
+	unsigned long	lpcsel;
+};
+
+extern void __init s3c24xx_fb_set_platdata(struct s3c2410fb_mach_info *);
+
+#endif /* __ASM_ARM_FB_H */
Index: build_tree/linux/include/asm/arch-s3c2410/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,68 @@
+/*
+ * linux/include/asm-arm/arch-s3c2410/gpio.h
+ *
+ * S3C2410 GPIO wrappers for arch-neutral GPIO calls
+ *
+ * Written by Philipp Zabel <philipp.zabel@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __ASM_ARCH_S3C2410_GPIO_H
+#define __ASM_ARCH_S3C2410_GPIO_H
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/arch/regs-gpio.h>
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+	return;
+}
+
+static inline int gpio_direction_input(unsigned gpio)
+{
+	s3c2410_gpio_cfgpin(gpio, S3C2410_GPIO_INPUT);
+	return 0;
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	s3c2410_gpio_cfgpin(gpio, S3C2410_GPIO_OUTPUT);
+	/* REVISIT can we write the value first, to avoid glitching? */
+	s3c2410_gpio_setpin(gpio, value);
+	return 0;
+}
+
+#define gpio_get_value(gpio)		s3c2410_gpio_getpin(gpio)
+#define gpio_set_value(gpio,value)	s3c2410_gpio_setpin(gpio, value)
+
+#include <asm-generic/gpio.h>			/* cansleep wrappers */
+
+#ifdef CONFIG_CPU_S3C2400
+#define gpio_to_irq(gpio)		s3c2400_gpio_getirq(gpio)
+#else
+#define gpio_to_irq(gpio)		s3c2410_gpio_getirq(gpio)
+#endif
+
+/* FIXME implement irq_to_gpio() */
+
+#endif
Index: build_tree/linux/include/asm/arch-s3c2410/h1940-latch.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/h1940-latch.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/h1940-latch.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,64 @@
+/* linux/include/asm-arm/arch-s3c2410/h1940-latch.h
+ *
+ * Copyright (c) 2005 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ *  iPAQ H1940 series - latch definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_H1940_LATCH_H
+#define __ASM_ARCH_H1940_LATCH_H
+
+
+#ifndef __ASSEMBLY__
+#define H1940_LATCH		((void __force __iomem *)0xF8000000)
+#else
+#define H1940_LATCH		0xF8000000
+#endif
+
+#define H1940_PA_LATCH		(S3C2410_CS2)
+
+/* SD layer latch */
+
+#define H1940_LATCH_SDQ1		(1<<16)
+#define H1940_LATCH_LCD_P1		(1<<17)
+#define H1940_LATCH_LCD_P2		(1<<18)
+#define H1940_LATCH_LCD_P3		(1<<19)
+#define H1940_LATCH_MAX1698_nSHUTDOWN	(1<<20)		/* LCD backlight */
+#define H1940_LATCH_LED_RED		(1<<21)
+#define H1940_LATCH_SDQ7		(1<<22)
+#define H1940_LATCH_USB_DP		(1<<23)
+
+/* CPU layer latch */
+
+#define H1940_LATCH_UDA_POWER		(1<<24)
+#define H1940_LATCH_AUDIO_POWER		(1<<25)
+#define H1940_LATCH_SM803_ENABLE	(1<<26)
+#define H1940_LATCH_LCD_P4		(1<<27)
+#define H1940_LATCH_CPUQ5		(1<<28)		/* untraced */
+#define H1940_LATCH_BLUETOOTH_POWER	(1<<29)		/* active high */
+#define H1940_LATCH_LED_GREEN		(1<<30)
+#define H1940_LATCH_LED_FLASH		(1<<31)
+
+/* default settings */
+
+#define H1940_LATCH_DEFAULT		\
+	H1940_LATCH_LCD_P4		| \
+	H1940_LATCH_SM803_ENABLE	| \
+	H1940_LATCH_SDQ1		| \
+	H1940_LATCH_LCD_P1		| \
+	H1940_LATCH_LCD_P2		| \
+	H1940_LATCH_LCD_P3		| \
+	H1940_LATCH_MAX1698_nSHUTDOWN   | \
+	H1940_LATCH_CPUQ5
+
+/* control functions */
+
+extern void h1940_latch_control(unsigned int clear, unsigned int set);
+
+#endif /* __ASM_ARCH_H1940_LATCH_H */
Index: build_tree/linux/include/asm/arch-s3c2410/h1940.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/h1940.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/h1940.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/* linux/include/asm-arm/arch-s3c2410/h1940.h
+ *
+ * Copyright 2006 Ben Dooks <ben-linux@fluff.org>
+ *
+ * H1940 definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_H1940_H
+#define __ASM_ARCH_H1940_H
+
+#define H1940_SUSPEND_CHECKSUM		(0x30003ff8)
+#define H1940_SUSPEND_RESUMEAT		(0x30081000)
+#define H1940_SUSPEND_CHECK		(0x30080000)
+
+extern void h1940_pm_return(void);
+
+#endif /* __ASM_ARCH_H1940_H */
Index: build_tree/linux/include/asm/arch-s3c2410/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,113 @@
+/* linux/include/asm-arm/arch-s3c2410/hardware.h
+ *
+ * Copyright (c) 2003 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - hardware
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#ifndef __ASM_HARDWARE_H
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#ifndef __ASSEMBLY__
+
+/* external functions for GPIO support
+ *
+ * These allow various different clients to access the same GPIO
+ * registers without conflicting. If your driver only owns the entire
+ * GPIO register, then it is safe to ioremap/__raw_{read|write} to it.
+*/
+
+/* s3c2410_gpio_cfgpin
+ *
+ * set the configuration of the given pin to the value passed.
+ *
+ * eg:
+ *    s3c2410_gpio_cfgpin(S3C2410_GPA0, S3C2410_GPA0_ADDR0);
+ *    s3c2410_gpio_cfgpin(S3C2410_GPE8, S3C2410_GPE8_SDDAT1);
+*/
+
+extern void s3c2410_gpio_cfgpin(unsigned int pin, unsigned int function);
+
+extern unsigned int s3c2410_gpio_getcfg(unsigned int pin);
+
+/* s3c2410_gpio_getirq
+ *
+ * turn the given pin number into the corresponding IRQ number
+ *
+ * returns:
+ *	< 0 = no interrupt for this pin
+ *	>=0 = interrupt number for the pin
+*/
+
+extern int s3c2410_gpio_getirq(unsigned int pin);
+
+#ifdef CONFIG_CPU_S3C2400
+
+extern int s3c2400_gpio_getirq(unsigned int pin);
+
+#endif /* CONFIG_CPU_S3C2400 */
+
+/* s3c2410_gpio_irqfilter
+ *
+ * set the irq filtering on the given pin
+ *
+ * on = 0 => disable filtering
+ *      1 => enable filtering
+ *
+ * config = S3C2410_EINTFLT_PCLK or S3C2410_EINTFLT_EXTCLK orred with
+ *          width of filter (0 through 63)
+ *
+ *
+*/
+
+extern int s3c2410_gpio_irqfilter(unsigned int pin, unsigned int on,
+				  unsigned int config);
+
+/* s3c2410_gpio_pullup
+ *
+ * configure the pull-up control on the given pin
+ *
+ * to = 1 => disable the pull-up
+ *      0 => enable the pull-up
+ *
+ * eg;
+ *
+ *   s3c2410_gpio_pullup(S3C2410_GPB0, 0);
+ *   s3c2410_gpio_pullup(S3C2410_GPE8, 0);
+*/
+
+extern void s3c2410_gpio_pullup(unsigned int pin, unsigned int to);
+
+extern void s3c2410_gpio_setpin(unsigned int pin, unsigned int to);
+
+extern unsigned int s3c2410_gpio_getpin(unsigned int pin);
+
+extern unsigned int s3c2410_modify_misccr(unsigned int clr, unsigned int chg);
+
+#ifdef CONFIG_CPU_S3C2440
+
+extern int s3c2440_set_dsc(unsigned int pin, unsigned int value);
+
+#endif /* CONFIG_CPU_S3C2440 */
+
+
+#endif /* __ASSEMBLY__ */
+
+#include <asm/sizes.h>
+#include <asm/arch/map.h>
+
+/* machine specific hardware definitions should go after this */
+
+/* currently here until moved into config (todo) */
+#define CONFIG_NO_MULTIWORD_IO
+
+#endif /* __ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-s3c2410/idle.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/idle.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/idle.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,24 @@
+/* linux/include/asm-arm/arch-s3c2410/idle.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 CPU Idle controls
+*/
+
+#ifndef __ASM_ARCH_IDLE_H
+#define __ASM_ARCH_IDLE_H __FILE__
+
+/* This allows the over-ride of the default idle code, in case there
+ * is any other things to be done over idle (like DVS)
+*/
+
+extern void (*s3c24xx_idle)(void);
+
+extern void s3c24xx_default_idle(void);
+
+#endif /* __ASM_ARCH_IDLE_H */
Index: build_tree/linux/include/asm/arch-s3c2410/iic.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/iic.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/iic.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/* linux/include/asm-arm/arch-s3c2410/iic.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - I2C Controller platfrom_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_IIC_H
+#define __ASM_ARCH_IIC_H __FILE__
+
+#define S3C_IICFLG_FILTER	(1<<0)	/* enable s3c2440 filter */
+
+/* Notes:
+ *	1) All frequencies are expressed in Hz
+ *	2) A value of zero is `do not care`
+*/
+
+struct s3c2410_platform_i2c {
+	unsigned int	flags;
+	unsigned int	slave_addr;	/* slave address for controller */
+	unsigned long	bus_freq;	/* standard bus frequency */
+	unsigned long	max_freq;	/* max frequency for the bus */
+	unsigned long	min_freq;	/* min frequency for the bus */
+	unsigned int	sda_delay;	/* pclks (s3c2440 only) */
+};
+
+#endif /* __ASM_ARCH_IIC_H */
Index: build_tree/linux/include/asm/arch-s3c2410/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,218 @@
+/*
+ * linux/include/asm-arm/arch-s3c2410/io.h
+ *  from linux/include/asm-arm/arch-rpc/io.h
+ *
+ * Copyright (C) 1997 Russell King
+ *	     (C) 2003 Simtec Electronics
+*/
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We use two different types of addressing - PC style addresses, and ARM
+ * addresses.  PC style accesses the PC hardware with the normal PC IO
+ * addresses, eg 0x3f8 for serial#1.  ARM addresses are above A28
+ * and are translated to the start of IO.  Note that all addresses are
+ * not shifted left!
+ */
+
+#define __PORT_PCIO(x)	((x) < (1<<28))
+
+#define PCIO_BASE	 (S3C24XX_VA_ISA_WORD)
+#define PCIO_BASE_b	 (S3C24XX_VA_ISA_BYTE)
+#define PCIO_BASE_w	 (S3C24XX_VA_ISA_WORD)
+#define PCIO_BASE_l	 (S3C24XX_VA_ISA_WORD)
+/*
+ * Dynamic IO functions - let the compiler
+ * optimize the expressions
+ */
+
+#define DECLARE_DYN_OUT(sz,fnsuffix,instr) \
+static inline void __out##fnsuffix (unsigned int val, unsigned int port) \
+{ \
+	unsigned long temp;				      \
+	__asm__ __volatile__(				      \
+	"cmp	%2, #(1<<28)\n\t"			      \
+	"mov	%0, %2\n\t"				      \
+	"addcc	%0, %0, %3\n\t"				      \
+	"str" instr " %1, [%0, #0 ]	@ out" #fnsuffix      \
+	: "=&r" (temp)					      \
+	: "r" (val), "r" (port), "Ir" (PCIO_BASE_##fnsuffix)  \
+	: "cc");					      \
+}
+
+
+#define DECLARE_DYN_IN(sz,fnsuffix,instr)				\
+static inline unsigned sz __in##fnsuffix (unsigned int port)		\
+{									\
+	unsigned long temp, value;					\
+	__asm__ __volatile__(						\
+	"cmp	%2, #(1<<28)\n\t"					\
+	"mov	%0, %2\n\t"						\
+	"addcc	%0, %0, %3\n\t"						\
+	"ldr" instr "	%1, [%0, #0 ]	@ in" #fnsuffix		\
+	: "=&r" (temp), "=r" (value)					\
+	: "r" (port), "Ir" (PCIO_BASE_##fnsuffix)	\
+	: "cc");							\
+	return (unsigned sz)value;					\
+}
+
+static inline void __iomem *__ioaddr (unsigned long port)
+{
+	return __PORT_PCIO(port) ? (PCIO_BASE + port) : (void __iomem *)port;
+}
+
+#define DECLARE_IO(sz,fnsuffix,instr)	\
+	DECLARE_DYN_IN(sz,fnsuffix,instr) \
+	DECLARE_DYN_OUT(sz,fnsuffix,instr)
+
+DECLARE_IO(char,b,"b")
+DECLARE_IO(short,w,"h")
+DECLARE_IO(int,l,"")
+
+#undef DECLARE_IO
+#undef DECLARE_DYN_IN
+
+/*
+ * Constant address IO functions
+ *
+ * These have to be macros for the 'J' constraint to work -
+ * +/-4096 immediate operand.
+ */
+#define __outbc(value,port)						\
+({									\
+	if (__PORT_PCIO((port)))					\
+		__asm__ __volatile__(					\
+		"strb	%0, [%1, %2]	@ outbc"			\
+		: : "r" (value), "r" (PCIO_BASE), "Jr" ((port)));	\
+	else								\
+		__asm__ __volatile__(					\
+		"strb	%0, [%1, #0]	@ outbc"			\
+		: : "r" (value), "r" ((port)));				\
+})
+
+#define __inbc(port)							\
+({									\
+	unsigned char result;						\
+	if (__PORT_PCIO((port)))					\
+		__asm__ __volatile__(					\
+		"ldrb	%0, [%1, %2]	@ inbc"				\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port)));	\
+	else								\
+		__asm__ __volatile__(					\
+		"ldrb	%0, [%1, #0]	@ inbc"				\
+		: "=r" (result) : "r" ((port)));			\
+	result;								\
+})
+
+#define __outwc(value,port)						\
+({									\
+	unsigned long v = value;					\
+	if (__PORT_PCIO((port))) {					\
+		if ((port) < 256 && (port) > -256)			\
+			__asm__ __volatile__(				\
+			"strh	%0, [%1, %2]	@ outwc"		\
+			: : "r" (v), "r" (PCIO_BASE), "Jr" ((port)));	\
+		else if ((port) > 0)					\
+			__asm__ __volatile__(				\
+			"strh	%0, [%1, %2]	@ outwc"		\
+			: : "r" (v),					\
+			    "r" (PCIO_BASE + ((port) & ~0xff)),		\
+			     "Jr" (((port) & 0xff)));			\
+		else							\
+			__asm__ __volatile__(				\
+			"strh	%0, [%1, #0]	@ outwc"		\
+			: : "r" (v),					\
+			    "r" (PCIO_BASE + (port)));			\
+	} else								\
+		__asm__ __volatile__(					\
+		"strh	%0, [%1, #0]	@ outwc"			\
+		: : "r" (v), "r" ((port)));				\
+})
+
+#define __inwc(port)							\
+({									\
+	unsigned short result;						\
+	if (__PORT_PCIO((port))) {					\
+		if ((port) < 256 && (port) > -256 )			\
+			__asm__ __volatile__(				\
+			"ldrh	%0, [%1, %2]	@ inwc"			\
+			: "=r" (result)					\
+			: "r" (PCIO_BASE),				\
+			  "Jr" ((port)));				\
+		else if ((port) > 0)					\
+			__asm__ __volatile__(				\
+			"ldrh	%0, [%1, %2]	@ inwc"			\
+			: "=r" (result)					\
+			: "r" (PCIO_BASE + ((port) & ~0xff)),		\
+			  "Jr" (((port) & 0xff)));			\
+		else							\
+			__asm__ __volatile__(				\
+			"ldrh	%0, [%1, #0]	@ inwc"			\
+			: "=r" (result)					\
+			: "r" (PCIO_BASE + ((port))));			\
+	} else								\
+		__asm__ __volatile__(					\
+		"ldrh	%0, [%1, #0]	@ inwc"				\
+		: "=r" (result) : "r" ((port)));			\
+	result;								\
+})
+
+#define __outlc(value,port)						\
+({									\
+	unsigned long v = value;					\
+	if (__PORT_PCIO((port)))					\
+		__asm__ __volatile__(					\
+		"str	%0, [%1, %2]	@ outlc"			\
+		: : "r" (v), "r" (PCIO_BASE), "Jr" ((port)));	\
+	else								\
+		__asm__ __volatile__(					\
+		"str	%0, [%1, #0]	@ outlc"			\
+		: : "r" (v), "r" ((port)));		\
+})
+
+#define __inlc(port)							\
+({									\
+	unsigned long result;						\
+	if (__PORT_PCIO((port)))					\
+		__asm__ __volatile__(					\
+		"ldr	%0, [%1, %2]	@ inlc"				\
+		: "=r" (result) : "r" (PCIO_BASE), "Jr" ((port)));	\
+	else								\
+		__asm__ __volatile__(					\
+		"ldr	%0, [%1, #0]	@ inlc"				\
+		: "=r" (result) : "r" ((port)));		\
+	result;								\
+})
+
+#define __ioaddrc(port)	((__PORT_PCIO(port) ? PCIO_BASE + (port) : (void __iomem *)(port)))
+
+#define inb(p)		(__builtin_constant_p((p)) ? __inbc(p)	   : __inb(p))
+#define inw(p)		(__builtin_constant_p((p)) ? __inwc(p)	   : __inw(p))
+#define inl(p)		(__builtin_constant_p((p)) ? __inlc(p)	   : __inl(p))
+#define outb(v,p)	(__builtin_constant_p((p)) ? __outbc(v,p) : __outb(v,p))
+#define outw(v,p)	(__builtin_constant_p((p)) ? __outwc(v,p) : __outw(v,p))
+#define outl(v,p)	(__builtin_constant_p((p)) ? __outlc(v,p) : __outl(v,p))
+#define __ioaddr(p)	(__builtin_constant_p((p)) ? __ioaddr(p)  : __ioaddrc(p))
+/* the following macro is deprecated */
+#define ioaddr(port)	__ioaddr((port))
+
+#define insb(p,d,l)	__raw_readsb(__ioaddr(p),d,l)
+#define insw(p,d,l)	__raw_readsw(__ioaddr(p),d,l)
+#define insl(p,d,l)	__raw_readsl(__ioaddr(p),d,l)
+
+#define outsb(p,d,l)	__raw_writesb(__ioaddr(p),d,l)
+#define outsw(p,d,l)	__raw_writesw(__ioaddr(p),d,l)
+#define outsl(p,d,l)	__raw_writesl(__ioaddr(p),d,l)
+
+/*
+ * 1:1 mapping for ioremapped regions.
+ */
+#define __mem_pci(x)	(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-s3c2410/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,156 @@
+/* linux/include/asm-arm/arch-s3c2410/irqs.h
+ *
+ * Copyright (c) 2003-2005 Simtec Electronics
+ *   Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H __FILE__
+
+#ifndef __ASM_ARM_IRQ_H
+#error "Do not include this directly, instead #include <asm/irq.h>"
+#endif
+
+/* we keep the first set of CPU IRQs out of the range of
+ * the ISA space, so that the PC104 has them to itself
+ * and we don't end up having to do horrible things to the
+ * standard ISA drivers....
+ */
+
+#define S3C2410_CPUIRQ_OFFSET	 (16)
+
+#define S3C2410_IRQ(x) ((x) + S3C2410_CPUIRQ_OFFSET)
+
+/* main cpu interrupts */
+#define IRQ_EINT0      S3C2410_IRQ(0)	    /* 16 */
+#define IRQ_EINT1      S3C2410_IRQ(1)
+#define IRQ_EINT2      S3C2410_IRQ(2)
+#define IRQ_EINT3      S3C2410_IRQ(3)
+#define IRQ_EINT4t7    S3C2410_IRQ(4)	    /* 20 */
+#define IRQ_EINT8t23   S3C2410_IRQ(5)
+#define IRQ_RESERVED6  S3C2410_IRQ(6)	    /* for s3c2410 */
+#define IRQ_CAM        S3C2410_IRQ(6)	    /* for s3c2440,s3c2443 */
+#define IRQ_BATT_FLT   S3C2410_IRQ(7)
+#define IRQ_TICK       S3C2410_IRQ(8)	    /* 24 */
+#define IRQ_WDT	       S3C2410_IRQ(9)	    /* WDT/AC97 for s3c2443 */
+#define IRQ_TIMER0     S3C2410_IRQ(10)
+#define IRQ_TIMER1     S3C2410_IRQ(11)
+#define IRQ_TIMER2     S3C2410_IRQ(12)
+#define IRQ_TIMER3     S3C2410_IRQ(13)
+#define IRQ_TIMER4     S3C2410_IRQ(14)
+#define IRQ_UART2      S3C2410_IRQ(15)
+#define IRQ_LCD	       S3C2410_IRQ(16)	    /* 32 */
+#define IRQ_DMA0       S3C2410_IRQ(17)	    /* IRQ_DMA for s3c2443 */
+#define IRQ_DMA1       S3C2410_IRQ(18)
+#define IRQ_DMA2       S3C2410_IRQ(19)
+#define IRQ_DMA3       S3C2410_IRQ(20)
+#define IRQ_SDI	       S3C2410_IRQ(21)
+#define IRQ_SPI0       S3C2410_IRQ(22)
+#define IRQ_UART1      S3C2410_IRQ(23)
+#define IRQ_RESERVED24 S3C2410_IRQ(24)	    /* 40 */
+#define IRQ_NFCON      S3C2410_IRQ(24)	    /* for s3c2440 */
+#define IRQ_USBD       S3C2410_IRQ(25)
+#define IRQ_USBH       S3C2410_IRQ(26)
+#define IRQ_IIC	       S3C2410_IRQ(27)
+#define IRQ_UART0      S3C2410_IRQ(28)	    /* 44 */
+#define IRQ_SPI1       S3C2410_IRQ(29)
+#define IRQ_RTC	       S3C2410_IRQ(30)
+#define IRQ_ADCPARENT  S3C2410_IRQ(31)
+
+/* interrupts generated from the external interrupts sources */
+#define IRQ_EINT4      S3C2410_IRQ(32)	   /* 48 */
+#define IRQ_EINT5      S3C2410_IRQ(33)
+#define IRQ_EINT6      S3C2410_IRQ(34)
+#define IRQ_EINT7      S3C2410_IRQ(35)
+#define IRQ_EINT8      S3C2410_IRQ(36)
+#define IRQ_EINT9      S3C2410_IRQ(37)
+#define IRQ_EINT10     S3C2410_IRQ(38)
+#define IRQ_EINT11     S3C2410_IRQ(39)
+#define IRQ_EINT12     S3C2410_IRQ(40)
+#define IRQ_EINT13     S3C2410_IRQ(41)
+#define IRQ_EINT14     S3C2410_IRQ(42)
+#define IRQ_EINT15     S3C2410_IRQ(43)
+#define IRQ_EINT16     S3C2410_IRQ(44)
+#define IRQ_EINT17     S3C2410_IRQ(45)
+#define IRQ_EINT18     S3C2410_IRQ(46)
+#define IRQ_EINT19     S3C2410_IRQ(47)
+#define IRQ_EINT20     S3C2410_IRQ(48)	   /* 64 */
+#define IRQ_EINT21     S3C2410_IRQ(49)
+#define IRQ_EINT22     S3C2410_IRQ(50)
+#define IRQ_EINT23     S3C2410_IRQ(51)
+
+
+#define IRQ_EINT(x)    S3C2410_IRQ((x >= 4) ? (IRQ_EINT4 + (x) - 4) : (S3C2410_IRQ(0) + (x)))
+
+#define IRQ_LCD_FIFO   S3C2410_IRQ(52)
+#define IRQ_LCD_FRAME  S3C2410_IRQ(53)
+
+/* IRQs for the interal UARTs, and ADC
+ * these need to be ordered in number of appearance in the
+ * SUBSRC mask register
+*/
+
+#define S3C2410_IRQSUB(x)	S3C2410_IRQ((x)+54)
+
+#define IRQ_S3CUART_RX0		S3C2410_IRQSUB(0)	/* 70 */
+#define IRQ_S3CUART_TX0		S3C2410_IRQSUB(1)
+#define IRQ_S3CUART_ERR0	S3C2410_IRQSUB(2)
+
+#define IRQ_S3CUART_RX1		S3C2410_IRQSUB(3)	/* 73 */
+#define IRQ_S3CUART_TX1		S3C2410_IRQSUB(4)
+#define IRQ_S3CUART_ERR1	S3C2410_IRQSUB(5)
+
+#define IRQ_S3CUART_RX2		S3C2410_IRQSUB(6)	/* 76 */
+#define IRQ_S3CUART_TX2		S3C2410_IRQSUB(7)
+#define IRQ_S3CUART_ERR2	S3C2410_IRQSUB(8)
+
+#define IRQ_TC			S3C2410_IRQSUB(9)
+#define IRQ_ADC			S3C2410_IRQSUB(10)
+
+/* extra irqs for s3c2440 */
+
+#define IRQ_S3C2440_CAM_C	S3C2410_IRQSUB(11)	/* S3C2443 too */
+#define IRQ_S3C2440_CAM_P	S3C2410_IRQSUB(12)	/* S3C2443 too */
+#define IRQ_S3C2440_WDT		S3C2410_IRQSUB(13)
+#define IRQ_S3C2440_AC97	S3C2410_IRQSUB(14)
+
+/* irqs for s3c2443 */
+
+#define IRQ_S3C2443_DMA		S3C2410_IRQ(17)		/* IRQ_DMA1 */
+#define IRQ_S3C2443_UART3	S3C2410_IRQ(18)		/* IRQ_DMA2 */
+#define IRQ_S3C2443_CFCON	S3C2410_IRQ(19)		/* IRQ_DMA3 */
+#define IRQ_S3C2443_SDI1	S3C2410_IRQ(20)		/* IRQ_SDI */
+#define IRQ_S3C2443_NAND	S3C2410_IRQ(24)		/* reserved */
+
+#define IRQ_S3C2443_LCD1	S3C2410_IRQSUB(14)
+#define IRQ_S3C2443_LCD2	S3C2410_IRQSUB(15)
+#define IRQ_S3C2443_LCD3	S3C2410_IRQSUB(16)
+#define IRQ_S3C2443_LCD4	S3C2410_IRQSUB(17)
+
+#define IRQ_S3C2443_DMA0	S3C2410_IRQSUB(18)
+#define IRQ_S3C2443_DMA1	S3C2410_IRQSUB(19)
+#define IRQ_S3C2443_DMA2	S3C2410_IRQSUB(20)
+#define IRQ_S3C2443_DMA3	S3C2410_IRQSUB(21)
+#define IRQ_S3C2443_DMA4	S3C2410_IRQSUB(22)
+#define IRQ_S3C2443_DMA5	S3C2410_IRQSUB(23)
+
+/* UART3 */
+#define IRQ_S3C2443_RX3		S3C2410_IRQSUB(24)
+#define IRQ_S3C2443_TX3		S3C2410_IRQSUB(25)
+#define IRQ_S3C2443_ERR3	S3C2410_IRQSUB(26)
+
+#define IRQ_S3C2443_WDT		S3C2410_IRQSUB(27)
+#define IRQ_S3C2443_AC97	S3C2410_IRQSUB(28)
+
+#ifdef CONFIG_CPU_S3C2443
+#define NR_IRQS (IRQ_S3C2443_AC97+1)
+#else
+#define NR_IRQS (IRQ_S3C2440_AC97+1)
+#endif
+
+#endif /* __ASM_ARCH_IRQ_H */
Index: build_tree/linux/include/asm/arch-s3c2410/leds-gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/leds-gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/leds-gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/* linux/include/asm-arm/arch-s3c2410/leds-gpio.h
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C24XX - LEDs GPIO connector
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_LEDSGPIO_H
+#define __ASM_ARCH_LEDSGPIO_H "leds-gpio.h"
+
+#define S3C24XX_LEDF_ACTLOW	(1<<0)		/* LED is on when GPIO low */
+#define S3C24XX_LEDF_TRISTATE	(1<<1)		/* tristate to turn off */
+
+struct s3c24xx_led_platdata {
+	unsigned int		 gpio;
+	unsigned int		 flags;
+
+	char			*name;
+	char			*def_trigger;
+};
+
+#endif /* __ASM_ARCH_LEDSGPIO_H */
Index: build_tree/linux/include/asm/arch-s3c2410/map.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/map.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/map.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,241 @@
+/* linux/include/asm-arm/arch-s3c2410/map.h
+ *
+ * Copyright (c) 2003 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - Memory map definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_MAP_H
+#define __ASM_ARCH_MAP_H
+
+/* we have a bit of a tight squeeze to fit all our registers from
+ * 0xF00000000 upwards, since we use all of the nGCS space in some
+ * capacity, and also need to fit the S3C2410 registers in as well...
+ *
+ * we try to ensure stuff like the IRQ registers are available for
+ * an single MOVS instruction (ie, only 8 bits of set data)
+ *
+ * Note, we are trying to remove some of these from the implementation
+ * as they are only useful to certain drivers...
+ */
+
+#ifndef __ASSEMBLY__
+#define S3C2410_ADDR(x)	  ((void __iomem __force *)0xF0000000 + (x))
+#else
+#define S3C2410_ADDR(x)	  (0xF0000000 + (x))
+#endif
+
+#define S3C2400_ADDR(x)	  S3C2410_ADDR(x)
+
+/* interrupt controller is the first thing we put in, to make
+ * the assembly code for the irq detection easier
+ */
+#define S3C24XX_VA_IRQ	   S3C2410_ADDR(0x00000000)
+#define S3C2400_PA_IRQ	   (0x14400000)
+#define S3C2410_PA_IRQ	   (0x4A000000)
+#define S3C24XX_SZ_IRQ	   SZ_1M
+
+/* memory controller registers */
+#define S3C24XX_VA_MEMCTRL S3C2410_ADDR(0x00100000)
+#define S3C2400_PA_MEMCTRL (0x14000000)
+#define S3C2410_PA_MEMCTRL (0x48000000)
+#define S3C24XX_SZ_MEMCTRL SZ_1M
+
+/* USB host controller */
+#define S3C2400_PA_USBHOST (0x14200000)
+#define S3C2410_PA_USBHOST (0x49000000)
+#define S3C24XX_SZ_USBHOST SZ_1M
+
+/* DMA controller */
+#define S3C2400_PA_DMA	   (0x14600000)
+#define S3C2410_PA_DMA	   (0x4B000000)
+#define S3C24XX_SZ_DMA	   SZ_1M
+
+/* Clock and Power management */
+#define S3C24XX_VA_CLKPWR  S3C2410_ADDR(0x00200000)
+#define S3C2400_PA_CLKPWR  (0x14800000)
+#define S3C2410_PA_CLKPWR  (0x4C000000)
+#define S3C24XX_SZ_CLKPWR  SZ_1M
+
+/* LCD controller */
+#define S3C24XX_VA_LCD	   S3C2410_ADDR(0x00300000)
+#define S3C2400_PA_LCD	   (0x14A00000)
+#define S3C2410_PA_LCD	   (0x4D000000)
+#define S3C24XX_SZ_LCD	   SZ_1M
+
+/* NAND flash controller */
+#define S3C2410_PA_NAND	   (0x4E000000)
+#define S3C24XX_SZ_NAND	   SZ_1M
+
+/* MMC controller - available on the S3C2400 */
+#define S3C2400_PA_MMC 	   (0x15A00000)
+#define S3C2400_SZ_MMC 	   SZ_1M
+
+/* UARTs */
+#define S3C24XX_VA_UART	   S3C2410_ADDR(0x00400000)
+#define S3C2400_PA_UART	   (0x15000000)
+#define S3C2410_PA_UART	   (0x50000000)
+#define S3C24XX_SZ_UART	   SZ_1M
+
+/* Timers */
+#define S3C24XX_VA_TIMER   S3C2410_ADDR(0x00500000)
+#define S3C2400_PA_TIMER   (0x15100000)
+#define S3C2410_PA_TIMER   (0x51000000)
+#define S3C24XX_SZ_TIMER   SZ_1M
+
+/* USB Device port */
+#define S3C24XX_VA_USBDEV  S3C2410_ADDR(0x00600000)
+#define S3C2400_PA_USBDEV  (0x15200140)
+#define S3C2410_PA_USBDEV  (0x52000000)
+#define S3C24XX_SZ_USBDEV  SZ_1M
+
+/* Watchdog */
+#define S3C24XX_VA_WATCHDOG S3C2410_ADDR(0x00700000)
+#define S3C2400_PA_WATCHDOG (0x15300000)
+#define S3C2410_PA_WATCHDOG (0x53000000)
+#define S3C24XX_SZ_WATCHDOG SZ_1M
+
+/* IIC hardware controller */
+#define S3C2400_PA_IIC	   (0x15400000)
+#define S3C2410_PA_IIC	   (0x54000000)
+#define S3C24XX_SZ_IIC	   SZ_1M
+
+/* IIS controller */
+#define S3C2400_PA_IIS	   (0x15508000)
+#define S3C2410_PA_IIS	   (0x55000000)
+#define S3C24XX_SZ_IIS	   SZ_1M
+
+/* GPIO ports */
+
+/* the calculation for the VA of this must ensure that
+ * it is the same distance apart from the UART in the
+ * phsyical address space, as the initial mapping for the IO
+ * is done as a 1:1 maping. This puts it (currently) at
+ * 0xF6800000, which is not in the way of any current mapping
+ * by the base system.
+*/
+
+#define S3C2400_PA_GPIO	   (0x15600000)
+#define S3C2410_PA_GPIO	   (0x56000000)
+#define S3C24XX_VA_GPIO	   ((S3C2410_PA_GPIO - S3C24XX_PA_UART) + S3C24XX_VA_UART)
+#define S3C24XX_SZ_GPIO	   SZ_1M
+
+/* RTC */
+#define S3C2400_PA_RTC	   (0x15700040)
+#define S3C2410_PA_RTC	   (0x57000000)
+#define S3C24XX_SZ_RTC	   SZ_1M
+
+/* ADC */
+#define S3C2400_PA_ADC	   (0x15800000)
+#define S3C2410_PA_ADC	   (0x58000000)
+#define S3C24XX_SZ_ADC	   SZ_1M
+
+/* SPI */
+#define S3C2400_PA_SPI	   (0x15900000)
+#define S3C2410_PA_SPI	   (0x59000000)
+#define S3C24XX_SZ_SPI	   SZ_1M
+
+/* SDI */
+#define S3C2410_PA_SDI	   (0x5A000000)
+#define S3C24XX_SZ_SDI	   SZ_1M
+
+/* CAMIF */
+#define S3C2440_PA_CAMIF   (0x4F000000)
+#define S3C2440_SZ_CAMIF   SZ_1M
+
+/* AC97 */
+
+#define S3C2440_PA_AC97	   (0x5B000000)
+#define S3C2440_SZ_AC97	   SZ_1M
+
+/* ISA style IO, for each machine to sort out mappings for, if it
+ * implements it. We reserve two 16M regions for ISA.
+ */
+
+#define S3C24XX_VA_ISA_WORD  S3C2410_ADDR(0x02000000)
+#define S3C24XX_VA_ISA_BYTE  S3C2410_ADDR(0x03000000)
+
+/* physical addresses of all the chip-select areas */
+
+#define S3C2410_CS0 (0x00000000)
+#define S3C2410_CS1 (0x08000000)
+#define S3C2410_CS2 (0x10000000)
+#define S3C2410_CS3 (0x18000000)
+#define S3C2410_CS4 (0x20000000)
+#define S3C2410_CS5 (0x28000000)
+#define S3C2410_CS6 (0x30000000)
+#define S3C2410_CS7 (0x38000000)
+
+#define S3C2410_SDRAM_PA    (S3C2410_CS6)
+
+#define S3C2400_CS0 (0x00000000)
+#define S3C2400_CS1 (0x02000000)
+#define S3C2400_CS2 (0x04000000)
+#define S3C2400_CS3 (0x06000000)
+#define S3C2400_CS4 (0x08000000)
+#define S3C2400_CS5 (0x0A000000)
+#define S3C2400_CS6 (0x0C000000)
+#define S3C2400_CS7 (0x0E000000)
+
+#define S3C2400_SDRAM_PA    (S3C2400_CS6)
+
+/* Use a single interface for common resources between S3C24XX cpus */
+
+#ifdef CONFIG_CPU_S3C2400
+#define S3C24XX_PA_IRQ      S3C2400_PA_IRQ
+#define S3C24XX_PA_MEMCTRL  S3C2400_PA_MEMCTRL
+#define S3C24XX_PA_USBHOST  S3C2400_PA_USBHOST
+#define S3C24XX_PA_DMA      S3C2400_PA_DMA
+#define S3C24XX_PA_CLKPWR   S3C2400_PA_CLKPWR
+#define S3C24XX_PA_LCD      S3C2400_PA_LCD
+#define S3C24XX_PA_UART     S3C2400_PA_UART
+#define S3C24XX_PA_TIMER    S3C2400_PA_TIMER
+#define S3C24XX_PA_USBDEV   S3C2400_PA_USBDEV
+#define S3C24XX_PA_WATCHDOG S3C2400_PA_WATCHDOG
+#define S3C24XX_PA_IIC      S3C2400_PA_IIC
+#define S3C24XX_PA_IIS      S3C2400_PA_IIS
+#define S3C24XX_PA_GPIO     S3C2400_PA_GPIO
+#define S3C24XX_PA_RTC      S3C2400_PA_RTC
+#define S3C24XX_PA_ADC      S3C2400_PA_ADC
+#define S3C24XX_PA_SPI      S3C2400_PA_SPI
+#else
+#define S3C24XX_PA_IRQ      S3C2410_PA_IRQ
+#define S3C24XX_PA_MEMCTRL  S3C2410_PA_MEMCTRL
+#define S3C24XX_PA_USBHOST  S3C2410_PA_USBHOST
+#define S3C24XX_PA_DMA      S3C2410_PA_DMA
+#define S3C24XX_PA_CLKPWR   S3C2410_PA_CLKPWR
+#define S3C24XX_PA_LCD      S3C2410_PA_LCD
+#define S3C24XX_PA_UART     S3C2410_PA_UART
+#define S3C24XX_PA_TIMER    S3C2410_PA_TIMER
+#define S3C24XX_PA_USBDEV   S3C2410_PA_USBDEV
+#define S3C24XX_PA_WATCHDOG S3C2410_PA_WATCHDOG
+#define S3C24XX_PA_IIC      S3C2410_PA_IIC
+#define S3C24XX_PA_IIS      S3C2410_PA_IIS
+#define S3C24XX_PA_GPIO     S3C2410_PA_GPIO
+#define S3C24XX_PA_RTC      S3C2410_PA_RTC
+#define S3C24XX_PA_ADC      S3C2410_PA_ADC
+#define S3C24XX_PA_SPI      S3C2410_PA_SPI
+#endif
+
+/* deal with the registers that move under the 2412/2413 */
+
+#if defined(CONFIG_CPU_S3C2412) || defined(CONFIG_CPU_S3C2413)
+#ifndef __ASSEMBLY__
+extern void __iomem *s3c24xx_va_gpio2;
+#endif
+#ifdef CONFIG_CPU_S3C2412_ONLY
+#define S3C24XX_VA_GPIO2 (S3C24XX_VA_GPIO + 0x10)
+#else
+#define S3C24XX_VA_GPIO2 s3c24xx_va_gpio2
+#endif
+#else
+#define s3c24xx_va_gpio2 S3C24XX_VA_GPIO
+#define S3C24XX_VA_GPIO2 S3C24XX_VA_GPIO
+#endif
+
+#endif /* __ASM_ARCH_MAP_H */
Index: build_tree/linux/include/asm/arch-s3c2410/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/* linux/include/asm-arm/arch-s3c2410/memory.h
+ *  from linux/include/asm-arm/arch-rpc/memory.h
+ *
+ *  Copyright (C) 1996,1997,1998 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * DRAM starts at 0x30000000 for S3C2410/S3C2440
+ * and at 0x0C000000 for S3C2400
+ */
+#ifdef CONFIG_CPU_S3C2400
+#define PHYS_OFFSET	UL(0x0C000000)
+#else
+#define PHYS_OFFSET	UL(0x30000000)
+#endif
+
+/*
+ * These are exactly the same on the S3C2410 as the
+ * physical memory view.
+*/
+
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
+
+#endif
Index: build_tree/linux/include/asm/arch-s3c2410/nand.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/nand.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/nand.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,45 @@
+/* linux/include/asm-arm/arch-s3c2410/nand.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - NAND device controller platfrom_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* struct s3c2410_nand_set
+ *
+ * define an set of one or more nand chips registered with an unique mtd
+ *
+ * nr_chips	 = number of chips in this set
+ * nr_partitions = number of partitions pointed to be partitoons (or zero)
+ * name		 = name of set (optional)
+ * nr_map	 = map for low-layer logical to physical chip numbers (option)
+ * partitions	 = mtd partition list
+*/
+
+struct s3c2410_nand_set {
+	int			nr_chips;
+	int			nr_partitions;
+	char			*name;
+	int			*nr_map;
+	struct mtd_partition	*partitions;
+};
+
+struct s3c2410_platform_nand {
+	/* timing information for controller, all times in nanoseconds */
+
+	int	tacls;	/* time for active CLE/ALE to nWE/nOE */
+	int	twrph0;	/* active time for nWE/nOE */
+	int	twrph1;	/* time for release CLE/ALE from nWE/nOE inactive */
+
+	int			nr_sets;
+	struct s3c2410_nand_set *sets;
+
+	void			(*select_chip)(struct s3c2410_nand_set *,
+					       int chip);
+};
+
Index: build_tree/linux/include/asm/arch-s3c2410/osiris-cpld.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/osiris-cpld.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/osiris-cpld.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,25 @@
+/* linux/include/asm-arm/arch-s3c2410/osiris-cpld.h
+ *
+ * Copyright (c) 2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * OSIRIS - CPLD control constants
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_OSIRISCPLD_H
+#define __ASM_ARCH_OSIRISCPLD_H
+
+/* CTRL1 - NAND WP control */
+
+#define OSIRIS_CTRL1_NANDSEL		(0x3)
+#define OSIRIS_CTRL1_BOOT_INT		(1<<3)
+#define OSIRIS_CTRL1_PCMCIA		(1<<4)
+#define OSIRIS_CTRL1_PCMCIA_nWAIT	(1<<6)
+#define OSIRIS_CTRL1_PCMCIA_nIOIS16	(1<<7)
+
+#endif /* __ASM_ARCH_OSIRISCPLD_H */
Index: build_tree/linux/include/asm/arch-s3c2410/osiris-map.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/osiris-map.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/osiris-map.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/* linux/include/asm-arm/arch-s3c2410/osiris-map.h
+ *
+ * (c) 2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * OSIRIS - Memory map definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* needs arch/map.h including with this */
+
+#ifndef __ASM_ARCH_OSIRISMAP_H
+#define __ASM_ARCH_OSIRISMAP_H
+
+/* start peripherals off after the S3C2410 */
+
+#define OSIRIS_IOADDR(x)	(S3C2410_ADDR((x) + 0x04000000))
+
+#define OSIRIS_PA_CPLD		(S3C2410_CS1 | (1<<26))
+
+/* we put the CPLD registers next, to get them out of the way */
+
+#define OSIRIS_VA_CTRL1	    OSIRIS_IOADDR(0x00000000)
+#define OSIRIS_PA_CTRL1	    (OSIRIS_PA_CPLD)
+
+#define OSIRIS_VA_CTRL2	    OSIRIS_IOADDR(0x00100000)
+#define OSIRIS_PA_CTRL2	    (OSIRIS_PA_CPLD + (1<<23))
+
+#define OSIRIS_VA_CTRL3	    OSIRIS_IOADDR(0x00200000)
+#define OSIRIS_PA_CTRL3	    (OSIRIS_PA_CPLD + (2<<23))
+
+#define OSIRIS_VA_CTRL4	    OSIRIS_IOADDR(0x00300000)
+#define OSIRIS_PA_CTRL4	    (OSIRIS_PA_CPLD + (3<<23))
+
+#endif /* __ASM_ARCH_OSIRISMAP_H */
Index: build_tree/linux/include/asm/arch-s3c2410/otom-map.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/otom-map.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/otom-map.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,30 @@
+/* linux/include/asm-arm/arch-s3c2410/otom-map.h
+ *
+ * (c) 2005 Guillaume GOURAT / NexVision
+ *          guillaume.gourat@nexvision.fr
+ *
+ * NexVision OTOM board memory map definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* needs arch/map.h including with this */
+
+/* ok, we've used up to 0x01300000, now we need to find space for the
+ * peripherals that live in the nGCS[x] areas, which are quite numerous
+ * in their space.
+ */
+
+#ifndef __ASM_ARCH_OTOMMAP_H
+#define __ASM_ARCH_OTOMMAP_H
+
+#define OTOM_PA_CS8900A_BASE       (S3C2410_CS3 + 0x01000000)	/* nGCS3 +0x01000000 */
+#define OTOM_VA_CS8900A_BASE       S3C2410_ADDR(0x04000000)		/* 0xF4000000 */
+
+/* physical offset addresses for the peripherals */
+
+#define OTOM_PA_FLASH0_BASE        (S3C2410_CS0)				/* Bank 0 */
+
+#endif /* __ASM_ARCH_OTOMMAP_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-ac97.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-ac97.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-ac97.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-ac97.h
+ *
+ * Copyright (c) 2006 Simtec Electronics <linux@simtec.co.uk>
+ *		http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2440 AC97 Controller
+*/
+
+#ifndef __ASM_ARCH_REGS_AC97_H
+#define __ASM_ARCH_REGS_AC97_H __FILE__
+
+#define S3C_AC97_GLBCTRL	(0x00)
+#define S3C_AC97_GLBSTAT	(0x04)
+#define S3C_AC97_CODEC_CMD	(0x08)
+#define S3C_AC97_PCM_ADDR	(0x10)
+#define S3C_AC97_PCM_DATA	(0x18)
+#define S3C_AC97_MIC_DATA	(0x1C)
+
+#endif /* __ASM_ARCH_REGS_AC97_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-adc.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-adc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-adc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,60 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-adc.h
+ *
+ * Copyright (c) 2004 Shannon Holland <holland@loser.net>
+ *
+ * This program is free software; yosu can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 ADC registers
+*/
+
+#ifndef __ASM_ARCH_REGS_ADC_H
+#define __ASM_ARCH_REGS_ADC_H "regs-adc.h"
+
+#define S3C2410_ADCREG(x) (x)
+
+#define S3C2410_ADCCON	   S3C2410_ADCREG(0x00)
+#define S3C2410_ADCTSC	   S3C2410_ADCREG(0x04)
+#define S3C2410_ADCDLY	   S3C2410_ADCREG(0x08)
+#define S3C2410_ADCDAT0	   S3C2410_ADCREG(0x0C)
+#define S3C2410_ADCDAT1	   S3C2410_ADCREG(0x10)
+
+
+/* ADCCON Register Bits */
+#define S3C2410_ADCCON_ECFLG		(1<<15)
+#define S3C2410_ADCCON_PRSCEN		(1<<14)
+#define S3C2410_ADCCON_PRSCVL(x)	(((x)&0xFF)<<6)
+#define S3C2410_ADCCON_PRSCVLMASK	(0xFF<<6)
+#define S3C2410_ADCCON_SELMUX(x)	(((x)&0x7)<<3)
+#define S3C2410_ADCCON_MUXMASK		(0x7<<3)
+#define S3C2410_ADCCON_STDBM		(1<<2)
+#define S3C2410_ADCCON_READ_START	(1<<1)
+#define S3C2410_ADCCON_ENABLE_START	(1<<0)
+#define S3C2410_ADCCON_STARTMASK	(0x3<<0)
+
+
+/* ADCTSC Register Bits */
+#define S3C2410_ADCTSC_YM_SEN		(1<<7)
+#define S3C2410_ADCTSC_YP_SEN		(1<<6)
+#define S3C2410_ADCTSC_XM_SEN		(1<<5)
+#define S3C2410_ADCTSC_XP_SEN		(1<<4)
+#define S3C2410_ADCTSC_PULL_UP_DISABLE	(1<<3)
+#define S3C2410_ADCTSC_AUTO_PST		(1<<2)
+#define S3C2410_ADCTSC_XY_PST(x)	(((x)&0x3)<<0)
+
+/* ADCDAT0 Bits */
+#define S3C2410_ADCDAT0_UPDOWN		(1<<15)
+#define S3C2410_ADCDAT0_AUTO_PST	(1<<14)
+#define S3C2410_ADCDAT0_XY_PST		(0x3<<12)
+#define S3C2410_ADCDAT0_XPDATA_MASK	(0x03FF)
+
+/* ADCDAT1 Bits */
+#define S3C2410_ADCDAT1_UPDOWN		(1<<15)
+#define S3C2410_ADCDAT1_AUTO_PST	(1<<14)
+#define S3C2410_ADCDAT1_XY_PST		(0x3<<12)
+#define S3C2410_ADCDAT1_YPDATA_MASK	(0x03FF)
+
+#endif /* __ASM_ARCH_REGS_ADC_H */
+
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-clock.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-clock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-clock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,193 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-clock.h
+ *
+ * Copyright (c) 2003,2004,2005,2006 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 clock register definitions
+*/
+
+#ifndef __ASM_ARM_REGS_CLOCK
+#define __ASM_ARM_REGS_CLOCK "$Id: clock.h,v 1.4 2003/04/30 14:50:51 ben Exp $"
+
+#define S3C2410_CLKREG(x) ((x) + S3C24XX_VA_CLKPWR)
+
+#define S3C2410_PLLVAL(_m,_p,_s) ((_m) << 12 | ((_p) << 4) | ((_s)))
+
+#define S3C2410_LOCKTIME    S3C2410_CLKREG(0x00)
+#define S3C2410_MPLLCON	    S3C2410_CLKREG(0x04)
+#define S3C2410_UPLLCON	    S3C2410_CLKREG(0x08)
+#define S3C2410_CLKCON	    S3C2410_CLKREG(0x0C)
+#define S3C2410_CLKSLOW	    S3C2410_CLKREG(0x10)
+#define S3C2410_CLKDIVN	    S3C2410_CLKREG(0x14)
+
+#define S3C2410_CLKCON_IDLE	     (1<<2)
+#define S3C2410_CLKCON_POWER	     (1<<3)
+#define S3C2410_CLKCON_NAND	     (1<<4)
+#define S3C2410_CLKCON_LCDC	     (1<<5)
+#define S3C2410_CLKCON_USBH	     (1<<6)
+#define S3C2410_CLKCON_USBD	     (1<<7)
+#define S3C2410_CLKCON_PWMT	     (1<<8)
+#define S3C2410_CLKCON_SDI	     (1<<9)
+#define S3C2410_CLKCON_UART0	     (1<<10)
+#define S3C2410_CLKCON_UART1	     (1<<11)
+#define S3C2410_CLKCON_UART2	     (1<<12)
+#define S3C2410_CLKCON_GPIO	     (1<<13)
+#define S3C2410_CLKCON_RTC	     (1<<14)
+#define S3C2410_CLKCON_ADC	     (1<<15)
+#define S3C2410_CLKCON_IIC	     (1<<16)
+#define S3C2410_CLKCON_IIS	     (1<<17)
+#define S3C2410_CLKCON_SPI	     (1<<18)
+
+#define S3C2410_PLLCON_MDIVSHIFT     12
+#define S3C2410_PLLCON_PDIVSHIFT     4
+#define S3C2410_PLLCON_SDIVSHIFT     0
+#define S3C2410_PLLCON_MDIVMASK	     ((1<<(1+(19-12)))-1)
+#define S3C2410_PLLCON_PDIVMASK	     ((1<<5)-1)
+#define S3C2410_PLLCON_SDIVMASK	     3
+
+/* DCLKCON register addresses in gpio.h */
+
+#define S3C2410_DCLKCON_DCLK0EN	     (1<<0)
+#define S3C2410_DCLKCON_DCLK0_PCLK   (0<<1)
+#define S3C2410_DCLKCON_DCLK0_UCLK   (1<<1)
+#define S3C2410_DCLKCON_DCLK0_DIV(x) (((x) - 1 )<<4)
+#define S3C2410_DCLKCON_DCLK0_CMP(x) (((x) - 1 )<<8)
+#define S3C2410_DCLKCON_DCLK0_DIV_MASK ((0xf)<<4)
+#define S3C2410_DCLKCON_DCLK0_CMP_MASK ((0xf)<<8)
+
+#define S3C2410_DCLKCON_DCLK1EN	     (1<<16)
+#define S3C2410_DCLKCON_DCLK1_PCLK   (0<<17)
+#define S3C2410_DCLKCON_DCLK1_UCLK   (1<<17)
+#define S3C2410_DCLKCON_DCLK1_DIV(x) (((x) - 1) <<20)
+#define S3C2410_DCLKCON_DCLK1_CMP(x) (((x) - 1) <<24)
+#define S3C2410_DCLKCON_DCLK1_DIV_MASK ((0xf) <<20)
+#define S3C2410_DCLKCON_DCLK1_CMP_MASK ((0xf) <<24)
+
+#define S3C2410_CLKDIVN_PDIVN	     (1<<0)
+#define S3C2410_CLKDIVN_HDIVN	     (1<<1)
+
+#define S3C2410_CLKSLOW_UCLK_OFF	(1<<7)
+#define S3C2410_CLKSLOW_MPLL_OFF	(1<<5)
+#define S3C2410_CLKSLOW_SLOW		(1<<4)
+#define S3C2410_CLKSLOW_SLOWVAL(x)	(x)
+#define S3C2410_CLKSLOW_GET_SLOWVAL(x)	((x) & 7)
+
+#ifndef __ASSEMBLY__
+
+#include <asm/div64.h>
+
+static inline unsigned int
+s3c2410_get_pll(unsigned int pllval, unsigned int baseclk)
+{
+	unsigned int mdiv, pdiv, sdiv;
+	uint64_t fvco;
+
+	mdiv = pllval >> S3C2410_PLLCON_MDIVSHIFT;
+	pdiv = pllval >> S3C2410_PLLCON_PDIVSHIFT;
+	sdiv = pllval >> S3C2410_PLLCON_SDIVSHIFT;
+
+	mdiv &= S3C2410_PLLCON_MDIVMASK;
+	pdiv &= S3C2410_PLLCON_PDIVMASK;
+	sdiv &= S3C2410_PLLCON_SDIVMASK;
+
+	fvco = (uint64_t)baseclk * (mdiv + 8);
+	do_div(fvco, (pdiv + 2) << sdiv);
+
+	return (unsigned int)fvco;
+}
+
+#endif /* __ASSEMBLY__ */
+
+#if defined(CONFIG_CPU_S3C2440) || defined(CONFIG_CPU_S3C2442)
+
+/* extra registers */
+#define S3C2440_CAMDIVN	    S3C2410_CLKREG(0x18)
+
+#define S3C2440_CLKCON_CAMERA        (1<<19)
+#define S3C2440_CLKCON_AC97          (1<<20)
+
+#define S3C2440_CLKDIVN_PDIVN	     (1<<0)
+#define S3C2440_CLKDIVN_HDIVN_MASK   (3<<1)
+#define S3C2440_CLKDIVN_HDIVN_1      (0<<1)
+#define S3C2440_CLKDIVN_HDIVN_2      (1<<1)
+#define S3C2440_CLKDIVN_HDIVN_4_8    (2<<1)
+#define S3C2440_CLKDIVN_HDIVN_3_6    (3<<1)
+#define S3C2440_CLKDIVN_UCLK         (1<<3)
+
+#define S3C2440_CAMDIVN_CAMCLK_MASK  (0xf<<0)
+#define S3C2440_CAMDIVN_CAMCLK_SEL   (1<<4)
+#define S3C2440_CAMDIVN_HCLK3_HALF   (1<<8)
+#define S3C2440_CAMDIVN_HCLK4_HALF   (1<<9)
+#define S3C2440_CAMDIVN_DVSEN        (1<<12)
+
+#define S3C2442_CAMDIVN_CAMCLK_DIV3  (1<<5)
+
+#endif /* CONFIG_CPU_S3C2440 or CONFIG_CPU_S3C2442 */
+
+#if defined(CONFIG_CPU_S3C2412) || defined(CONFIG_CPU_S3C2413)
+
+#define S3C2412_OSCSET		S3C2410_CLKREG(0x18)
+#define S3C2412_CLKSRC		S3C2410_CLKREG(0x1C)
+
+#define S3C2412_PLLCON_OFF		(1<<20)
+
+#define S3C2412_CLKDIVN_PDIVN		(1<<2)
+#define S3C2412_CLKDIVN_HDIVN_MASK	(3<<0)
+#define S3C2421_CLKDIVN_ARMDIVN		(1<<3)
+#define S3C2412_CLKDIVN_USB48DIV	(1<<6)
+#define S3C2412_CLKDIVN_UARTDIV_MASK	(15<<8)
+#define S3C2412_CLKDIVN_UARTDIV_SHIFT	(8)
+#define S3C2412_CLKDIVN_I2SDIV_MASK	(15<<12)
+#define S3C2412_CLKDIVN_I2SDIV_SHIFT	(12)
+#define S3C2412_CLKDIVN_CAMDIV_MASK	(15<<16)
+#define S3C2412_CLKDIVN_CAMDIV_SHIFT	(16)
+
+#define S3C2412_CLKCON_WDT		(1<<28)
+#define S3C2412_CLKCON_SPI		(1<<27)
+#define S3C2412_CLKCON_IIS		(1<<26)
+#define S3C2412_CLKCON_IIC		(1<<25)
+#define S3C2412_CLKCON_ADC		(1<<24)
+#define S3C2412_CLKCON_RTC		(1<<23)
+#define S3C2412_CLKCON_GPIO		(1<<22)
+#define S3C2412_CLKCON_UART2		(1<<21)
+#define S3C2412_CLKCON_UART1		(1<<20)
+#define S3C2412_CLKCON_UART0		(1<<19)
+#define S3C2412_CLKCON_SDI		(1<<18)
+#define S3C2412_CLKCON_PWMT		(1<<17)
+#define S3C2412_CLKCON_USBD		(1<<16)
+#define S3C2412_CLKCON_CAMCLK		(1<<15)
+#define S3C2412_CLKCON_UARTCLK		(1<<14)
+/* missing 13 */
+#define S3C2412_CLKCON_USB_HOST48	(1<<12)
+#define S3C2412_CLKCON_USB_DEV48	(1<<11)
+#define S3C2412_CLKCON_HCLKdiv2		(1<<10)
+#define S3C2412_CLKCON_HCLKx2		(1<<9)
+#define S3C2412_CLKCON_SDRAM		(1<<8)
+/* missing 7 */
+#define S3C2412_CLKCON_USBH		S3C2410_CLKCON_USBH
+#define S3C2412_CLKCON_LCDC		S3C2410_CLKCON_LCDC
+#define S3C2412_CLKCON_NAND		S3C2410_CLKCON_NAND
+#define S3C2412_CLKCON_DMA3		(1<<3)
+#define S3C2412_CLKCON_DMA2		(1<<2)
+#define S3C2412_CLKCON_DMA1		(1<<1)
+#define S3C2412_CLKCON_DMA0		(1<<0)
+
+/* clock sourec controls */
+
+#define S3C2412_CLKSRC_EXTCLKDIV_MASK		(7 << 0)
+#define S3C2412_CLKSRC_EXTCLKDIV_SHIFT		(0)
+#define S3C2412_CLKSRC_MDIVCLK_EXTCLKDIV	(1<<3)
+#define S3C2412_CLKSRC_MSYSCLK_MPLL		(1<<4)
+#define S3C2412_CLKSRC_USYSCLK_UPLL		(1<<5)
+#define S3C2412_CLKSRC_UARTCLK_MPLL		(1<<8)
+#define S3C2412_CLKSRC_I2SCLK_MPLL		(1<<9)
+#define S3C2412_CLKSRC_USBCLK_HCLK		(1<<10)
+#define S3C2412_CLKSRC_CAMCLK_HCLK		(1<<11)
+
+#endif /* CONFIG_CPU_S3C2412 | CONFIG_CPU_S3C2413 */
+
+#endif /* __ASM_ARM_REGS_CLOCK */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-dsc.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-dsc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-dsc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,184 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-dsc.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2440/S3C2412 Signal Drive Strength Control
+*/
+
+
+#ifndef __ASM_ARCH_REGS_DSC_H
+#define __ASM_ARCH_REGS_DSC_H "2440-dsc"
+
+#if defined(CONFIG_CPU_S3C2412)
+#define S3C2412_DSC0	   S3C2410_GPIOREG(0xdc)
+#define S3C2412_DSC1	   S3C2410_GPIOREG(0xe0)
+#endif
+
+#if defined(CONFIG_CPU_S3C2440)
+
+#define S3C2440_DSC0	   S3C2410_GPIOREG(0xc4)
+#define S3C2440_DSC1	   S3C2410_GPIOREG(0xc8)
+
+#define S3C2440_SELECT_DSC0 (0)
+#define S3C2440_SELECT_DSC1 (1<<31)
+
+#define S3C2440_DSC_GETSHIFT(x) ((x) & 31)
+
+#define S3C2440_DSC0_DISABLE	(1<<31)
+
+#define S3C2440_DSC0_ADDR       (S3C2440_SELECT_DSC0 | 8)
+#define S3C2440_DSC0_ADDR_12mA  (0<<8)
+#define S3C2440_DSC0_ADDR_10mA  (1<<8)
+#define S3C2440_DSC0_ADDR_8mA   (2<<8)
+#define S3C2440_DSC0_ADDR_6mA   (3<<8)
+#define S3C2440_DSC0_ADDR_MASK  (3<<8)
+
+/* D24..D31 */
+#define S3C2440_DSC0_DATA3      (S3C2440_SELECT_DSC0 | 6)
+#define S3C2440_DSC0_DATA3_12mA (0<<6)
+#define S3C2440_DSC0_DATA3_10mA (1<<6)
+#define S3C2440_DSC0_DATA3_8mA  (2<<6)
+#define S3C2440_DSC0_DATA3_6mA  (3<<6)
+#define S3C2440_DSC0_DATA3_MASK (3<<6)
+
+/* D16..D23 */
+#define S3C2440_DSC0_DATA2      (S3C2440_SELECT_DSC0 | 4)
+#define S3C2440_DSC0_DATA2_12mA (0<<4)
+#define S3C2440_DSC0_DATA2_10mA (1<<4)
+#define S3C2440_DSC0_DATA2_8mA  (2<<4)
+#define S3C2440_DSC0_DATA2_6mA  (3<<4)
+#define S3C2440_DSC0_DATA2_MASK (3<<4)
+
+/* D8..D15 */
+#define S3C2440_DSC0_DATA1      (S3C2440_SELECT_DSC0 | 2)
+#define S3C2440_DSC0_DATA1_12mA (0<<2)
+#define S3C2440_DSC0_DATA1_10mA (1<<2)
+#define S3C2440_DSC0_DATA1_8mA  (2<<2)
+#define S3C2440_DSC0_DATA1_6mA  (3<<2)
+#define S3C2440_DSC0_DATA1_MASK (3<<2)
+
+/* D0..D7 */
+#define S3C2440_DSC0_DATA0      (S3C2440_SELECT_DSC0 | 0)
+#define S3C2440_DSC0_DATA0_12mA (0<<0)
+#define S3C2440_DSC0_DATA0_10mA (1<<0)
+#define S3C2440_DSC0_DATA0_8mA  (2<<0)
+#define S3C2440_DSC0_DATA0_6mA  (3<<0)
+#define S3C2440_DSC0_DATA0_MASK (3<<0)
+
+#define S3C2440_DSC1_SCK1       (S3C2440_SELECT_DSC1 | 28)
+#define S3C2440_DSC1_SCK1_12mA  (0<<28)
+#define S3C2440_DSC1_SCK1_10mA  (1<<28)
+#define S3C2440_DSC1_SCK1_8mA   (2<<28)
+#define S3C2440_DSC1_SCK1_6mA   (3<<28)
+#define S3C2440_DSC1_SCK1_MASK  (3<<28)
+
+#define S3C2440_DSC1_SCK0       (S3C2440_SELECT_DSC1 | 26)
+#define S3C2440_DSC1_SCK0_12mA  (0<<26)
+#define S3C2440_DSC1_SCK0_10mA  (1<<26)
+#define S3C2440_DSC1_SCK0_8mA   (2<<26)
+#define S3C2440_DSC1_SCK0_6mA   (3<<26)
+#define S3C2440_DSC1_SCK0_MASK  (3<<26)
+
+#define S3C2440_DSC1_SCKE       (S3C2440_SELECT_DSC1 | 24)
+#define S3C2440_DSC1_SCKE_10mA  (0<<24)
+#define S3C2440_DSC1_SCKE_8mA   (1<<24)
+#define S3C2440_DSC1_SCKE_6mA   (2<<24)
+#define S3C2440_DSC1_SCKE_4mA   (3<<24)
+#define S3C2440_DSC1_SCKE_MASK  (3<<24)
+
+/* SDRAM nRAS/nCAS */
+#define S3C2440_DSC1_SDR        (S3C2440_SELECT_DSC1 | 22)
+#define S3C2440_DSC1_SDR_10mA   (0<<22)
+#define S3C2440_DSC1_SDR_8mA    (1<<22)
+#define S3C2440_DSC1_SDR_6mA    (2<<22)
+#define S3C2440_DSC1_SDR_4mA    (3<<22)
+#define S3C2440_DSC1_SDR_MASK   (3<<22)
+
+/* NAND Flash Controller */
+#define S3C2440_DSC1_NFC        (S3C2440_SELECT_DSC1 | 20)
+#define S3C2440_DSC1_NFC_10mA   (0<<20)
+#define S3C2440_DSC1_NFC_8mA    (1<<20)
+#define S3C2440_DSC1_NFC_6mA    (2<<20)
+#define S3C2440_DSC1_NFC_4mA    (3<<20)
+#define S3C2440_DSC1_NFC_MASK   (3<<20)
+
+/* nBE[0..3] */
+#define S3C2440_DSC1_nBE        (S3C2440_SELECT_DSC1 | 18)
+#define S3C2440_DSC1_nBE_10mA   (0<<18)
+#define S3C2440_DSC1_nBE_8mA    (1<<18)
+#define S3C2440_DSC1_nBE_6mA    (2<<18)
+#define S3C2440_DSC1_nBE_4mA    (3<<18)
+#define S3C2440_DSC1_nBE_MASK   (3<<18)
+
+#define S3C2440_DSC1_WOE        (S3C2440_SELECT_DSC1 | 16)
+#define S3C2440_DSC1_WOE_10mA   (0<<16)
+#define S3C2440_DSC1_WOE_8mA    (1<<16)
+#define S3C2440_DSC1_WOE_6mA    (2<<16)
+#define S3C2440_DSC1_WOE_4mA    (3<<16)
+#define S3C2440_DSC1_WOE_MASK   (3<<16)
+
+#define S3C2440_DSC1_CS7        (S3C2440_SELECT_DSC1 | 14)
+#define S3C2440_DSC1_CS7_10mA   (0<<14)
+#define S3C2440_DSC1_CS7_8mA    (1<<14)
+#define S3C2440_DSC1_CS7_6mA    (2<<14)
+#define S3C2440_DSC1_CS7_4mA    (3<<14)
+#define S3C2440_DSC1_CS7_MASK   (3<<14)
+
+#define S3C2440_DSC1_CS6        (S3C2440_SELECT_DSC1 | 12)
+#define S3C2440_DSC1_CS6_10mA   (0<<12)
+#define S3C2440_DSC1_CS6_8mA    (1<<12)
+#define S3C2440_DSC1_CS6_6mA    (2<<12)
+#define S3C2440_DSC1_CS6_4mA    (3<<12)
+#define S3C2440_DSC1_CS6_MASK   (3<<12)
+
+#define S3C2440_DSC1_CS5        (S3C2440_SELECT_DSC1 | 10)
+#define S3C2440_DSC1_CS5_10mA   (0<<10)
+#define S3C2440_DSC1_CS5_8mA    (1<<10)
+#define S3C2440_DSC1_CS5_6mA    (2<<10)
+#define S3C2440_DSC1_CS5_4mA    (3<<10)
+#define S3C2440_DSC1_CS5_MASK   (3<<10)
+
+#define S3C2440_DSC1_CS4        (S3C2440_SELECT_DSC1 | 8)
+#define S3C2440_DSC1_CS4_10mA   (0<<8)
+#define S3C2440_DSC1_CS4_8mA    (1<<8)
+#define S3C2440_DSC1_CS4_6mA    (2<<8)
+#define S3C2440_DSC1_CS4_4mA    (3<<8)
+#define S3C2440_DSC1_CS4_MASK   (3<<8)
+
+#define S3C2440_DSC1_CS3        (S3C2440_SELECT_DSC1 | 6)
+#define S3C2440_DSC1_CS3_10mA   (0<<6)
+#define S3C2440_DSC1_CS3_8mA    (1<<6)
+#define S3C2440_DSC1_CS3_6mA    (2<<6)
+#define S3C2440_DSC1_CS3_4mA    (3<<6)
+#define S3C2440_DSC1_CS3_MASK   (3<<6)
+
+#define S3C2440_DSC1_CS2        (S3C2440_SELECT_DSC1 | 4)
+#define S3C2440_DSC1_CS2_10mA   (0<<4)
+#define S3C2440_DSC1_CS2_8mA    (1<<4)
+#define S3C2440_DSC1_CS2_6mA    (2<<4)
+#define S3C2440_DSC1_CS2_4mA    (3<<4)
+#define S3C2440_DSC1_CS2_MASK   (3<<4)
+
+#define S3C2440_DSC1_CS1        (S3C2440_SELECT_DSC1 | 2)
+#define S3C2440_DSC1_CS1_10mA   (0<<2)
+#define S3C2440_DSC1_CS1_8mA    (1<<2)
+#define S3C2440_DSC1_CS1_6mA    (2<<2)
+#define S3C2440_DSC1_CS1_4mA    (3<<2)
+#define S3C2440_DSC1_CS1_MASK   (3<<2)
+
+#define S3C2440_DSC1_CS0        (S3C2440_SELECT_DSC1 | 0)
+#define S3C2440_DSC1_CS0_10mA   (0<<0)
+#define S3C2440_DSC1_CS0_8mA    (1<<0)
+#define S3C2440_DSC1_CS0_6mA    (2<<0)
+#define S3C2440_DSC1_CS0_4mA    (3<<0)
+#define S3C2440_DSC1_CS0_MASK   (3<<0)
+
+#endif /* CONFIG_CPU_S3C2440 */
+
+#endif	/* __ASM_ARCH_REGS_DSC_H */
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,1149 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-gpio.h
+ *
+ * Copyright (c) 2003,2004 Simtec Electronics <linux@simtec.co.uk>
+ *		           http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 GPIO register definitions
+*/
+
+
+#ifndef __ASM_ARCH_REGS_GPIO_H
+#define __ASM_ARCH_REGS_GPIO_H "$Id: gpio.h,v 1.5 2003/05/19 12:51:08 ben Exp $"
+
+#define S3C2410_GPIONO(bank,offset) ((bank) + (offset))
+
+#define S3C2410_GPIO_BANKA   (32*0)
+#define S3C2410_GPIO_BANKB   (32*1)
+#define S3C2410_GPIO_BANKC   (32*2)
+#define S3C2410_GPIO_BANKD   (32*3)
+#define S3C2410_GPIO_BANKE   (32*4)
+#define S3C2410_GPIO_BANKF   (32*5)
+#define S3C2410_GPIO_BANKG   (32*6)
+#define S3C2410_GPIO_BANKH   (32*7)
+
+#ifdef CONFIG_CPU_S3C2400
+#define S3C24XX_GPIO_BASE(x)  S3C2400_GPIO_BASE(x)
+#define S3C24XX_MISCCR        S3C2400_MISCCR
+#else
+#define S3C24XX_GPIO_BASE(x)  S3C2410_GPIO_BASE(x)
+#define S3C24XX_MISCCR	      S3C24XX_GPIOREG2(0x80)
+#endif /* CONFIG_CPU_S3C2400 */
+
+
+/* S3C2400 doesn't have a 1:1 mapping to S3C2410 gpio base pins */
+
+#define S3C2400_BANKNUM(pin)     (((pin) & ~31) / 32)
+#define S3C2400_BASEA2B(pin)     ((((pin) & ~31) >> 2))
+#define S3C2400_BASEC2H(pin)     ((S3C2400_BANKNUM(pin) * 10) + \
+                                 (2 * (S3C2400_BANKNUM(pin)-2)))
+
+#define S3C2400_GPIO_BASE(pin)   (pin < S3C2410_GPIO_BANKC ? \
+                                 S3C2400_BASEA2B(pin)+S3C24XX_VA_GPIO : \
+                                 S3C2400_BASEC2H(pin)+S3C24XX_VA_GPIO)
+
+
+#define S3C2410_GPIO_BASE(pin)   ((((pin) & ~31) >> 1) + S3C24XX_VA_GPIO)
+#define S3C2410_GPIO_OFFSET(pin) ((pin) & 31)
+
+/* general configuration options */
+
+#define S3C2410_GPIO_LEAVE   (0xFFFFFFFF)
+#define S3C2410_GPIO_INPUT   (0xFFFFFFF0)	/* not available on A */
+#define S3C2410_GPIO_OUTPUT  (0xFFFFFFF1)
+#define S3C2410_GPIO_IRQ     (0xFFFFFFF2)	/* not available for all */
+#define S3C2410_GPIO_SFN2    (0xFFFFFFF2)	/* bank A => addr/cs/nand */
+#define S3C2410_GPIO_SFN3    (0xFFFFFFF3)	/* not available on A */
+
+/* register address for the GPIO registers.
+ * S3C24XX_GPIOREG2 is for the second set of registers in the
+ * GPIO which move between s3c2410 and s3c2412 type systems */
+
+#define S3C2410_GPIOREG(x) ((x) + S3C24XX_VA_GPIO)
+#define S3C24XX_GPIOREG2(x) ((x) + S3C24XX_VA_GPIO2)
+
+
+/* configure GPIO ports A..G */
+
+/* port A - S3C2410: 22bits, zero in bit X makes pin X output
+ *          S3C2400: 18bits, zero in bit X makes pin X output
+ * 1 makes port special function, this is default
+*/
+#define S3C2410_GPACON	   S3C2410_GPIOREG(0x00)
+#define S3C2410_GPADAT	   S3C2410_GPIOREG(0x04)
+
+#define S3C2400_GPACON	   S3C2410_GPIOREG(0x00)
+#define S3C2400_GPADAT	   S3C2410_GPIOREG(0x04)
+
+#define S3C2410_GPA0         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 0)
+#define S3C2410_GPA0_OUT     (0<<0)
+#define S3C2410_GPA0_ADDR0   (1<<0)
+
+#define S3C2410_GPA1         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 1)
+#define S3C2410_GPA1_OUT     (0<<1)
+#define S3C2410_GPA1_ADDR16  (1<<1)
+
+#define S3C2410_GPA2         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 2)
+#define S3C2410_GPA2_OUT     (0<<2)
+#define S3C2410_GPA2_ADDR17  (1<<2)
+
+#define S3C2410_GPA3         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 3)
+#define S3C2410_GPA3_OUT     (0<<3)
+#define S3C2410_GPA3_ADDR18  (1<<3)
+
+#define S3C2410_GPA4         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 4)
+#define S3C2410_GPA4_OUT     (0<<4)
+#define S3C2410_GPA4_ADDR19  (1<<4)
+
+#define S3C2410_GPA5         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 5)
+#define S3C2410_GPA5_OUT     (0<<5)
+#define S3C2410_GPA5_ADDR20  (1<<5)
+
+#define S3C2410_GPA6         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 6)
+#define S3C2410_GPA6_OUT     (0<<6)
+#define S3C2410_GPA6_ADDR21  (1<<6)
+
+#define S3C2410_GPA7         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 7)
+#define S3C2410_GPA7_OUT     (0<<7)
+#define S3C2410_GPA7_ADDR22  (1<<7)
+
+#define S3C2410_GPA8         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 8)
+#define S3C2410_GPA8_OUT     (0<<8)
+#define S3C2410_GPA8_ADDR23  (1<<8)
+
+#define S3C2410_GPA9         S3C2410_GPIONO(S3C2410_GPIO_BANKA, 9)
+#define S3C2410_GPA9_OUT     (0<<9)
+#define S3C2410_GPA9_ADDR24  (1<<9)
+
+#define S3C2410_GPA10        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 10)
+#define S3C2410_GPA10_OUT    (0<<10)
+#define S3C2410_GPA10_ADDR25 (1<<10)
+#define S3C2400_GPA10_SCKE   (1<<10)
+
+#define S3C2410_GPA11        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 11)
+#define S3C2410_GPA11_OUT    (0<<11)
+#define S3C2410_GPA11_ADDR26 (1<<11)
+#define S3C2400_GPA11_nCAS0  (1<<11)
+
+#define S3C2410_GPA12        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 12)
+#define S3C2410_GPA12_OUT    (0<<12)
+#define S3C2410_GPA12_nGCS1  (1<<12)
+#define S3C2400_GPA12_nCAS1  (1<<12)
+
+#define S3C2410_GPA13        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 13)
+#define S3C2410_GPA13_OUT    (0<<13)
+#define S3C2410_GPA13_nGCS2  (1<<13)
+#define S3C2400_GPA13_nGCS1  (1<<13)
+
+#define S3C2410_GPA14        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 14)
+#define S3C2410_GPA14_OUT    (0<<14)
+#define S3C2410_GPA14_nGCS3  (1<<14)
+#define S3C2400_GPA14_nGCS2  (1<<14)
+
+#define S3C2410_GPA15        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 15)
+#define S3C2410_GPA15_OUT    (0<<15)
+#define S3C2410_GPA15_nGCS4  (1<<15)
+#define S3C2400_GPA15_nGCS3  (1<<15)
+
+#define S3C2410_GPA16        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 16)
+#define S3C2410_GPA16_OUT    (0<<16)
+#define S3C2410_GPA16_nGCS5  (1<<16)
+#define S3C2400_GPA16_nGCS4  (1<<16)
+
+#define S3C2410_GPA17        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 17)
+#define S3C2410_GPA17_OUT    (0<<17)
+#define S3C2410_GPA17_CLE    (1<<17)
+#define S3C2400_GPA17_nGCS5  (1<<17)
+
+#define S3C2410_GPA18        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 18)
+#define S3C2410_GPA18_OUT    (0<<18)
+#define S3C2410_GPA18_ALE    (1<<18)
+
+#define S3C2410_GPA19        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 19)
+#define S3C2410_GPA19_OUT    (0<<19)
+#define S3C2410_GPA19_nFWE   (1<<19)
+
+#define S3C2410_GPA20        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 20)
+#define S3C2410_GPA20_OUT    (0<<20)
+#define S3C2410_GPA20_nFRE   (1<<20)
+
+#define S3C2410_GPA21        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 21)
+#define S3C2410_GPA21_OUT    (0<<21)
+#define S3C2410_GPA21_nRSTOUT (1<<21)
+
+#define S3C2410_GPA22        S3C2410_GPIONO(S3C2410_GPIO_BANKA, 22)
+#define S3C2410_GPA22_OUT    (0<<22)
+#define S3C2410_GPA22_nFCE   (1<<22)
+
+/* 0x08 and 0x0c are reserved on S3C2410 */
+
+/* S3C2410:
+ * GPB is 10 IO pins, each configured by 2 bits each in GPBCON.
+ *   00 = input, 01 = output, 10=special function, 11=reserved
+
+ * S3C2400:
+ * GPB is 16 IO pins, each configured by 2 bits each in GPBCON.
+ *   00 = input, 01 = output, 10=data, 11=special function
+
+ * bit 0,1 = pin 0, 2,3= pin 1...
+ *
+ * CPBUP = pull up resistor control, 1=disabled, 0=enabled
+*/
+
+#define S3C2410_GPBCON	   S3C2410_GPIOREG(0x10)
+#define S3C2410_GPBDAT	   S3C2410_GPIOREG(0x14)
+#define S3C2410_GPBUP	   S3C2410_GPIOREG(0x18)
+
+#define S3C2400_GPBCON	   S3C2410_GPIOREG(0x08)
+#define S3C2400_GPBDAT	   S3C2410_GPIOREG(0x0C)
+#define S3C2400_GPBUP	   S3C2410_GPIOREG(0x10)
+
+/* no i/o pin in port b can have value 3 (unless it is a s3c2443) ! */
+
+#define S3C2410_GPB0         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 0)
+#define S3C2410_GPB0_INP     (0x00 << 0)
+#define S3C2410_GPB0_OUTP    (0x01 << 0)
+#define S3C2410_GPB0_TOUT0   (0x02 << 0)
+#define S3C2400_GPB0_DATA16  (0x02 << 0)
+
+#define S3C2410_GPB1         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 1)
+#define S3C2410_GPB1_INP     (0x00 << 2)
+#define S3C2410_GPB1_OUTP    (0x01 << 2)
+#define S3C2410_GPB1_TOUT1   (0x02 << 2)
+#define S3C2400_GPB1_DATA17  (0x02 << 2)
+
+#define S3C2410_GPB2         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 2)
+#define S3C2410_GPB2_INP     (0x00 << 4)
+#define S3C2410_GPB2_OUTP    (0x01 << 4)
+#define S3C2410_GPB2_TOUT2   (0x02 << 4)
+#define S3C2400_GPB2_DATA18  (0x02 << 4)
+#define S3C2400_GPB2_TCLK1   (0x03 << 4)
+
+#define S3C2410_GPB3         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 3)
+#define S3C2410_GPB3_INP     (0x00 << 6)
+#define S3C2410_GPB3_OUTP    (0x01 << 6)
+#define S3C2410_GPB3_TOUT3   (0x02 << 6)
+#define S3C2400_GPB3_DATA19  (0x02 << 6)
+#define S3C2400_GPB3_TXD1    (0x03 << 6)
+
+#define S3C2410_GPB4         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 4)
+#define S3C2410_GPB4_INP     (0x00 << 8)
+#define S3C2410_GPB4_OUTP    (0x01 << 8)
+#define S3C2410_GPB4_TCLK0   (0x02 << 8)
+#define S3C2400_GPB4_DATA20  (0x02 << 8)
+#define S3C2410_GPB4_MASK    (0x03 << 8)
+#define S3C2400_GPB4_RXD1    (0x03 << 8)
+#define S3C2400_GPB4_MASK    (0x03 << 8)
+
+#define S3C2410_GPB5         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 5)
+#define S3C2410_GPB5_INP     (0x00 << 10)
+#define S3C2410_GPB5_OUTP    (0x01 << 10)
+#define S3C2410_GPB5_nXBACK  (0x02 << 10)
+#define S3C2443_GPB5_XBACK   (0x03 << 10)
+#define S3C2400_GPB5_DATA21  (0x02 << 10)
+#define S3C2400_GPB5_nCTS1   (0x03 << 10)
+
+#define S3C2410_GPB6         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 6)
+#define S3C2410_GPB6_INP     (0x00 << 12)
+#define S3C2410_GPB6_OUTP    (0x01 << 12)
+#define S3C2410_GPB6_nXBREQ  (0x02 << 12)
+#define S3C2443_GPB6_XBREQ   (0x03 << 12)
+#define S3C2400_GPB6_DATA22  (0x02 << 12)
+#define S3C2400_GPB6_nRTS1   (0x03 << 12)
+
+#define S3C2410_GPB7         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 7)
+#define S3C2410_GPB7_INP     (0x00 << 14)
+#define S3C2410_GPB7_OUTP    (0x01 << 14)
+#define S3C2410_GPB7_nXDACK1 (0x02 << 14)
+#define S3C2443_GPB7_XDACK1  (0x03 << 14)
+#define S3C2400_GPB7_DATA23  (0x02 << 14)
+
+#define S3C2410_GPB8         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 8)
+#define S3C2410_GPB8_INP     (0x00 << 16)
+#define S3C2410_GPB8_OUTP    (0x01 << 16)
+#define S3C2410_GPB8_nXDREQ1 (0x02 << 16)
+#define S3C2400_GPB8_DATA24  (0x02 << 16)
+
+#define S3C2410_GPB9         S3C2410_GPIONO(S3C2410_GPIO_BANKB, 9)
+#define S3C2410_GPB9_INP     (0x00 << 18)
+#define S3C2410_GPB9_OUTP    (0x01 << 18)
+#define S3C2410_GPB9_nXDACK0 (0x02 << 18)
+#define S3C2443_GPB9_XDACK0  (0x03 << 18)
+#define S3C2400_GPB9_DATA25  (0x02 << 18)
+#define S3C2400_GPB9_I2SSDI  (0x03 << 18)
+
+#define S3C2410_GPB10        S3C2410_GPIONO(S3C2410_GPIO_BANKB, 10)
+#define S3C2410_GPB10_INP    (0x00 << 20)
+#define S3C2410_GPB10_OUTP   (0x01 << 20)
+#define S3C2410_GPB10_nXDRE0 (0x02 << 20)
+#define S3C2443_GPB10_XDREQ0 (0x03 << 20)
+#define S3C2400_GPB10_DATA26 (0x02 << 20)
+#define S3C2400_GPB10_nSS    (0x03 << 20)
+
+#define S3C2400_GPB11        S3C2410_GPIONO(S3C2410_GPIO_BANKB, 11)
+#define S3C2400_GPB11_INP    (0x00 << 22)
+#define S3C2400_GPB11_OUTP   (0x01 << 22)
+#define S3C2400_GPB11_DATA27 (0x02 << 22)
+
+#define S3C2400_GPB12        S3C2410_GPIONO(S3C2410_GPIO_BANKB, 12)
+#define S3C2400_GPB12_INP    (0x00 << 24)
+#define S3C2400_GPB12_OUTP   (0x01 << 24)
+#define S3C2400_GPB12_DATA28 (0x02 << 24)
+
+#define S3C2400_GPB13        S3C2410_GPIONO(S3C2410_GPIO_BANKB, 13)
+#define S3C2400_GPB13_INP    (0x00 << 26)
+#define S3C2400_GPB13_OUTP   (0x01 << 26)
+#define S3C2400_GPB13_DATA29 (0x02 << 26)
+
+#define S3C2400_GPB14        S3C2410_GPIONO(S3C2410_GPIO_BANKB, 14)
+#define S3C2400_GPB14_INP    (0x00 << 28)
+#define S3C2400_GPB14_OUTP   (0x01 << 28)
+#define S3C2400_GPB14_DATA30 (0x02 << 28)
+
+#define S3C2400_GPB15        S3C2410_GPIONO(S3C2410_GPIO_BANKB, 15)
+#define S3C2400_GPB15_INP    (0x00 << 30)
+#define S3C2400_GPB15_OUTP   (0x01 << 30)
+#define S3C2400_GPB15_DATA31 (0x02 << 30)
+
+#define S3C2410_GPB_PUPDIS(x)  (1<<(x))
+
+/* Port C consits of 16 GPIO/Special function
+ *
+ * almost identical setup to port b, but the special functions are mostly
+ * to do with the video system's sync/etc.
+*/
+
+#define S3C2410_GPCCON	   S3C2410_GPIOREG(0x20)
+#define S3C2410_GPCDAT	   S3C2410_GPIOREG(0x24)
+#define S3C2410_GPCUP	   S3C2410_GPIOREG(0x28)
+
+#define S3C2400_GPCCON	   S3C2410_GPIOREG(0x14)
+#define S3C2400_GPCDAT	   S3C2410_GPIOREG(0x18)
+#define S3C2400_GPCUP	   S3C2410_GPIOREG(0x1C)
+
+#define S3C2410_GPC0            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 0)
+#define S3C2410_GPC0_INP	(0x00 << 0)
+#define S3C2410_GPC0_OUTP	(0x01 << 0)
+#define S3C2410_GPC0_LEND	(0x02 << 0)
+#define S3C2400_GPC0_VD0 	(0x02 << 0)
+
+#define S3C2410_GPC1            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 1)
+#define S3C2410_GPC1_INP	(0x00 << 2)
+#define S3C2410_GPC1_OUTP	(0x01 << 2)
+#define S3C2410_GPC1_VCLK	(0x02 << 2)
+#define S3C2400_GPC1_VD1 	(0x02 << 2)
+
+#define S3C2410_GPC2            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 2)
+#define S3C2410_GPC2_INP	(0x00 << 4)
+#define S3C2410_GPC2_OUTP	(0x01 << 4)
+#define S3C2410_GPC2_VLINE	(0x02 << 4)
+#define S3C2400_GPC2_VD2  	(0x02 << 4)
+
+#define S3C2410_GPC3            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 3)
+#define S3C2410_GPC3_INP	(0x00 << 6)
+#define S3C2410_GPC3_OUTP	(0x01 << 6)
+#define S3C2410_GPC3_VFRAME	(0x02 << 6)
+#define S3C2400_GPC3_VD3   	(0x02 << 6)
+
+#define S3C2410_GPC4            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 4)
+#define S3C2410_GPC4_INP	(0x00 << 8)
+#define S3C2410_GPC4_OUTP	(0x01 << 8)
+#define S3C2410_GPC4_VM		(0x02 << 8)
+#define S3C2400_GPC4_VD4	(0x02 << 8)
+
+#define S3C2410_GPC5            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 5)
+#define S3C2410_GPC5_INP	(0x00 << 10)
+#define S3C2410_GPC5_OUTP	(0x01 << 10)
+#define S3C2410_GPC5_LCDVF0	(0x02 << 10)
+#define S3C2400_GPC5_VD5   	(0x02 << 10)
+
+#define S3C2410_GPC6            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 6)
+#define S3C2410_GPC6_INP	(0x00 << 12)
+#define S3C2410_GPC6_OUTP	(0x01 << 12)
+#define S3C2410_GPC6_LCDVF1	(0x02 << 12)
+#define S3C2400_GPC6_VD6   	(0x02 << 12)
+
+#define S3C2410_GPC7            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 7)
+#define S3C2410_GPC7_INP	(0x00 << 14)
+#define S3C2410_GPC7_OUTP	(0x01 << 14)
+#define S3C2410_GPC7_LCDVF2	(0x02 << 14)
+#define S3C2400_GPC7_VD7   	(0x02 << 14)
+
+#define S3C2410_GPC8            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 8)
+#define S3C2410_GPC8_INP	(0x00 << 16)
+#define S3C2410_GPC8_OUTP	(0x01 << 16)
+#define S3C2410_GPC8_VD0	(0x02 << 16)
+#define S3C2400_GPC8_VD8	(0x02 << 16)
+
+#define S3C2410_GPC9            S3C2410_GPIONO(S3C2410_GPIO_BANKC, 9)
+#define S3C2410_GPC9_INP	(0x00 << 18)
+#define S3C2410_GPC9_OUTP	(0x01 << 18)
+#define S3C2410_GPC9_VD1	(0x02 << 18)
+#define S3C2400_GPC9_VD9	(0x02 << 18)
+
+#define S3C2410_GPC10           S3C2410_GPIONO(S3C2410_GPIO_BANKC, 10)
+#define S3C2410_GPC10_INP	(0x00 << 20)
+#define S3C2410_GPC10_OUTP	(0x01 << 20)
+#define S3C2410_GPC10_VD2	(0x02 << 20)
+#define S3C2400_GPC10_VD10	(0x02 << 20)
+
+#define S3C2410_GPC11           S3C2410_GPIONO(S3C2410_GPIO_BANKC, 11)
+#define S3C2410_GPC11_INP	(0x00 << 22)
+#define S3C2410_GPC11_OUTP	(0x01 << 22)
+#define S3C2410_GPC11_VD3	(0x02 << 22)
+#define S3C2400_GPC11_VD11	(0x02 << 22)
+
+#define S3C2410_GPC12           S3C2410_GPIONO(S3C2410_GPIO_BANKC, 12)
+#define S3C2410_GPC12_INP	(0x00 << 24)
+#define S3C2410_GPC12_OUTP	(0x01 << 24)
+#define S3C2410_GPC12_VD4	(0x02 << 24)
+#define S3C2400_GPC12_VD12	(0x02 << 24)
+
+#define S3C2410_GPC13           S3C2410_GPIONO(S3C2410_GPIO_BANKC, 13)
+#define S3C2410_GPC13_INP	(0x00 << 26)
+#define S3C2410_GPC13_OUTP	(0x01 << 26)
+#define S3C2410_GPC13_VD5	(0x02 << 26)
+#define S3C2400_GPC13_VD13	(0x02 << 26)
+
+#define S3C2410_GPC14           S3C2410_GPIONO(S3C2410_GPIO_BANKC, 14)
+#define S3C2410_GPC14_INP	(0x00 << 28)
+#define S3C2410_GPC14_OUTP	(0x01 << 28)
+#define S3C2410_GPC14_VD6	(0x02 << 28)
+#define S3C2400_GPC14_VD14	(0x02 << 28)
+
+#define S3C2410_GPC15           S3C2410_GPIONO(S3C2410_GPIO_BANKC, 15)
+#define S3C2410_GPC15_INP	(0x00 << 30)
+#define S3C2410_GPC15_OUTP	(0x01 << 30)
+#define S3C2410_GPC15_VD7	(0x02 << 30)
+#define S3C2400_GPC15_VD15	(0x02 << 30)
+
+#define S3C2410_GPC_PUPDIS(x)  (1<<(x))
+
+/*
+ * S3C2410: Port D consists of 16 GPIO/Special function
+ *
+ * almost identical setup to port b, but the special functions are mostly
+ * to do with the video system's data.
+ *
+ * S3C2400: Port D consists of 11 GPIO/Special function
+ *
+ * almost identical setup to port c
+*/
+
+#define S3C2410_GPDCON	   S3C2410_GPIOREG(0x30)
+#define S3C2410_GPDDAT	   S3C2410_GPIOREG(0x34)
+#define S3C2410_GPDUP	   S3C2410_GPIOREG(0x38)
+
+#define S3C2400_GPDCON	   S3C2410_GPIOREG(0x20)
+#define S3C2400_GPDDAT	   S3C2410_GPIOREG(0x24)
+#define S3C2400_GPDUP	   S3C2410_GPIOREG(0x28)
+
+#define S3C2410_GPD0            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 0)
+#define S3C2410_GPD0_INP	(0x00 << 0)
+#define S3C2410_GPD0_OUTP	(0x01 << 0)
+#define S3C2410_GPD0_VD8	(0x02 << 0)
+#define S3C2400_GPD0_VFRAME	(0x02 << 0)
+#define S3C2442_GPD0_nSPICS1	(0x03 << 0)
+
+#define S3C2410_GPD1            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 1)
+#define S3C2410_GPD1_INP	(0x00 << 2)
+#define S3C2410_GPD1_OUTP	(0x01 << 2)
+#define S3C2410_GPD1_VD9	(0x02 << 2)
+#define S3C2400_GPD1_VM		(0x02 << 2)
+#define S3C2442_GPD1_SPICLK1	(0x03 << 2)
+
+#define S3C2410_GPD2            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 2)
+#define S3C2410_GPD2_INP	(0x00 << 4)
+#define S3C2410_GPD2_OUTP	(0x01 << 4)
+#define S3C2410_GPD2_VD10	(0x02 << 4)
+#define S3C2400_GPD2_VLINE	(0x02 << 4)
+
+#define S3C2410_GPD3            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 3)
+#define S3C2410_GPD3_INP	(0x00 << 6)
+#define S3C2410_GPD3_OUTP	(0x01 << 6)
+#define S3C2410_GPD3_VD11	(0x02 << 6)
+#define S3C2400_GPD3_VCLK	(0x02 << 6)
+
+#define S3C2410_GPD4            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 4)
+#define S3C2410_GPD4_INP	(0x00 << 8)
+#define S3C2410_GPD4_OUTP	(0x01 << 8)
+#define S3C2410_GPD4_VD12	(0x02 << 8)
+#define S3C2400_GPD4_LEND	(0x02 << 8)
+
+#define S3C2410_GPD5            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 5)
+#define S3C2410_GPD5_INP	(0x00 << 10)
+#define S3C2410_GPD5_OUTP	(0x01 << 10)
+#define S3C2410_GPD5_VD13	(0x02 << 10)
+#define S3C2400_GPD5_TOUT0	(0x02 << 10)
+
+#define S3C2410_GPD6            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 6)
+#define S3C2410_GPD6_INP	(0x00 << 12)
+#define S3C2410_GPD6_OUTP	(0x01 << 12)
+#define S3C2410_GPD6_VD14	(0x02 << 12)
+#define S3C2400_GPD6_TOUT1	(0x02 << 12)
+
+#define S3C2410_GPD7            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 7)
+#define S3C2410_GPD7_INP	(0x00 << 14)
+#define S3C2410_GPD7_OUTP	(0x01 << 14)
+#define S3C2410_GPD7_VD15	(0x02 << 14)
+#define S3C2400_GPD7_TOUT2	(0x02 << 14)
+
+#define S3C2410_GPD8            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 8)
+#define S3C2410_GPD8_INP	(0x00 << 16)
+#define S3C2410_GPD8_OUTP	(0x01 << 16)
+#define S3C2410_GPD8_VD16	(0x02 << 16)
+#define S3C2400_GPD8_TOUT3	(0x02 << 16)
+
+#define S3C2410_GPD9            S3C2410_GPIONO(S3C2410_GPIO_BANKD, 9)
+#define S3C2410_GPD9_INP	(0x00 << 18)
+#define S3C2410_GPD9_OUTP	(0x01 << 18)
+#define S3C2410_GPD9_VD17	(0x02 << 18)
+#define S3C2400_GPD9_TCLK0	(0x02 << 18)
+#define S3C2410_GPD9_MASK       (0x03 << 18)
+
+#define S3C2410_GPD10           S3C2410_GPIONO(S3C2410_GPIO_BANKD, 10)
+#define S3C2410_GPD10_INP	(0x00 << 20)
+#define S3C2410_GPD10_OUTP	(0x01 << 20)
+#define S3C2410_GPD10_VD18	(0x02 << 20)
+#define S3C2400_GPD10_nWAIT	(0x02 << 20)
+
+#define S3C2410_GPD11           S3C2410_GPIONO(S3C2410_GPIO_BANKD, 11)
+#define S3C2410_GPD11_INP	(0x00 << 22)
+#define S3C2410_GPD11_OUTP	(0x01 << 22)
+#define S3C2410_GPD11_VD19	(0x02 << 22)
+
+#define S3C2410_GPD12           S3C2410_GPIONO(S3C2410_GPIO_BANKD, 12)
+#define S3C2410_GPD12_INP	(0x00 << 24)
+#define S3C2410_GPD12_OUTP	(0x01 << 24)
+#define S3C2410_GPD12_VD20	(0x02 << 24)
+
+#define S3C2410_GPD13           S3C2410_GPIONO(S3C2410_GPIO_BANKD, 13)
+#define S3C2410_GPD13_INP	(0x00 << 26)
+#define S3C2410_GPD13_OUTP	(0x01 << 26)
+#define S3C2410_GPD13_VD21	(0x02 << 26)
+
+#define S3C2410_GPD14           S3C2410_GPIONO(S3C2410_GPIO_BANKD, 14)
+#define S3C2410_GPD14_INP	(0x00 << 28)
+#define S3C2410_GPD14_OUTP	(0x01 << 28)
+#define S3C2410_GPD14_VD22	(0x02 << 28)
+
+#define S3C2410_GPD15           S3C2410_GPIONO(S3C2410_GPIO_BANKD, 15)
+#define S3C2410_GPD15_INP	(0x00 << 30)
+#define S3C2410_GPD15_OUTP	(0x01 << 30)
+#define S3C2410_GPD15_VD23	(0x02 << 30)
+
+#define S3C2410_GPD_PUPDIS(x)  (1<<(x))
+
+/* S3C2410:
+ * Port E consists of 16 GPIO/Special function
+ *
+ * again, the same as port B, but dealing with I2S, SDI, and
+ * more miscellaneous functions
+ *
+ * S3C2400:
+ * Port E consists of 12 GPIO/Special function
+ *
+ * GPIO / interrupt inputs
+*/
+
+#define S3C2410_GPECON	   S3C2410_GPIOREG(0x40)
+#define S3C2410_GPEDAT	   S3C2410_GPIOREG(0x44)
+#define S3C2410_GPEUP	   S3C2410_GPIOREG(0x48)
+
+#define S3C2400_GPECON	   S3C2410_GPIOREG(0x2C)
+#define S3C2400_GPEDAT	   S3C2410_GPIOREG(0x30)
+#define S3C2400_GPEUP	   S3C2410_GPIOREG(0x34)
+
+#define S3C2410_GPE0           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 0)
+#define S3C2410_GPE0_INP       (0x00 << 0)
+#define S3C2410_GPE0_OUTP      (0x01 << 0)
+#define S3C2410_GPE0_I2SLRCK   (0x02 << 0)
+#define S3C2443_GPE0_AC_nRESET (0x03 << 0)
+#define S3C2400_GPE0_EINT0     (0x02 << 0)
+#define S3C2410_GPE0_MASK      (0x03 << 0)
+
+#define S3C2410_GPE1           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 1)
+#define S3C2410_GPE1_INP       (0x00 << 2)
+#define S3C2410_GPE1_OUTP      (0x01 << 2)
+#define S3C2410_GPE1_I2SSCLK   (0x02 << 2)
+#define S3C2443_GPE1_AC_SYNC   (0x03 << 2)
+#define S3C2400_GPE1_EINT1     (0x02 << 2)
+#define S3C2400_GPE1_nSS       (0x03 << 2)
+#define S3C2410_GPE1_MASK      (0x03 << 2)
+
+#define S3C2410_GPE2           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 2)
+#define S3C2410_GPE2_INP       (0x00 << 4)
+#define S3C2410_GPE2_OUTP      (0x01 << 4)
+#define S3C2410_GPE2_CDCLK     (0x02 << 4)
+#define S3C2443_GPE2_AC_BITCLK (0x03 << 4)
+#define S3C2400_GPE2_EINT2     (0x02 << 4)
+#define S3C2400_GPE2_I2SSDI    (0x03 << 4)
+
+#define S3C2410_GPE3           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 3)
+#define S3C2410_GPE3_INP       (0x00 << 6)
+#define S3C2410_GPE3_OUTP      (0x01 << 6)
+#define S3C2410_GPE3_I2SSDI    (0x02 << 6)
+#define S3C2443_GPE3_AC_SDI    (0x03 << 6)
+#define S3C2400_GPE3_EINT3     (0x02 << 6)
+#define S3C2400_GPE3_nCTS1     (0x03 << 6)
+#define S3C2410_GPE3_nSS0      (0x03 << 6)
+#define S3C2410_GPE3_MASK      (0x03 << 6)
+
+#define S3C2410_GPE4           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 4)
+#define S3C2410_GPE4_INP       (0x00 << 8)
+#define S3C2410_GPE4_OUTP      (0x01 << 8)
+#define S3C2410_GPE4_I2SSDO    (0x02 << 8)
+#define S3C2443_GPE4_AC_SDO    (0x03 << 8)
+#define S3C2400_GPE4_EINT4     (0x02 << 8)
+#define S3C2400_GPE4_nRTS1     (0x03 << 8)
+#define S3C2410_GPE4_I2SSDI    (0x03 << 8)
+#define S3C2410_GPE4_MASK      (0x03 << 8)
+
+#define S3C2410_GPE5           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 5)
+#define S3C2410_GPE5_INP       (0x00 << 10)
+#define S3C2410_GPE5_OUTP      (0x01 << 10)
+#define S3C2410_GPE5_SDCLK     (0x02 << 10)
+#define S3C2443_GPE5_SD1_CLK   (0x02 << 10)
+#define S3C2400_GPE5_EINT5     (0x02 << 10)
+#define S3C2400_GPE5_TCLK1     (0x03 << 10)
+
+#define S3C2410_GPE6           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 6)
+#define S3C2410_GPE6_INP       (0x00 << 12)
+#define S3C2410_GPE6_OUTP      (0x01 << 12)
+#define S3C2410_GPE6_SDCMD     (0x02 << 12)
+#define S3C2443_GPE6_SD1_CMD   (0x02 << 12)
+#define S3C2443_GPE6_AC_BITCLK (0x03 << 12)
+#define S3C2400_GPE6_EINT6     (0x02 << 12)
+
+#define S3C2410_GPE7           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 7)
+#define S3C2410_GPE7_INP       (0x00 << 14)
+#define S3C2410_GPE7_OUTP      (0x01 << 14)
+#define S3C2410_GPE7_SDDAT0    (0x02 << 14)
+#define S3C2443_GPE5_SD1_DAT0  (0x02 << 14)
+#define S3C2443_GPE7_AC_SDI    (0x03 << 14)
+#define S3C2400_GPE7_EINT7     (0x02 << 14)
+
+#define S3C2410_GPE8           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 8)
+#define S3C2410_GPE8_INP       (0x00 << 16)
+#define S3C2410_GPE8_OUTP      (0x01 << 16)
+#define S3C2410_GPE8_SDDAT1    (0x02 << 16)
+#define S3C2443_GPE8_SD1_DAT1  (0x02 << 16)
+#define S3C2443_GPE8_AC_SDO    (0x03 << 16)
+#define S3C2400_GPE8_nXDACK0   (0x02 << 16)
+
+#define S3C2410_GPE9           S3C2410_GPIONO(S3C2410_GPIO_BANKE, 9)
+#define S3C2410_GPE9_INP       (0x00 << 18)
+#define S3C2410_GPE9_OUTP      (0x01 << 18)
+#define S3C2410_GPE9_SDDAT2    (0x02 << 18)
+#define S3C2443_GPE9_SD1_DAT2  (0x02 << 18)
+#define S3C2443_GPE9_AC_SYNC   (0x03 << 18)
+#define S3C2400_GPE9_nXDACK1   (0x02 << 18)
+#define S3C2400_GPE9_nXBACK    (0x03 << 18)
+
+#define S3C2410_GPE10          S3C2410_GPIONO(S3C2410_GPIO_BANKE, 10)
+#define S3C2410_GPE10_INP      (0x00 << 20)
+#define S3C2410_GPE10_OUTP     (0x01 << 20)
+#define S3C2410_GPE10_SDDAT3   (0x02 << 20)
+#define S3C2443_GPE10_SD1_DAT3 (0x02 << 20)
+#define S3C2443_GPE10_AC_nRESET (0x03 << 20)
+#define S3C2400_GPE10_nXDREQ0  (0x02 << 20)
+
+#define S3C2410_GPE11          S3C2410_GPIONO(S3C2410_GPIO_BANKE, 11)
+#define S3C2410_GPE11_INP      (0x00 << 22)
+#define S3C2410_GPE11_OUTP     (0x01 << 22)
+#define S3C2410_GPE11_SPIMISO0 (0x02 << 22)
+#define S3C2400_GPE11_nXDREQ1  (0x02 << 22)
+#define S3C2400_GPE11_nXBREQ   (0x03 << 22)
+
+#define S3C2410_GPE12          S3C2410_GPIONO(S3C2410_GPIO_BANKE, 12)
+#define S3C2410_GPE12_INP      (0x00 << 24)
+#define S3C2410_GPE12_OUTP     (0x01 << 24)
+#define S3C2410_GPE12_SPIMOSI0 (0x02 << 24)
+
+#define S3C2410_GPE13          S3C2410_GPIONO(S3C2410_GPIO_BANKE, 13)
+#define S3C2410_GPE13_INP      (0x00 << 26)
+#define S3C2410_GPE13_OUTP     (0x01 << 26)
+#define S3C2410_GPE13_SPICLK0  (0x02 << 26)
+
+#define S3C2410_GPE14          S3C2410_GPIONO(S3C2410_GPIO_BANKE, 14)
+#define S3C2410_GPE14_INP      (0x00 << 28)
+#define S3C2410_GPE14_OUTP     (0x01 << 28)
+#define S3C2410_GPE14_IICSCL   (0x02 << 28)
+#define S3C2410_GPE14_MASK     (0x03 << 28)
+
+#define S3C2410_GPE15          S3C2410_GPIONO(S3C2410_GPIO_BANKE, 15)
+#define S3C2410_GPE15_INP      (0x00 << 30)
+#define S3C2410_GPE15_OUTP     (0x01 << 30)
+#define S3C2410_GPE15_IICSDA   (0x02 << 30)
+#define S3C2410_GPE15_MASK     (0x03 << 30)
+
+#define S3C2440_GPE0_ACSYNC    (0x03 << 0)
+#define S3C2440_GPE1_ACBITCLK  (0x03 << 2)
+#define S3C2440_GPE2_ACRESET   (0x03 << 4)
+#define S3C2440_GPE3_ACIN      (0x03 << 6)
+#define S3C2440_GPE4_ACOUT     (0x03 << 8)
+
+#define S3C2410_GPE_PUPDIS(x)  (1<<(x))
+
+/* S3C2410:
+ * Port F consists of 8 GPIO/Special function
+ *
+ * GPIO / interrupt inputs
+ *
+ * GPFCON has 2 bits for each of the input pins on port F
+ *   00 = 0 input, 1 output, 2 interrupt (EINT0..7), 3 undefined
+ *
+ * pull up works like all other ports.
+ *
+ * S3C2400:
+ * Port F consists of 7 GPIO/Special function
+ *
+ * GPIO/serial/misc pins
+*/
+
+#define S3C2410_GPFCON	   S3C2410_GPIOREG(0x50)
+#define S3C2410_GPFDAT	   S3C2410_GPIOREG(0x54)
+#define S3C2410_GPFUP	   S3C2410_GPIOREG(0x58)
+
+#define S3C2400_GPFCON	   S3C2410_GPIOREG(0x38)
+#define S3C2400_GPFDAT	   S3C2410_GPIOREG(0x3C)
+#define S3C2400_GPFUP	   S3C2410_GPIOREG(0x40)
+
+#define S3C2410_GPF0        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 0)
+#define S3C2410_GPF0_INP    (0x00 << 0)
+#define S3C2410_GPF0_OUTP   (0x01 << 0)
+#define S3C2410_GPF0_EINT0  (0x02 << 0)
+#define S3C2400_GPF0_RXD0   (0x02 << 0)
+
+#define S3C2410_GPF1        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 1)
+#define S3C2410_GPF1_INP    (0x00 << 2)
+#define S3C2410_GPF1_OUTP   (0x01 << 2)
+#define S3C2410_GPF1_EINT1  (0x02 << 2)
+#define S3C2400_GPF1_RXD1   (0x02 << 2)
+#define S3C2400_GPF1_IICSDA (0x03 << 2)
+
+#define S3C2410_GPF2        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 2)
+#define S3C2410_GPF2_INP    (0x00 << 4)
+#define S3C2410_GPF2_OUTP   (0x01 << 4)
+#define S3C2410_GPF2_EINT2  (0x02 << 4)
+#define S3C2400_GPF2_TXD0   (0x02 << 4)
+
+#define S3C2410_GPF3        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 3)
+#define S3C2410_GPF3_INP    (0x00 << 6)
+#define S3C2410_GPF3_OUTP   (0x01 << 6)
+#define S3C2410_GPF3_EINT3  (0x02 << 6)
+#define S3C2400_GPF3_TXD1   (0x02 << 6)
+#define S3C2400_GPF3_IICSCL (0x03 << 6)
+
+#define S3C2410_GPF4        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 4)
+#define S3C2410_GPF4_INP    (0x00 << 8)
+#define S3C2410_GPF4_OUTP   (0x01 << 8)
+#define S3C2410_GPF4_EINT4  (0x02 << 8)
+#define S3C2400_GPF4_nRTS0  (0x02 << 8)
+#define S3C2400_GPF4_nXBACK (0x03 << 8)
+
+#define S3C2410_GPF5        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 5)
+#define S3C2410_GPF5_INP    (0x00 << 10)
+#define S3C2410_GPF5_OUTP   (0x01 << 10)
+#define S3C2410_GPF5_EINT5  (0x02 << 10)
+#define S3C2400_GPF5_nCTS0  (0x02 << 10)
+#define S3C2400_GPF5_nXBREQ (0x03 << 10)
+
+#define S3C2410_GPF6        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 6)
+#define S3C2410_GPF6_INP    (0x00 << 12)
+#define S3C2410_GPF6_OUTP   (0x01 << 12)
+#define S3C2410_GPF6_EINT6  (0x02 << 12)
+#define S3C2400_GPF6_CLKOUT (0x02 << 12)
+
+#define S3C2410_GPF7        S3C2410_GPIONO(S3C2410_GPIO_BANKF, 7)
+#define S3C2410_GPF7_INP    (0x00 << 14)
+#define S3C2410_GPF7_OUTP   (0x01 << 14)
+#define S3C2410_GPF7_EINT7  (0x02 << 14)
+
+#define S3C2410_GPF_PUPDIS(x)  (1<<(x))
+
+/* S3C2410:
+ * Port G consists of 8 GPIO/IRQ/Special function
+ *
+ * GPGCON has 2 bits for each of the input pins on port F
+ *   00 = 0 input, 1 output, 2 interrupt (EINT0..7), 3 special func
+ *
+ * pull up works like all other ports.
+ *
+ * S3C2400:
+ * Port G consists of 10 GPIO/Special function
+*/
+
+#define S3C2410_GPGCON	   S3C2410_GPIOREG(0x60)
+#define S3C2410_GPGDAT	   S3C2410_GPIOREG(0x64)
+#define S3C2410_GPGUP	   S3C2410_GPIOREG(0x68)
+
+#define S3C2400_GPGCON	   S3C2410_GPIOREG(0x44)
+#define S3C2400_GPGDAT	   S3C2410_GPIOREG(0x48)
+#define S3C2400_GPGUP	   S3C2410_GPIOREG(0x4C)
+
+#define S3C2410_GPG0          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 0)
+#define S3C2410_GPG0_INP      (0x00 << 0)
+#define S3C2410_GPG0_OUTP     (0x01 << 0)
+#define S3C2410_GPG0_EINT8    (0x02 << 0)
+#define S3C2400_GPG0_I2SLRCK  (0x02 << 0)
+
+#define S3C2410_GPG1          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 1)
+#define S3C2410_GPG1_INP      (0x00 << 2)
+#define S3C2410_GPG1_OUTP     (0x01 << 2)
+#define S3C2410_GPG1_EINT9    (0x02 << 2)
+#define S3C2400_GPG1_I2SSCLK  (0x02 << 2)
+
+#define S3C2410_GPG2          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 2)
+#define S3C2410_GPG2_INP      (0x00 << 4)
+#define S3C2410_GPG2_OUTP     (0x01 << 4)
+#define S3C2410_GPG2_EINT10   (0x02 << 4)
+#define S3C2400_GPG2_CDCLK    (0x02 << 4)
+
+#define S3C2410_GPG3          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 3)
+#define S3C2410_GPG3_INP      (0x00 << 6)
+#define S3C2410_GPG3_OUTP     (0x01 << 6)
+#define S3C2410_GPG3_EINT11   (0x02 << 6)
+#define S3C2400_GPG3_I2SSDO   (0x02 << 6)
+#define S3C2400_GPG3_I2SSDI   (0x03 << 6)
+
+#define S3C2410_GPG4          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 4)
+#define S3C2410_GPG4_INP      (0x00 << 8)
+#define S3C2410_GPG4_OUTP     (0x01 << 8)
+#define S3C2410_GPG4_EINT12   (0x02 << 8)
+#define S3C2400_GPG4_MMCCLK   (0x02 << 8)
+#define S3C2400_GPG4_I2SSDI   (0x03 << 8)
+#define S3C2410_GPG4_LCDPWREN (0x03 << 8)
+#define S3C2443_GPG4_LCDPWRDN (0x03 << 8)
+
+#define S3C2410_GPG5          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 5)
+#define S3C2410_GPG5_INP      (0x00 << 10)
+#define S3C2410_GPG5_OUTP     (0x01 << 10)
+#define S3C2410_GPG5_EINT13   (0x02 << 10)
+#define S3C2400_GPG5_MMCCMD   (0x02 << 10)
+#define S3C2400_GPG5_IICSDA   (0x03 << 10)
+#define S3C2410_GPG5_SPIMISO1 (0x03 << 10)	/* not s3c2443 */
+
+#define S3C2410_GPG6          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 6)
+#define S3C2410_GPG6_INP      (0x00 << 12)
+#define S3C2410_GPG6_OUTP     (0x01 << 12)
+#define S3C2410_GPG6_EINT14   (0x02 << 12)
+#define S3C2400_GPG6_MMCDAT   (0x02 << 12)
+#define S3C2400_GPG6_IICSCL   (0x03 << 12)
+#define S3C2410_GPG6_SPIMOSI1 (0x03 << 12)
+
+#define S3C2410_GPG7          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 7)
+#define S3C2410_GPG7_INP      (0x00 << 14)
+#define S3C2410_GPG7_OUTP     (0x01 << 14)
+#define S3C2410_GPG7_EINT15   (0x02 << 14)
+#define S3C2410_GPG7_SPICLK1  (0x03 << 14)
+#define S3C2400_GPG7_SPIMISO  (0x02 << 14)
+#define S3C2400_GPG7_IICSDA   (0x03 << 14)
+
+#define S3C2410_GPG8          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 8)
+#define S3C2410_GPG8_INP      (0x00 << 16)
+#define S3C2410_GPG8_OUTP     (0x01 << 16)
+#define S3C2410_GPG8_EINT16   (0x02 << 16)
+#define S3C2400_GPG8_SPIMOSI  (0x02 << 16)
+#define S3C2400_GPG8_IICSCL   (0x03 << 16)
+
+#define S3C2410_GPG9          S3C2410_GPIONO(S3C2410_GPIO_BANKG, 9)
+#define S3C2410_GPG9_INP      (0x00 << 18)
+#define S3C2410_GPG9_OUTP     (0x01 << 18)
+#define S3C2410_GPG9_EINT17   (0x02 << 18)
+#define S3C2400_GPG9_SPICLK   (0x02 << 18)
+#define S3C2400_GPG9_MMCCLK   (0x03 << 18)
+
+#define S3C2410_GPG10         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 10)
+#define S3C2410_GPG10_INP     (0x00 << 20)
+#define S3C2410_GPG10_OUTP    (0x01 << 20)
+#define S3C2410_GPG10_EINT18  (0x02 << 20)
+
+#define S3C2410_GPG11         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 11)
+#define S3C2410_GPG11_INP     (0x00 << 22)
+#define S3C2410_GPG11_OUTP    (0x01 << 22)
+#define S3C2410_GPG11_EINT19  (0x02 << 22)
+#define S3C2410_GPG11_TCLK1   (0x03 << 22)
+#define S3C2443_GPG11_CF_nIREQ (0x03 << 22)
+
+#define S3C2410_GPG12         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 12)
+#define S3C2410_GPG12_INP     (0x00 << 24)
+#define S3C2410_GPG12_OUTP    (0x01 << 24)
+#define S3C2410_GPG12_EINT20  (0x02 << 24)
+#define S3C2410_GPG12_XMON    (0x03 << 24)
+#define S3C2442_GPG12_nSPICS0 (0x03 << 24)
+#define S3C2443_GPG12_nINPACK (0x03 << 24)
+
+#define S3C2410_GPG13         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 13)
+#define S3C2410_GPG13_INP     (0x00 << 26)
+#define S3C2410_GPG13_OUTP    (0x01 << 26)
+#define S3C2410_GPG13_EINT21  (0x02 << 26)
+#define S3C2410_GPG13_nXPON   (0x03 << 26)
+#define S3C2443_GPG13_CF_nREG (0x03 << 26)
+
+#define S3C2410_GPG14         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 14)
+#define S3C2410_GPG14_INP     (0x00 << 28)
+#define S3C2410_GPG14_OUTP    (0x01 << 28)
+#define S3C2410_GPG14_EINT22  (0x02 << 28)
+#define S3C2410_GPG14_YMON    (0x03 << 28)
+#define S3C2443_GPG14_CF_RESET (0x03 << 28)
+
+#define S3C2410_GPG15         S3C2410_GPIONO(S3C2410_GPIO_BANKG, 15)
+#define S3C2410_GPG15_INP     (0x00 << 30)
+#define S3C2410_GPG15_OUTP    (0x01 << 30)
+#define S3C2410_GPG15_EINT23  (0x02 << 30)
+#define S3C2410_GPG15_nYPON   (0x03 << 30)
+#define S3C2443_GPG15_CF_PWR  (0x03 << 30)
+
+#define S3C2410_GPG_PUPDIS(x)  (1<<(x))
+
+/* Port H consists of11 GPIO/serial/Misc pins
+ *
+ * GPGCON has 2 bits for each of the input pins on port F
+ *   00 = 0 input, 1 output, 2 interrupt (EINT0..7), 3 special func
+ *
+ * pull up works like all other ports.
+*/
+
+#define S3C2410_GPHCON	   S3C2410_GPIOREG(0x70)
+#define S3C2410_GPHDAT	   S3C2410_GPIOREG(0x74)
+#define S3C2410_GPHUP	   S3C2410_GPIOREG(0x78)
+
+#define S3C2410_GPH0        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 0)
+#define S3C2410_GPH0_INP    (0x00 << 0)
+#define S3C2410_GPH0_OUTP   (0x01 << 0)
+#define S3C2410_GPH0_nCTS0  (0x02 << 0)
+
+#define S3C2410_GPH1        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 1)
+#define S3C2410_GPH1_INP    (0x00 << 2)
+#define S3C2410_GPH1_OUTP   (0x01 << 2)
+#define S3C2410_GPH1_nRTS0  (0x02 << 2)
+
+#define S3C2410_GPH2        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 2)
+#define S3C2410_GPH2_INP    (0x00 << 4)
+#define S3C2410_GPH2_OUTP   (0x01 << 4)
+#define S3C2410_GPH2_TXD0   (0x02 << 4)
+
+#define S3C2410_GPH3        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 3)
+#define S3C2410_GPH3_INP    (0x00 << 6)
+#define S3C2410_GPH3_OUTP   (0x01 << 6)
+#define S3C2410_GPH3_RXD0   (0x02 << 6)
+
+#define S3C2410_GPH4        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 4)
+#define S3C2410_GPH4_INP    (0x00 << 8)
+#define S3C2410_GPH4_OUTP   (0x01 << 8)
+#define S3C2410_GPH4_TXD1   (0x02 << 8)
+
+#define S3C2410_GPH5        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 5)
+#define S3C2410_GPH5_INP    (0x00 << 10)
+#define S3C2410_GPH5_OUTP   (0x01 << 10)
+#define S3C2410_GPH5_RXD1   (0x02 << 10)
+
+#define S3C2410_GPH6        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 6)
+#define S3C2410_GPH6_INP    (0x00 << 12)
+#define S3C2410_GPH6_OUTP   (0x01 << 12)
+#define S3C2410_GPH6_TXD2   (0x02 << 12)
+#define S3C2410_GPH6_nRTS1  (0x03 << 12)
+
+#define S3C2410_GPH7        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 7)
+#define S3C2410_GPH7_INP    (0x00 << 14)
+#define S3C2410_GPH7_OUTP   (0x01 << 14)
+#define S3C2410_GPH7_RXD2   (0x02 << 14)
+#define S3C2410_GPH7_nCTS1  (0x03 << 14)
+
+#define S3C2410_GPH8        S3C2410_GPIONO(S3C2410_GPIO_BANKH, 8)
+#define S3C2410_GPH8_INP    (0x00 << 16)
+#define S3C2410_GPH8_OUTP   (0x01 << 16)
+#define S3C2410_GPH8_UCLK   (0x02 << 16)
+
+#define S3C2410_GPH9          S3C2410_GPIONO(S3C2410_GPIO_BANKH, 9)
+#define S3C2410_GPH9_INP      (0x00 << 18)
+#define S3C2410_GPH9_OUTP     (0x01 << 18)
+#define S3C2410_GPH9_CLKOUT0  (0x02 << 18)
+#define S3C2442_GPH9_nSPICS0  (0x03 << 18)
+
+#define S3C2410_GPH10         S3C2410_GPIONO(S3C2410_GPIO_BANKH, 10)
+#define S3C2410_GPH10_INP     (0x00 << 20)
+#define S3C2410_GPH10_OUTP    (0x01 << 20)
+#define S3C2410_GPH10_CLKOUT1 (0x02 << 20)
+
+/* The S3C2412 and S3C2413 move the GPJ register set to after
+ * GPH, which means all registers after 0x80 are now offset by 0x10
+ * for the 2412/2413 from the 2410/2440/2442
+*/
+
+/* miscellaneous control */
+#define S3C2400_MISCCR	   S3C2410_GPIOREG(0x54)
+#define S3C2410_MISCCR	   S3C2410_GPIOREG(0x80)
+#define S3C2410_DCLKCON	   S3C2410_GPIOREG(0x84)
+
+#define S3C24XX_DCLKCON	   S3C24XX_GPIOREG2(0x84)
+
+/* see clock.h for dclk definitions */
+
+/* pullup control on databus */
+#define S3C2410_MISCCR_SPUCR_HEN    (0<<0)
+#define S3C2410_MISCCR_SPUCR_HDIS   (1<<0)
+#define S3C2410_MISCCR_SPUCR_LEN    (0<<1)
+#define S3C2410_MISCCR_SPUCR_LDIS   (1<<1)
+
+#define S3C2400_MISCCR_SPUCR_LEN    (0<<0)
+#define S3C2400_MISCCR_SPUCR_LDIS   (1<<0)
+#define S3C2400_MISCCR_SPUCR_HEN    (0<<1)
+#define S3C2400_MISCCR_SPUCR_HDIS   (1<<1)
+
+#define S3C2400_MISCCR_HZ_STOPEN    (0<<2)
+#define S3C2400_MISCCR_HZ_STOPPREV  (1<<2)
+
+#define S3C2410_MISCCR_USBDEV	    (0<<3)
+#define S3C2410_MISCCR_USBHOST	    (1<<3)
+
+#define S3C2410_MISCCR_CLK0_MPLL    (0<<4)
+#define S3C2410_MISCCR_CLK0_UPLL    (1<<4)
+#define S3C2410_MISCCR_CLK0_FCLK    (2<<4)
+#define S3C2410_MISCCR_CLK0_HCLK    (3<<4)
+#define S3C2410_MISCCR_CLK0_PCLK    (4<<4)
+#define S3C2410_MISCCR_CLK0_DCLK0   (5<<4)
+#define S3C2410_MISCCR_CLK0_MASK    (7<<4)
+
+#define S3C2412_MISCCR_CLK0_RTC	    (2<<4)
+
+#define S3C2410_MISCCR_CLK1_MPLL    (0<<8)
+#define S3C2410_MISCCR_CLK1_UPLL    (1<<8)
+#define S3C2410_MISCCR_CLK1_FCLK    (2<<8)
+#define S3C2410_MISCCR_CLK1_HCLK    (3<<8)
+#define S3C2410_MISCCR_CLK1_PCLK    (4<<8)
+#define S3C2410_MISCCR_CLK1_DCLK1   (5<<8)
+#define S3C2410_MISCCR_CLK1_MASK    (7<<8)
+
+#define S3C2412_MISCCR_CLK1_CLKsrc  (0<<8)
+
+#define S3C2410_MISCCR_USBSUSPND0   (1<<12)
+#define S3C2410_MISCCR_USBSUSPND1   (1<<13)
+
+#define S3C2410_MISCCR_nRSTCON	    (1<<16)
+
+#define S3C2410_MISCCR_nEN_SCLK0    (1<<17)
+#define S3C2410_MISCCR_nEN_SCLK1    (1<<18)
+#define S3C2410_MISCCR_nEN_SCLKE    (1<<19)	/* not 2412 */
+#define S3C2410_MISCCR_SDSLEEP	    (7<<17)
+
+/* external interrupt control... */
+/* S3C2410_EXTINT0 -> irq sense control for EINT0..EINT7
+ * S3C2410_EXTINT1 -> irq sense control for EINT8..EINT15
+ * S3C2410_EXTINT2 -> irq sense control for EINT16..EINT23
+ *
+ * note S3C2410_EXTINT2 has filtering options for EINT16..EINT23
+ *
+ * Samsung datasheet p9-25
+*/
+#define S3C2400_EXTINT0    S3C2410_GPIOREG(0x58)
+#define S3C2410_EXTINT0	   S3C2410_GPIOREG(0x88)
+#define S3C2410_EXTINT1	   S3C2410_GPIOREG(0x8C)
+#define S3C2410_EXTINT2	   S3C2410_GPIOREG(0x90)
+
+#define S3C24XX_EXTINT0	   S3C24XX_GPIOREG2(0x88)
+#define S3C24XX_EXTINT1	   S3C24XX_GPIOREG2(0x8C)
+#define S3C24XX_EXTINT2	   S3C24XX_GPIOREG2(0x90)
+
+/* values for S3C2410_EXTINT0/1/2 */
+#define S3C2410_EXTINT_LOWLEV	 (0x00)
+#define S3C2410_EXTINT_HILEV	 (0x01)
+#define S3C2410_EXTINT_FALLEDGE	 (0x02)
+#define S3C2410_EXTINT_RISEEDGE	 (0x04)
+#define S3C2410_EXTINT_BOTHEDGE	 (0x06)
+
+/* interrupt filtering conrrol for EINT16..EINT23 */
+#define S3C2410_EINFLT0	   S3C2410_GPIOREG(0x94)
+#define S3C2410_EINFLT1	   S3C2410_GPIOREG(0x98)
+#define S3C2410_EINFLT2	   S3C2410_GPIOREG(0x9C)
+#define S3C2410_EINFLT3	   S3C2410_GPIOREG(0xA0)
+
+#define S3C24XX_EINFLT0	   S3C24XX_GPIOREG2(0x94)
+#define S3C24XX_EINFLT1	   S3C24XX_GPIOREG2(0x98)
+#define S3C24XX_EINFLT2	   S3C24XX_GPIOREG2(0x9C)
+#define S3C24XX_EINFLT3	   S3C24XX_GPIOREG2(0xA0)
+
+/* values for interrupt filtering */
+#define S3C2410_EINTFLT_PCLK		(0x00)
+#define S3C2410_EINTFLT_EXTCLK		(1<<7)
+#define S3C2410_EINTFLT_WIDTHMSK(x)	((x) & 0x3f)
+
+/* removed EINTxxxx defs from here, not meant for this */
+
+/* GSTATUS have miscellaneous information in them
+ *
+ * These move between s3c2410 and s3c2412 style systems.
+ */
+
+#define S3C2410_GSTATUS0   S3C2410_GPIOREG(0x0AC)
+#define S3C2410_GSTATUS1   S3C2410_GPIOREG(0x0B0)
+#define S3C2410_GSTATUS2   S3C2410_GPIOREG(0x0B4)
+#define S3C2410_GSTATUS3   S3C2410_GPIOREG(0x0B8)
+#define S3C2410_GSTATUS4   S3C2410_GPIOREG(0x0BC)
+
+#define S3C2412_GSTATUS0   S3C2410_GPIOREG(0x0BC)
+#define S3C2412_GSTATUS1   S3C2410_GPIOREG(0x0C0)
+#define S3C2412_GSTATUS2   S3C2410_GPIOREG(0x0C4)
+#define S3C2412_GSTATUS3   S3C2410_GPIOREG(0x0C8)
+#define S3C2412_GSTATUS4   S3C2410_GPIOREG(0x0CC)
+
+#define S3C24XX_GSTATUS0   S3C24XX_GPIOREG2(0x0AC)
+#define S3C24XX_GSTATUS1   S3C24XX_GPIOREG2(0x0B0)
+#define S3C24XX_GSTATUS2   S3C24XX_GPIOREG2(0x0B4)
+#define S3C24XX_GSTATUS3   S3C24XX_GPIOREG2(0x0B8)
+#define S3C24XX_GSTATUS4   S3C24XX_GPIOREG2(0x0BC)
+
+#define S3C2410_GSTATUS0_nWAIT	   (1<<3)
+#define S3C2410_GSTATUS0_NCON	   (1<<2)
+#define S3C2410_GSTATUS0_RnB	   (1<<1)
+#define S3C2410_GSTATUS0_nBATTFLT  (1<<0)
+
+#define S3C2410_GSTATUS1_IDMASK	   (0xffff0000)
+#define S3C2410_GSTATUS1_2410	   (0x32410000)
+#define S3C2410_GSTATUS1_2412	   (0x32412001)
+#define S3C2410_GSTATUS1_2440	   (0x32440000)
+#define S3C2410_GSTATUS1_2442	   (0x32440aaa)
+
+#define S3C2410_GSTATUS2_WTRESET   (1<<2)
+#define S3C2410_GSTATUS2_OFFRESET  (1<<1)
+#define S3C2410_GSTATUS2_PONRESET  (1<<0)
+
+/* open drain control register */
+#define S3C2400_OPENCR     S3C2410_GPIOREG(0x50)
+
+#define S3C2400_OPENCR_OPC_RXD1DIS  (0<<0)
+#define S3C2400_OPENCR_OPC_RXD1EN   (1<<0)
+#define S3C2400_OPENCR_OPC_TXD1DIS  (0<<1)
+#define S3C2400_OPENCR_OPC_TXD1EN   (1<<1)
+#define S3C2400_OPENCR_OPC_CMDDIS   (0<<2)
+#define S3C2400_OPENCR_OPC_CMDEN    (1<<2)
+#define S3C2400_OPENCR_OPC_DATDIS   (0<<3)
+#define S3C2400_OPENCR_OPC_DATEN    (1<<3)
+#define S3C2400_OPENCR_OPC_MISODIS  (0<<4)
+#define S3C2400_OPENCR_OPC_MISOEN   (1<<4)
+#define S3C2400_OPENCR_OPC_MOSIDIS  (0<<5)
+#define S3C2400_OPENCR_OPC_MOSIEN   (1<<5)
+
+/* 2412/2413 sleep configuration registers */
+
+#define S3C2412_GPBSLPCON	S3C2410_GPIOREG(0x1C)
+#define S3C2412_GPCSLPCON	S3C2410_GPIOREG(0x2C)
+#define S3C2412_GPDSLPCON	S3C2410_GPIOREG(0x3C)
+#define S3C2412_GPESLPCON	S3C2410_GPIOREG(0x4C)
+#define S3C2412_GPFSLPCON	S3C2410_GPIOREG(0x5C)
+#define S3C2412_GPGSLPCON	S3C2410_GPIOREG(0x6C)
+#define S3C2412_GPHSLPCON	S3C2410_GPIOREG(0x7C)
+
+/* definitions for each pin bit */
+#define S3C2412_SLPCON_LOW(x)	( 0x00 << ((x) * 2))
+#define S3C2412_SLPCON_HI(x)	( 0x01 << ((x) * 2))
+#define S3C2412_SLPCON_IN(x)	( 0x02 << ((x) * 2))
+#define S3C2412_SLPCON_PDWN(x)	( 0x03 << ((x) * 2))
+#define S3C2412_SLPCON_MASK(x)	( 0x03 << ((x) * 2))
+
+#endif	/* __ASM_ARCH_REGS_GPIO_H */
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-gpioj.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-gpioj.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-gpioj.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,102 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-gpioj.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2440 GPIO J register definitions
+*/
+
+
+#ifndef __ASM_ARCH_REGS_GPIOJ_H
+#define __ASM_ARCH_REGS_GPIOJ_H "gpioj"
+
+/* Port J consists of 13 GPIO/Camera pins
+ *
+ * GPJCON has 2 bits for each of the input pins on port F
+ *   00 = 0 input, 1 output, 2 Camera
+ *
+ * pull up works like all other ports.
+*/
+
+#define S3C2440_GPIO_BANKJ  (416)
+
+#define S3C2440_GPJCON	    S3C2410_GPIOREG(0xd0)
+#define S3C2440_GPJDAT	    S3C2410_GPIOREG(0xd4)
+#define S3C2440_GPJUP	    S3C2410_GPIOREG(0xd8)
+
+#define S3C2413_GPJCON		S3C2410_GPIOREG(0x80)
+#define S3C2413_GPJDAT		S3C2410_GPIOREG(0x84)
+#define S3C2413_GPJUP		S3C2410_GPIOREG(0x88)
+#define S3C2413_GPJSLPCON	S3C2410_GPIOREG(0x8C)
+
+#define S3C2440_GPJ0            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 0)
+#define S3C2440_GPJ0_INP        (0x00 << 0)
+#define S3C2440_GPJ0_OUTP       (0x01 << 0)
+#define S3C2440_GPJ0_CAMDATA0   (0x02 << 0)
+
+#define S3C2440_GPJ1            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 1)
+#define S3C2440_GPJ1_INP        (0x00 << 2)
+#define S3C2440_GPJ1_OUTP       (0x01 << 2)
+#define S3C2440_GPJ1_CAMDATA1   (0x02 << 2)
+
+#define S3C2440_GPJ2            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 2)
+#define S3C2440_GPJ2_INP        (0x00 << 4)
+#define S3C2440_GPJ2_OUTP       (0x01 << 4)
+#define S3C2440_GPJ2_CAMDATA2   (0x02 << 4)
+
+#define S3C2440_GPJ3            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 3)
+#define S3C2440_GPJ3_INP        (0x00 << 6)
+#define S3C2440_GPJ3_OUTP       (0x01 << 6)
+#define S3C2440_GPJ3_CAMDATA3   (0x02 << 6)
+
+#define S3C2440_GPJ4            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 4)
+#define S3C2440_GPJ4_INP        (0x00 << 8)
+#define S3C2440_GPJ4_OUTP       (0x01 << 8)
+#define S3C2440_GPJ4_CAMDATA4   (0x02 << 8)
+
+#define S3C2440_GPJ5            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 5)
+#define S3C2440_GPJ5_INP        (0x00 << 10)
+#define S3C2440_GPJ5_OUTP       (0x01 << 10)
+#define S3C2440_GPJ5_CAMDATA5   (0x02 << 10)
+
+#define S3C2440_GPJ6            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 6)
+#define S3C2440_GPJ6_INP        (0x00 << 12)
+#define S3C2440_GPJ6_OUTP       (0x01 << 12)
+#define S3C2440_GPJ6_CAMDATA6   (0x02 << 12)
+
+#define S3C2440_GPJ7            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 7)
+#define S3C2440_GPJ7_INP        (0x00 << 14)
+#define S3C2440_GPJ7_OUTP       (0x01 << 14)
+#define S3C2440_GPJ7_CAMDATA7   (0x02 << 14)
+
+#define S3C2440_GPJ8            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 8)
+#define S3C2440_GPJ8_INP        (0x00 << 16)
+#define S3C2440_GPJ8_OUTP       (0x01 << 16)
+#define S3C2440_GPJ8_CAMPCLK    (0x02 << 16)
+
+#define S3C2440_GPJ9            S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 9)
+#define S3C2440_GPJ9_INP        (0x00 << 18)
+#define S3C2440_GPJ9_OUTP       (0x01 << 18)
+#define S3C2440_GPJ9_CAMVSYNC   (0x02 << 18)
+
+#define S3C2440_GPJ10           S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 10)
+#define S3C2440_GPJ10_INP       (0x00 << 20)
+#define S3C2440_GPJ10_OUTP      (0x01 << 20)
+#define S3C2440_GPJ10_CAMHREF   (0x02 << 20)
+
+#define S3C2440_GPJ11           S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 11)
+#define S3C2440_GPJ11_INP       (0x00 << 22)
+#define S3C2440_GPJ11_OUTP      (0x01 << 22)
+#define S3C2440_GPJ11_CAMCLKOUT (0x02 << 22)
+
+#define S3C2440_GPJ12           S3C2410_GPIONO(S3C2440_GPIO_BANKJ, 12)
+#define S3C2440_GPJ12_INP       (0x00 << 24)
+#define S3C2440_GPJ12_OUTP      (0x01 << 24)
+#define S3C2440_GPJ12_CAMRESET  (0x02 << 24)
+
+#endif	/* __ASM_ARCH_REGS_GPIOJ_H */
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-iic.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-iic.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-iic.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,56 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-iic.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 I2C Controller
+*/
+
+#ifndef __ASM_ARCH_REGS_IIC_H
+#define __ASM_ARCH_REGS_IIC_H __FILE__
+
+/* see s3c2410x user guide, v1.1, section 9 (p447) for more info */
+
+#define S3C2410_IICREG(x) (x)
+
+#define S3C2410_IICCON    S3C2410_IICREG(0x00)
+#define S3C2410_IICSTAT   S3C2410_IICREG(0x04)
+#define S3C2410_IICADD    S3C2410_IICREG(0x08)
+#define S3C2410_IICDS     S3C2410_IICREG(0x0C)
+#define S3C2440_IICLC	  S3C2410_IICREG(0x10)
+
+#define S3C2410_IICCON_ACKEN		(1<<7)
+#define S3C2410_IICCON_TXDIV_16		(0<<6)
+#define S3C2410_IICCON_TXDIV_512	(1<<6)
+#define S3C2410_IICCON_IRQEN		(1<<5)
+#define S3C2410_IICCON_IRQPEND		(1<<4)
+#define S3C2410_IICCON_SCALE(x)		((x)&15)
+#define S3C2410_IICCON_SCALEMASK	(0xf)
+
+#define S3C2410_IICSTAT_MASTER_RX	(2<<6)
+#define S3C2410_IICSTAT_MASTER_TX	(3<<6)
+#define S3C2410_IICSTAT_SLAVE_RX	(0<<6)
+#define S3C2410_IICSTAT_SLAVE_TX	(1<<6)
+#define S3C2410_IICSTAT_MODEMASK	(3<<6)
+
+#define S3C2410_IICSTAT_START		(1<<5)
+#define S3C2410_IICSTAT_BUSBUSY		(1<<5)
+#define S3C2410_IICSTAT_TXRXEN		(1<<4)
+#define S3C2410_IICSTAT_ARBITR		(1<<3)
+#define S3C2410_IICSTAT_ASSLAVE		(1<<2)
+#define S3C2410_IICSTAT_ADDR0		(1<<1)
+#define S3C2410_IICSTAT_LASTBIT		(1<<0)
+
+#define S3C2410_IICLC_SDA_DELAY0	(0 << 0)
+#define S3C2410_IICLC_SDA_DELAY5	(1 << 0)
+#define S3C2410_IICLC_SDA_DELAY10	(2 << 0)
+#define S3C2410_IICLC_SDA_DELAY15	(3 << 0)
+#define S3C2410_IICLC_SDA_DELAY_MASK	(3 << 0)
+
+#define S3C2410_IICLC_FILTER_ON		(1<<2)
+
+#endif /* __ASM_ARCH_REGS_IIC_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-iis.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-iis.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-iis.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,77 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-iis.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 IIS register definition
+*/
+
+#ifndef __ASM_ARCH_REGS_IIS_H
+#define __ASM_ARCH_REGS_IIS_H
+
+#define S3C2410_IISCON	 (0x00)
+
+#define S3C2410_IISCON_LRINDEX	  (1<<8)
+#define S3C2410_IISCON_TXFIFORDY  (1<<7)
+#define S3C2410_IISCON_RXFIFORDY  (1<<6)
+#define S3C2410_IISCON_TXDMAEN	  (1<<5)
+#define S3C2410_IISCON_RXDMAEN	  (1<<4)
+#define S3C2410_IISCON_TXIDLE	  (1<<3)
+#define S3C2410_IISCON_RXIDLE	  (1<<2)
+#define S3C2410_IISCON_PSCEN	  (1<<1)
+#define S3C2410_IISCON_IISEN	  (1<<0)
+
+#define S3C2410_IISMOD	 (0x04)
+
+#define S3C2440_IISMOD_MPLL	  (1<<9)
+#define S3C2410_IISMOD_SLAVE	  (1<<8)
+#define S3C2410_IISMOD_NOXFER	  (0<<6)
+#define S3C2410_IISMOD_RXMODE	  (1<<6)
+#define S3C2410_IISMOD_TXMODE	  (2<<6)
+#define S3C2410_IISMOD_TXRXMODE	  (3<<6)
+#define S3C2410_IISMOD_LR_LLOW	  (0<<5)
+#define S3C2410_IISMOD_LR_RLOW	  (1<<5)
+#define S3C2410_IISMOD_IIS	  (0<<4)
+#define S3C2410_IISMOD_MSB	  (1<<4)
+#define S3C2410_IISMOD_8BIT	  (0<<3)
+#define S3C2410_IISMOD_16BIT	  (1<<3)
+#define S3C2410_IISMOD_BITMASK	  (1<<3)
+#define S3C2410_IISMOD_256FS	  (0<<2)
+#define S3C2410_IISMOD_384FS	  (1<<2)
+#define S3C2410_IISMOD_16FS	  (0<<0)
+#define S3C2410_IISMOD_32FS	  (1<<0)
+#define S3C2410_IISMOD_48FS	  (2<<0)
+#define S3C2410_IISMOD_FS_MASK	  (3<<0)
+
+#define S3C2410_IISPSR		(0x08)
+#define S3C2410_IISPSR_INTMASK	(31<<5)
+#define S3C2410_IISPSR_INTSHIFT	(5)
+#define S3C2410_IISPSR_EXTMASK	(31<<0)
+#define S3C2410_IISPSR_EXTSHFIT	(0)
+
+#define S3C2410_IISFCON  (0x0c)
+
+#define S3C2410_IISFCON_TXDMA	  (1<<15)
+#define S3C2410_IISFCON_RXDMA	  (1<<14)
+#define S3C2410_IISFCON_TXENABLE  (1<<13)
+#define S3C2410_IISFCON_RXENABLE  (1<<12)
+#define S3C2410_IISFCON_TXMASK	  (0x3f << 6)
+#define S3C2410_IISFCON_TXSHIFT	  (6)
+#define S3C2410_IISFCON_RXMASK	  (0x3f)
+#define S3C2410_IISFCON_RXSHIFT	  (0)
+
+#define S3C2400_IISFCON_TXDMA     (1<<11)
+#define S3C2400_IISFCON_RXDMA     (1<<10)
+#define S3C2400_IISFCON_TXENABLE  (1<<9)
+#define S3C2400_IISFCON_RXENABLE  (1<<8)
+#define S3C2400_IISFCON_TXMASK	  (0x07 << 4)
+#define S3C2400_IISFCON_TXSHIFT	  (4)
+#define S3C2400_IISFCON_RXMASK	  (0x07)
+#define S3C2400_IISFCON_RXSHIFT	  (0)
+
+#define S3C2410_IISFIFO  (0x10)
+#endif /* __ASM_ARCH_REGS_IIS_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-irq.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-irq.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,43 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-irq.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef ___ASM_ARCH_REGS_IRQ_H
+#define ___ASM_ARCH_REGS_IRQ_H "$Id: irq.h,v 1.3 2003/03/25 21:29:06 ben Exp $"
+
+/* interrupt controller */
+
+#define S3C2410_IRQREG(x)   ((x) + S3C24XX_VA_IRQ)
+#define S3C2410_EINTREG(x)  ((x) + S3C24XX_VA_GPIO)
+#define S3C24XX_EINTREG(x)  ((x) + S3C24XX_VA_GPIO2)
+
+#define S3C2410_SRCPND	       S3C2410_IRQREG(0x000)
+#define S3C2410_INTMOD	       S3C2410_IRQREG(0x004)
+#define S3C2410_INTMSK	       S3C2410_IRQREG(0x008)
+#define S3C2410_PRIORITY       S3C2410_IRQREG(0x00C)
+#define S3C2410_INTPND	       S3C2410_IRQREG(0x010)
+#define S3C2410_INTOFFSET      S3C2410_IRQREG(0x014)
+#define S3C2410_SUBSRCPND      S3C2410_IRQREG(0x018)
+#define S3C2410_INTSUBMSK      S3C2410_IRQREG(0x01C)
+
+/* mask: 0=enable, 1=disable
+ * 1 bit EINT, 4=EINT4, 23=EINT23
+ * EINT0,1,2,3 are not handled here.
+*/
+
+#define S3C2410_EINTMASK       S3C2410_EINTREG(0x0A4)
+#define S3C2410_EINTPEND       S3C2410_EINTREG(0X0A8)
+#define S3C2412_EINTMASK       S3C2410_EINTREG(0x0B4)
+#define S3C2412_EINTPEND       S3C2410_EINTREG(0X0B8)
+
+#define S3C24XX_EINTMASK       S3C24XX_EINTREG(0x0A4)
+#define S3C24XX_EINTPEND       S3C24XX_EINTREG(0X0A8)
+
+#endif /* ___ASM_ARCH_REGS_IRQ_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-lcd.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-lcd.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-lcd.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,153 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-lcd.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef ___ASM_ARCH_REGS_LCD_H
+#define ___ASM_ARCH_REGS_LCD_H "$Id: lcd.h,v 1.3 2003/06/26 13:25:06 ben Exp $"
+
+#define S3C2410_LCDREG(x) ((x) + S3C24XX_VA_LCD)
+
+/* LCD control registers */
+#define S3C2410_LCDCON1	    S3C2410_LCDREG(0x00)
+#define S3C2410_LCDCON2	    S3C2410_LCDREG(0x04)
+#define S3C2410_LCDCON3	    S3C2410_LCDREG(0x08)
+#define S3C2410_LCDCON4	    S3C2410_LCDREG(0x0C)
+#define S3C2410_LCDCON5	    S3C2410_LCDREG(0x10)
+
+#define S3C2410_LCDCON1_CLKVAL(x)  ((x) << 8)
+#define S3C2410_LCDCON1_MMODE	   (1<<7)
+#define S3C2410_LCDCON1_DSCAN4	   (0<<5)
+#define S3C2410_LCDCON1_STN4	   (1<<5)
+#define S3C2410_LCDCON1_STN8	   (2<<5)
+#define S3C2410_LCDCON1_TFT	   (3<<5)
+
+#define S3C2410_LCDCON1_STN1BPP	   (0<<1)
+#define S3C2410_LCDCON1_STN2GREY   (1<<1)
+#define S3C2410_LCDCON1_STN4GREY   (2<<1)
+#define S3C2410_LCDCON1_STN8BPP	   (3<<1)
+#define S3C2410_LCDCON1_STN12BPP   (4<<1)
+
+#define S3C2410_LCDCON1_TFT1BPP	   (8<<1)
+#define S3C2410_LCDCON1_TFT2BPP	   (9<<1)
+#define S3C2410_LCDCON1_TFT4BPP	   (10<<1)
+#define S3C2410_LCDCON1_TFT8BPP	   (11<<1)
+#define S3C2410_LCDCON1_TFT16BPP   (12<<1)
+#define S3C2410_LCDCON1_TFT24BPP   (13<<1)
+
+#define S3C2410_LCDCON1_ENVID	   (1)
+
+#define S3C2410_LCDCON1_MODEMASK    0x1E
+
+#define S3C2410_LCDCON2_VBPD(x)	    ((x) << 24)
+#define S3C2410_LCDCON2_LINEVAL(x)  ((x) << 14)
+#define S3C2410_LCDCON2_VFPD(x)	    ((x) << 6)
+#define S3C2410_LCDCON2_VSPW(x)	    ((x) << 0)
+
+#define S3C2410_LCDCON2_GET_VBPD(x) ( ((x) >> 24) & 0xFF)
+#define S3C2410_LCDCON2_GET_VFPD(x) ( ((x) >>  6) & 0xFF)
+#define S3C2410_LCDCON2_GET_VSPW(x) ( ((x) >>  0) & 0x3F)
+
+#define S3C2410_LCDCON3_HBPD(x)	    ((x) << 19)
+#define S3C2410_LCDCON3_WDLY(x)	    ((x) << 19)
+#define S3C2410_LCDCON3_HOZVAL(x)   ((x) << 8)
+#define S3C2410_LCDCON3_HFPD(x)	    ((x) << 0)
+#define S3C2410_LCDCON3_LINEBLANK(x)((x) << 0)
+
+#define S3C2410_LCDCON3_GET_HBPD(x) ( ((x) >> 19) & 0x7F)
+#define S3C2410_LCDCON3_GET_HFPD(x) ( ((x) >>  0) & 0xFF)
+
+/* LDCCON4 changes for STN mode on the S3C2412 */
+
+#define S3C2410_LCDCON4_MVAL(x)	    ((x) << 8)
+#define S3C2410_LCDCON4_HSPW(x)	    ((x) << 0)
+#define S3C2410_LCDCON4_WLH(x)	    ((x) << 0)
+
+#define S3C2410_LCDCON4_GET_HSPW(x) ( ((x) >>  0) & 0xFF)
+
+#define S3C2410_LCDCON5_BPP24BL	    (1<<12)
+#define S3C2410_LCDCON5_FRM565	    (1<<11)
+#define S3C2410_LCDCON5_INVVCLK	    (1<<10)
+#define S3C2410_LCDCON5_INVVLINE    (1<<9)
+#define S3C2410_LCDCON5_INVVFRAME   (1<<8)
+#define S3C2410_LCDCON5_INVVD	    (1<<7)
+#define S3C2410_LCDCON5_INVVDEN	    (1<<6)
+#define S3C2410_LCDCON5_INVPWREN    (1<<5)
+#define S3C2410_LCDCON5_INVLEND	    (1<<4)
+#define S3C2410_LCDCON5_PWREN	    (1<<3)
+#define S3C2410_LCDCON5_ENLEND	    (1<<2)
+#define S3C2410_LCDCON5_BSWP	    (1<<1)
+#define S3C2410_LCDCON5_HWSWP	    (1<<0)
+
+/* framebuffer start addressed */
+#define S3C2410_LCDSADDR1   S3C2410_LCDREG(0x14)
+#define S3C2410_LCDSADDR2   S3C2410_LCDREG(0x18)
+#define S3C2410_LCDSADDR3   S3C2410_LCDREG(0x1C)
+
+#define S3C2410_LCDBANK(x)	((x) << 21)
+#define S3C2410_LCDBASEU(x)	(x)
+
+#define S3C2410_OFFSIZE(x)	((x) << 11)
+#define S3C2410_PAGEWIDTH(x)	(x)
+
+/* colour lookup and miscellaneous controls */
+
+#define S3C2410_REDLUT	   S3C2410_LCDREG(0x20)
+#define S3C2410_GREENLUT   S3C2410_LCDREG(0x24)
+#define S3C2410_BLUELUT	   S3C2410_LCDREG(0x28)
+
+#define S3C2410_DITHMODE   S3C2410_LCDREG(0x4C)
+#define S3C2410_TPAL	   S3C2410_LCDREG(0x50)
+
+#define S3C2410_TPAL_EN		(1<<24)
+
+/* interrupt info */
+#define S3C2410_LCDINTPND  S3C2410_LCDREG(0x54)
+#define S3C2410_LCDSRCPND  S3C2410_LCDREG(0x58)
+#define S3C2410_LCDINTMSK  S3C2410_LCDREG(0x5C)
+#define S3C2410_LCDINT_FIWSEL	(1<<2)
+#define	S3C2410_LCDINT_FRSYNC	(1<<1)
+#define S3C2410_LCDINT_FICNT	(1<<0)
+
+/* s3c2442 extra stn registers */
+
+#define S3C2442_REDLUT		S3C2410_LCDREG(0x20)
+#define S3C2442_GREENLUT	S3C2410_LCDREG(0x24)
+#define S3C2442_BLUELUT		S3C2410_LCDREG(0x28)
+#define S3C2442_DITHMODE	S3C2410_LCDREG(0x20)
+
+#define S3C2410_LPCSEL	   S3C2410_LCDREG(0x60)
+
+#define S3C2410_TFTPAL(x)  S3C2410_LCDREG((0x400 + (x)*4))
+
+/* S3C2412 registers */
+
+#define S3C2412_TPAL		S3C2410_LCDREG(0x20)
+
+#define S3C2412_LCDINTPND	S3C2410_LCDREG(0x24)
+#define S3C2412_LCDSRCPND	S3C2410_LCDREG(0x28)
+#define S3C2412_LCDINTMSK	S3C2410_LCDREG(0x2C)
+
+#define S3C2412_TCONSEL		S3C2410_LCDREG(0x30)
+
+#define S3C2412_LCDCON6		S3C2410_LCDREG(0x34)
+#define S3C2412_LCDCON7		S3C2410_LCDREG(0x38)
+#define S3C2412_LCDCON8		S3C2410_LCDREG(0x3C)
+#define S3C2412_LCDCON9		S3C2410_LCDREG(0x40)
+
+#define S3C2412_REDLUT(x)	S3C2410_LCDREG(0x44 + ((x)*4))
+#define S3C2412_GREENLUT(x)	S3C2410_LCDREG(0x60 + ((x)*4))
+#define S3C2412_BLUELUT(x)	S3C2410_LCDREG(0x98 + ((x)*4))
+
+#define S3C2412_FRCPAT(x)	S3C2410_LCDREG(0xB4 + ((x)*4))
+
+#endif /* ___ASM_ARCH_REGS_LCD_H */
+
+
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-mem.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-mem.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-mem.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,214 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-mem.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 Memory Control register definitions
+*/
+
+#ifndef __ASM_ARM_MEMREGS_H
+#define __ASM_ARM_MEMREGS_H "$Id: regs.h,v 1.8 2003/05/01 15:55:41 ben Exp $"
+
+#ifndef S3C2410_MEMREG
+#define S3C2410_MEMREG(x) (S3C24XX_VA_MEMCTRL + (x))
+#endif
+
+/* bus width, and wait state control */
+#define S3C2410_BWSCON			S3C2410_MEMREG(0x0000)
+
+/* bank zero config - note, pinstrapped from OM pins! */
+#define S3C2410_BWSCON_DW0_16		(1<<1)
+#define S3C2410_BWSCON_DW0_32		(2<<1)
+
+/* bank one configs */
+#define S3C2410_BWSCON_DW1_8		(0<<4)
+#define S3C2410_BWSCON_DW1_16		(1<<4)
+#define S3C2410_BWSCON_DW1_32		(2<<4)
+#define S3C2410_BWSCON_WS1		(1<<6)
+#define S3C2410_BWSCON_ST1		(1<<7)
+
+/* bank 2 configurations */
+#define S3C2410_BWSCON_DW2_8		(0<<8)
+#define S3C2410_BWSCON_DW2_16		(1<<8)
+#define S3C2410_BWSCON_DW2_32		(2<<8)
+#define S3C2410_BWSCON_WS2		(1<<10)
+#define S3C2410_BWSCON_ST2		(1<<11)
+
+/* bank 3 configurations */
+#define S3C2410_BWSCON_DW3_8		(0<<12)
+#define S3C2410_BWSCON_DW3_16		(1<<12)
+#define S3C2410_BWSCON_DW3_32		(2<<12)
+#define S3C2410_BWSCON_WS3		(1<<14)
+#define S3C2410_BWSCON_ST3		(1<<15)
+
+/* bank 4 configurations */
+#define S3C2410_BWSCON_DW4_8		(0<<16)
+#define S3C2410_BWSCON_DW4_16		(1<<16)
+#define S3C2410_BWSCON_DW4_32		(2<<16)
+#define S3C2410_BWSCON_WS4		(1<<18)
+#define S3C2410_BWSCON_ST4		(1<<19)
+
+/* bank 5 configurations */
+#define S3C2410_BWSCON_DW5_8		(0<<20)
+#define S3C2410_BWSCON_DW5_16		(1<<20)
+#define S3C2410_BWSCON_DW5_32		(2<<20)
+#define S3C2410_BWSCON_WS5		(1<<22)
+#define S3C2410_BWSCON_ST5		(1<<23)
+
+/* bank 6 configurations */
+#define S3C2410_BWSCON_DW6_8		(0<<24)
+#define S3C2410_BWSCON_DW6_16		(1<<24)
+#define S3C2410_BWSCON_DW6_32		(2<<24)
+#define S3C2410_BWSCON_WS6		(1<<26)
+#define S3C2410_BWSCON_ST6		(1<<27)
+
+/* bank 7 configurations */
+#define S3C2410_BWSCON_DW7_8		(0<<28)
+#define S3C2410_BWSCON_DW7_16		(1<<28)
+#define S3C2410_BWSCON_DW7_32		(2<<28)
+#define S3C2410_BWSCON_WS7		(1<<30)
+#define S3C2410_BWSCON_ST7		(1<<31)
+
+/* memory set (rom, ram) */
+#define S3C2410_BANKCON0		S3C2410_MEMREG(0x0004)
+#define S3C2410_BANKCON1		S3C2410_MEMREG(0x0008)
+#define S3C2410_BANKCON2		S3C2410_MEMREG(0x000C)
+#define S3C2410_BANKCON3		S3C2410_MEMREG(0x0010)
+#define S3C2410_BANKCON4		S3C2410_MEMREG(0x0014)
+#define S3C2410_BANKCON5		S3C2410_MEMREG(0x0018)
+#define S3C2410_BANKCON6		S3C2410_MEMREG(0x001C)
+#define S3C2410_BANKCON7		S3C2410_MEMREG(0x0020)
+
+/* bank configuration registers */
+
+#define S3C2410_BANKCON_PMCnorm		(0x00)
+#define S3C2410_BANKCON_PMC4		(0x01)
+#define S3C2410_BANKCON_PMC8		(0x02)
+#define S3C2410_BANKCON_PMC16		(0x03)
+
+/* bank configurations for banks 0..7, note banks
+ * 6 and 7 have differnt configurations depending on
+ * the memory type bits */
+
+#define S3C2410_BANKCON_Tacp2		(0x0 << 2)
+#define S3C2410_BANKCON_Tacp3		(0x1 << 2)
+#define S3C2410_BANKCON_Tacp4		(0x2 << 2)
+#define S3C2410_BANKCON_Tacp6		(0x3 << 2)
+
+#define S3C2410_BANKCON_Tcah0		(0x0 << 4)
+#define S3C2410_BANKCON_Tcah1		(0x1 << 4)
+#define S3C2410_BANKCON_Tcah2		(0x2 << 4)
+#define S3C2410_BANKCON_Tcah4		(0x3 << 4)
+
+#define S3C2410_BANKCON_Tcoh0		(0x0 << 6)
+#define S3C2410_BANKCON_Tcoh1		(0x1 << 6)
+#define S3C2410_BANKCON_Tcoh2		(0x2 << 6)
+#define S3C2410_BANKCON_Tcoh4		(0x3 << 6)
+
+#define S3C2410_BANKCON_Tacc1		(0x0 << 8)
+#define S3C2410_BANKCON_Tacc2		(0x1 << 8)
+#define S3C2410_BANKCON_Tacc3		(0x2 << 8)
+#define S3C2410_BANKCON_Tacc4		(0x3 << 8)
+#define S3C2410_BANKCON_Tacc6		(0x4 << 8)
+#define S3C2410_BANKCON_Tacc8		(0x5 << 8)
+#define S3C2410_BANKCON_Tacc10		(0x6 << 8)
+#define S3C2410_BANKCON_Tacc14		(0x7 << 8)
+
+#define S3C2410_BANKCON_Tcos0		(0x0 << 11)
+#define S3C2410_BANKCON_Tcos1		(0x1 << 11)
+#define S3C2410_BANKCON_Tcos2		(0x2 << 11)
+#define S3C2410_BANKCON_Tcos4		(0x3 << 11)
+
+#define S3C2410_BANKCON_Tacs0		(0x0 << 13)
+#define S3C2410_BANKCON_Tacs1		(0x1 << 13)
+#define S3C2410_BANKCON_Tacs2		(0x2 << 13)
+#define S3C2410_BANKCON_Tacs4		(0x3 << 13)
+
+#define S3C2410_BANKCON_SRAM		(0x0 << 15)
+#define S3C2400_BANKCON_EDODRAM		(0x2 << 15)
+#define S3C2410_BANKCON_SDRAM		(0x3 << 15)
+
+/* next bits only for EDO DRAM in 6,7 */
+#define S3C2400_BANKCON_EDO_Trcd1      (0x00 << 4)
+#define S3C2400_BANKCON_EDO_Trcd2      (0x01 << 4)
+#define S3C2400_BANKCON_EDO_Trcd3      (0x02 << 4)
+#define S3C2400_BANKCON_EDO_Trcd4      (0x03 << 4)
+
+/* CAS pulse width */
+#define S3C2400_BANKCON_EDO_PULSE1     (0x00 << 3)
+#define S3C2400_BANKCON_EDO_PULSE2     (0x01 << 3)
+
+/* CAS pre-charge */
+#define S3C2400_BANKCON_EDO_TCP1       (0x00 << 2)
+#define S3C2400_BANKCON_EDO_TCP2       (0x01 << 2)
+
+/* control column address select */
+#define S3C2400_BANKCON_EDO_SCANb8     (0x00 << 0)
+#define S3C2400_BANKCON_EDO_SCANb9     (0x01 << 0)
+#define S3C2400_BANKCON_EDO_SCANb10    (0x02 << 0)
+#define S3C2400_BANKCON_EDO_SCANb11    (0x03 << 0)
+
+/* next bits only for SDRAM in 6,7 */
+#define S3C2410_BANKCON_Trcd2		(0x00 << 2)
+#define S3C2410_BANKCON_Trcd3		(0x01 << 2)
+#define S3C2410_BANKCON_Trcd4		(0x02 << 2)
+
+/* control column address select */
+#define S3C2410_BANKCON_SCANb8		(0x00 << 0)
+#define S3C2410_BANKCON_SCANb9		(0x01 << 0)
+#define S3C2410_BANKCON_SCANb10		(0x02 << 0)
+
+#define S3C2410_REFRESH			S3C2410_MEMREG(0x0024)
+#define S3C2410_BANKSIZE		S3C2410_MEMREG(0x0028)
+#define S3C2410_MRSRB6			S3C2410_MEMREG(0x002C)
+#define S3C2410_MRSRB7			S3C2410_MEMREG(0x0030)
+
+/* refresh control */
+
+#define S3C2410_REFRESH_REFEN		(1<<23)
+#define S3C2410_REFRESH_SELF		(1<<22)
+#define S3C2410_REFRESH_REFCOUNTER	((1<<11)-1)
+
+#define S3C2410_REFRESH_TRP_MASK	(3<<20)
+#define S3C2410_REFRESH_TRP_2clk	(0<<20)
+#define S3C2410_REFRESH_TRP_3clk	(1<<20)
+#define S3C2410_REFRESH_TRP_4clk	(2<<20)
+
+#define S3C2400_REFRESH_DRAM_TRP_MASK   (3<<20)
+#define S3C2400_REFRESH_DRAM_TRP_1_5clk (0<<20)
+#define S3C2400_REFRESH_DRAM_TRP_2_5clk (1<<20)
+#define S3C2400_REFRESH_DRAM_TRP_3_5clk (2<<20)
+#define S3C2400_REFRESH_DRAM_TRP_4_5clk (3<<20)
+
+#define S3C2410_REFRESH_TSRC_MASK	(3<<18)
+#define S3C2410_REFRESH_TSRC_4clk	(0<<18)
+#define S3C2410_REFRESH_TSRC_5clk	(1<<18)
+#define S3C2410_REFRESH_TSRC_6clk	(2<<18)
+#define S3C2410_REFRESH_TSRC_7clk	(3<<18)
+
+
+/* mode select register(s) */
+
+#define  S3C2410_MRSRB_CL1		(0x00 << 4)
+#define  S3C2410_MRSRB_CL2		(0x02 << 4)
+#define  S3C2410_MRSRB_CL3		(0x03 << 4)
+
+/* bank size register */
+#define S3C2410_BANKSIZE_128M		(0x2 << 0)
+#define S3C2410_BANKSIZE_64M		(0x1 << 0)
+#define S3C2410_BANKSIZE_32M		(0x0 << 0)
+#define S3C2410_BANKSIZE_16M		(0x7 << 0)
+#define S3C2410_BANKSIZE_8M		(0x6 << 0)
+#define S3C2410_BANKSIZE_4M		(0x5 << 0)
+#define S3C2410_BANKSIZE_2M		(0x4 << 0)
+#define S3C2410_BANKSIZE_MASK		(0x7 << 0)
+#define S3C2400_BANKSIZE_MASK           (0x4 << 0)
+#define S3C2410_BANKSIZE_SCLK_EN	(1<<4)
+#define S3C2410_BANKSIZE_SCKE_EN	(1<<5)
+#define S3C2410_BANKSIZE_BURST		(1<<7)
+
+#endif /* __ASM_ARM_MEMREGS_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-nand.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-nand.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-nand.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,123 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-nand.h
+ *
+ * Copyright (c) 2004,2005 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 NAND register definitions
+*/
+
+#ifndef __ASM_ARM_REGS_NAND
+#define __ASM_ARM_REGS_NAND "$Id: nand.h,v 1.3 2003/12/09 11:36:29 ben Exp $"
+
+
+#define S3C2410_NFREG(x) (x)
+
+#define S3C2410_NFCONF  S3C2410_NFREG(0x00)
+#define S3C2410_NFCMD   S3C2410_NFREG(0x04)
+#define S3C2410_NFADDR  S3C2410_NFREG(0x08)
+#define S3C2410_NFDATA  S3C2410_NFREG(0x0C)
+#define S3C2410_NFSTAT  S3C2410_NFREG(0x10)
+#define S3C2410_NFECC   S3C2410_NFREG(0x14)
+
+#define S3C2440_NFCONT   S3C2410_NFREG(0x04)
+#define S3C2440_NFCMD    S3C2410_NFREG(0x08)
+#define S3C2440_NFADDR   S3C2410_NFREG(0x0C)
+#define S3C2440_NFDATA   S3C2410_NFREG(0x10)
+#define S3C2440_NFECCD0  S3C2410_NFREG(0x14)
+#define S3C2440_NFECCD1  S3C2410_NFREG(0x18)
+#define S3C2440_NFECCD   S3C2410_NFREG(0x1C)
+#define S3C2440_NFSTAT   S3C2410_NFREG(0x20)
+#define S3C2440_NFESTAT0 S3C2410_NFREG(0x24)
+#define S3C2440_NFESTAT1 S3C2410_NFREG(0x28)
+#define S3C2440_NFMECC0  S3C2410_NFREG(0x2C)
+#define S3C2440_NFMECC1  S3C2410_NFREG(0x30)
+#define S3C2440_NFSECC   S3C24E10_NFREG(0x34)
+#define S3C2440_NFSBLK   S3C2410_NFREG(0x38)
+#define S3C2440_NFEBLK   S3C2410_NFREG(0x3C)
+
+#define S3C2412_NFSBLK		S3C2410_NFREG(0x20)
+#define S3C2412_NFEBLK		S3C2410_NFREG(0x24)
+#define S3C2412_NFSTAT		S3C2410_NFREG(0x28)
+#define S3C2412_NFMECC_ERR0	S3C2410_NFREG(0x2C)
+#define S3C2412_NFMECC_ERR1	S3C2410_NFREG(0x30)
+#define S3C2412_NFMECC0		S3C2410_NFREG(0x34)
+#define S3C2412_NFMECC1		S3C2410_NFREG(0x38)
+#define S3C2412_NFSECC		S3C2410_NFREG(0x3C)
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_nFCE        (1<<11)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#define S3C2410_NFSTAT_BUSY        (1<<0)
+
+#define S3C2440_NFCONF_BUSWIDTH_8	(0<<0)
+#define S3C2440_NFCONF_BUSWIDTH_16	(1<<0)
+#define S3C2440_NFCONF_ADVFLASH		(1<<3)
+#define S3C2440_NFCONF_TACLS(x)		((x)<<12)
+#define S3C2440_NFCONF_TWRPH0(x)	((x)<<8)
+#define S3C2440_NFCONF_TWRPH1(x)	((x)<<4)
+
+#define S3C2440_NFCONT_LOCKTIGHT	(1<<13)
+#define S3C2440_NFCONT_SOFTLOCK		(1<<12)
+#define S3C2440_NFCONT_ILLEGALACC_EN	(1<<10)
+#define S3C2440_NFCONT_RNBINT_EN	(1<<9)
+#define S3C2440_NFCONT_RN_FALLING	(1<<8)
+#define S3C2440_NFCONT_SPARE_ECCLOCK	(1<<6)
+#define S3C2440_NFCONT_MAIN_ECCLOCK	(1<<5)
+#define S3C2440_NFCONT_INITECC		(1<<4)
+#define S3C2440_NFCONT_nFCE		(1<<1)
+#define S3C2440_NFCONT_ENABLE		(1<<0)
+
+#define S3C2440_NFSTAT_READY		(1<<0)
+#define S3C2440_NFSTAT_nCE		(1<<1)
+#define S3C2440_NFSTAT_RnB_CHANGE	(1<<2)
+#define S3C2440_NFSTAT_ILLEGAL_ACCESS	(1<<3)
+
+#define S3C2412_NFCONF_NANDBOOT		(1<<31)
+#define S3C2412_NFCONF_ECCCLKCON	(1<<30)
+#define S3C2412_NFCONF_ECC_MLC		(1<<24)
+#define S3C2412_NFCONF_TACLS_MASK	(7<<12)	/* 1 extra bit of Tacls */
+
+#define S3C2412_NFCONT_ECC4_DIRWR	(1<<18)
+#define S3C2412_NFCONT_LOCKTIGHT	(1<<17)
+#define S3C2412_NFCONT_SOFTLOCK		(1<<16)
+#define S3C2412_NFCONT_ECC4_ENCINT	(1<<13)
+#define S3C2412_NFCONT_ECC4_DECINT	(1<<12)
+#define S3C2412_NFCONT_MAIN_ECC_LOCK	(1<<7)
+#define S3C2412_NFCONT_INIT_MAIN_ECC	(1<<5)
+#define S3C2412_NFCONT_nFCE1		(1<<2)
+#define S3C2412_NFCONT_nFCE0		(1<<1)
+
+#define S3C2412_NFSTAT_ECC_ENCDONE	(1<<7)
+#define S3C2412_NFSTAT_ECC_DECDONE	(1<<6)
+#define S3C2412_NFSTAT_ILLEGAL_ACCESS	(1<<5)
+#define S3C2412_NFSTAT_RnB_CHANGE	(1<<4)
+#define S3C2412_NFSTAT_nFCE1		(1<<3)
+#define S3C2412_NFSTAT_nFCE0		(1<<2)
+#define S3C2412_NFSTAT_Res1		(1<<1)
+#define S3C2412_NFSTAT_READY		(1<<0)
+
+#define S3C2412_NFECCERR_SERRDATA(x)	(((x) >> 21) & 0xf)
+#define S3C2412_NFECCERR_SERRBIT(x)	(((x) >> 18) & 0x7)
+#define S3C2412_NFECCERR_MERRDATA(x)	(((x) >> 7) & 0x3ff)
+#define S3C2412_NFECCERR_MERRBIT(x)	(((x) >> 4) & 0x7)
+#define S3C2412_NFECCERR_SPARE_ERR(x)	(((x) >> 2) & 0x3)
+#define S3C2412_NFECCERR_MAIN_ERR(x)	(((x) >> 2) & 0x3)
+#define S3C2412_NFECCERR_NONE		(0)
+#define S3C2412_NFECCERR_1BIT		(1)
+#define S3C2412_NFECCERR_MULTIBIT	(2)
+#define S3C2412_NFECCERR_ECCAREA	(3)
+
+
+
+#endif /* __ASM_ARM_REGS_NAND */
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-power.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-power.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-power.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,34 @@
+/* linux/include/asm/arch-s3c2410/regs-power.h
+ *
+ * Copyright (c) 2003,2004,2005,2006 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C24XX power control register definitions
+*/
+
+#ifndef __ASM_ARM_REGS_PWR
+#define __ASM_ARM_REGS_PWR __FILE__
+
+#define S3C24XX_PWRREG(x) ((x) + S3C24XX_VA_CLKPWR)
+
+#define S3C2412_PWRMODECON	S3C24XX_PWRREG(0x20)
+#define S3C2412_PWRCFG		S3C24XX_PWRREG(0x24)
+
+#define S3C2412_PWRCFG_BATF_IGNORE		(0<<0)
+#define S3C2412_PWRCFG_BATF_SLEEP		(3<<0)
+#define S3C2412_PWRCFG_BATF_MASK		(3<<0)
+
+#define S3C2412_PWRCFG_STANDBYWFI_IGNORE	(0<<6)
+#define S3C2412_PWRCFG_STANDBYWFI_IDLE		(1<<6)
+#define S3C2412_PWRCFG_STANDBYWFI_STOP		(2<<6)
+#define S3C2412_PWRCFG_STANDBYWFI_SLEEP		(3<<6)
+#define S3C2412_PWRCFG_STANDBYWFI_MASK		(3<<6)
+
+#define S3C2412_PWRCFG_RTC_MASKIRQ		(1<<8)
+#define S3C2412_PWRCFG_NAND_NORST		(1<<9)
+
+#endif /* __ASM_ARM_REGS_PWR */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-rtc.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-rtc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-rtc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,61 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-rtc.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 Internal RTC register definition
+*/
+
+#ifndef __ASM_ARCH_REGS_RTC_H
+#define __ASM_ARCH_REGS_RTC_H __FILE__
+
+#define S3C2410_RTCREG(x) (x)
+
+#define S3C2410_RTCCON	      S3C2410_RTCREG(0x40)
+#define S3C2410_RTCCON_RTCEN  (1<<0)
+#define S3C2410_RTCCON_CLKSEL (1<<1)
+#define S3C2410_RTCCON_CNTSEL (1<<2)
+#define S3C2410_RTCCON_CLKRST (1<<3)
+
+#define S3C2410_TICNT	      S3C2410_RTCREG(0x44)
+#define S3C2410_TICNT_ENABLE  (1<<7)
+
+#define S3C2410_RTCALM	      S3C2410_RTCREG(0x50)
+#define S3C2410_RTCALM_ALMEN  (1<<6)
+#define S3C2410_RTCALM_YEAREN (1<<5)
+#define S3C2410_RTCALM_MONEN  (1<<4)
+#define S3C2410_RTCALM_DAYEN  (1<<3)
+#define S3C2410_RTCALM_HOUREN (1<<2)
+#define S3C2410_RTCALM_MINEN  (1<<1)
+#define S3C2410_RTCALM_SECEN  (1<<0)
+
+#define S3C2410_RTCALM_ALL \
+  S3C2410_RTCALM_ALMEN | S3C2410_RTCALM_YEAREN | S3C2410_RTCALM_MONEN |\
+  S3C2410_RTCALM_DAYEN | S3C2410_RTCALM_HOUREN | S3C2410_RTCALM_MINEN |\
+  S3C2410_RTCALM_SECEN
+
+
+#define S3C2410_ALMSEC	      S3C2410_RTCREG(0x54)
+#define S3C2410_ALMMIN	      S3C2410_RTCREG(0x58)
+#define S3C2410_ALMHOUR	      S3C2410_RTCREG(0x5c)
+
+#define S3C2410_ALMDATE	      S3C2410_RTCREG(0x60)
+#define S3C2410_ALMMON	      S3C2410_RTCREG(0x64)
+#define S3C2410_ALMYEAR	      S3C2410_RTCREG(0x68)
+
+#define S3C2410_RTCRST	      S3C2410_RTCREG(0x6c)
+
+#define S3C2410_RTCSEC	      S3C2410_RTCREG(0x70)
+#define S3C2410_RTCMIN	      S3C2410_RTCREG(0x74)
+#define S3C2410_RTCHOUR	      S3C2410_RTCREG(0x78)
+#define S3C2410_RTCDATE	      S3C2410_RTCREG(0x7c)
+#define S3C2410_RTCDAY	      S3C2410_RTCREG(0x80)
+#define S3C2410_RTCMON	      S3C2410_RTCREG(0x84)
+#define S3C2410_RTCYEAR	      S3C2410_RTCREG(0x88)
+
+
+#endif /* __ASM_ARCH_REGS_RTC_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-s3c2443-clock.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-s3c2443-clock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-s3c2443-clock.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,194 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-clock.h
+ *
+ * Copyright (c) 2007 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2443 clock register definitions
+*/
+
+#ifndef __ASM_ARM_REGS_S3C2443_CLOCK
+#define __ASM_ARM_REGS_S3C2443_CLOCK
+
+#define S3C2443_CLKREG(x)		((x) + S3C24XX_VA_CLKPWR)
+
+#define S3C2443_PLLCON_MDIVSHIFT	16
+#define S3C2443_PLLCON_PDIVSHIFT	8
+#define S3C2443_PLLCON_SDIVSHIFT	0
+#define S3C2443_PLLCON_MDIVMASK		((1<<(1+(23-16)))-1)
+#define S3C2443_PLLCON_PDIVMASK		((1<<(1+(9-8)))-1)
+#define S3C2443_PLLCON_SDIVMASK		(3)
+
+#define S3C2443_MPLLCON			S3C2443_CLKREG(0x10)
+#define S3C2443_EPLLCON			S3C2443_CLKREG(0x18)
+#define S3C2443_CLKSRC			S3C2443_CLKREG(0x20)
+#define S3C2443_CLKDIV0			S3C2443_CLKREG(0x24)
+#define S3C2443_CLKDIV1			S3C2443_CLKREG(0x28)
+#define S3C2443_HCLKCON			S3C2443_CLKREG(0x30)
+#define S3C2443_PCLKCON			S3C2443_CLKREG(0x34)
+#define S3C2443_SCLKCON			S3C2443_CLKREG(0x38)
+#define S3C2443_PWRMODE			S3C2443_CLKREG(0x40)
+#define S3C2443_SWRST			S3C2443_CLKREG(0x44)
+#define S3C2443_BUSPRI0			S3C2443_CLKREG(0x50)
+#define S3C2443_SYSID			S3C2443_CLKREG(0x5C)
+#define S3C2443_PWRCFG			S3C2443_CLKREG(0x60)
+#define S3C2443_RSTCON			S3C2443_CLKREG(0x64)
+
+#define S3C2443_SWRST_RESET		(0x533c2443)
+
+#define S3C2443_PLLCON_OFF		(1<<24)
+
+#define S3C2443_CLKSRC_I2S_EXT		(1<<14)
+#define S3C2443_CLKSRC_I2S_EPLLDIV	(0<<14)
+#define S3C2443_CLKSRC_I2S_EPLLREF	(2<<14)
+#define S3C2443_CLKSRC_I2S_EPLLREF3	(3<<14)
+#define S3C2443_CLKSRC_I2S_MASK		(3<<14)
+
+#define S3C2443_CLKSRC_EPLLREF_XTAL	(2<<8)
+#define S3C2443_CLKSRC_EPLLREF_EXTCLK	(3<<8)
+#define S3C2443_CLKSRC_EPLLREF_MPLLREF	(0<<8)
+#define S3C2443_CLKSRC_EPLLREF_MPLLREF2	(1<<8)
+#define S3C2443_CLKSRC_EPLLREF_MASK	(3<<8)
+
+#define S3C2443_CLKSRC_ESYSCLK_EPLL	(1<<6)
+#define S3C2443_CLKSRC_MSYSCLK_MPLL	(1<<4)
+#define S3C2443_CLKSRC_EXTCLK_DIV	(1<<3)
+
+#define S3C2443_CLKDIV0_DVS		(1<<13)
+#define S3C2443_CLKDIV0_HALF_HCLK	(1<<3)
+#define S3C2443_CLKDIV0_HALF_PCLK	(1<<2)
+
+#define S3C2443_CLKDIV0_HCLKDIV_MASK	(3<<0)
+
+#define S3C2443_CLKDIV0_EXTDIV_MASK	(3<<6)
+#define S3C2443_CLKDIV0_EXTDIV_SHIFT	(6)
+
+#define S3C2443_CLKDIV0_PREDIV_MASK	(3<<4)
+#define S3C2443_CLKDIV0_PREDIV_SHIFT	(4)
+
+#define S3C2443_CLKDIV0_ARMDIV_MASK	(15<<9)
+#define S3C2443_CLKDIV0_ARMDIV_SHIFT	(9)
+#define S3C2443_CLKDIV0_ARMDIV_1	(0<<9)
+#define S3C2443_CLKDIV0_ARMDIV_2	(8<<9)
+#define S3C2443_CLKDIV0_ARMDIV_3	(2<<9)
+#define S3C2443_CLKDIV0_ARMDIV_4	(9<<9)
+#define S3C2443_CLKDIV0_ARMDIV_6	(10<<9)
+#define S3C2443_CLKDIV0_ARMDIV_8	(11<<9)
+#define S3C2443_CLKDIV0_ARMDIV_12	(13<<9)
+#define S3C2443_CLKDIV0_ARMDIV_16	(15<<9)
+
+/* S3C2443_CLKDIV1 */
+
+#define S3C2443_CLKDIV1_CAMDIV_MASK	(15<<26)
+#define S3C2443_CLKDIV1_CAMDIV_SHIFT	(26)
+
+#define S3C2443_CLKDIV1_HSSPIDIV_MASK	(3<<24)
+#define S3C2443_CLKDIV1_HSSPIDIV_SHIFT	(24)
+
+#define S3C2443_CLKDIV1_DISPDIV_MASK	(0xff<<16)
+#define S3C2443_CLKDIV1_DISPDIV_SHIFT	(16)
+
+#define S3C2443_CLKDIV1_I2SDIV_MASK	(15<<12)
+#define S3C2443_CLKDIV1_I2SDIV_SHIFT	(12)
+
+#define S3C2443_CLKDIV1_UARTDIV_MASK	(15<<8)
+#define S3C2443_CLKDIV1_UARTDIV_SHIFT	(8)
+
+#define S3C2443_CLKDIV1_HSMMCDIV_MASK	(3<<6)
+#define S3C2443_CLKDIV1_HSMMCDIV_SHIFT	(6)
+
+#define S3C2443_CLKDIV1_USBHOSTDIV_MASK	(3<<4)
+#define S3C2443_CLKDIV1_USBHOSTDIV_SHIFT (4)
+
+#define S3C2443_CLKCON_NAND
+
+#define S3C2443_HCLKCON_DMA0		(1<<0)
+#define S3C2443_HCLKCON_DMA1		(1<<1)
+#define S3C2443_HCLKCON_DMA2		(1<<2)
+#define S3C2443_HCLKCON_DMA3		(1<<3)
+#define S3C2443_HCLKCON_DMA4		(1<<4)
+#define S3C2443_HCLKCON_DMA5		(1<<5)
+#define S3C2443_HCLKCON_CAMIF		(1<<8)
+#define S3C2443_HCLKCON_DISP		(1<<9)
+#define S3C2443_HCLKCON_LCDC		(1<<10)
+#define S3C2443_HCLKCON_USBH		(1<<11)
+#define S3C2443_HCLKCON_USBD		(1<<12)
+#define S3C2443_HCLKCON_HSMMC		(1<<16)
+#define S3C2443_HCLKCON_CFC		(1<<17)
+#define S3C2443_HCLKCON_SSMC		(1<<18)
+#define S3C2443_HCLKCON_DRAMC		(1<<19)
+
+#define S3C2443_PCLKCON_UART0		(1<<0)
+#define S3C2443_PCLKCON_UART1		(1<<1)
+#define S3C2443_PCLKCON_UART2		(1<<2)
+#define S3C2443_PCLKCON_UART3		(1<<3)
+#define S3C2443_PCLKCON_IIC		(1<<4)
+#define S3C2443_PCLKCON_SDI		(1<<5)
+#define S3C2443_PCLKCON_ADC		(1<<7)
+#define S3C2443_PCLKCON_IIS		(1<<9)
+#define S3C2443_PCLKCON_PWMT		(1<<10)
+#define S3C2443_PCLKCON_WDT		(1<<11)
+#define S3C2443_PCLKCON_RTC		(1<<12)
+#define S3C2443_PCLKCON_GPIO		(1<<13)
+#define S3C2443_PCLKCON_SPI0		(1<<14)
+#define S3C2443_PCLKCON_SPI1		(1<<15)
+
+#define S3C2443_SCLKCON_DDRCLK		(1<<16)
+#define S3C2443_SCLKCON_SSMCCLK		(1<<15)
+#define S3C2443_SCLKCON_HSSPICLK	(1<<14)
+#define S3C2443_SCLKCON_HSMMCCLK_EXT	(1<<13)
+#define S3C2443_SCLKCON_HSMMCCLK_EPLL	(1<<12)
+#define S3C2443_SCLKCON_CAMCLK		(1<<11)
+#define S3C2443_SCLKCON_DISPCLK		(1<<10)
+#define S3C2443_SCLKCON_I2SCLK		(1<<9)
+#define S3C2443_SCLKCON_UARTCLK		(1<<8)
+#define S3C2443_SCLKCON_USBHOST		(1<<1)
+
+#include <asm/div64.h>
+
+static inline unsigned int
+s3c2443_get_mpll(unsigned int pllval, unsigned int baseclk)
+{
+	unsigned int mdiv, pdiv, sdiv;
+	uint64_t fvco;
+
+	mdiv = pllval >> S3C2443_PLLCON_MDIVSHIFT;
+	pdiv = pllval >> S3C2443_PLLCON_PDIVSHIFT;
+	sdiv = pllval >> S3C2443_PLLCON_SDIVSHIFT;
+
+	mdiv &= S3C2443_PLLCON_MDIVMASK;
+	pdiv &= S3C2443_PLLCON_PDIVMASK;
+	sdiv &= S3C2443_PLLCON_SDIVMASK;
+
+	fvco = (uint64_t)baseclk * (2 * (mdiv + 8));
+	do_div(fvco, pdiv << sdiv);
+
+	return (unsigned int)fvco;
+}
+
+static inline unsigned int
+s3c2443_get_epll(unsigned int pllval, unsigned int baseclk)
+{
+	unsigned int mdiv, pdiv, sdiv;
+	uint64_t fvco;
+
+	mdiv = pllval >> S3C2443_PLLCON_MDIVSHIFT;
+	pdiv = pllval >> S3C2443_PLLCON_PDIVSHIFT;
+	sdiv = pllval >> S3C2443_PLLCON_SDIVSHIFT;
+
+	mdiv &= S3C2443_PLLCON_MDIVMASK;
+	pdiv &= S3C2443_PLLCON_PDIVMASK;
+	sdiv &= S3C2443_PLLCON_SDIVMASK;
+
+	fvco = (uint64_t)baseclk * (mdiv + 8);
+	do_div(fvco, (pdiv + 2) << sdiv);
+
+	return (unsigned int)fvco;
+}
+
+#endif /*  __ASM_ARM_REGS_S3C2443_CLOCK */
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-sdi.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-sdi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-sdi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,113 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-sdi.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 MMC/SDIO register definitions
+*/
+
+#ifndef __ASM_ARM_REGS_SDI
+#define __ASM_ARM_REGS_SDI "regs-sdi.h"
+
+#define S3C2410_SDICON                (0x00)
+#define S3C2410_SDIPRE                (0x04)
+#define S3C2410_SDICMDARG             (0x08)
+#define S3C2410_SDICMDCON             (0x0C)
+#define S3C2410_SDICMDSTAT            (0x10)
+#define S3C2410_SDIRSP0               (0x14)
+#define S3C2410_SDIRSP1               (0x18)
+#define S3C2410_SDIRSP2               (0x1C)
+#define S3C2410_SDIRSP3               (0x20)
+#define S3C2410_SDITIMER              (0x24)
+#define S3C2410_SDIBSIZE              (0x28)
+#define S3C2410_SDIDCON               (0x2C)
+#define S3C2410_SDIDCNT               (0x30)
+#define S3C2410_SDIDSTA               (0x34)
+#define S3C2410_SDIFSTA               (0x38)
+#define S3C2410_SDIDATA               (0x3C)
+#define S3C2410_SDIIMSK               (0x40)
+
+#define S3C2410_SDICON_BYTEORDER      (1<<4)
+#define S3C2410_SDICON_SDIOIRQ        (1<<3)
+#define S3C2410_SDICON_RWAITEN        (1<<2)
+#define S3C2410_SDICON_FIFORESET      (1<<1)
+#define S3C2410_SDICON_CLOCKTYPE      (1<<0)
+
+#define S3C2410_SDICMDCON_ABORT       (1<<12)
+#define S3C2410_SDICMDCON_WITHDATA    (1<<11)
+#define S3C2410_SDICMDCON_LONGRSP     (1<<10)
+#define S3C2410_SDICMDCON_WAITRSP     (1<<9)
+#define S3C2410_SDICMDCON_CMDSTART    (1<<8)
+#define S3C2410_SDICMDCON_INDEX       (0xff)
+
+#define S3C2410_SDICMDSTAT_CRCFAIL    (1<<12)
+#define S3C2410_SDICMDSTAT_CMDSENT    (1<<11)
+#define S3C2410_SDICMDSTAT_CMDTIMEOUT (1<<10)
+#define S3C2410_SDICMDSTAT_RSPFIN     (1<<9)
+#define S3C2410_SDICMDSTAT_XFERING    (1<<8)
+#define S3C2410_SDICMDSTAT_INDEX      (0xff)
+
+#define S3C2410_SDIDCON_IRQPERIOD     (1<<21)
+#define S3C2410_SDIDCON_TXAFTERRESP   (1<<20)
+#define S3C2410_SDIDCON_RXAFTERCMD    (1<<19)
+#define S3C2410_SDIDCON_BUSYAFTERCMD  (1<<18)
+#define S3C2410_SDIDCON_BLOCKMODE     (1<<17)
+#define S3C2410_SDIDCON_WIDEBUS       (1<<16)
+#define S3C2410_SDIDCON_DMAEN         (1<<15)
+#define S3C2410_SDIDCON_STOP          (1<<14)
+#define S3C2410_SDIDCON_DATMODE	      (3<<12)
+#define S3C2410_SDIDCON_BLKNUM        (0x7ff)
+
+/* constants for S3C2410_SDIDCON_DATMODE */
+#define S3C2410_SDIDCON_XFER_READY    (0<<12)
+#define S3C2410_SDIDCON_XFER_CHKSTART (1<<12)
+#define S3C2410_SDIDCON_XFER_RXSTART  (2<<12)
+#define S3C2410_SDIDCON_XFER_TXSTART  (3<<12)
+
+#define S3C2410_SDIDCNT_BLKNUM_SHIFT  (12)
+
+#define S3C2410_SDIDSTA_RDYWAITREQ    (1<<10)
+#define S3C2410_SDIDSTA_SDIOIRQDETECT (1<<9)
+#define S3C2410_SDIDSTA_FIFOFAIL      (1<<8)	/* reserved on 2440 */
+#define S3C2410_SDIDSTA_CRCFAIL       (1<<7)
+#define S3C2410_SDIDSTA_RXCRCFAIL     (1<<6)
+#define S3C2410_SDIDSTA_DATATIMEOUT   (1<<5)
+#define S3C2410_SDIDSTA_XFERFINISH    (1<<4)
+#define S3C2410_SDIDSTA_BUSYFINISH    (1<<3)
+#define S3C2410_SDIDSTA_SBITERR       (1<<2)	/* reserved on 2410a/2440 */
+#define S3C2410_SDIDSTA_TXDATAON      (1<<1)
+#define S3C2410_SDIDSTA_RXDATAON      (1<<0)
+
+#define S3C2410_SDIFSTA_TFDET          (1<<13)
+#define S3C2410_SDIFSTA_RFDET          (1<<12)
+#define S3C2410_SDIFSTA_TXHALF         (1<<11)
+#define S3C2410_SDIFSTA_TXEMPTY        (1<<10)
+#define S3C2410_SDIFSTA_RFLAST         (1<<9)
+#define S3C2410_SDIFSTA_RFFULL         (1<<8)
+#define S3C2410_SDIFSTA_RFHALF         (1<<7)
+#define S3C2410_SDIFSTA_COUNTMASK      (0x7f)
+
+#define S3C2410_SDIIMSK_RESPONSECRC    (1<<17)
+#define S3C2410_SDIIMSK_CMDSENT        (1<<16)
+#define S3C2410_SDIIMSK_CMDTIMEOUT     (1<<15)
+#define S3C2410_SDIIMSK_RESPONSEND     (1<<14)
+#define S3C2410_SDIIMSK_READWAIT       (1<<13)
+#define S3C2410_SDIIMSK_SDIOIRQ        (1<<12)
+#define S3C2410_SDIIMSK_FIFOFAIL       (1<<11)
+#define S3C2410_SDIIMSK_CRCSTATUS      (1<<10)
+#define S3C2410_SDIIMSK_DATACRC        (1<<9)
+#define S3C2410_SDIIMSK_DATATIMEOUT    (1<<8)
+#define S3C2410_SDIIMSK_DATAFINISH     (1<<7)
+#define S3C2410_SDIIMSK_BUSYFINISH     (1<<6)
+#define S3C2410_SDIIMSK_SBITERR        (1<<5)	/* reserved 2440/2410a */
+#define S3C2410_SDIIMSK_TXFIFOHALF     (1<<4)
+#define S3C2410_SDIIMSK_TXFIFOEMPTY    (1<<3)
+#define S3C2410_SDIIMSK_RXFIFOLAST     (1<<2)
+#define S3C2410_SDIIMSK_RXFIFOFULL     (1<<1)
+#define S3C2410_SDIIMSK_RXFIFOHALF     (1<<0)
+
+#endif /* __ASM_ARM_REGS_SDI */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-serial.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-serial.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-serial.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,232 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-serial.h
+ *
+ *  From linux/include/asm-arm/hardware/serial_s3c2410.h
+ *
+ *  Internal header file for Samsung S3C2410 serial ports (UART0-2)
+ *
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *
+ *  Additional defines, (c) 2003 Simtec Electronics (linux@simtec.co.uk)
+ *
+ *  Adapted from:
+ *
+ *  Internal header file for MX1ADS serial ports (UART1 & 2)
+ *
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __ASM_ARM_REGS_SERIAL_H
+#define __ASM_ARM_REGS_SERIAL_H
+
+#define S3C24XX_VA_UART0      (S3C24XX_VA_UART)
+#define S3C24XX_VA_UART1      (S3C24XX_VA_UART + 0x4000 )
+#define S3C24XX_VA_UART2      (S3C24XX_VA_UART + 0x8000 )
+#define S3C24XX_VA_UART3      (S3C24XX_VA_UART + 0xC000 )
+
+#define S3C2410_PA_UART0      (S3C24XX_PA_UART)
+#define S3C2410_PA_UART1      (S3C24XX_PA_UART + 0x4000 )
+#define S3C2410_PA_UART2      (S3C24XX_PA_UART + 0x8000 )
+#define S3C2443_PA_UART3      (S3C24XX_PA_UART + 0xC000 )
+
+#define S3C2410_URXH	  (0x24)
+#define S3C2410_UTXH	  (0x20)
+#define S3C2410_ULCON	  (0x00)
+#define S3C2410_UCON	  (0x04)
+#define S3C2410_UFCON	  (0x08)
+#define S3C2410_UMCON	  (0x0C)
+#define S3C2410_UBRDIV	  (0x28)
+#define S3C2410_UTRSTAT	  (0x10)
+#define S3C2410_UERSTAT	  (0x14)
+#define S3C2410_UFSTAT	  (0x18)
+#define S3C2410_UMSTAT	  (0x1C)
+
+#define S3C2410_LCON_CFGMASK	  ((0xF<<3)|(0x3))
+
+#define S3C2410_LCON_CS5	  (0x0)
+#define S3C2410_LCON_CS6	  (0x1)
+#define S3C2410_LCON_CS7	  (0x2)
+#define S3C2410_LCON_CS8	  (0x3)
+#define S3C2410_LCON_CSMASK	  (0x3)
+
+#define S3C2410_LCON_PNONE	  (0x0)
+#define S3C2410_LCON_PEVEN	  (0x5 << 3)
+#define S3C2410_LCON_PODD	  (0x4 << 3)
+#define S3C2410_LCON_PMASK	  (0x7 << 3)
+
+#define S3C2410_LCON_STOPB	  (1<<2)
+#define S3C2410_LCON_IRM          (1<<6)
+
+#define S3C2440_UCON_CLKMASK	  (3<<10)
+#define S3C2440_UCON_PCLK	  (0<<10)
+#define S3C2440_UCON_UCLK	  (1<<10)
+#define S3C2440_UCON_PCLK2	  (2<<10)
+#define S3C2440_UCON_FCLK	  (3<<10)
+#define S3C2443_UCON_EPLL	  (3<<10)
+
+#define S3C2440_UCON2_FCLK_EN	  (1<<15)
+#define S3C2440_UCON0_DIVMASK	  (15 << 12)
+#define S3C2440_UCON1_DIVMASK	  (15 << 12)
+#define S3C2440_UCON2_DIVMASK	  (7 << 12)
+#define S3C2440_UCON_DIVSHIFT	  (12)
+
+#define S3C2412_UCON_CLKMASK	(3<<10)
+#define S3C2412_UCON_UCLK	(1<<10)
+#define S3C2412_UCON_USYSCLK	(3<<10)
+#define S3C2412_UCON_PCLK	(0<<10)
+#define S3C2412_UCON_PCLK2	(2<<10)
+
+#define S3C2410_UCON_UCLK	  (1<<10)
+#define S3C2410_UCON_SBREAK	  (1<<4)
+
+#define S3C2410_UCON_TXILEVEL	  (1<<9)
+#define S3C2410_UCON_RXILEVEL	  (1<<8)
+#define S3C2410_UCON_TXIRQMODE	  (1<<2)
+#define S3C2410_UCON_RXIRQMODE	  (1<<0)
+#define S3C2410_UCON_RXFIFO_TOI	  (1<<7)
+#define S3C2443_UCON_RXERR_IRQEN  (1<<6)
+#define S3C2443_UCON_LOOPBACK	  (1<<5)
+
+#define S3C2410_UCON_DEFAULT	  (S3C2410_UCON_TXILEVEL  | \
+				   S3C2410_UCON_RXILEVEL  | \
+				   S3C2410_UCON_TXIRQMODE | \
+				   S3C2410_UCON_RXIRQMODE | \
+				   S3C2410_UCON_RXFIFO_TOI)
+
+#define S3C2410_UFCON_FIFOMODE	  (1<<0)
+#define S3C2410_UFCON_TXTRIG0	  (0<<6)
+#define S3C2410_UFCON_RXTRIG8	  (1<<4)
+#define S3C2410_UFCON_RXTRIG12	  (2<<4)
+
+/* S3C2440 FIFO trigger levels */
+#define S3C2440_UFCON_RXTRIG1	  (0<<4)
+#define S3C2440_UFCON_RXTRIG8	  (1<<4)
+#define S3C2440_UFCON_RXTRIG16	  (2<<4)
+#define S3C2440_UFCON_RXTRIG32	  (3<<4)
+
+#define S3C2440_UFCON_TXTRIG0	  (0<<6)
+#define S3C2440_UFCON_TXTRIG16	  (1<<6)
+#define S3C2440_UFCON_TXTRIG32	  (2<<6)
+#define S3C2440_UFCON_TXTRIG48	  (3<<6)
+
+#define S3C2410_UFCON_RESETBOTH	  (3<<1)
+#define S3C2410_UFCON_RESETTX	  (1<<2)
+#define S3C2410_UFCON_RESETRX	  (1<<1)
+
+#define S3C2410_UFCON_DEFAULT	  (S3C2410_UFCON_FIFOMODE | \
+				   S3C2410_UFCON_TXTRIG0  | \
+				   S3C2410_UFCON_RXTRIG8 )
+
+#define	S3C2410_UMCOM_AFC	  (1<<4)
+#define	S3C2410_UMCOM_RTS_LOW	  (1<<0)
+
+#define S3C2412_UMCON_AFC_63	(0<<5)		/* same as s3c2443 */
+#define S3C2412_UMCON_AFC_56	(1<<5)
+#define S3C2412_UMCON_AFC_48	(2<<5)
+#define S3C2412_UMCON_AFC_40	(3<<5)
+#define S3C2412_UMCON_AFC_32	(4<<5)
+#define S3C2412_UMCON_AFC_24	(5<<5)
+#define S3C2412_UMCON_AFC_16	(6<<5)
+#define S3C2412_UMCON_AFC_8	(7<<5)
+
+#define S3C2410_UFSTAT_TXFULL	  (1<<9)
+#define S3C2410_UFSTAT_RXFULL	  (1<<8)
+#define S3C2410_UFSTAT_TXMASK	  (15<<4)
+#define S3C2410_UFSTAT_TXSHIFT	  (4)
+#define S3C2410_UFSTAT_RXMASK	  (15<<0)
+#define S3C2410_UFSTAT_RXSHIFT	  (0)
+
+/* UFSTAT S3C2443 same as S3C2440 */
+#define S3C2440_UFSTAT_TXFULL	  (1<<14)
+#define S3C2440_UFSTAT_RXFULL	  (1<<6)
+#define S3C2440_UFSTAT_TXSHIFT	  (8)
+#define S3C2440_UFSTAT_RXSHIFT	  (0)
+#define S3C2440_UFSTAT_TXMASK	  (63<<8)
+#define S3C2440_UFSTAT_RXMASK	  (63)
+
+#define S3C2410_UTRSTAT_TXE	  (1<<2)
+#define S3C2410_UTRSTAT_TXFE	  (1<<1)
+#define S3C2410_UTRSTAT_RXDR	  (1<<0)
+
+#define S3C2410_UERSTAT_OVERRUN	  (1<<0)
+#define S3C2410_UERSTAT_FRAME	  (1<<2)
+#define S3C2410_UERSTAT_BREAK	  (1<<3)
+#define S3C2443_UERSTAT_PARITY	  (1<<1)
+
+#define S3C2410_UERSTAT_ANY	  (S3C2410_UERSTAT_OVERRUN | \
+				   S3C2410_UERSTAT_FRAME | \
+				   S3C2410_UERSTAT_BREAK)
+
+#define S3C2410_UMSTAT_CTS	  (1<<0)
+#define S3C2410_UMSTAT_DeltaCTS	  (1<<2)
+
+#define S3C2443_DIVSLOT		  (0x2C)
+
+#ifndef __ASSEMBLY__
+
+/* struct s3c24xx_uart_clksrc
+ *
+ * this structure defines a named clock source that can be used for the
+ * uart, so that the best clock can be selected for the requested baud
+ * rate.
+ *
+ * min_baud and max_baud define the range of baud-rates this clock is
+ * acceptable for, if they are both zero, it is assumed any baud rate that
+ * can be generated from this clock will be used.
+ *
+ * divisor gives the divisor from the clock to the one seen by the uart
+*/
+
+struct s3c24xx_uart_clksrc {
+	const char	*name;
+	unsigned int	 divisor;
+	unsigned int	 min_baud;
+	unsigned int	 max_baud;
+};
+
+/* configuration structure for per-machine configurations for the
+ * serial port
+ *
+ * the pointer is setup by the machine specific initialisation from the
+ * arch/arm/mach-s3c2410/ directory.
+*/
+
+struct s3c2410_uartcfg {
+	unsigned char	   hwport;	 /* hardware port number */
+	unsigned char	   unused;
+	unsigned short	   flags;
+	upf_t		   uart_flags;	 /* default uart flags */
+
+	unsigned long	   ucon;	 /* value of ucon for port */
+	unsigned long	   ulcon;	 /* value of ulcon for port */
+	unsigned long	   ufcon;	 /* value of ufcon for port */
+
+	struct s3c24xx_uart_clksrc *clocks;
+	unsigned int		    clocks_size;
+};
+
+/* s3c24xx_uart_devs
+ *
+ * this is exported from the core as we cannot use driver_register(),
+ * or platform_add_device() before the console_initcall()
+*/
+
+extern struct platform_device *s3c24xx_uart_devs[3];
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __ASM_ARM_REGS_SERIAL_H */
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-spi.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-spi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-spi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,52 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-spi.h
+ *
+ * Copyright (c) 2004 Fetron GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 SPI register definition
+*/
+
+#ifndef __ASM_ARCH_REGS_SPI_H
+#define __ASM_ARCH_REGS_SPI_H
+
+
+#define S3C2410_SPCON	(0x00)
+
+#define S3C2410_SPCON_SMOD_DMA	  (2<<5)	/* DMA mode */
+#define S3C2410_SPCON_SMOD_INT	  (1<<5)	/* interrupt mode */
+#define S3C2410_SPCON_SMOD_POLL   (0<<5)	/* polling mode */
+#define S3C2410_SPCON_ENSCK	  (1<<4)	/* Enable SCK */
+#define S3C2410_SPCON_MSTR	  (1<<3)	/* Master/Slave select
+						   0: slave, 1: master */
+#define S3C2410_SPCON_CPOL_HIGH	  (1<<2)	/* Clock polarity select */
+#define S3C2410_SPCON_CPOL_LOW	  (0<<2)	/* Clock polarity select */
+
+#define S3C2410_SPCON_CPHA_FMTB	  (1<<1)	/* Clock Phase Select */
+#define S3C2410_SPCON_CPHA_FMTA	  (0<<1)	/* Clock Phase Select */
+
+#define S3C2410_SPCON_TAGD	  (1<<0)	/* Tx auto garbage data mode */
+
+
+#define S3C2410_SPSTA	 (0x04)
+
+#define S3C2410_SPSTA_DCOL	  (1<<2)	/* Data Collision Error */
+#define S3C2410_SPSTA_MULD	  (1<<1)	/* Multi Master Error */
+#define S3C2410_SPSTA_READY	  (1<<0)	/* Data Tx/Rx ready */
+
+
+#define S3C2410_SPPIN	 (0x08)
+
+#define S3C2410_SPPIN_ENMUL	  (1<<2)	/* Multi Master Error detect */
+#define S3C2410_SPPIN_RESERVED	  (1<<1)
+#define S3C2400_SPPIN_nCS     	  (1<<1)	/* SPI Card Select */
+#define S3C2410_SPPIN_KEEP	  (1<<0)	/* Master Out keep */
+
+
+#define S3C2410_SPPRE	 (0x0C)
+#define S3C2410_SPTDAT	 (0x10)
+#define S3C2410_SPRDAT	 (0x14)
+
+#endif /* __ASM_ARCH_REGS_SPI_H */
Index: build_tree/linux/include/asm/arch-s3c2410/regs-timer.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-timer.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-timer.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,106 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-timer.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 Timer configuration
+*/
+
+
+#ifndef __ASM_ARCH_REGS_TIMER_H
+#define __ASM_ARCH_REGS_TIMER_H "$Id: timer.h,v 1.4 2003/05/06 19:30:50 ben Exp $"
+
+#define S3C2410_TIMERREG(x) (S3C24XX_VA_TIMER + (x))
+#define S3C2410_TIMERREG2(tmr,reg) S3C2410_TIMERREG((reg)+0x0c+((tmr)*0x0c))
+
+#define S3C2410_TCFG0	      S3C2410_TIMERREG(0x00)
+#define S3C2410_TCFG1	      S3C2410_TIMERREG(0x04)
+#define S3C2410_TCON	      S3C2410_TIMERREG(0x08)
+
+#define S3C2410_TCFG_PRESCALER0_MASK (255<<0)
+#define S3C2410_TCFG_PRESCALER1_MASK (255<<8)
+#define S3C2410_TCFG_PRESCALER1_SHIFT (8)
+#define S3C2410_TCFG_DEADZONE_MASK   (255<<16)
+#define S3C2410_TCFG_DEADZONE_SHIFT  (16)
+
+#define S3C2410_TCFG1_MUX4_DIV2	  (0<<16)
+#define S3C2410_TCFG1_MUX4_DIV4	  (1<<16)
+#define S3C2410_TCFG1_MUX4_DIV8	  (2<<16)
+#define S3C2410_TCFG1_MUX4_DIV16  (3<<16)
+#define S3C2410_TCFG1_MUX4_TCLK1  (4<<16)
+#define S3C2410_TCFG1_MUX4_MASK	  (15<<16)
+#define S3C2410_TCFG1_MUX4_SHIFT  (16)
+
+#define S3C2410_TCFG1_MUX3_DIV2	  (0<<12)
+#define S3C2410_TCFG1_MUX3_DIV4	  (1<<12)
+#define S3C2410_TCFG1_MUX3_DIV8	  (2<<12)
+#define S3C2410_TCFG1_MUX3_DIV16  (3<<12)
+#define S3C2410_TCFG1_MUX3_TCLK1  (4<<12)
+#define S3C2410_TCFG1_MUX3_MASK	  (15<<12)
+
+
+#define S3C2410_TCFG1_MUX2_DIV2	  (0<<8)
+#define S3C2410_TCFG1_MUX2_DIV4	  (1<<8)
+#define S3C2410_TCFG1_MUX2_DIV8	  (2<<8)
+#define S3C2410_TCFG1_MUX2_DIV16  (3<<8)
+#define S3C2410_TCFG1_MUX2_TCLK1  (4<<8)
+#define S3C2410_TCFG1_MUX2_MASK	  (15<<8)
+
+
+#define S3C2410_TCFG1_MUX1_DIV2	  (0<<4)
+#define S3C2410_TCFG1_MUX1_DIV4	  (1<<4)
+#define S3C2410_TCFG1_MUX1_DIV8	  (2<<4)
+#define S3C2410_TCFG1_MUX1_DIV16  (3<<4)
+#define S3C2410_TCFG1_MUX1_TCLK0  (4<<4)
+#define S3C2410_TCFG1_MUX1_MASK	  (15<<4)
+
+#define S3C2410_TCFG1_MUX0_DIV2	  (0<<0)
+#define S3C2410_TCFG1_MUX0_DIV4	  (1<<0)
+#define S3C2410_TCFG1_MUX0_DIV8	  (2<<0)
+#define S3C2410_TCFG1_MUX0_DIV16  (3<<0)
+#define S3C2410_TCFG1_MUX0_TCLK0  (4<<0)
+#define S3C2410_TCFG1_MUX0_MASK	  (15<<0)
+
+/* for each timer, we have an count buffer, an compare buffer and
+ * an observation buffer
+*/
+
+/* WARNING - timer 4 has no buffer reg, and it's observation is at +4 */
+
+#define S3C2410_TCNTB(tmr)    S3C2410_TIMERREG2(tmr, 0x00)
+#define S3C2410_TCMPB(tmr)    S3C2410_TIMERREG2(tmr, 0x04)
+#define S3C2410_TCNTO(tmr)    S3C2410_TIMERREG2(tmr, (((tmr) == 4) ? 0x04 : 0x08))
+
+#define S3C2410_TCON_T4RELOAD	  (1<<22)
+#define S3C2410_TCON_T4MANUALUPD  (1<<21)
+#define S3C2410_TCON_T4START	  (1<<20)
+
+#define S3C2410_TCON_T3RELOAD	  (1<<19)
+#define S3C2410_TCON_T3INVERT	  (1<<18)
+#define S3C2410_TCON_T3MANUALUPD  (1<<17)
+#define S3C2410_TCON_T3START	  (1<<16)
+
+#define S3C2410_TCON_T2RELOAD	  (1<<15)
+#define S3C2410_TCON_T2INVERT	  (1<<14)
+#define S3C2410_TCON_T2MANUALUPD  (1<<13)
+#define S3C2410_TCON_T2START	  (1<<12)
+
+#define S3C2410_TCON_T1RELOAD	  (1<<11)
+#define S3C2410_TCON_T1INVERT	  (1<<10)
+#define S3C2410_TCON_T1MANUALUPD  (1<<9)
+#define S3C2410_TCON_T1START	  (1<<8)
+
+#define S3C2410_TCON_T0DEADZONE	  (1<<4)
+#define S3C2410_TCON_T0RELOAD	  (1<<3)
+#define S3C2410_TCON_T0INVERT	  (1<<2)
+#define S3C2410_TCON_T0MANUALUPD  (1<<1)
+#define S3C2410_TCON_T0START	  (1<<0)
+
+#endif /*  __ASM_ARCH_REGS_TIMER_H */
+
+
+
Index: build_tree/linux/include/asm/arch-s3c2410/regs-udc.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-udc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-udc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,157 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-udc.h
+ *
+ * Copyright (C) 2004 Herbert Poetzl <herbert@13thfloor.at>
+ *
+ * This include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+*/
+
+#ifndef __ASM_ARCH_REGS_UDC_H
+#define __ASM_ARCH_REGS_UDC_H
+
+#define S3C2410_USBDREG(x) (x)
+
+#define S3C2410_UDC_FUNC_ADDR_REG	S3C2410_USBDREG(0x0140)
+#define S3C2410_UDC_PWR_REG		S3C2410_USBDREG(0x0144)
+#define S3C2410_UDC_EP_INT_REG		S3C2410_USBDREG(0x0148)
+
+#define S3C2410_UDC_USB_INT_REG		S3C2410_USBDREG(0x0158)
+#define S3C2410_UDC_EP_INT_EN_REG	S3C2410_USBDREG(0x015c)
+
+#define S3C2410_UDC_USB_INT_EN_REG	S3C2410_USBDREG(0x016c)
+
+#define S3C2410_UDC_FRAME_NUM1_REG	S3C2410_USBDREG(0x0170)
+#define S3C2410_UDC_FRAME_NUM2_REG	S3C2410_USBDREG(0x0174)
+
+#define S3C2410_UDC_EP0_FIFO_REG	S3C2410_USBDREG(0x01c0)
+#define S3C2410_UDC_EP1_FIFO_REG	S3C2410_USBDREG(0x01c4)
+#define S3C2410_UDC_EP2_FIFO_REG	S3C2410_USBDREG(0x01c8)
+#define S3C2410_UDC_EP3_FIFO_REG	S3C2410_USBDREG(0x01cc)
+#define S3C2410_UDC_EP4_FIFO_REG	S3C2410_USBDREG(0x01d0)
+
+#define S3C2410_UDC_EP1_DMA_CON		S3C2410_USBDREG(0x0200)
+#define S3C2410_UDC_EP1_DMA_UNIT	S3C2410_USBDREG(0x0204)
+#define S3C2410_UDC_EP1_DMA_FIFO	S3C2410_USBDREG(0x0208)
+#define S3C2410_UDC_EP1_DMA_TTC_L	S3C2410_USBDREG(0x020c)
+#define S3C2410_UDC_EP1_DMA_TTC_M	S3C2410_USBDREG(0x0210)
+#define S3C2410_UDC_EP1_DMA_TTC_H	S3C2410_USBDREG(0x0214)
+
+#define S3C2410_UDC_EP2_DMA_CON		S3C2410_USBDREG(0x0218)
+#define S3C2410_UDC_EP2_DMA_UNIT	S3C2410_USBDREG(0x021c)
+#define S3C2410_UDC_EP2_DMA_FIFO	S3C2410_USBDREG(0x0220)
+#define S3C2410_UDC_EP2_DMA_TTC_L	S3C2410_USBDREG(0x0224)
+#define S3C2410_UDC_EP2_DMA_TTC_M	S3C2410_USBDREG(0x0228)
+#define S3C2410_UDC_EP2_DMA_TTC_H	S3C2410_USBDREG(0x022c)
+
+#define S3C2410_UDC_EP3_DMA_CON		S3C2410_USBDREG(0x0240)
+#define S3C2410_UDC_EP3_DMA_UNIT	S3C2410_USBDREG(0x0244)
+#define S3C2410_UDC_EP3_DMA_FIFO	S3C2410_USBDREG(0x0248)
+#define S3C2410_UDC_EP3_DMA_TTC_L	S3C2410_USBDREG(0x024c)
+#define S3C2410_UDC_EP3_DMA_TTC_M	S3C2410_USBDREG(0x0250)
+#define S3C2410_UDC_EP3_DMA_TTC_H	S3C2410_USBDREG(0x0254)
+
+#define S3C2410_UDC_EP4_DMA_CON		S3C2410_USBDREG(0x0258)
+#define S3C2410_UDC_EP4_DMA_UNIT	S3C2410_USBDREG(0x025c)
+#define S3C2410_UDC_EP4_DMA_FIFO	S3C2410_USBDREG(0x0260)
+#define S3C2410_UDC_EP4_DMA_TTC_L	S3C2410_USBDREG(0x0264)
+#define S3C2410_UDC_EP4_DMA_TTC_M	S3C2410_USBDREG(0x0268)
+#define S3C2410_UDC_EP4_DMA_TTC_H	S3C2410_USBDREG(0x026c)
+
+#define S3C2410_UDC_INDEX_REG		S3C2410_USBDREG(0x0178)
+
+/* indexed registers */
+
+#define S3C2410_UDC_MAXP_REG		S3C2410_USBDREG(0x0180)
+
+#define S3C2410_UDC_EP0_CSR_REG		S3C2410_USBDREG(0x0184)
+
+#define S3C2410_UDC_IN_CSR1_REG		S3C2410_USBDREG(0x0184)
+#define S3C2410_UDC_IN_CSR2_REG		S3C2410_USBDREG(0x0188)
+
+#define S3C2410_UDC_OUT_CSR1_REG	S3C2410_USBDREG(0x0190)
+#define S3C2410_UDC_OUT_CSR2_REG	S3C2410_USBDREG(0x0194)
+#define S3C2410_UDC_OUT_FIFO_CNT1_REG	S3C2410_USBDREG(0x0198)
+#define S3C2410_UDC_OUT_FIFO_CNT2_REG	S3C2410_USBDREG(0x019c)
+
+
+
+#define S3C2410_UDC_PWR_ISOUP		(1<<7) // R/W
+#define S3C2410_UDC_PWR_RESET		(1<<3) // R
+#define S3C2410_UDC_PWR_RESUME		(1<<2) // R/W
+#define S3C2410_UDC_PWR_SUSPEND		(1<<1) // R
+#define S3C2410_UDC_PWR_ENSUSPEND	(1<<0) // R/W
+
+#define S3C2410_UDC_PWR_DEFAULT		0x00
+
+#define S3C2410_UDC_INT_EP4		(1<<4) // R/W (clear only)
+#define S3C2410_UDC_INT_EP3		(1<<3) // R/W (clear only)
+#define S3C2410_UDC_INT_EP2		(1<<2) // R/W (clear only)
+#define S3C2410_UDC_INT_EP1		(1<<1) // R/W (clear only)
+#define S3C2410_UDC_INT_EP0		(1<<0) // R/W (clear only)
+
+#define S3C2410_UDC_USBINT_RESET	(1<<2) // R/W (clear only)
+#define S3C2410_UDC_USBINT_RESUME	(1<<1) // R/W (clear only)
+#define S3C2410_UDC_USBINT_SUSPEND	(1<<0) // R/W (clear only)
+
+#define S3C2410_UDC_INTE_EP4		(1<<4) // R/W
+#define S3C2410_UDC_INTE_EP3		(1<<3) // R/W
+#define S3C2410_UDC_INTE_EP2		(1<<2) // R/W
+#define S3C2410_UDC_INTE_EP1		(1<<1) // R/W
+#define S3C2410_UDC_INTE_EP0		(1<<0) // R/W
+
+#define S3C2410_UDC_USBINTE_RESET	(1<<2) // R/W
+#define S3C2410_UDC_USBINTE_SUSPEND	(1<<0) // R/W
+
+
+#define S3C2410_UDC_INDEX_EP0		(0x00)
+#define S3C2410_UDC_INDEX_EP1		(0x01) // ??
+#define S3C2410_UDC_INDEX_EP2		(0x02) // ??
+#define S3C2410_UDC_INDEX_EP3		(0x03) // ??
+#define S3C2410_UDC_INDEX_EP4		(0x04) // ??
+
+#define S3C2410_UDC_ICSR1_CLRDT		(1<<6) // R/W
+#define S3C2410_UDC_ICSR1_SENTSTL	(1<<5) // R/W (clear only)
+#define S3C2410_UDC_ICSR1_SENDSTL	(1<<4) // R/W
+#define S3C2410_UDC_ICSR1_FFLUSH	(1<<3) // W   (set only)
+#define S3C2410_UDC_ICSR1_UNDRUN	(1<<2) // R/W (clear only)
+#define S3C2410_UDC_ICSR1_PKTRDY	(1<<0) // R/W (set only)
+
+#define S3C2410_UDC_ICSR2_AUTOSET	(1<<7) // R/W
+#define S3C2410_UDC_ICSR2_ISO		(1<<6) // R/W
+#define S3C2410_UDC_ICSR2_MODEIN	(1<<5) // R/W
+#define S3C2410_UDC_ICSR2_DMAIEN	(1<<4) // R/W
+
+#define S3C2410_UDC_OCSR1_CLRDT		(1<<7) // R/W
+#define S3C2410_UDC_OCSR1_SENTSTL	(1<<6) // R/W (clear only)
+#define S3C2410_UDC_OCSR1_SENDSTL	(1<<5) // R/W
+#define S3C2410_UDC_OCSR1_FFLUSH	(1<<4) // R/W
+#define S3C2410_UDC_OCSR1_DERROR	(1<<3) // R
+#define S3C2410_UDC_OCSR1_OVRRUN	(1<<2) // R/W (clear only)
+#define S3C2410_UDC_OCSR1_PKTRDY	(1<<0) // R/W (clear only)
+
+#define S3C2410_UDC_OCSR2_AUTOCLR	(1<<7) // R/W
+#define S3C2410_UDC_OCSR2_ISO		(1<<6) // R/W
+#define S3C2410_UDC_OCSR2_DMAIEN	(1<<5) // R/W
+
+#define S3C2410_UDC_SETIX(base,x)	    \
+	writel(S3C2410_UDC_INDEX_ ## x, base+S3C2410_UDC_INDEX_REG);
+
+
+#define S3C2410_UDC_EP0_CSR_OPKRDY	(1<<0)
+#define S3C2410_UDC_EP0_CSR_IPKRDY	(1<<1)
+#define S3C2410_UDC_EP0_CSR_SENTSTL	(1<<2)
+#define S3C2410_UDC_EP0_CSR_DE		(1<<3)
+#define S3C2410_UDC_EP0_CSR_SE		(1<<4)
+#define S3C2410_UDC_EP0_CSR_SENDSTL	(1<<5)
+#define S3C2410_UDC_EP0_CSR_SOPKTRDY	(1<<6)
+#define S3C2410_UDC_EP0_CSR_SSE	(1<<7)
+
+#define S3C2410_UDC_MAXP_8		(1<<0)
+#define S3C2410_UDC_MAXP_16		(1<<1)
+#define S3C2410_UDC_MAXP_32		(1<<2)
+#define S3C2410_UDC_MAXP_64		(1<<3)
+
+
+#endif
Index: build_tree/linux/include/asm/arch-s3c2410/regs-watchdog.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/regs-watchdog.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/regs-watchdog.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/* linux/include/asm/arch-s3c2410/regs-watchdog.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 Watchdog timer control
+*/
+
+
+#ifndef __ASM_ARCH_REGS_WATCHDOG_H
+#define __ASM_ARCH_REGS_WATCHDOG_H "$Id: watchdog.h,v 1.2 2003/04/29 13:31:09 ben Exp $"
+
+#define S3C2410_WDOGREG(x) ((x) + S3C24XX_VA_WATCHDOG)
+
+#define S3C2410_WTCON	   S3C2410_WDOGREG(0x00)
+#define S3C2410_WTDAT	   S3C2410_WDOGREG(0x04)
+#define S3C2410_WTCNT	   S3C2410_WDOGREG(0x08)
+
+/* the watchdog can either generate a reset pulse, or an
+ * interrupt.
+ */
+
+#define S3C2410_WTCON_RSTEN   (0x01)
+#define S3C2410_WTCON_INTEN   (1<<2)
+#define S3C2410_WTCON_ENABLE  (1<<5)
+
+#define S3C2410_WTCON_DIV16   (0<<3)
+#define S3C2410_WTCON_DIV32   (1<<3)
+#define S3C2410_WTCON_DIV64   (2<<3)
+#define S3C2410_WTCON_DIV128  (3<<3)
+
+#define S3C2410_WTCON_PRESCALE(x) ((x) << 8)
+#define S3C2410_WTCON_PRESCALE_MASK (0xff00)
+
+#endif /* __ASM_ARCH_REGS_WATCHDOG_H */
+
+
Index: build_tree/linux/include/asm/arch-s3c2410/reset.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/reset.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/reset.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/* linux/include/asm-arm/arch-s3c2410/reset.h
+ *
+ * Copyright (c) 2007 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 CPU reset controls
+*/
+
+#ifndef __ASM_ARCH_RESET_H
+#define __ASM_ARCH_RESET_H __FILE__
+
+/* This allows the over-ride of the default reset code
+*/
+
+extern void (*s3c24xx_reset_hook)(void);
+
+#endif /* __ASM_ARCH_RESET_H */
Index: build_tree/linux/include/asm/arch-s3c2410/spi-gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/spi-gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/spi-gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,31 @@
+/* linux/include/asm-arm/arch-s3c2410/spi-gpio.h
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - SPI Controller platfrom_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_SPIGPIO_H
+#define __ASM_ARCH_SPIGPIO_H __FILE__
+
+struct s3c2410_spigpio_info;
+struct spi_board_info;
+
+struct s3c2410_spigpio_info {
+	unsigned long		 pin_clk;
+	unsigned long		 pin_mosi;
+	unsigned long		 pin_miso;
+
+	unsigned long		 board_size;
+	struct spi_board_info	*board_info;
+
+	void (*chip_select)(struct s3c2410_spigpio_info *spi, int cs);
+};
+
+
+#endif /* __ASM_ARCH_SPIGPIO_H */
Index: build_tree/linux/include/asm/arch-s3c2410/spi.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/spi.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/spi.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/* linux/include/asm-arm/arch-s3c2410/spi.h
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - SPI Controller platform_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_SPI_H
+#define __ASM_ARCH_SPI_H __FILE__
+
+struct s3c2410_spi_info;
+struct spi_board_info;
+
+struct s3c2410_spi_info {
+	unsigned long		 pin_cs;	/* simple gpio cs */
+
+	unsigned long		 board_size;
+	struct spi_board_info	*board_info;
+
+	void (*set_cs)(struct s3c2410_spi_info *spi, int cs, int pol);
+};
+
+
+#endif /* __ASM_ARCH_SPI_H */
Index: build_tree/linux/include/asm/arch-s3c2410/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,88 @@
+/* linux/include/asm-arm/arch-s3c2410/system.h
+ *
+ * Copyright (c) 2003 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - System function defines and includes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <asm/arch/map.h>
+#include <asm/arch/idle.h>
+#include <asm/arch/reset.h>
+
+#include <asm/arch/regs-watchdog.h>
+#include <asm/arch/regs-clock.h>
+
+void (*s3c24xx_idle)(void);
+void (*s3c24xx_reset_hook)(void);
+
+void s3c24xx_default_idle(void)
+{
+	unsigned long tmp;
+	int i;
+
+	/* idle the system by using the idle mode which will wait for an
+	 * interrupt to happen before restarting the system.
+	 */
+
+	/* Warning: going into idle state upsets jtag scanning */
+
+	__raw_writel(__raw_readl(S3C2410_CLKCON) | S3C2410_CLKCON_IDLE,
+		     S3C2410_CLKCON);
+
+	/* the samsung port seems to do a loop and then unset idle.. */
+	for (i = 0; i < 50; i++) {
+		tmp += __raw_readl(S3C2410_CLKCON); /* ensure loop not optimised out */
+	}
+
+	/* this bit is not cleared on re-start... */
+
+	__raw_writel(__raw_readl(S3C2410_CLKCON) & ~S3C2410_CLKCON_IDLE,
+		     S3C2410_CLKCON);
+}
+
+static void arch_idle(void)
+{
+	if (s3c24xx_idle != NULL)
+		(s3c24xx_idle)();
+	else
+		s3c24xx_default_idle();
+}
+
+static void
+arch_reset(char mode)
+{
+	if (mode == 's') {
+		cpu_reset(0);
+	}
+
+	if (s3c24xx_reset_hook)
+		s3c24xx_reset_hook();
+
+	printk("arch_reset: attempting watchdog reset\n");
+
+	__raw_writel(0, S3C2410_WTCON);	  /* disable watchdog, to be safe  */
+
+	/* put initial values into count and data */
+	__raw_writel(0x100, S3C2410_WTCNT);
+	__raw_writel(0x100, S3C2410_WTDAT);
+
+	/* set the watchdog to go and reset... */
+	__raw_writel(S3C2410_WTCON_ENABLE|S3C2410_WTCON_DIV16|S3C2410_WTCON_RSTEN |
+		     S3C2410_WTCON_PRESCALE(0x20), S3C2410_WTCON);
+
+	/* wait for reset to assert... */
+	mdelay(5000);
+
+	printk(KERN_ERR "Watchdog reset failed to assert reset\n");
+
+	/* we'll take a jump through zero as a poor second */
+	cpu_reset(0);
+}
Index: build_tree/linux/include/asm/arch-s3c2410/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/* linux/include/asm-arm/arch-s3c2410/timex.h
+ *
+ * Copyright (c) 2003-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - time parameters
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+/* CLOCK_TICK_RATE needs to be evaluatable by the cpp, so making it
+ * a variable is useless. It seems as long as we make our timers an
+ * exact multiple of HZ, any value that makes a 1->1 correspondence
+ * for the time conversion functions to/from jiffies is acceptable.
+*/
+
+
+#define CLOCK_TICK_RATE 12000000
+
+
+#endif /* __ASM_ARCH_TIMEX_H */
Index: build_tree/linux/include/asm/arch-s3c2410/udc.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/udc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/udc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/* linux/include/asm/arch-s3c2410/udc.h
+ *
+ * Copyright (c) 2005 Arnaud Patard <arnaud.patard@rtp-net.org>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *
+ *  Changelog:
+ *	14-Mar-2005	RTP	Created file
+ *	02-Aug-2005	RTP	File rename
+ *	07-Sep-2005	BJD	Minor cleanups, changed cmd to enum
+ *	18-Jan-2007	HMW	Add per-platform vbus_draw function
+*/
+
+#ifndef __ASM_ARM_ARCH_UDC_H
+#define __ASM_ARM_ARCH_UDC_H
+
+enum s3c2410_udc_cmd_e {
+	S3C2410_UDC_P_ENABLE	= 1,	/* Pull-up enable        */
+	S3C2410_UDC_P_DISABLE	= 2,	/* Pull-up disable       */
+	S3C2410_UDC_P_RESET	= 3,	/* UDC reset, in case of */
+};
+
+struct s3c2410_udc_mach_info {
+	void	(*udc_command)(enum s3c2410_udc_cmd_e);
+ 	void	(*vbus_draw)(unsigned int ma);
+	unsigned int vbus_pin;
+	unsigned char vbus_pin_inverted;
+};
+
+extern void __init s3c24xx_udc_set_platdata(struct s3c2410_udc_mach_info *);
+
+#endif /* __ASM_ARM_ARCH_UDC_H */
Index: build_tree/linux/include/asm/arch-s3c2410/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,165 @@
+/* linux/include/asm-arm/arch-s3c2410/uncompress.h
+ *
+ * Copyright (c) 2003 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - uncompress code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+typedef unsigned int upf_t;	/* cannot include linux/serial_core.h */
+
+/* defines for UART registers */
+#include "asm/arch/regs-serial.h"
+#include "asm/arch/regs-gpio.h"
+#include "asm/arch/regs-watchdog.h"
+
+#include <asm/arch/map.h>
+
+/* working in physical space... */
+#undef S3C2410_GPIOREG
+#undef S3C2410_WDOGREG
+
+#define S3C2410_GPIOREG(x) ((S3C24XX_PA_GPIO + (x)))
+#define S3C2410_WDOGREG(x) ((S3C24XX_PA_WATCHDOG + (x)))
+
+/* how many bytes we allow into the FIFO at a time in FIFO mode */
+#define FIFO_MAX	 (14)
+
+#define uart_base S3C24XX_PA_UART + (0x4000*CONFIG_S3C2410_LOWLEVEL_UART_PORT)
+
+static __inline__ void
+uart_wr(unsigned int reg, unsigned int val)
+{
+	volatile unsigned int *ptr;
+
+	ptr = (volatile unsigned int *)(reg + uart_base);
+	*ptr = val;
+}
+
+static __inline__ unsigned int
+uart_rd(unsigned int reg)
+{
+	volatile unsigned int *ptr;
+
+	ptr = (volatile unsigned int *)(reg + uart_base);
+	return *ptr;
+}
+
+
+/* we can deal with the case the UARTs are being run
+ * in FIFO mode, so that we don't hold up our execution
+ * waiting for tx to happen...
+*/
+
+static void putc(int ch)
+{
+	int cpuid = S3C2410_GSTATUS1_2410;
+
+#ifndef CONFIG_CPU_S3C2400
+	cpuid = *((volatile unsigned int *)S3C2410_GSTATUS1);
+	cpuid &= S3C2410_GSTATUS1_IDMASK;
+#endif
+
+	if (uart_rd(S3C2410_UFCON) & S3C2410_UFCON_FIFOMODE) {
+		int level;
+
+		while (1) {
+			level = uart_rd(S3C2410_UFSTAT);
+
+			if (cpuid == S3C2410_GSTATUS1_2440 ||
+			    cpuid == S3C2410_GSTATUS1_2442) {
+				level &= S3C2440_UFSTAT_TXMASK;
+				level >>= S3C2440_UFSTAT_TXSHIFT;
+			} else {
+				level &= S3C2410_UFSTAT_TXMASK;
+				level >>= S3C2410_UFSTAT_TXSHIFT;
+			}
+
+			if (level < FIFO_MAX)
+				break;
+		}
+
+	} else {
+		/* not using fifos */
+
+		while ((uart_rd(S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXE) != S3C2410_UTRSTAT_TXE)
+			barrier();
+	}
+
+	/* write byte to transmission register */
+	uart_wr(S3C2410_UTXH, ch);
+}
+
+static inline void flush(void)
+{
+}
+
+#define __raw_writel(d,ad) do { *((volatile unsigned int *)(ad)) = (d); } while(0)
+
+/* CONFIG_S3C2410_BOOT_WATCHDOG
+ *
+ * Simple boot-time watchdog setup, to reboot the system if there is
+ * any problem with the boot process
+*/
+
+#ifdef CONFIG_S3C2410_BOOT_WATCHDOG
+
+#define WDOG_COUNT (0xff00)
+
+static inline void arch_decomp_wdog(void)
+{
+	__raw_writel(WDOG_COUNT, S3C2410_WTCNT);
+}
+
+static void arch_decomp_wdog_start(void)
+{
+	__raw_writel(WDOG_COUNT, S3C2410_WTDAT);
+	__raw_writel(WDOG_COUNT, S3C2410_WTCNT);
+	__raw_writel(S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128 | S3C2410_WTCON_RSTEN | S3C2410_WTCON_PRESCALE(0x80), S3C2410_WTCON);
+}
+
+#else
+#define arch_decomp_wdog_start()
+#define arch_decomp_wdog()
+#endif
+
+#ifdef CONFIG_S3C2410_BOOT_ERROR_RESET
+
+static void arch_decomp_error(const char *x)
+{
+	putstr("\n\n");
+	putstr(x);
+	putstr("\n\n -- System resetting\n");
+
+	__raw_writel(0x4000, S3C2410_WTDAT);
+	__raw_writel(0x4000, S3C2410_WTCNT);
+	__raw_writel(S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128 | S3C2410_WTCON_RSTEN | S3C2410_WTCON_PRESCALE(0x40), S3C2410_WTCON);
+
+	while(1);
+}
+
+#define arch_error arch_decomp_error
+#endif
+
+static void error(char *err);
+
+static void
+arch_decomp_setup(void)
+{
+	/* we may need to setup the uart(s) here if we are not running
+	 * on an BAST... the BAST will have left the uarts configured
+	 * after calling linux.
+	 */
+
+	arch_decomp_wdog_start();
+}
+
+
+#endif /* __ASM_ARCH_UNCOMPRESS_H */
Index: build_tree/linux/include/asm/arch-s3c2410/usb-control.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/usb-control.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/usb-control.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/* linux/include/asm-arm/arch-s3c2410/usb-control.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - usb port information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_USBCONTROL_H
+#define __ASM_ARCH_USBCONTROL_H "include/asm-arm/arch-s3c2410/usb-control.h"
+
+#define S3C_HCDFLG_USED	(1)
+
+struct s3c2410_hcd_port {
+	unsigned char	flags;
+	unsigned char	power;
+	unsigned char	oc_status;
+	unsigned char	oc_changed;
+};
+
+struct s3c2410_hcd_info {
+	struct usb_hcd		*hcd;
+	struct s3c2410_hcd_port	port[2];
+
+	void		(*power_control)(int port, int to);
+	void		(*enable_oc)(struct s3c2410_hcd_info *, int on);
+	void		(*report_oc)(struct s3c2410_hcd_info *, int ports);
+};
+
+static void inline s3c2410_usb_report_oc(struct s3c2410_hcd_info *info, int ports)
+{
+	if (info->report_oc != NULL) {
+		(info->report_oc)(info, ports);
+	}
+}
+
+#endif /*__ASM_ARCH_USBCONTROL_H */
Index: build_tree/linux/include/asm/arch-s3c2410/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/* linux/include/asm-arm/arch-s3c2410/vmalloc.h
+ *
+ * from linux/include/asm-arm/arch-iop3xx/vmalloc.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 vmalloc definition
+*/
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END	  (0xE0000000)
+
+#endif /* __ASM_ARCH_VMALLOC_H */
Index: build_tree/linux/include/asm/arch-s3c2410/vr1000-cpld.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/vr1000-cpld.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/vr1000-cpld.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/* linux/include/asm-arm/arch-s3c2410/vr1000-cpld.h
+ *
+ * Copyright (c) 2003 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * VR1000 - CPLD control constants
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_VR1000CPLD_H
+#define __ASM_ARCH_VR1000CPLD_H
+
+#define VR1000_CPLD_CTRL2_RAMWEN     (0x04)   /* SRAM Write Enable */
+
+#endif /* __ASM_ARCH_VR1000CPLD_H */
Index: build_tree/linux/include/asm/arch-s3c2410/vr1000-irq.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/vr1000-irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/vr1000-irq.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/* linux/include/asm-arm/arch-s3c2410/vr1000-irq.h
+ *
+ * Copyright (c) 2003,2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Machine VR1000 - IRQ Number definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_VR1000IRQ_H
+#define __ASM_ARCH_VR1000IRQ_H
+
+/* irq numbers to onboard peripherals */
+
+#define IRQ_USBOC	     IRQ_EINT19
+#define IRQ_IDE0	     IRQ_EINT16
+#define IRQ_IDE1	     IRQ_EINT17
+#define IRQ_VR1000_SERIAL    IRQ_EINT12
+#define IRQ_VR1000_DM9000A   IRQ_EINT10
+#define IRQ_VR1000_DM9000N   IRQ_EINT9
+#define IRQ_SMALERT	     IRQ_EINT8
+
+#endif /* __ASM_ARCH_VR1000IRQ_H */
Index: build_tree/linux/include/asm/arch-s3c2410/vr1000-map.h
diff -u /dev/null build_tree/linux/include/asm/arch-s3c2410/vr1000-map.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-s3c2410/vr1000-map.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,110 @@
+/* linux/include/asm-arm/arch-s3c2410/vr1000-map.h
+ *
+ * Copyright (c) 2003-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Machine VR1000 - Memory map definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* needs arch/map.h including with this */
+
+/* ok, we've used up to 0x13000000, now we need to find space for the
+ * peripherals that live in the nGCS[x] areas, which are quite numerous
+ * in their space. We also have the board's CPLD to find register space
+ * for.
+ */
+
+#ifndef __ASM_ARCH_VR1000MAP_H
+#define __ASM_ARCH_VR1000MAP_H
+
+#include <asm/arch/bast-map.h>
+
+#define VR1000_IOADDR(x) BAST_IOADDR(x)
+
+/* we put the CPLD registers next, to get them out of the way */
+
+#define VR1000_VA_CTRL1	    VR1000_IOADDR(0x00000000)	 /* 0x01300000 */
+#define VR1000_PA_CTRL1	    (S3C2410_CS5 | 0x7800000)
+
+#define VR1000_VA_CTRL2	    VR1000_IOADDR(0x00100000)	 /* 0x01400000 */
+#define VR1000_PA_CTRL2	    (S3C2410_CS1 | 0x6000000)
+
+#define VR1000_VA_CTRL3	    VR1000_IOADDR(0x00200000)	 /* 0x01500000 */
+#define VR1000_PA_CTRL3	    (S3C2410_CS1 | 0x6800000)
+
+#define VR1000_VA_CTRL4	    VR1000_IOADDR(0x00300000)	 /* 0x01600000 */
+#define VR1000_PA_CTRL4	    (S3C2410_CS1 | 0x7000000)
+
+/* next, we have the PC104 ISA interrupt registers */
+
+#define VR1000_PA_PC104_IRQREQ  (S3C2410_CS5 | 0x6000000) /* 0x01700000 */
+#define VR1000_VA_PC104_IRQREQ  VR1000_IOADDR(0x00400000)
+
+#define VR1000_PA_PC104_IRQRAW  (S3C2410_CS5 | 0x6800000) /* 0x01800000 */
+#define VR1000_VA_PC104_IRQRAW  VR1000_IOADDR(0x00500000)
+
+#define VR1000_PA_PC104_IRQMASK (S3C2410_CS5 | 0x7000000) /* 0x01900000 */
+#define VR1000_VA_PC104_IRQMASK VR1000_IOADDR(0x00600000)
+
+/* 0xE0000000 contains the IO space that is split by speed and
+ * wether the access is for 8 or 16bit IO... this ensures that
+ * the correct access is made
+ *
+ * 0x10000000 of space, partitioned as so:
+ *
+ * 0x00000000 to 0x04000000  8bit,  slow
+ * 0x04000000 to 0x08000000  16bit, slow
+ * 0x08000000 to 0x0C000000  16bit, net
+ * 0x0C000000 to 0x10000000  16bit, fast
+ *
+ * each of these spaces has the following in:
+ *
+ * 0x02000000 to 0x02100000 1MB  IDE primary channel
+ * 0x02100000 to 0x02200000 1MB  IDE primary channel aux
+ * 0x02200000 to 0x02400000 1MB  IDE secondary channel
+ * 0x02300000 to 0x02400000 1MB  IDE secondary channel aux
+ * 0x02500000 to 0x02600000 1MB  Davicom DM9000 ethernet controllers
+ * 0x02600000 to 0x02700000 1MB
+ *
+ * the phyiscal layout of the zones are:
+ *  nGCS2 - 8bit, slow
+ *  nGCS3 - 16bit, slow
+ *  nGCS4 - 16bit, net
+ *  nGCS5 - 16bit, fast
+ */
+
+#define VR1000_VA_MULTISPACE (0xE0000000)
+
+#define VR1000_VA_ISAIO		   (VR1000_VA_MULTISPACE + 0x00000000)
+#define VR1000_VA_ISAMEM	   (VR1000_VA_MULTISPACE + 0x01000000)
+#define VR1000_VA_IDEPRI	   (VR1000_VA_MULTISPACE + 0x02000000)
+#define VR1000_VA_IDEPRIAUX	   (VR1000_VA_MULTISPACE + 0x02100000)
+#define VR1000_VA_IDESEC	   (VR1000_VA_MULTISPACE + 0x02200000)
+#define VR1000_VA_IDESECAUX	   (VR1000_VA_MULTISPACE + 0x02300000)
+#define VR1000_VA_ASIXNET	   (VR1000_VA_MULTISPACE + 0x02400000)
+#define VR1000_VA_DM9000	   (VR1000_VA_MULTISPACE + 0x02500000)
+#define VR1000_VA_SUPERIO	   (VR1000_VA_MULTISPACE + 0x02600000)
+
+/* physical offset addresses for the peripherals */
+
+#define VR1000_PA_IDEPRI	   (0x02000000)
+#define VR1000_PA_IDEPRIAUX	   (0x02800000)
+#define VR1000_PA_IDESEC	   (0x03000000)
+#define VR1000_PA_IDESECAUX	   (0x03800000)
+#define VR1000_PA_DM9000	   (0x05000000)
+
+#define VR1000_PA_SERIAL	   (0x11800000)
+#define VR1000_VA_SERIAL	   (VR1000_IOADDR(0x00700000))
+
+/* VR1000 ram is in CS1, with A26..A24 = 2_101 */
+#define VR1000_PA_SRAM		   (S3C2410_CS1 | 0x05000000)
+
+/* some configurations for the peripherals */
+
+#define VR1000_DM9000_CS	 VR1000_VAM_CS4
+
+#endif /* __ASM_ARCH_VR1000MAP_H */
Index: build_tree/linux/include/asm/arch-sa1100/SA-1100.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/SA-1100.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/SA-1100.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,2072 @@
+/*
+ *	FILE    	SA-1100.h
+ *
+ *	Version 	1.2
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	January 1998 (April 1997)
+ *	System  	StrongARM SA-1100
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of constants related to the StrongARM
+ *	        	SA-1100 microprocessor (Advanced RISC Machine (ARM)
+ *	        	architecture version 4). This file is based on the
+ *	        	StrongARM SA-1100 data sheet version 2.2.
+ *
+ */
+
+
+/* Be sure that virtual mapping is defined right */
+#ifndef __ASM_ARCH_HARDWARE_H
+#error You must include hardware.h not SA-1100.h
+#endif
+
+#include "bitfield.h"
+
+/*
+ * SA1100 CS line to physical address
+ */
+
+#define SA1100_CS0_PHYS	0x00000000
+#define SA1100_CS1_PHYS	0x08000000
+#define SA1100_CS2_PHYS	0x10000000
+#define SA1100_CS3_PHYS	0x18000000
+#define SA1100_CS4_PHYS	0x40000000
+#define SA1100_CS5_PHYS	0x48000000
+
+/*
+ * Personal Computer Memory Card International Association (PCMCIA) sockets
+ */
+
+#define PCMCIAPrtSp	0x04000000	/* PCMCIA Partition Space [byte]   */
+#define PCMCIASp	(4*PCMCIAPrtSp)	/* PCMCIA Space [byte]             */
+#define PCMCIAIOSp	PCMCIAPrtSp	/* PCMCIA I/O Space [byte]         */
+#define PCMCIAAttrSp	PCMCIAPrtSp	/* PCMCIA Attribute Space [byte]   */
+#define PCMCIAMemSp	PCMCIAPrtSp	/* PCMCIA Memory Space [byte]      */
+
+#define PCMCIA0Sp	PCMCIASp	/* PCMCIA 0 Space [byte]           */
+#define PCMCIA0IOSp	PCMCIAIOSp	/* PCMCIA 0 I/O Space [byte]       */
+#define PCMCIA0AttrSp	PCMCIAAttrSp	/* PCMCIA 0 Attribute Space [byte] */
+#define PCMCIA0MemSp	PCMCIAMemSp	/* PCMCIA 0 Memory Space [byte]    */
+
+#define PCMCIA1Sp	PCMCIASp	/* PCMCIA 1 Space [byte]           */
+#define PCMCIA1IOSp	PCMCIAIOSp	/* PCMCIA 1 I/O Space [byte]       */
+#define PCMCIA1AttrSp	PCMCIAAttrSp	/* PCMCIA 1 Attribute Space [byte] */
+#define PCMCIA1MemSp	PCMCIAMemSp	/* PCMCIA 1 Memory Space [byte]    */
+
+#define _PCMCIA(Nb)	        	/* PCMCIA [0..1]                   */ \
+                	(0x20000000 + (Nb)*PCMCIASp)
+#define _PCMCIAIO(Nb)	_PCMCIA (Nb)	/* PCMCIA I/O [0..1]               */
+#define _PCMCIAAttr(Nb)	        	/* PCMCIA Attribute [0..1]         */ \
+                	(_PCMCIA (Nb) + 2*PCMCIAPrtSp)
+#define _PCMCIAMem(Nb)	        	/* PCMCIA Memory [0..1]            */ \
+                	(_PCMCIA (Nb) + 3*PCMCIAPrtSp)
+
+#define _PCMCIA0	_PCMCIA (0)	/* PCMCIA 0                        */
+#define _PCMCIA0IO	_PCMCIAIO (0)	/* PCMCIA 0 I/O                    */
+#define _PCMCIA0Attr	_PCMCIAAttr (0)	/* PCMCIA 0 Attribute              */
+#define _PCMCIA0Mem	_PCMCIAMem (0)	/* PCMCIA 0 Memory                 */
+
+#define _PCMCIA1	_PCMCIA (1)	/* PCMCIA 1                        */
+#define _PCMCIA1IO	_PCMCIAIO (1)	/* PCMCIA 1 I/O                    */
+#define _PCMCIA1Attr	_PCMCIAAttr (1)	/* PCMCIA 1 Attribute              */
+#define _PCMCIA1Mem	_PCMCIAMem (1)	/* PCMCIA 1 Memory                 */
+
+
+/*
+ * Universal Serial Bus (USB) Device Controller (UDC) control registers
+ *
+ * Registers
+ *    Ser0UDCCR 	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Control Register (read/write).
+ *    Ser0UDCAR 	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Address Register (read/write).
+ *    Ser0UDCOMP	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Output Maximum Packet size register
+ *              	(read/write).
+ *    Ser0UDCIMP	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Input Maximum Packet size register
+ *              	(read/write).
+ *    Ser0UDCCS0	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Control/Status register end-point 0
+ *              	(read/write).
+ *    Ser0UDCCS1	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Control/Status register end-point 1
+ *              	(output, read/write).
+ *    Ser0UDCCS2	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Control/Status register end-point 2
+ *              	(input, read/write).
+ *    Ser0UDCD0 	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Data register end-point 0
+ *              	(read/write).
+ *    Ser0UDCWC 	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Write Count register end-point 0
+ *              	(read).
+ *    Ser0UDCDR 	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Data Register (read/write).
+ *    Ser0UDCSR 	Serial port 0 Universal Serial Bus (USB) Device
+ *              	Controller (UDC) Status Register (read/write).
+ */
+
+#define Ser0UDCCR	__REG(0x80000000)  /* Ser. port 0 UDC Control Reg. */
+#define Ser0UDCAR	__REG(0x80000004)  /* Ser. port 0 UDC Address Reg. */
+#define Ser0UDCOMP	__REG(0x80000008)  /* Ser. port 0 UDC Output Maximum Packet size reg. */
+#define Ser0UDCIMP	__REG(0x8000000C)  /* Ser. port 0 UDC Input Maximum Packet size reg. */
+#define Ser0UDCCS0	__REG(0x80000010)  /* Ser. port 0 UDC Control/Status reg. end-point 0 */
+#define Ser0UDCCS1	__REG(0x80000014)  /* Ser. port 0 UDC Control/Status reg. end-point 1 (output) */
+#define Ser0UDCCS2	__REG(0x80000018)  /* Ser. port 0 UDC Control/Status reg. end-point 2 (input) */
+#define Ser0UDCD0	__REG(0x8000001C)  /* Ser. port 0 UDC Data reg. end-point 0 */
+#define Ser0UDCWC	__REG(0x80000020)  /* Ser. port 0 UDC Write Count reg. end-point 0 */
+#define Ser0UDCDR	__REG(0x80000028)  /* Ser. port 0 UDC Data Reg. */
+#define Ser0UDCSR	__REG(0x80000030)  /* Ser. port 0 UDC Status Reg. */
+
+#define UDCCR_UDD	0x00000001	/* UDC Disable                     */
+#define UDCCR_UDA	0x00000002	/* UDC Active (read)               */
+#define UDCCR_RESIM	0x00000004	/* Resume Interrupt Mask, per errata */
+#define UDCCR_EIM	0x00000008	/* End-point 0 Interrupt Mask      */
+                	        	/* (disable)                       */
+#define UDCCR_RIM	0x00000010	/* Receive Interrupt Mask          */
+                	        	/* (disable)                       */
+#define UDCCR_TIM	0x00000020	/* Transmit Interrupt Mask         */
+                	        	/* (disable)                       */
+#define UDCCR_SRM	0x00000040	/* Suspend/Resume interrupt Mask   */
+                	        	/* (disable)                       */
+#define UDCCR_SUSIM	UDCCR_SRM	/* Per errata, SRM just masks suspend */
+#define UDCCR_REM	0x00000080	/* REset interrupt Mask (disable)  */
+
+#define UDCAR_ADD	Fld (7, 0)	/* function ADDress                */
+
+#define UDCOMP_OUTMAXP	Fld (8, 0)	/* OUTput MAXimum Packet size - 1  */
+                	        	/* [byte]                          */
+#define UDCOMP_OutMaxPkt(Size)  	/* Output Maximum Packet size      */ \
+                	        	/* [1..256 byte]                   */ \
+                	(((Size) - 1) << FShft (UDCOMP_OUTMAXP))
+
+#define UDCIMP_INMAXP	Fld (8, 0)	/* INput MAXimum Packet size - 1   */
+                	        	/* [byte]                          */
+#define UDCIMP_InMaxPkt(Size)   	/* Input Maximum Packet size       */ \
+                	        	/* [1..256 byte]                   */ \
+                	(((Size) - 1) << FShft (UDCIMP_INMAXP))
+
+#define UDCCS0_OPR	0x00000001	/* Output Packet Ready (read)      */
+#define UDCCS0_IPR	0x00000002	/* Input Packet Ready              */
+#define UDCCS0_SST	0x00000004	/* Sent STall                      */
+#define UDCCS0_FST	0x00000008	/* Force STall                     */
+#define UDCCS0_DE	0x00000010	/* Data End                        */
+#define UDCCS0_SE	0x00000020	/* Setup End (read)                */
+#define UDCCS0_SO	0x00000040	/* Serviced Output packet ready    */
+                	        	/* (write)                         */
+#define UDCCS0_SSE	0x00000080	/* Serviced Setup End (write)      */
+
+#define UDCCS1_RFS	0x00000001	/* Receive FIFO 12-bytes or more   */
+                	        	/* Service request (read)          */
+#define UDCCS1_RPC	0x00000002	/* Receive Packet Complete         */
+#define UDCCS1_RPE	0x00000004	/* Receive Packet Error (read)     */
+#define UDCCS1_SST	0x00000008	/* Sent STall                      */
+#define UDCCS1_FST	0x00000010	/* Force STall                     */
+#define UDCCS1_RNE	0x00000020	/* Receive FIFO Not Empty (read)   */
+
+#define UDCCS2_TFS	0x00000001	/* Transmit FIFO 8-bytes or less   */
+                	        	/* Service request (read)          */
+#define UDCCS2_TPC	0x00000002	/* Transmit Packet Complete        */
+#define UDCCS2_TPE	0x00000004	/* Transmit Packet Error (read)    */
+#define UDCCS2_TUR	0x00000008	/* Transmit FIFO Under-Run         */
+#define UDCCS2_SST	0x00000010	/* Sent STall                      */
+#define UDCCS2_FST	0x00000020	/* Force STall                     */
+
+#define UDCD0_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
+
+#define UDCWC_WC	Fld (4, 0)	/* Write Count                     */
+
+#define UDCDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
+
+#define UDCSR_EIR	0x00000001	/* End-point 0 Interrupt Request   */
+#define UDCSR_RIR	0x00000002	/* Receive Interrupt Request       */
+#define UDCSR_TIR	0x00000004	/* Transmit Interrupt Request      */
+#define UDCSR_SUSIR	0x00000008	/* SUSpend Interrupt Request       */
+#define UDCSR_RESIR	0x00000010	/* RESume Interrupt Request        */
+#define UDCSR_RSTIR	0x00000020	/* ReSeT Interrupt Request         */
+
+
+/*
+ * Universal Asynchronous Receiver/Transmitter (UART) control registers
+ *
+ * Registers
+ *    Ser1UTCR0 	Serial port 1 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 0
+ *              	(read/write).
+ *    Ser1UTCR1 	Serial port 1 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 1
+ *              	(read/write).
+ *    Ser1UTCR2 	Serial port 1 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 2
+ *              	(read/write).
+ *    Ser1UTCR3 	Serial port 1 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 3
+ *              	(read/write).
+ *    Ser1UTDR  	Serial port 1 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Data Register
+ *              	(read/write).
+ *    Ser1UTSR0 	Serial port 1 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Status Register 0
+ *              	(read/write).
+ *    Ser1UTSR1 	Serial port 1 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Status Register 1 (read).
+ *
+ *    Ser2UTCR0 	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 0
+ *              	(read/write).
+ *    Ser2UTCR1 	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 1
+ *              	(read/write).
+ *    Ser2UTCR2 	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 2
+ *              	(read/write).
+ *    Ser2UTCR3 	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 3
+ *              	(read/write).
+ *    Ser2UTCR4 	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 4
+ *              	(read/write).
+ *    Ser2UTDR  	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Data Register
+ *              	(read/write).
+ *    Ser2UTSR0 	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Status Register 0
+ *              	(read/write).
+ *    Ser2UTSR1 	Serial port 2 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Status Register 1 (read).
+ *
+ *    Ser3UTCR0 	Serial port 3 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 0
+ *              	(read/write).
+ *    Ser3UTCR1 	Serial port 3 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 1
+ *              	(read/write).
+ *    Ser3UTCR2 	Serial port 3 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 2
+ *              	(read/write).
+ *    Ser3UTCR3 	Serial port 3 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Control Register 3
+ *              	(read/write).
+ *    Ser3UTDR  	Serial port 3 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Data Register
+ *              	(read/write).
+ *    Ser3UTSR0 	Serial port 3 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Status Register 0
+ *              	(read/write).
+ *    Ser3UTSR1 	Serial port 3 Universal Asynchronous
+ *              	Receiver/Transmitter (UART) Status Register 1 (read).
+ *
+ * Clocks
+ *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
+ *              	or 3.5795 MHz).
+ *    fua, Tua  	Frequency, period of the UART communication.
+ */
+
+#define _UTCR0(Nb)	__REG(0x80010000 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 0 [1..3] */
+#define _UTCR1(Nb)	__REG(0x80010004 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 1 [1..3] */
+#define _UTCR2(Nb)	__REG(0x80010008 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 2 [1..3] */
+#define _UTCR3(Nb)	__REG(0x8001000C + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 3 [1..3] */
+#define _UTCR4(Nb)	__REG(0x80010010 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 4 [2] */
+#define _UTDR(Nb)	__REG(0x80010014 + ((Nb) - 1)*0x00020000)  /* UART Data Reg. [1..3] */
+#define _UTSR0(Nb)	__REG(0x8001001C + ((Nb) - 1)*0x00020000)  /* UART Status Reg. 0 [1..3] */
+#define _UTSR1(Nb)	__REG(0x80010020 + ((Nb) - 1)*0x00020000)  /* UART Status Reg. 1 [1..3] */
+
+#define Ser1UTCR0	_UTCR0 (1)	/* Ser. port 1 UART Control Reg. 0 */
+#define Ser1UTCR1	_UTCR1 (1)	/* Ser. port 1 UART Control Reg. 1 */
+#define Ser1UTCR2	_UTCR2 (1)	/* Ser. port 1 UART Control Reg. 2 */
+#define Ser1UTCR3	_UTCR3 (1)	/* Ser. port 1 UART Control Reg. 3 */
+#define Ser1UTDR	_UTDR (1)	/* Ser. port 1 UART Data Reg.      */
+#define Ser1UTSR0	_UTSR0 (1)	/* Ser. port 1 UART Status Reg. 0  */
+#define Ser1UTSR1	_UTSR1 (1)	/* Ser. port 1 UART Status Reg. 1  */
+
+#define Ser2UTCR0	_UTCR0 (2)	/* Ser. port 2 UART Control Reg. 0 */
+#define Ser2UTCR1	_UTCR1 (2)	/* Ser. port 2 UART Control Reg. 1 */
+#define Ser2UTCR2	_UTCR2 (2)	/* Ser. port 2 UART Control Reg. 2 */
+#define Ser2UTCR3	_UTCR3 (2)	/* Ser. port 2 UART Control Reg. 3 */
+#define Ser2UTCR4	_UTCR4 (2)	/* Ser. port 2 UART Control Reg. 4 */
+#define Ser2UTDR	_UTDR (2)	/* Ser. port 2 UART Data Reg.      */
+#define Ser2UTSR0	_UTSR0 (2)	/* Ser. port 2 UART Status Reg. 0  */
+#define Ser2UTSR1	_UTSR1 (2)	/* Ser. port 2 UART Status Reg. 1  */
+
+#define Ser3UTCR0	_UTCR0 (3)	/* Ser. port 3 UART Control Reg. 0 */
+#define Ser3UTCR1	_UTCR1 (3)	/* Ser. port 3 UART Control Reg. 1 */
+#define Ser3UTCR2	_UTCR2 (3)	/* Ser. port 3 UART Control Reg. 2 */
+#define Ser3UTCR3	_UTCR3 (3)	/* Ser. port 3 UART Control Reg. 3 */
+#define Ser3UTDR	_UTDR (3)	/* Ser. port 3 UART Data Reg.      */
+#define Ser3UTSR0	_UTSR0 (3)	/* Ser. port 3 UART Status Reg. 0  */
+#define Ser3UTSR1	_UTSR1 (3)	/* Ser. port 3 UART Status Reg. 1  */
+
+/* Those are still used in some places */
+#define _Ser1UTCR0	__PREG(Ser1UTCR0)
+#define _Ser2UTCR0	__PREG(Ser2UTCR0)
+#define _Ser3UTCR0	__PREG(Ser3UTCR0)
+
+/* Register offsets */
+#define UTCR0		0x00
+#define UTCR1		0x04
+#define UTCR2		0x08
+#define UTCR3		0x0c
+#define UTDR		0x14
+#define UTSR0		0x1c
+#define UTSR1		0x20
+
+#define UTCR0_PE	0x00000001	/* Parity Enable                   */
+#define UTCR0_OES	0x00000002	/* Odd/Even parity Select          */
+#define UTCR0_OddPar	(UTCR0_OES*0)	/*  Odd Parity                     */
+#define UTCR0_EvenPar	(UTCR0_OES*1)	/*  Even Parity                    */
+#define UTCR0_SBS	0x00000004	/* Stop Bit Select                 */
+#define UTCR0_1StpBit	(UTCR0_SBS*0)	/*  1 Stop Bit per frame           */
+#define UTCR0_2StpBit	(UTCR0_SBS*1)	/*  2 Stop Bits per frame          */
+#define UTCR0_DSS	0x00000008	/* Data Size Select                */
+#define UTCR0_7BitData	(UTCR0_DSS*0)	/*  7-Bit Data                     */
+#define UTCR0_8BitData	(UTCR0_DSS*1)	/*  8-Bit Data                     */
+#define UTCR0_SCE	0x00000010	/* Sample Clock Enable             */
+                	        	/* (ser. port 1: GPIO [18],        */
+                	        	/* ser. port 3: GPIO [20])         */
+#define UTCR0_RCE	0x00000020	/* Receive Clock Edge select       */
+#define UTCR0_RcRsEdg	(UTCR0_RCE*0)	/*  Receive clock Rising-Edge      */
+#define UTCR0_RcFlEdg	(UTCR0_RCE*1)	/*  Receive clock Falling-Edge     */
+#define UTCR0_TCE	0x00000040	/* Transmit Clock Edge select      */
+#define UTCR0_TrRsEdg	(UTCR0_TCE*0)	/*  Transmit clock Rising-Edge     */
+#define UTCR0_TrFlEdg	(UTCR0_TCE*1)	/*  Transmit clock Falling-Edge    */
+#define UTCR0_Ser2IrDA	        	/* Ser. port 2 IrDA settings       */ \
+                	(UTCR0_1StpBit + UTCR0_8BitData)
+
+#define UTCR1_BRD	Fld (4, 0)	/* Baud Rate Divisor/16 - 1 [11:8] */
+#define UTCR2_BRD	Fld (8, 0)	/* Baud Rate Divisor/16 - 1  [7:0] */
+                	        	/* fua = fxtl/(16*(BRD[11:0] + 1)) */
+                	        	/* Tua = 16*(BRD [11:0] + 1)*Txtl  */
+#define UTCR1_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
+                	(((Div) - 16)/16 >> FSize (UTCR2_BRD) << \
+                	 FShft (UTCR1_BRD))
+#define UTCR2_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
+                	(((Div) - 16)/16 & FAlnMsk (UTCR2_BRD) << \
+                	 FShft (UTCR2_BRD))
+                	        	/*  fua = fxtl/(16*Floor (Div/16)) */
+                	        	/*  Tua = 16*Floor (Div/16)*Txtl   */
+#define UTCR1_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
+                	(((Div) - 1)/16 >> FSize (UTCR2_BRD) << \
+                	 FShft (UTCR1_BRD))
+#define UTCR2_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
+                	(((Div) - 1)/16 & FAlnMsk (UTCR2_BRD) << \
+                	 FShft (UTCR2_BRD))
+                	        	/*  fua = fxtl/(16*Ceil (Div/16))  */
+                	        	/*  Tua = 16*Ceil (Div/16)*Txtl    */
+
+#define UTCR3_RXE	0x00000001	/* Receive Enable                  */
+#define UTCR3_TXE	0x00000002	/* Transmit Enable                 */
+#define UTCR3_BRK	0x00000004	/* BReaK mode                      */
+#define UTCR3_RIE	0x00000008	/* Receive FIFO 1/3-to-2/3-full or */
+                	        	/* more Interrupt Enable           */
+#define UTCR3_TIE	0x00000010	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Interrupt Enable                */
+#define UTCR3_LBM	0x00000020	/* Look-Back Mode                  */
+#define UTCR3_Ser2IrDA	        	/* Ser. port 2 IrDA settings (RIE, */ \
+                	        	/* TIE, LBM can be set or cleared) */ \
+                	(UTCR3_RXE + UTCR3_TXE)
+
+#define UTCR4_HSE	0x00000001	/* Hewlett-Packard Serial InfraRed */
+                	        	/* (HP-SIR) modulation Enable      */
+#define UTCR4_NRZ	(UTCR4_HSE*0)	/*  Non-Return to Zero modulation  */
+#define UTCR4_HPSIR	(UTCR4_HSE*1)	/*  HP-SIR modulation              */
+#define UTCR4_LPM	0x00000002	/* Low-Power Mode                  */
+#define UTCR4_Z3_16Bit	(UTCR4_LPM*0)	/*  Zero pulse = 3/16 Bit time     */
+#define UTCR4_Z1_6us	(UTCR4_LPM*1)	/*  Zero pulse = 1.6 us            */
+
+#define UTDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
+#if 0           	        	/* Hidden receive FIFO bits        */
+#define UTDR_PRE	0x00000100	/*  receive PaRity Error (read)    */
+#define UTDR_FRE	0x00000200	/*  receive FRaming Error (read)   */
+#define UTDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
+#endif /* 0 */
+
+#define UTSR0_TFS	0x00000001	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Service request (read)          */
+#define UTSR0_RFS	0x00000002	/* Receive FIFO 1/3-to-2/3-full or */
+                	        	/* more Service request (read)     */
+#define UTSR0_RID	0x00000004	/* Receiver IDle                   */
+#define UTSR0_RBB	0x00000008	/* Receive Beginning of Break      */
+#define UTSR0_REB	0x00000010	/* Receive End of Break            */
+#define UTSR0_EIF	0x00000020	/* Error In FIFO (read)            */
+
+#define UTSR1_TBY	0x00000001	/* Transmitter BusY (read)         */
+#define UTSR1_RNE	0x00000002	/* Receive FIFO Not Empty (read)   */
+#define UTSR1_TNF	0x00000004	/* Transmit FIFO Not Full (read)   */
+#define UTSR1_PRE	0x00000008	/* receive PaRity Error (read)     */
+#define UTSR1_FRE	0x00000010	/* receive FRaming Error (read)    */
+#define UTSR1_ROR	0x00000020	/* Receive FIFO Over-Run (read)    */
+
+
+/*
+ * Synchronous Data Link Controller (SDLC) control registers
+ *
+ * Registers
+ *    Ser1SDCR0 	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Control Register 0 (read/write).
+ *    Ser1SDCR1 	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Control Register 1 (read/write).
+ *    Ser1SDCR2 	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Control Register 2 (read/write).
+ *    Ser1SDCR3 	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Control Register 3 (read/write).
+ *    Ser1SDCR4 	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Control Register 4 (read/write).
+ *    Ser1SDDR  	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Data Register (read/write).
+ *    Ser1SDSR0 	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Status Register 0 (read/write).
+ *    Ser1SDSR1 	Serial port 1 Synchronous Data Link Controller (SDLC)
+ *              	Status Register 1 (read/write).
+ *
+ * Clocks
+ *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
+ *              	or 3.5795 MHz).
+ *    fsd, Tsd  	Frequency, period of the SDLC communication.
+ */
+
+#define Ser1SDCR0	__REG(0x80020060)  /* Ser. port 1 SDLC Control Reg. 0 */
+#define Ser1SDCR1	__REG(0x80020064)  /* Ser. port 1 SDLC Control Reg. 1 */
+#define Ser1SDCR2	__REG(0x80020068)  /* Ser. port 1 SDLC Control Reg. 2 */
+#define Ser1SDCR3	__REG(0x8002006C)  /* Ser. port 1 SDLC Control Reg. 3 */
+#define Ser1SDCR4	__REG(0x80020070)  /* Ser. port 1 SDLC Control Reg. 4 */
+#define Ser1SDDR	__REG(0x80020078)  /* Ser. port 1 SDLC Data Reg.      */
+#define Ser1SDSR0	__REG(0x80020080)  /* Ser. port 1 SDLC Status Reg. 0  */
+#define Ser1SDSR1	__REG(0x80020084)  /* Ser. port 1 SDLC Status Reg. 1  */
+
+#define SDCR0_SUS	0x00000001	/* SDLC/UART Select                */
+#define SDCR0_SDLC	(SDCR0_SUS*0)	/*  SDLC mode (TXD1 & RXD1)        */
+#define SDCR0_UART	(SDCR0_SUS*1)	/*  UART mode (TXD1 & RXD1)        */
+#define SDCR0_SDF	0x00000002	/* Single/Double start Flag select */
+#define SDCR0_SglFlg	(SDCR0_SDF*0)	/*  Single start Flag              */
+#define SDCR0_DblFlg	(SDCR0_SDF*1)	/*  Double start Flag              */
+#define SDCR0_LBM	0x00000004	/* Look-Back Mode                  */
+#define SDCR0_BMS	0x00000008	/* Bit Modulation Select           */
+#define SDCR0_FM0	(SDCR0_BMS*0)	/*  Freq. Modulation zero (0)      */
+#define SDCR0_NRZ	(SDCR0_BMS*1)	/*  Non-Return to Zero modulation  */
+#define SDCR0_SCE	0x00000010	/* Sample Clock Enable (GPIO [16]) */
+#define SDCR0_SCD	0x00000020	/* Sample Clock Direction select   */
+                	        	/* (GPIO [16])                     */
+#define SDCR0_SClkIn	(SDCR0_SCD*0)	/*  Sample Clock Input             */
+#define SDCR0_SClkOut	(SDCR0_SCD*1)	/*  Sample Clock Output            */
+#define SDCR0_RCE	0x00000040	/* Receive Clock Edge select       */
+#define SDCR0_RcRsEdg	(SDCR0_RCE*0)	/*  Receive clock Rising-Edge      */
+#define SDCR0_RcFlEdg	(SDCR0_RCE*1)	/*  Receive clock Falling-Edge     */
+#define SDCR0_TCE	0x00000080	/* Transmit Clock Edge select      */
+#define SDCR0_TrRsEdg	(SDCR0_TCE*0)	/*  Transmit clock Rising-Edge     */
+#define SDCR0_TrFlEdg	(SDCR0_TCE*1)	/*  Transmit clock Falling-Edge    */
+
+#define SDCR1_AAF	0x00000001	/* Abort After Frame enable        */
+                	        	/* (GPIO [17])                     */
+#define SDCR1_TXE	0x00000002	/* Transmit Enable                 */
+#define SDCR1_RXE	0x00000004	/* Receive Enable                  */
+#define SDCR1_RIE	0x00000008	/* Receive FIFO 1/3-to-2/3-full or */
+                	        	/* more Interrupt Enable           */
+#define SDCR1_TIE	0x00000010	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Interrupt Enable                */
+#define SDCR1_AME	0x00000020	/* Address Match Enable            */
+#define SDCR1_TUS	0x00000040	/* Transmit FIFO Under-run Select  */
+#define SDCR1_EFrmURn	(SDCR1_TUS*0)	/*  End Frame on Under-Run         */
+#define SDCR1_AbortURn	(SDCR1_TUS*1)	/*  Abort on Under-Run             */
+#define SDCR1_RAE	0x00000080	/* Receive Abort interrupt Enable  */
+
+#define SDCR2_AMV	Fld (8, 0)	/* Address Match Value             */
+
+#define SDCR3_BRD	Fld (4, 0)	/* Baud Rate Divisor/16 - 1 [11:8] */
+#define SDCR4_BRD	Fld (8, 0)	/* Baud Rate Divisor/16 - 1  [7:0] */
+                	        	/* fsd = fxtl/(16*(BRD[11:0] + 1)) */
+                	        	/* Tsd = 16*(BRD[11:0] + 1)*Txtl   */
+#define SDCR3_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
+                	(((Div) - 16)/16 >> FSize (SDCR4_BRD) << \
+                	 FShft (SDCR3_BRD))
+#define SDCR4_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
+                	(((Div) - 16)/16 & FAlnMsk (SDCR4_BRD) << \
+                	 FShft (SDCR4_BRD))
+                	        	/*  fsd = fxtl/(16*Floor (Div/16)) */
+                	        	/*  Tsd = 16*Floor (Div/16)*Txtl   */
+#define SDCR3_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
+                	(((Div) - 1)/16 >> FSize (SDCR4_BRD) << \
+                	 FShft (SDCR3_BRD))
+#define SDCR4_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
+                	(((Div) - 1)/16 & FAlnMsk (SDCR4_BRD) << \
+                	 FShft (SDCR4_BRD))
+                	        	/*  fsd = fxtl/(16*Ceil (Div/16))  */
+                	        	/*  Tsd = 16*Ceil (Div/16)*Txtl    */
+
+#define SDDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
+#if 0           	        	/* Hidden receive FIFO bits        */
+#define SDDR_EOF	0x00000100	/*  receive End-Of-Frame (read)    */
+#define SDDR_CRE	0x00000200	/*  receive CRC Error (read)       */
+#define SDDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
+#endif /* 0 */
+
+#define SDSR0_EIF	0x00000001	/* Error In FIFO (read)            */
+#define SDSR0_TUR	0x00000002	/* Transmit FIFO Under-Run         */
+#define SDSR0_RAB	0x00000004	/* Receive ABort                   */
+#define SDSR0_TFS	0x00000008	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Service request (read)          */
+#define SDSR0_RFS	0x00000010	/* Receive FIFO 1/3-to-2/3-full or */
+                	        	/* more Service request (read)     */
+
+#define SDSR1_RSY	0x00000001	/* Receiver SYnchronized (read)    */
+#define SDSR1_TBY	0x00000002	/* Transmitter BusY (read)         */
+#define SDSR1_RNE	0x00000004	/* Receive FIFO Not Empty (read)   */
+#define SDSR1_TNF	0x00000008	/* Transmit FIFO Not Full (read)   */
+#define SDSR1_RTD	0x00000010	/* Receive Transition Detected     */
+#define SDSR1_EOF	0x00000020	/* receive End-Of-Frame (read)     */
+#define SDSR1_CRE	0x00000040	/* receive CRC Error (read)        */
+#define SDSR1_ROR	0x00000080	/* Receive FIFO Over-Run (read)    */
+
+
+/*
+ * High-Speed Serial to Parallel controller (HSSP) control registers
+ *
+ * Registers
+ *    Ser2HSCR0 	Serial port 2 High-Speed Serial to Parallel
+ *              	controller (HSSP) Control Register 0 (read/write).
+ *    Ser2HSCR1 	Serial port 2 High-Speed Serial to Parallel
+ *              	controller (HSSP) Control Register 1 (read/write).
+ *    Ser2HSDR  	Serial port 2 High-Speed Serial to Parallel
+ *              	controller (HSSP) Data Register (read/write).
+ *    Ser2HSSR0 	Serial port 2 High-Speed Serial to Parallel
+ *              	controller (HSSP) Status Register 0 (read/write).
+ *    Ser2HSSR1 	Serial port 2 High-Speed Serial to Parallel
+ *              	controller (HSSP) Status Register 1 (read).
+ *    Ser2HSCR2 	Serial port 2 High-Speed Serial to Parallel
+ *              	controller (HSSP) Control Register 2 (read/write).
+ *              	[The HSCR2 register is only implemented in
+ *              	versions 2.0 (rev. = 8) and higher of the StrongARM
+ *              	SA-1100.]
+ */
+
+#define Ser2HSCR0	__REG(0x80040060)  /* Ser. port 2 HSSP Control Reg. 0 */
+#define Ser2HSCR1	__REG(0x80040064)  /* Ser. port 2 HSSP Control Reg. 1 */
+#define Ser2HSDR	__REG(0x8004006C)  /* Ser. port 2 HSSP Data Reg.      */
+#define Ser2HSSR0	__REG(0x80040074)  /* Ser. port 2 HSSP Status Reg. 0  */
+#define Ser2HSSR1	__REG(0x80040078)  /* Ser. port 2 HSSP Status Reg. 1  */
+#define Ser2HSCR2	__REG(0x90060028)  /* Ser. port 2 HSSP Control Reg. 2 */
+
+#define HSCR0_ITR	0x00000001	/* IrDA Transmission Rate          */
+#define HSCR0_UART	(HSCR0_ITR*0)	/*  UART mode (115.2 kb/s if IrDA) */
+#define HSCR0_HSSP	(HSCR0_ITR*1)	/*  HSSP mode (4 Mb/s)             */
+#define HSCR0_LBM	0x00000002	/* Look-Back Mode                  */
+#define HSCR0_TUS	0x00000004	/* Transmit FIFO Under-run Select  */
+#define HSCR0_EFrmURn	(HSCR0_TUS*0)	/*  End Frame on Under-Run         */
+#define HSCR0_AbortURn	(HSCR0_TUS*1)	/*  Abort on Under-Run             */
+#define HSCR0_TXE	0x00000008	/* Transmit Enable                 */
+#define HSCR0_RXE	0x00000010	/* Receive Enable                  */
+#define HSCR0_RIE	0x00000020	/* Receive FIFO 2/5-to-3/5-full or */
+                	        	/* more Interrupt Enable           */
+#define HSCR0_TIE	0x00000040	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Interrupt Enable                */
+#define HSCR0_AME	0x00000080	/* Address Match Enable            */
+
+#define HSCR1_AMV	Fld (8, 0)	/* Address Match Value             */
+
+#define HSDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
+#if 0           	        	/* Hidden receive FIFO bits        */
+#define HSDR_EOF	0x00000100	/*  receive End-Of-Frame (read)    */
+#define HSDR_CRE	0x00000200	/*  receive CRC Error (read)       */
+#define HSDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
+#endif /* 0 */
+
+#define HSSR0_EIF	0x00000001	/* Error In FIFO (read)            */
+#define HSSR0_TUR	0x00000002	/* Transmit FIFO Under-Run         */
+#define HSSR0_RAB	0x00000004	/* Receive ABort                   */
+#define HSSR0_TFS	0x00000008	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Service request (read)          */
+#define HSSR0_RFS	0x00000010	/* Receive FIFO 2/5-to-3/5-full or */
+                	        	/* more Service request (read)     */
+#define HSSR0_FRE	0x00000020	/* receive FRaming Error           */
+
+#define HSSR1_RSY	0x00000001	/* Receiver SYnchronized (read)    */
+#define HSSR1_TBY	0x00000002	/* Transmitter BusY (read)         */
+#define HSSR1_RNE	0x00000004	/* Receive FIFO Not Empty (read)   */
+#define HSSR1_TNF	0x00000008	/* Transmit FIFO Not Full (read)   */
+#define HSSR1_EOF	0x00000010	/* receive End-Of-Frame (read)     */
+#define HSSR1_CRE	0x00000020	/* receive CRC Error (read)        */
+#define HSSR1_ROR	0x00000040	/* Receive FIFO Over-Run (read)    */
+
+#define HSCR2_TXP	0x00040000	/* Transmit data Polarity (TXD_2)  */
+#define HSCR2_TrDataL	(HSCR2_TXP*0)	/*  Transmit Data active Low       */
+                	        	/*  (inverted)                     */
+#define HSCR2_TrDataH	(HSCR2_TXP*1)	/*  Transmit Data active High      */
+                	        	/*  (non-inverted)                 */
+#define HSCR2_RXP	0x00080000	/* Receive data Polarity (RXD_2)   */
+#define HSCR2_RcDataL	(HSCR2_RXP*0)	/*  Receive Data active Low        */
+                	        	/*  (inverted)                     */
+#define HSCR2_RcDataH	(HSCR2_RXP*1)	/*  Receive Data active High       */
+                	        	/*  (non-inverted)                 */
+
+
+/*
+ * Multi-media Communications Port (MCP) control registers
+ *
+ * Registers
+ *    Ser4MCCR0 	Serial port 4 Multi-media Communications Port (MCP)
+ *              	Control Register 0 (read/write).
+ *    Ser4MCDR0 	Serial port 4 Multi-media Communications Port (MCP)
+ *              	Data Register 0 (audio, read/write).
+ *    Ser4MCDR1 	Serial port 4 Multi-media Communications Port (MCP)
+ *              	Data Register 1 (telecom, read/write).
+ *    Ser4MCDR2 	Serial port 4 Multi-media Communications Port (MCP)
+ *              	Data Register 2 (CODEC registers, read/write).
+ *    Ser4MCSR  	Serial port 4 Multi-media Communications Port (MCP)
+ *              	Status Register (read/write).
+ *    Ser4MCCR1 	Serial port 4 Multi-media Communications Port (MCP)
+ *              	Control Register 1 (read/write).
+ *              	[The MCCR1 register is only implemented in
+ *              	versions 2.0 (rev. = 8) and higher of the StrongARM
+ *              	SA-1100.]
+ *
+ * Clocks
+ *    fmc, Tmc  	Frequency, period of the MCP communication (10 MHz,
+ *              	12 MHz, or GPIO [21]).
+ *    faud, Taud	Frequency, period of the audio sampling.
+ *    ftcm, Ttcm	Frequency, period of the telecom sampling.
+ */
+
+#define Ser4MCCR0	__REG(0x80060000)  /* Ser. port 4 MCP Control Reg. 0 */
+#define Ser4MCDR0	__REG(0x80060008)  /* Ser. port 4 MCP Data Reg. 0 (audio) */
+#define Ser4MCDR1	__REG(0x8006000C)  /* Ser. port 4 MCP Data Reg. 1 (telecom) */
+#define Ser4MCDR2	__REG(0x80060010)  /* Ser. port 4 MCP Data Reg. 2 (CODEC reg.) */
+#define Ser4MCSR	__REG(0x80060018)  /* Ser. port 4 MCP Status Reg. */
+#define Ser4MCCR1	__REG(0x90060030)  /* Ser. port 4 MCP Control Reg. 1 */
+
+#define MCCR0_ASD	Fld (7, 0)	/* Audio Sampling rate Divisor/32  */
+                	        	/* [6..127]                        */
+                	        	/* faud = fmc/(32*ASD)             */
+                	        	/* Taud = 32*ASD*Tmc               */
+#define MCCR0_AudSmpDiv(Div)    	/*  Audio Sampling rate Divisor    */ \
+                	        	/*  [192..4064]                    */ \
+                	((Div)/32 << FShft (MCCR0_ASD))
+                	        	/*  faud = fmc/(32*Floor (Div/32)) */
+                	        	/*  Taud = 32*Floor (Div/32)*Tmc   */
+#define MCCR0_CeilAudSmpDiv(Div)	/*  Ceil. of AudSmpDiv [192..4064] */ \
+                	(((Div) + 31)/32 << FShft (MCCR0_ASD))
+                	        	/*  faud = fmc/(32*Ceil (Div/32))  */
+                	        	/*  Taud = 32*Ceil (Div/32)*Tmc    */
+#define MCCR0_TSD	Fld (7, 8)	/* Telecom Sampling rate           */
+                	        	/* Divisor/32 [16..127]            */
+                	        	/* ftcm = fmc/(32*TSD)             */
+                	        	/* Ttcm = 32*TSD*Tmc               */
+#define MCCR0_TcmSmpDiv(Div)    	/*  Telecom Sampling rate Divisor  */ \
+                	        	/*  [512..4064]                    */ \
+                	((Div)/32 << FShft (MCCR0_TSD))
+                	        	/*  ftcm = fmc/(32*Floor (Div/32)) */
+                	        	/*  Ttcm = 32*Floor (Div/32)*Tmc   */
+#define MCCR0_CeilTcmSmpDiv(Div)	/*  Ceil. of TcmSmpDiv [512..4064] */ \
+                	(((Div) + 31)/32 << FShft (MCCR0_TSD))
+                	        	/*  ftcm = fmc/(32*Ceil (Div/32))  */
+                	        	/*  Ttcm = 32*Ceil (Div/32)*Tmc    */
+#define MCCR0_MCE	0x00010000	/* MCP Enable                      */
+#define MCCR0_ECS	0x00020000	/* External Clock Select           */
+#define MCCR0_IntClk	(MCCR0_ECS*0)	/*  Internal Clock (10 or 12 MHz)  */
+#define MCCR0_ExtClk	(MCCR0_ECS*1)	/*  External Clock (GPIO [21])     */
+#define MCCR0_ADM	0x00040000	/* A/D (audio/telecom) data        */
+                	        	/* sampling/storing Mode           */
+#define MCCR0_VldBit	(MCCR0_ADM*0)	/*  Valid Bit storing mode         */
+#define MCCR0_SmpCnt	(MCCR0_ADM*1)	/*  Sampling Counter storing mode  */
+#define MCCR0_TTE	0x00080000	/* Telecom Transmit FIFO 1/2-full  */
+                	        	/* or less interrupt Enable        */
+#define MCCR0_TRE	0x00100000	/* Telecom Receive FIFO 1/2-full   */
+                	        	/* or more interrupt Enable        */
+#define MCCR0_ATE	0x00200000	/* Audio Transmit FIFO 1/2-full    */
+                	        	/* or less interrupt Enable        */
+#define MCCR0_ARE	0x00400000	/* Audio Receive FIFO 1/2-full or  */
+                	        	/* more interrupt Enable           */
+#define MCCR0_LBM	0x00800000	/* Look-Back Mode                  */
+#define MCCR0_ECP	Fld (2, 24)	/* External Clock Prescaler - 1    */
+#define MCCR0_ExtClkDiv(Div)    	/*  External Clock Divisor [1..4]  */ \
+                	(((Div) - 1) << FShft (MCCR0_ECP))
+
+#define MCDR0_DATA	Fld (12, 4)	/* receive/transmit audio DATA     */
+                	        	/* FIFOs                           */
+
+#define MCDR1_DATA	Fld (14, 2)	/* receive/transmit telecom DATA   */
+                	        	/* FIFOs                           */
+
+                	        	/* receive/transmit CODEC reg.     */
+                	        	/* FIFOs:                          */
+#define MCDR2_DATA	Fld (16, 0)	/*  reg. DATA                      */
+#define MCDR2_RW	0x00010000	/*  reg. Read/Write (transmit)     */
+#define MCDR2_Rd	(MCDR2_RW*0)	/*   reg. Read                     */
+#define MCDR2_Wr	(MCDR2_RW*1)	/*   reg. Write                    */
+#define MCDR2_ADD	Fld (4, 17)	/*  reg. ADDress                   */
+
+#define MCSR_ATS	0x00000001	/* Audio Transmit FIFO 1/2-full    */
+                	        	/* or less Service request (read)  */
+#define MCSR_ARS	0x00000002	/* Audio Receive FIFO 1/2-full or  */
+                	        	/* more Service request (read)     */
+#define MCSR_TTS	0x00000004	/* Telecom Transmit FIFO 1/2-full  */
+                	        	/* or less Service request (read)  */
+#define MCSR_TRS	0x00000008	/* Telecom Receive FIFO 1/2-full   */
+                	        	/* or more Service request (read)  */
+#define MCSR_ATU	0x00000010	/* Audio Transmit FIFO Under-run   */
+#define MCSR_ARO	0x00000020	/* Audio Receive FIFO Over-run     */
+#define MCSR_TTU	0x00000040	/* Telecom Transmit FIFO Under-run */
+#define MCSR_TRO	0x00000080	/* Telecom Receive FIFO Over-run   */
+#define MCSR_ANF	0x00000100	/* Audio transmit FIFO Not Full    */
+                	        	/* (read)                          */
+#define MCSR_ANE	0x00000200	/* Audio receive FIFO Not Empty    */
+                	        	/* (read)                          */
+#define MCSR_TNF	0x00000400	/* Telecom transmit FIFO Not Full  */
+                	        	/* (read)                          */
+#define MCSR_TNE	0x00000800	/* Telecom receive FIFO Not Empty  */
+                	        	/* (read)                          */
+#define MCSR_CWC	0x00001000	/* CODEC register Write Completed  */
+                	        	/* (read)                          */
+#define MCSR_CRC	0x00002000	/* CODEC register Read Completed   */
+                	        	/* (read)                          */
+#define MCSR_ACE	0x00004000	/* Audio CODEC Enabled (read)      */
+#define MCSR_TCE	0x00008000	/* Telecom CODEC Enabled (read)    */
+
+#define MCCR1_CFS	0x00100000	/* Clock Freq. Select              */
+#define MCCR1_F12MHz	(MCCR1_CFS*0)	/*  Freq. (fmc) = ~ 12 MHz         */
+                	        	/*  (11.981 MHz)                   */
+#define MCCR1_F10MHz	(MCCR1_CFS*1)	/*  Freq. (fmc) = ~ 10 MHz         */
+                	        	/*  (9.585 MHz)                    */
+
+
+/*
+ * Synchronous Serial Port (SSP) control registers
+ *
+ * Registers
+ *    Ser4SSCR0 	Serial port 4 Synchronous Serial Port (SSP) Control
+ *              	Register 0 (read/write).
+ *    Ser4SSCR1 	Serial port 4 Synchronous Serial Port (SSP) Control
+ *              	Register 1 (read/write).
+ *              	[Bits SPO and SP are only implemented in versions 2.0
+ *              	(rev. = 8) and higher of the StrongARM SA-1100.]
+ *    Ser4SSDR  	Serial port 4 Synchronous Serial Port (SSP) Data
+ *              	Register (read/write).
+ *    Ser4SSSR  	Serial port 4 Synchronous Serial Port (SSP) Status
+ *              	Register (read/write).
+ *
+ * Clocks
+ *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
+ *              	or 3.5795 MHz).
+ *    fss, Tss  	Frequency, period of the SSP communication.
+ */
+
+#define Ser4SSCR0	__REG(0x80070060)  /* Ser. port 4 SSP Control Reg. 0 */
+#define Ser4SSCR1	__REG(0x80070064)  /* Ser. port 4 SSP Control Reg. 1 */
+#define Ser4SSDR	__REG(0x8007006C)  /* Ser. port 4 SSP Data Reg. */
+#define Ser4SSSR	__REG(0x80070074)  /* Ser. port 4 SSP Status Reg. */
+
+#define SSCR0_DSS	Fld (4, 0)	/* Data Size - 1 Select [3..15]    */
+#define SSCR0_DataSize(Size)    	/*  Data Size Select [4..16]       */ \
+                	(((Size) - 1) << FShft (SSCR0_DSS))
+#define SSCR0_FRF	Fld (2, 4)	/* FRame Format                    */
+#define SSCR0_Motorola	        	/*  Motorola Serial Peripheral     */ \
+                	        	/*  Interface (SPI) format         */ \
+                	(0 << FShft (SSCR0_FRF))
+#define SSCR0_TI	        	/*  Texas Instruments Synchronous  */ \
+                	        	/*  Serial format                  */ \
+                	(1 << FShft (SSCR0_FRF))
+#define SSCR0_National	        	/*  National Microwire format      */ \
+                	(2 << FShft (SSCR0_FRF))
+#define SSCR0_SSE	0x00000080	/* SSP Enable                      */
+#define SSCR0_SCR	Fld (8, 8)	/* Serial Clock Rate divisor/2 - 1 */
+                	        	/* fss = fxtl/(2*(SCR + 1))        */
+                	        	/* Tss = 2*(SCR + 1)*Txtl          */
+#define SSCR0_SerClkDiv(Div)    	/*  Serial Clock Divisor [2..512]  */ \
+                	(((Div) - 2)/2 << FShft (SSCR0_SCR))
+                	        	/*  fss = fxtl/(2*Floor (Div/2))   */
+                	        	/*  Tss = 2*Floor (Div/2)*Txtl     */
+#define SSCR0_CeilSerClkDiv(Div)	/*  Ceil. of SerClkDiv [2..512]    */ \
+                	(((Div) - 1)/2 << FShft (SSCR0_SCR))
+                	        	/*  fss = fxtl/(2*Ceil (Div/2))    */
+                	        	/*  Tss = 2*Ceil (Div/2)*Txtl      */
+
+#define SSCR1_RIE	0x00000001	/* Receive FIFO 1/2-full or more   */
+                	        	/* Interrupt Enable                */
+#define SSCR1_TIE	0x00000002	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Interrupt Enable                */
+#define SSCR1_LBM	0x00000004	/* Look-Back Mode                  */
+#define SSCR1_SPO	0x00000008	/* Sample clock (SCLK) POlarity    */
+#define SSCR1_SClkIactL	(SSCR1_SPO*0)	/*  Sample Clock Inactive Low      */
+#define SSCR1_SClkIactH	(SSCR1_SPO*1)	/*  Sample Clock Inactive High     */
+#define SSCR1_SP	0x00000010	/* Sample clock (SCLK) Phase       */
+#define SSCR1_SClk1P	(SSCR1_SP*0)	/*  Sample Clock active 1 Period   */
+                	        	/*  after frame (SFRM, 1st edge)   */
+#define SSCR1_SClk1_2P	(SSCR1_SP*1)	/*  Sample Clock active 1/2 Period */
+                	        	/*  after frame (SFRM, 1st edge)   */
+#define SSCR1_ECS	0x00000020	/* External Clock Select           */
+#define SSCR1_IntClk	(SSCR1_ECS*0)	/*  Internal Clock                 */
+#define SSCR1_ExtClk	(SSCR1_ECS*1)	/*  External Clock (GPIO [19])     */
+
+#define SSDR_DATA	Fld (16, 0)	/* receive/transmit DATA FIFOs     */
+
+#define SSSR_TNF	0x00000002	/* Transmit FIFO Not Full (read)   */
+#define SSSR_RNE	0x00000004	/* Receive FIFO Not Empty (read)   */
+#define SSSR_BSY	0x00000008	/* SSP BuSY (read)                 */
+#define SSSR_TFS	0x00000010	/* Transmit FIFO 1/2-full or less  */
+                	        	/* Service request (read)          */
+#define SSSR_RFS	0x00000020	/* Receive FIFO 1/2-full or more   */
+                	        	/* Service request (read)          */
+#define SSSR_ROR	0x00000040	/* Receive FIFO Over-Run           */
+
+
+/*
+ * Operating System (OS) timer control registers
+ *
+ * Registers
+ *    OSMR0     	Operating System (OS) timer Match Register 0
+ *              	(read/write).
+ *    OSMR1     	Operating System (OS) timer Match Register 1
+ *              	(read/write).
+ *    OSMR2     	Operating System (OS) timer Match Register 2
+ *              	(read/write).
+ *    OSMR3     	Operating System (OS) timer Match Register 3
+ *              	(read/write).
+ *    OSCR      	Operating System (OS) timer Counter Register
+ *              	(read/write).
+ *    OSSR      	Operating System (OS) timer Status Register
+ *              	(read/write).
+ *    OWER      	Operating System (OS) timer Watch-dog Enable Register
+ *              	(read/write).
+ *    OIER      	Operating System (OS) timer Interrupt Enable Register
+ *              	(read/write).
+ */
+
+#define OSMR0  		__REG(0x90000000)  /* OS timer Match Reg. 0 */
+#define OSMR1  		__REG(0x90000004)  /* OS timer Match Reg. 1 */
+#define OSMR2  		__REG(0x90000008)  /* OS timer Match Reg. 2 */
+#define OSMR3  		__REG(0x9000000c)  /* OS timer Match Reg. 3 */
+#define OSCR   	__REG(0x90000010)  /* OS timer Counter Reg. */
+#define OSSR   	__REG(0x90000014	)  /* OS timer Status Reg. */
+#define OWER   	__REG(0x90000018	)  /* OS timer Watch-dog Enable Reg. */
+#define OIER   	__REG(0x9000001C	)  /* OS timer Interrupt Enable Reg. */
+
+#define OSSR_M(Nb)	        	/* Match detected [0..3]           */ \
+                	(0x00000001 << (Nb))
+#define OSSR_M0 	OSSR_M (0)	/* Match detected 0                */
+#define OSSR_M1 	OSSR_M (1)	/* Match detected 1                */
+#define OSSR_M2 	OSSR_M (2)	/* Match detected 2                */
+#define OSSR_M3 	OSSR_M (3)	/* Match detected 3                */
+
+#define OWER_WME	0x00000001	/* Watch-dog Match Enable          */
+                	        	/* (set only)                      */
+
+#define OIER_E(Nb)	        	/* match interrupt Enable [0..3]   */ \
+                	(0x00000001 << (Nb))
+#define OIER_E0 	OIER_E (0)	/* match interrupt Enable 0        */
+#define OIER_E1 	OIER_E (1)	/* match interrupt Enable 1        */
+#define OIER_E2 	OIER_E (2)	/* match interrupt Enable 2        */
+#define OIER_E3 	OIER_E (3)	/* match interrupt Enable 3        */
+
+
+/*
+ * Real-Time Clock (RTC) control registers
+ *
+ * Registers
+ *    RTAR      	Real-Time Clock (RTC) Alarm Register (read/write).
+ *    RCNR      	Real-Time Clock (RTC) CouNt Register (read/write).
+ *    RTTR      	Real-Time Clock (RTC) Trim Register (read/write).
+ *    RTSR      	Real-Time Clock (RTC) Status Register (read/write).
+ *
+ * Clocks
+ *    frtx, Trtx	Frequency, period of the real-time clock crystal
+ *              	(32.768 kHz nominal).
+ *    frtc, Trtc	Frequency, period of the real-time clock counter
+ *              	(1 Hz nominal).
+ */
+
+#define RTAR		__REG(0x90010000)  /* RTC Alarm Reg. */
+#define RCNR		__REG(0x90010004)  /* RTC CouNt Reg. */
+#define RTTR		__REG(0x90010008)  /* RTC Trim Reg. */
+#define RTSR		__REG(0x90010010)  /* RTC Status Reg. */
+
+#define RTTR_C  	Fld (16, 0)	/* clock divider Count - 1         */
+#define RTTR_D  	Fld (10, 16)	/* trim Delete count               */
+                	        	/* frtc = (1023*(C + 1) - D)*frtx/ */
+                	        	/*        (1023*(C + 1)^2)         */
+                	        	/* Trtc = (1023*(C + 1)^2)*Trtx/   */
+                	        	/*        (1023*(C + 1) - D)       */
+
+#define RTSR_AL 	0x00000001	/* ALarm detected                  */
+#define RTSR_HZ 	0x00000002	/* 1 Hz clock detected             */
+#define RTSR_ALE	0x00000004	/* ALarm interrupt Enable          */
+#define RTSR_HZE	0x00000008	/* 1 Hz clock interrupt Enable     */
+
+
+/*
+ * Power Manager (PM) control registers
+ *
+ * Registers
+ *    PMCR      	Power Manager (PM) Control Register (read/write).
+ *    PSSR      	Power Manager (PM) Sleep Status Register (read/write).
+ *    PSPR      	Power Manager (PM) Scratch-Pad Register (read/write).
+ *    PWER      	Power Manager (PM) Wake-up Enable Register
+ *              	(read/write).
+ *    PCFR      	Power Manager (PM) general ConFiguration Register
+ *              	(read/write).
+ *    PPCR      	Power Manager (PM) Phase-Locked Loop (PLL)
+ *              	Configuration Register (read/write).
+ *    PGSR      	Power Manager (PM) General-Purpose Input/Output (GPIO)
+ *              	Sleep state Register (read/write, see GPIO pins).
+ *    POSR      	Power Manager (PM) Oscillator Status Register (read).
+ *
+ * Clocks
+ *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
+ *              	or 3.5795 MHz).
+ *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
+ */
+
+#define PMCR		__REG(0x90020000)  /* PM Control Reg. */
+#define PSSR		__REG(0x90020004)  /* PM Sleep Status Reg. */
+#define PSPR		__REG(0x90020008)  /* PM Scratch-Pad Reg. */
+#define PWER		__REG(0x9002000C)  /* PM Wake-up Enable Reg. */
+#define PCFR		__REG(0x90020010)  /* PM general ConFiguration Reg. */
+#define PPCR		__REG(0x90020014)  /* PM PLL Configuration Reg. */
+#define PGSR		__REG(0x90020018)  /* PM GPIO Sleep state Reg. */
+#define POSR		__REG(0x9002001C)  /* PM Oscillator Status Reg. */
+
+#define PMCR_SF 	0x00000001	/* Sleep Force (set only)          */
+
+#define PSSR_SS 	0x00000001	/* Software Sleep                  */
+#define PSSR_BFS	0x00000002	/* Battery Fault Status            */
+                	        	/* (BATT_FAULT)                    */
+#define PSSR_VFS	0x00000004	/* Vdd Fault Status (VDD_FAULT)    */
+#define PSSR_DH 	0x00000008	/* DRAM control Hold               */
+#define PSSR_PH 	0x00000010	/* Peripheral control Hold         */
+
+#define PWER_GPIO(Nb)	GPIO_GPIO (Nb)	/* GPIO [0..27] wake-up enable     */
+#define PWER_GPIO0	PWER_GPIO (0)	/* GPIO  [0] wake-up enable        */
+#define PWER_GPIO1	PWER_GPIO (1)	/* GPIO  [1] wake-up enable        */
+#define PWER_GPIO2	PWER_GPIO (2)	/* GPIO  [2] wake-up enable        */
+#define PWER_GPIO3	PWER_GPIO (3)	/* GPIO  [3] wake-up enable        */
+#define PWER_GPIO4	PWER_GPIO (4)	/* GPIO  [4] wake-up enable        */
+#define PWER_GPIO5	PWER_GPIO (5)	/* GPIO  [5] wake-up enable        */
+#define PWER_GPIO6	PWER_GPIO (6)	/* GPIO  [6] wake-up enable        */
+#define PWER_GPIO7	PWER_GPIO (7)	/* GPIO  [7] wake-up enable        */
+#define PWER_GPIO8	PWER_GPIO (8)	/* GPIO  [8] wake-up enable        */
+#define PWER_GPIO9	PWER_GPIO (9)	/* GPIO  [9] wake-up enable        */
+#define PWER_GPIO10	PWER_GPIO (10)	/* GPIO [10] wake-up enable        */
+#define PWER_GPIO11	PWER_GPIO (11)	/* GPIO [11] wake-up enable        */
+#define PWER_GPIO12	PWER_GPIO (12)	/* GPIO [12] wake-up enable        */
+#define PWER_GPIO13	PWER_GPIO (13)	/* GPIO [13] wake-up enable        */
+#define PWER_GPIO14	PWER_GPIO (14)	/* GPIO [14] wake-up enable        */
+#define PWER_GPIO15	PWER_GPIO (15)	/* GPIO [15] wake-up enable        */
+#define PWER_GPIO16	PWER_GPIO (16)	/* GPIO [16] wake-up enable        */
+#define PWER_GPIO17	PWER_GPIO (17)	/* GPIO [17] wake-up enable        */
+#define PWER_GPIO18	PWER_GPIO (18)	/* GPIO [18] wake-up enable        */
+#define PWER_GPIO19	PWER_GPIO (19)	/* GPIO [19] wake-up enable        */
+#define PWER_GPIO20	PWER_GPIO (20)	/* GPIO [20] wake-up enable        */
+#define PWER_GPIO21	PWER_GPIO (21)	/* GPIO [21] wake-up enable        */
+#define PWER_GPIO22	PWER_GPIO (22)	/* GPIO [22] wake-up enable        */
+#define PWER_GPIO23	PWER_GPIO (23)	/* GPIO [23] wake-up enable        */
+#define PWER_GPIO24	PWER_GPIO (24)	/* GPIO [24] wake-up enable        */
+#define PWER_GPIO25	PWER_GPIO (25)	/* GPIO [25] wake-up enable        */
+#define PWER_GPIO26	PWER_GPIO (26)	/* GPIO [26] wake-up enable        */
+#define PWER_GPIO27	PWER_GPIO (27)	/* GPIO [27] wake-up enable        */
+#define PWER_RTC	0x80000000	/* RTC alarm wake-up enable        */
+
+#define PCFR_OPDE	0x00000001	/* Oscillator Power-Down Enable    */
+#define PCFR_ClkRun	(PCFR_OPDE*0)	/*  Clock Running in sleep mode    */
+#define PCFR_ClkStp	(PCFR_OPDE*1)	/*  Clock Stopped in sleep mode    */
+#define PCFR_FP 	0x00000002	/* Float PCMCIA pins               */
+#define PCFR_PCMCIANeg	(PCFR_FP*0)	/*  PCMCIA pins Negated (1)        */
+#define PCFR_PCMCIAFlt	(PCFR_FP*1)	/*  PCMCIA pins Floating           */
+#define PCFR_FS 	0x00000004	/* Float Static memory pins        */
+#define PCFR_StMemNeg	(PCFR_FS*0)	/*  Static Memory pins Negated (1) */
+#define PCFR_StMemFlt	(PCFR_FS*1)	/*  Static Memory pins Floating    */
+#define PCFR_FO 	0x00000008	/* Force RTC oscillator            */
+                	        	/* (32.768 kHz) enable On          */
+
+#define PPCR_CCF	Fld (5, 0)	/* CPU core Clock (CCLK) Freq.     */
+#define PPCR_Fx16	        	/*  Freq. x 16 (fcpu = 16*fxtl)    */ \
+                	(0x00 << FShft (PPCR_CCF))
+#define PPCR_Fx20	        	/*  Freq. x 20 (fcpu = 20*fxtl)    */ \
+                	(0x01 << FShft (PPCR_CCF))
+#define PPCR_Fx24	        	/*  Freq. x 24 (fcpu = 24*fxtl)    */ \
+                	(0x02 << FShft (PPCR_CCF))
+#define PPCR_Fx28	        	/*  Freq. x 28 (fcpu = 28*fxtl)    */ \
+                	(0x03 << FShft (PPCR_CCF))
+#define PPCR_Fx32	        	/*  Freq. x 32 (fcpu = 32*fxtl)    */ \
+                	(0x04 << FShft (PPCR_CCF))
+#define PPCR_Fx36	        	/*  Freq. x 36 (fcpu = 36*fxtl)    */ \
+                	(0x05 << FShft (PPCR_CCF))
+#define PPCR_Fx40	        	/*  Freq. x 40 (fcpu = 40*fxtl)    */ \
+                	(0x06 << FShft (PPCR_CCF))
+#define PPCR_Fx44	        	/*  Freq. x 44 (fcpu = 44*fxtl)    */ \
+                	(0x07 << FShft (PPCR_CCF))
+#define PPCR_Fx48	        	/*  Freq. x 48 (fcpu = 48*fxtl)    */ \
+                	(0x08 << FShft (PPCR_CCF))
+#define PPCR_Fx52	        	/*  Freq. x 52 (fcpu = 52*fxtl)    */ \
+                	(0x09 << FShft (PPCR_CCF))
+#define PPCR_Fx56	        	/*  Freq. x 56 (fcpu = 56*fxtl)    */ \
+                	(0x0A << FShft (PPCR_CCF))
+#define PPCR_Fx60	        	/*  Freq. x 60 (fcpu = 60*fxtl)    */ \
+                	(0x0B << FShft (PPCR_CCF))
+#define PPCR_Fx64	        	/*  Freq. x 64 (fcpu = 64*fxtl)    */ \
+                	(0x0C << FShft (PPCR_CCF))
+#define PPCR_Fx68	        	/*  Freq. x 68 (fcpu = 68*fxtl)    */ \
+                	(0x0D << FShft (PPCR_CCF))
+#define PPCR_Fx72	        	/*  Freq. x 72 (fcpu = 72*fxtl)    */ \
+                	(0x0E << FShft (PPCR_CCF))
+#define PPCR_Fx76	        	/*  Freq. x 76 (fcpu = 76*fxtl)    */ \
+                	(0x0F << FShft (PPCR_CCF))
+                	        	/*  3.6864 MHz crystal (fxtl):     */
+#define PPCR_F59_0MHz	PPCR_Fx16	/*   Freq. (fcpu) =  59.0 MHz      */
+#define PPCR_F73_7MHz	PPCR_Fx20	/*   Freq. (fcpu) =  73.7 MHz      */
+#define PPCR_F88_5MHz	PPCR_Fx24	/*   Freq. (fcpu) =  88.5 MHz      */
+#define PPCR_F103_2MHz	PPCR_Fx28	/*   Freq. (fcpu) = 103.2 MHz      */
+#define PPCR_F118_0MHz	PPCR_Fx32	/*   Freq. (fcpu) = 118.0 MHz      */
+#define PPCR_F132_7MHz	PPCR_Fx36	/*   Freq. (fcpu) = 132.7 MHz      */
+#define PPCR_F147_5MHz	PPCR_Fx40	/*   Freq. (fcpu) = 147.5 MHz      */
+#define PPCR_F162_2MHz	PPCR_Fx44	/*   Freq. (fcpu) = 162.2 MHz      */
+#define PPCR_F176_9MHz	PPCR_Fx48	/*   Freq. (fcpu) = 176.9 MHz      */
+#define PPCR_F191_7MHz	PPCR_Fx52	/*   Freq. (fcpu) = 191.7 MHz      */
+#define PPCR_F206_4MHz	PPCR_Fx56	/*   Freq. (fcpu) = 206.4 MHz      */
+#define PPCR_F221_2MHz	PPCR_Fx60	/*   Freq. (fcpu) = 221.2 MHz      */
+#define PPCR_F239_6MHz	PPCR_Fx64	/*   Freq. (fcpu) = 239.6 MHz      */
+#define PPCR_F250_7MHz	PPCR_Fx68	/*   Freq. (fcpu) = 250.7 MHz      */
+#define PPCR_F265_4MHz	PPCR_Fx72	/*   Freq. (fcpu) = 265.4 MHz      */
+#define PPCR_F280_2MHz	PPCR_Fx76	/*   Freq. (fcpu) = 280.2 MHz      */
+                	        	/*  3.5795 MHz crystal (fxtl):     */
+#define PPCR_F57_3MHz	PPCR_Fx16	/*   Freq. (fcpu) =  57.3 MHz      */
+#define PPCR_F71_6MHz	PPCR_Fx20	/*   Freq. (fcpu) =  71.6 MHz      */
+#define PPCR_F85_9MHz	PPCR_Fx24	/*   Freq. (fcpu) =  85.9 MHz      */
+#define PPCR_F100_2MHz	PPCR_Fx28	/*   Freq. (fcpu) = 100.2 MHz      */
+#define PPCR_F114_5MHz	PPCR_Fx32	/*   Freq. (fcpu) = 114.5 MHz      */
+#define PPCR_F128_9MHz	PPCR_Fx36	/*   Freq. (fcpu) = 128.9 MHz      */
+#define PPCR_F143_2MHz	PPCR_Fx40	/*   Freq. (fcpu) = 143.2 MHz      */
+#define PPCR_F157_5MHz	PPCR_Fx44	/*   Freq. (fcpu) = 157.5 MHz      */
+#define PPCR_F171_8MHz	PPCR_Fx48	/*   Freq. (fcpu) = 171.8 MHz      */
+#define PPCR_F186_1MHz	PPCR_Fx52	/*   Freq. (fcpu) = 186.1 MHz      */
+#define PPCR_F200_5MHz	PPCR_Fx56	/*   Freq. (fcpu) = 200.5 MHz      */
+#define PPCR_F214_8MHz	PPCR_Fx60	/*   Freq. (fcpu) = 214.8 MHz      */
+#define PPCR_F229_1MHz	PPCR_Fx64	/*   Freq. (fcpu) = 229.1 MHz      */
+#define PPCR_F243_4MHz	PPCR_Fx68	/*   Freq. (fcpu) = 243.4 MHz      */
+#define PPCR_F257_7MHz	PPCR_Fx72	/*   Freq. (fcpu) = 257.7 MHz      */
+#define PPCR_F272_0MHz	PPCR_Fx76	/*   Freq. (fcpu) = 272.0 MHz      */
+
+#define POSR_OOK	0x00000001	/* RTC Oscillator (32.768 kHz) OK  */
+
+
+/*
+ * Reset Controller (RC) control registers
+ *
+ * Registers
+ *    RSRR      	Reset Controller (RC) Software Reset Register
+ *              	(read/write).
+ *    RCSR      	Reset Controller (RC) Status Register (read/write).
+ */
+
+#define RSRR		__REG(0x90030000)  /* RC Software Reset Reg. */
+#define RCSR		__REG(0x90030004)  /* RC Status Reg. */
+
+#define RSRR_SWR	0x00000001	/* SoftWare Reset (set only)       */
+
+#define RCSR_HWR	0x00000001	/* HardWare Reset                  */
+#define RCSR_SWR	0x00000002	/* SoftWare Reset                  */
+#define RCSR_WDR	0x00000004	/* Watch-Dog Reset                 */
+#define RCSR_SMR	0x00000008	/* Sleep-Mode Reset                */
+
+
+/*
+ * Test unit control registers
+ *
+ * Registers
+ *    TUCR      	Test Unit Control Register (read/write).
+ */
+
+#define TUCR		__REG(0x90030008)  /* Test Unit Control Reg. */
+
+#define TUCR_TIC	0x00000040	/* TIC mode                        */
+#define TUCR_TTST	0x00000080	/* Trim TeST mode                  */
+#define TUCR_RCRC	0x00000100	/* Richard's Cyclic Redundancy     */
+                	        	/* Check                           */
+#define TUCR_PMD	0x00000200	/* Power Management Disable        */
+#define TUCR_MR 	0x00000400	/* Memory Request mode             */
+#define TUCR_NoMB	(TUCR_MR*0)	/*  No Memory Bus request & grant  */
+#define TUCR_MBGPIO	(TUCR_MR*1)	/*  Memory Bus request (MBREQ) &   */
+                	        	/*  grant (MBGNT) on GPIO [22:21]  */
+#define TUCR_CTB	Fld (3, 20)	/* Clock Test Bits                 */
+#define TUCR_FDC	0x00800000	/* RTC Force Delete Count          */
+#define TUCR_FMC	0x01000000	/* Force Michelle's Control mode   */
+#define TUCR_TMC	0x02000000	/* RTC Trimmer Multiplexer Control */
+#define TUCR_DPS	0x04000000	/* Disallow Pad Sleep              */
+#define TUCR_TSEL	Fld (3, 29)	/* clock Test SELect on GPIO [27]  */
+#define TUCR_32_768kHz	        	/*  32.768 kHz osc. on GPIO [27]   */ \
+                	(0 << FShft (TUCR_TSEL))
+#define TUCR_3_6864MHz	        	/*  3.6864 MHz osc. on GPIO [27]   */ \
+                	(1 << FShft (TUCR_TSEL))
+#define TUCR_VDD	        	/*  VDD ring osc./16 on GPIO [27]  */ \
+                	(2 << FShft (TUCR_TSEL))
+#define TUCR_96MHzPLL	        	/*  96 MHz PLL/4 on GPIO [27]      */ \
+                	(3 << FShft (TUCR_TSEL))
+#define TUCR_Clock	        	/*  internal (fcpu/2) & 32.768 kHz */ \
+                	        	/*  Clocks on GPIO [26:27]         */ \
+                	(4 << FShft (TUCR_TSEL))
+#define TUCR_3_6864MHzA	        	/*  3.6864 MHz osc. on GPIO [27]   */ \
+                	        	/*  (Alternative)                  */ \
+                	(5 << FShft (TUCR_TSEL))
+#define TUCR_MainPLL	        	/*  Main PLL/16 on GPIO [27]       */ \
+                	(6 << FShft (TUCR_TSEL))
+#define TUCR_VDDL	        	/*  VDDL ring osc./4 on GPIO [27]  */ \
+                	(7 << FShft (TUCR_TSEL))
+
+
+/*
+ * General-Purpose Input/Output (GPIO) control registers
+ *
+ * Registers
+ *    GPLR      	General-Purpose Input/Output (GPIO) Pin Level
+ *              	Register (read).
+ *    GPDR      	General-Purpose Input/Output (GPIO) Pin Direction
+ *              	Register (read/write).
+ *    GPSR      	General-Purpose Input/Output (GPIO) Pin output Set
+ *              	Register (write).
+ *    GPCR      	General-Purpose Input/Output (GPIO) Pin output Clear
+ *              	Register (write).
+ *    GRER      	General-Purpose Input/Output (GPIO) Rising-Edge
+ *              	detect Register (read/write).
+ *    GFER      	General-Purpose Input/Output (GPIO) Falling-Edge
+ *              	detect Register (read/write).
+ *    GEDR      	General-Purpose Input/Output (GPIO) Edge Detect
+ *              	status Register (read/write).
+ *    GAFR      	General-Purpose Input/Output (GPIO) Alternate
+ *              	Function Register (read/write).
+ *
+ * Clock
+ *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
+ */
+
+#define GPLR		__REG(0x90040000)  /* GPIO Pin Level Reg.             */
+#define GPDR		__REG(0x90040004)  /* GPIO Pin Direction Reg.         */
+#define GPSR		__REG(0x90040008)  /* GPIO Pin output Set Reg.        */
+#define GPCR		__REG(0x9004000C)  /* GPIO Pin output Clear Reg.      */
+#define GRER		__REG(0x90040010)  /* GPIO Rising-Edge detect Reg.    */
+#define GFER		__REG(0x90040014)  /* GPIO Falling-Edge detect Reg.   */
+#define GEDR		__REG(0x90040018)  /* GPIO Edge Detect status Reg.    */
+#define GAFR		__REG(0x9004001C)  /* GPIO Alternate Function Reg.    */
+
+#define GPIO_MIN	(0)
+#define GPIO_MAX	(27)
+
+#define GPIO_GPIO(Nb)	        	/* GPIO [0..27]                    */ \
+                	(0x00000001 << (Nb))
+#define GPIO_GPIO0	GPIO_GPIO (0)	/* GPIO  [0]                       */
+#define GPIO_GPIO1	GPIO_GPIO (1)	/* GPIO  [1]                       */
+#define GPIO_GPIO2	GPIO_GPIO (2)	/* GPIO  [2]                       */
+#define GPIO_GPIO3	GPIO_GPIO (3)	/* GPIO  [3]                       */
+#define GPIO_GPIO4	GPIO_GPIO (4)	/* GPIO  [4]                       */
+#define GPIO_GPIO5	GPIO_GPIO (5)	/* GPIO  [5]                       */
+#define GPIO_GPIO6	GPIO_GPIO (6)	/* GPIO  [6]                       */
+#define GPIO_GPIO7	GPIO_GPIO (7)	/* GPIO  [7]                       */
+#define GPIO_GPIO8	GPIO_GPIO (8)	/* GPIO  [8]                       */
+#define GPIO_GPIO9	GPIO_GPIO (9)	/* GPIO  [9]                       */
+#define GPIO_GPIO10	GPIO_GPIO (10)	/* GPIO [10]                       */
+#define GPIO_GPIO11	GPIO_GPIO (11)	/* GPIO [11]                       */
+#define GPIO_GPIO12	GPIO_GPIO (12)	/* GPIO [12]                       */
+#define GPIO_GPIO13	GPIO_GPIO (13)	/* GPIO [13]                       */
+#define GPIO_GPIO14	GPIO_GPIO (14)	/* GPIO [14]                       */
+#define GPIO_GPIO15	GPIO_GPIO (15)	/* GPIO [15]                       */
+#define GPIO_GPIO16	GPIO_GPIO (16)	/* GPIO [16]                       */
+#define GPIO_GPIO17	GPIO_GPIO (17)	/* GPIO [17]                       */
+#define GPIO_GPIO18	GPIO_GPIO (18)	/* GPIO [18]                       */
+#define GPIO_GPIO19	GPIO_GPIO (19)	/* GPIO [19]                       */
+#define GPIO_GPIO20	GPIO_GPIO (20)	/* GPIO [20]                       */
+#define GPIO_GPIO21	GPIO_GPIO (21)	/* GPIO [21]                       */
+#define GPIO_GPIO22	GPIO_GPIO (22)	/* GPIO [22]                       */
+#define GPIO_GPIO23	GPIO_GPIO (23)	/* GPIO [23]                       */
+#define GPIO_GPIO24	GPIO_GPIO (24)	/* GPIO [24]                       */
+#define GPIO_GPIO25	GPIO_GPIO (25)	/* GPIO [25]                       */
+#define GPIO_GPIO26	GPIO_GPIO (26)	/* GPIO [26]                       */
+#define GPIO_GPIO27	GPIO_GPIO (27)	/* GPIO [27]                       */
+
+#define GPIO_LDD(Nb)	        	/* LCD Data [8..15] (O)            */ \
+                	GPIO_GPIO ((Nb) - 6)
+#define GPIO_LDD8	GPIO_LDD (8)	/* LCD Data  [8] (O)               */
+#define GPIO_LDD9	GPIO_LDD (9)	/* LCD Data  [9] (O)               */
+#define GPIO_LDD10	GPIO_LDD (10)	/* LCD Data [10] (O)               */
+#define GPIO_LDD11	GPIO_LDD (11)	/* LCD Data [11] (O)               */
+#define GPIO_LDD12	GPIO_LDD (12)	/* LCD Data [12] (O)               */
+#define GPIO_LDD13	GPIO_LDD (13)	/* LCD Data [13] (O)               */
+#define GPIO_LDD14	GPIO_LDD (14)	/* LCD Data [14] (O)               */
+#define GPIO_LDD15	GPIO_LDD (15)	/* LCD Data [15] (O)               */
+                	        	/* ser. port 4:                    */
+#define GPIO_SSP_TXD	GPIO_GPIO (10)	/*  SSP Transmit Data (O)          */
+#define GPIO_SSP_RXD	GPIO_GPIO (11)	/*  SSP Receive Data (I)           */
+#define GPIO_SSP_SCLK	GPIO_GPIO (12)	/*  SSP Sample CLocK (O)           */
+#define GPIO_SSP_SFRM	GPIO_GPIO (13)	/*  SSP Sample FRaMe (O)           */
+                	        	/* ser. port 1:                    */
+#define GPIO_UART_TXD	GPIO_GPIO (14)	/*  UART Transmit Data (O)         */
+#define GPIO_UART_RXD	GPIO_GPIO (15)	/*  UART Receive Data (I)          */
+#define GPIO_SDLC_SCLK	GPIO_GPIO (16)	/*  SDLC Sample CLocK (I/O)        */
+#define GPIO_SDLC_AAF	GPIO_GPIO (17)	/*  SDLC Abort After Frame (O)     */
+#define GPIO_UART_SCLK1	GPIO_GPIO (18)	/*  UART Sample CLocK 1 (I)        */
+                	        	/* ser. port 4:                    */
+#define GPIO_SSP_CLK	GPIO_GPIO (19)	/*  SSP external CLocK (I)         */
+                	        	/* ser. port 3:                    */
+#define GPIO_UART_SCLK3	GPIO_GPIO (20)	/*  UART Sample CLocK 3 (I)        */
+                	        	/* ser. port 4:                    */
+#define GPIO_MCP_CLK	GPIO_GPIO (21)	/*  MCP CLocK (I)                  */
+                	        	/* test controller:                */
+#define GPIO_TIC_ACK	GPIO_GPIO (21)	/*  TIC ACKnowledge (O)            */
+#define GPIO_MBGNT	GPIO_GPIO (21)	/*  Memory Bus GraNT (O)           */
+#define GPIO_TREQA	GPIO_GPIO (22)	/*  TIC REQuest A (I)              */
+#define GPIO_MBREQ	GPIO_GPIO (22)	/*  Memory Bus REQuest (I)         */
+#define GPIO_TREQB	GPIO_GPIO (23)	/*  TIC REQuest B (I)              */
+#define GPIO_1Hz	GPIO_GPIO (25)	/* 1 Hz clock (O)                  */
+#define GPIO_RCLK	GPIO_GPIO (26)	/* internal (R) CLocK (O, fcpu/2)  */
+#define GPIO_32_768kHz	GPIO_GPIO (27)	/* 32.768 kHz clock (O, RTC)       */
+
+#define GPDR_In 	0       	/* Input                           */
+#define GPDR_Out	1       	/* Output                          */
+
+
+/*
+ * Interrupt Controller (IC) control registers
+ *
+ * Registers
+ *    ICIP      	Interrupt Controller (IC) Interrupt ReQuest (IRQ)
+ *              	Pending register (read).
+ *    ICMR      	Interrupt Controller (IC) Mask Register (read/write).
+ *    ICLR      	Interrupt Controller (IC) Level Register (read/write).
+ *    ICCR      	Interrupt Controller (IC) Control Register
+ *              	(read/write).
+ *              	[The ICCR register is only implemented in versions 2.0
+ *              	(rev. = 8) and higher of the StrongARM SA-1100.]
+ *    ICFP      	Interrupt Controller (IC) Fast Interrupt reQuest
+ *              	(FIQ) Pending register (read).
+ *    ICPR      	Interrupt Controller (IC) Pending Register (read).
+ *              	[The ICPR register is active low (inverted) in
+ *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
+ *              	StrongARM SA-1100, it is active high (non-inverted) in
+ *              	versions 2.0 (rev. = 8) and higher.]
+ */
+
+#define ICIP		__REG(0x90050000)  /* IC IRQ Pending reg.             */
+#define ICMR		__REG(0x90050004)  /* IC Mask Reg.                    */
+#define ICLR		__REG(0x90050008)  /* IC Level Reg.                   */
+#define ICCR		__REG(0x9005000C)  /* IC Control Reg.                 */
+#define ICFP		__REG(0x90050010)  /* IC FIQ Pending reg.             */
+#define ICPR		__REG(0x90050020)  /* IC Pending Reg.                 */
+
+#define IC_GPIO(Nb)	        	/* GPIO [0..10]                    */ \
+                	(0x00000001 << (Nb))
+#define IC_GPIO0	IC_GPIO (0)	/* GPIO  [0]                       */
+#define IC_GPIO1	IC_GPIO (1)	/* GPIO  [1]                       */
+#define IC_GPIO2	IC_GPIO (2)	/* GPIO  [2]                       */
+#define IC_GPIO3	IC_GPIO (3)	/* GPIO  [3]                       */
+#define IC_GPIO4	IC_GPIO (4)	/* GPIO  [4]                       */
+#define IC_GPIO5	IC_GPIO (5)	/* GPIO  [5]                       */
+#define IC_GPIO6	IC_GPIO (6)	/* GPIO  [6]                       */
+#define IC_GPIO7	IC_GPIO (7)	/* GPIO  [7]                       */
+#define IC_GPIO8	IC_GPIO (8)	/* GPIO  [8]                       */
+#define IC_GPIO9	IC_GPIO (9)	/* GPIO  [9]                       */
+#define IC_GPIO10	IC_GPIO (10)	/* GPIO [10]                       */
+#define IC_GPIO11_27	0x00000800	/* GPIO [11:27] (ORed)             */
+#define IC_LCD  	0x00001000	/* LCD controller                  */
+#define IC_Ser0UDC	0x00002000	/* Ser. port 0 UDC                 */
+#define IC_Ser1SDLC	0x00004000	/* Ser. port 1 SDLC                */
+#define IC_Ser1UART	0x00008000	/* Ser. port 1 UART                */
+#define IC_Ser2ICP	0x00010000	/* Ser. port 2 ICP                 */
+#define IC_Ser3UART	0x00020000	/* Ser. port 3 UART                */
+#define IC_Ser4MCP	0x00040000	/* Ser. port 4 MCP                 */
+#define IC_Ser4SSP	0x00080000	/* Ser. port 4 SSP                 */
+#define IC_DMA(Nb)	        	/* DMA controller channel [0..5]   */ \
+                	(0x00100000 << (Nb))
+#define IC_DMA0 	IC_DMA (0)	/* DMA controller channel 0        */
+#define IC_DMA1 	IC_DMA (1)	/* DMA controller channel 1        */
+#define IC_DMA2 	IC_DMA (2)	/* DMA controller channel 2        */
+#define IC_DMA3 	IC_DMA (3)	/* DMA controller channel 3        */
+#define IC_DMA4 	IC_DMA (4)	/* DMA controller channel 4        */
+#define IC_DMA5 	IC_DMA (5)	/* DMA controller channel 5        */
+#define IC_OST(Nb)	        	/* OS Timer match [0..3]           */ \
+                	(0x04000000 << (Nb))
+#define IC_OST0 	IC_OST (0)	/* OS Timer match 0                */
+#define IC_OST1 	IC_OST (1)	/* OS Timer match 1                */
+#define IC_OST2 	IC_OST (2)	/* OS Timer match 2                */
+#define IC_OST3 	IC_OST (3)	/* OS Timer match 3                */
+#define IC_RTC1Hz	0x40000000	/* RTC 1 Hz clock                  */
+#define IC_RTCAlrm	0x80000000	/* RTC Alarm                       */
+
+#define ICLR_IRQ	0       	/* Interrupt ReQuest               */
+#define ICLR_FIQ	1       	/* Fast Interrupt reQuest          */
+
+#define ICCR_DIM	0x00000001	/* Disable Idle-mode interrupt     */
+                	        	/* Mask                            */
+#define ICCR_IdleAllInt	(ICCR_DIM*0)	/*  Idle-mode All Interrupt enable */
+                	        	/*  (ICMR ignored)                 */
+#define ICCR_IdleMskInt	(ICCR_DIM*1)	/*  Idle-mode non-Masked Interrupt */
+                	        	/*  enable (ICMR used)             */
+
+
+/*
+ * Peripheral Pin Controller (PPC) control registers
+ *
+ * Registers
+ *    PPDR      	Peripheral Pin Controller (PPC) Pin Direction
+ *              	Register (read/write).
+ *    PPSR      	Peripheral Pin Controller (PPC) Pin State Register
+ *              	(read/write).
+ *    PPAR      	Peripheral Pin Controller (PPC) Pin Assignment
+ *              	Register (read/write).
+ *    PSDR      	Peripheral Pin Controller (PPC) Sleep-mode pin
+ *              	Direction Register (read/write).
+ *    PPFR      	Peripheral Pin Controller (PPC) Pin Flag Register
+ *              	(read).
+ */
+
+#define PPDR		__REG(0x90060000)  /* PPC Pin Direction Reg.          */
+#define PPSR		__REG(0x90060004)  /* PPC Pin State Reg.              */
+#define PPAR		__REG(0x90060008)  /* PPC Pin Assignment Reg.         */
+#define PSDR		__REG(0x9006000C)  /* PPC Sleep-mode pin Direction Reg. */
+#define PPFR		__REG(0x90060010)  /* PPC Pin Flag Reg.               */
+
+#define PPC_LDD(Nb)	        	/* LCD Data [0..7]                 */ \
+                	(0x00000001 << (Nb))
+#define PPC_LDD0	PPC_LDD (0)	/* LCD Data [0]                    */
+#define PPC_LDD1	PPC_LDD (1)	/* LCD Data [1]                    */
+#define PPC_LDD2	PPC_LDD (2)	/* LCD Data [2]                    */
+#define PPC_LDD3	PPC_LDD (3)	/* LCD Data [3]                    */
+#define PPC_LDD4	PPC_LDD (4)	/* LCD Data [4]                    */
+#define PPC_LDD5	PPC_LDD (5)	/* LCD Data [5]                    */
+#define PPC_LDD6	PPC_LDD (6)	/* LCD Data [6]                    */
+#define PPC_LDD7	PPC_LDD (7)	/* LCD Data [7]                    */
+#define PPC_L_PCLK	0x00000100	/* LCD Pixel CLocK                 */
+#define PPC_L_LCLK	0x00000200	/* LCD Line CLocK                  */
+#define PPC_L_FCLK	0x00000400	/* LCD Frame CLocK                 */
+#define PPC_L_BIAS	0x00000800	/* LCD AC BIAS                     */
+                	        	/* ser. port 1:                    */
+#define PPC_TXD1	0x00001000	/*  SDLC/UART Transmit Data 1      */
+#define PPC_RXD1	0x00002000	/*  SDLC/UART Receive Data 1       */
+                	        	/* ser. port 2:                    */
+#define PPC_TXD2	0x00004000	/*  IPC Transmit Data 2            */
+#define PPC_RXD2	0x00008000	/*  IPC Receive Data 2             */
+                	        	/* ser. port 3:                    */
+#define PPC_TXD3	0x00010000	/*  UART Transmit Data 3           */
+#define PPC_RXD3	0x00020000	/*  UART Receive Data 3            */
+                	        	/* ser. port 4:                    */
+#define PPC_TXD4	0x00040000	/*  MCP/SSP Transmit Data 4        */
+#define PPC_RXD4	0x00080000	/*  MCP/SSP Receive Data 4         */
+#define PPC_SCLK	0x00100000	/*  MCP/SSP Sample CLocK           */
+#define PPC_SFRM	0x00200000	/*  MCP/SSP Sample FRaMe           */
+
+#define PPDR_In 	0       	/* Input                           */
+#define PPDR_Out	1       	/* Output                          */
+
+                	        	/* ser. port 1:                    */
+#define PPAR_UPR	0x00001000	/*  UART Pin Reassignment          */
+#define PPAR_UARTTR	(PPAR_UPR*0)	/*   UART on TXD_1 & RXD_1         */
+#define PPAR_UARTGPIO	(PPAR_UPR*1)	/*   UART on GPIO [14:15]          */
+                	        	/* ser. port 4:                    */
+#define PPAR_SPR	0x00040000	/*  SSP Pin Reassignment           */
+#define PPAR_SSPTRSS	(PPAR_SPR*0)	/*   SSP on TXD_C, RXD_C, SCLK_C,  */
+                	        	/*   & SFRM_C                      */
+#define PPAR_SSPGPIO	(PPAR_SPR*1)	/*   SSP on GPIO [10:13]           */
+
+#define PSDR_OutL	0       	/* Output Low in sleep mode        */
+#define PSDR_Flt	1       	/* Floating (input) in sleep mode  */
+
+#define PPFR_LCD	0x00000001	/* LCD controller                  */
+#define PPFR_SP1TX	0x00001000	/* Ser. Port 1 SDLC/UART Transmit  */
+#define PPFR_SP1RX	0x00002000	/* Ser. Port 1 SDLC/UART Receive   */
+#define PPFR_SP2TX	0x00004000	/* Ser. Port 2 ICP Transmit        */
+#define PPFR_SP2RX	0x00008000	/* Ser. Port 2 ICP Receive         */
+#define PPFR_SP3TX	0x00010000	/* Ser. Port 3 UART Transmit       */
+#define PPFR_SP3RX	0x00020000	/* Ser. Port 3 UART Receive        */
+#define PPFR_SP4	0x00040000	/* Ser. Port 4 MCP/SSP             */
+#define PPFR_PerEn	0       	/* Peripheral Enabled              */
+#define PPFR_PPCEn	1       	/* PPC Enabled                     */
+
+
+/*
+ * Dynamic Random-Access Memory (DRAM) control registers
+ *
+ * Registers
+ *    MDCNFG    	Memory system: Dynamic Random-Access Memory (DRAM)
+ *              	CoNFiGuration register (read/write).
+ *    MDCAS0    	Memory system: Dynamic Random-Access Memory (DRAM)
+ *              	Column Address Strobe (CAS) shift register 0
+ *              	(read/write).
+ *    MDCAS1    	Memory system: Dynamic Random-Access Memory (DRAM)
+ *              	Column Address Strobe (CAS) shift register 1
+ *              	(read/write).
+ *    MDCAS2    	Memory system: Dynamic Random-Access Memory (DRAM)
+ *              	Column Address Strobe (CAS) shift register 2
+ *              	(read/write).
+ *
+ * Clocks
+ *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
+ *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
+ *    fcas, Tcas	Frequency, period of the DRAM CAS shift registers.
+ */
+
+#define MDCNFG		__REG(0xA0000000)  /*  DRAM CoNFiGuration reg. */
+#define MDCAS0		__REG(0xA0000004)  /* DRAM CAS shift reg. 0 */
+#define MDCAS1		__REG(0xA0000008)  /* DRAM CAS shift reg. 1 */
+#define MDCAS2		__REG(0xA000000c)  /* DRAM CAS shift reg. 2 */
+
+/* SA1100 MDCNFG values */
+#define MDCNFG_DE(Nb)	        	/* DRAM Enable bank [0..3]         */ \
+                	(0x00000001 << (Nb))
+#define MDCNFG_DE0	MDCNFG_DE (0)	/* DRAM Enable bank 0              */
+#define MDCNFG_DE1	MDCNFG_DE (1)	/* DRAM Enable bank 1              */
+#define MDCNFG_DE2	MDCNFG_DE (2)	/* DRAM Enable bank 2              */
+#define MDCNFG_DE3	MDCNFG_DE (3)	/* DRAM Enable bank 3              */
+#define MDCNFG_DRAC	Fld (2, 4)	/* DRAM Row Address Count - 9      */
+#define MDCNFG_RowAdd(Add)      	/*  Row Address count [9..12]      */ \
+                	(((Add) - 9) << FShft (MDCNFG_DRAC))
+#define MDCNFG_CDB2	0x00000040	/* shift reg. Clock Divide By 2    */
+                	        	/* (fcas = fcpu/2)                 */
+#define MDCNFG_TRP	Fld (4, 7)	/* Time RAS Pre-charge - 1 [Tmem]  */
+#define MDCNFG_PrChrg(Tcpu)     	/*  Pre-Charge time [2..32 Tcpu]   */ \
+                	(((Tcpu) - 2)/2 << FShft (MDCNFG_TRP))
+#define MDCNFG_CeilPrChrg(Tcpu) 	/*  Ceil. of PrChrg [2..32 Tcpu]   */ \
+                	(((Tcpu) - 1)/2 << FShft (MDCNFG_TRP))
+#define MDCNFG_TRASR	Fld (4, 11)	/* Time RAS Refresh - 1 [Tmem]     */
+#define MDCNFG_Ref(Tcpu)        	/*  Refresh time [2..32 Tcpu]      */ \
+                	(((Tcpu) - 2)/2 << FShft (MDCNFG_TRASR))
+#define MDCNFG_CeilRef(Tcpu)    	/*  Ceil. of Ref [2..32 Tcpu]      */ \
+                	(((Tcpu) - 1)/2 << FShft (MDCNFG_TRASR))
+#define MDCNFG_TDL	Fld (2, 15)	/* Time Data Latch [Tcpu]          */
+#define MDCNFG_DataLtch(Tcpu)   	/*  Data Latch delay [0..3 Tcpu]   */ \
+                	((Tcpu) << FShft (MDCNFG_TDL))
+#define MDCNFG_DRI	Fld (15, 17)	/* min. DRAM Refresh Interval/4    */
+                	        	/* [Tmem]                          */
+#define MDCNFG_RefInt(Tcpu)     	/*  min. Refresh Interval          */ \
+                	        	/*  [0..262136 Tcpu]               */ \
+                	((Tcpu)/8 << FShft (MDCNFG_DRI))
+
+/* SA1110 MDCNFG values */
+#define MDCNFG_SA1110_DE0	0x00000001	/* DRAM Enable bank 0        */
+#define MDCNFG_SA1110_DE1	0x00000002 	/* DRAM Enable bank 1        */
+#define MDCNFG_SA1110_DTIM0	0x00000004	/* DRAM timing type 0/1      */
+#define MDCNFG_SA1110_DWID0	0x00000008	/* DRAM bus width 0/1        */
+#define MDCNFG_SA1110_DRAC0	Fld(3, 4)	/* DRAM row addr bit count   */
+                	        		/* bank 0/1                  */
+#define MDCNFG_SA1110_CDB20	0x00000080	/* Mem Clock divide by 2 0/1 */
+#define MDCNFG_SA1110_TRP0	Fld(3, 8)	/* RAS precharge 0/1         */
+#define MDCNFG_SA1110_TDL0	Fld(2, 12)	/* Data input latch after CAS*/
+                	        		/* deassertion 0/1           */
+#define MDCNFG_SA1110_TWR0	Fld(2, 14)	/* SDRAM write recovery 0/1  */
+#define MDCNFG_SA1110_DE2	0x00010000	/* DRAM Enable bank 0        */
+#define MDCNFG_SA1110_DE3	0x00020000 	/* DRAM Enable bank 1        */
+#define MDCNFG_SA1110_DTIM2	0x00040000	/* DRAM timing type 0/1      */
+#define MDCNFG_SA1110_DWID2	0x00080000	/* DRAM bus width 0/1        */
+#define MDCNFG_SA1110_DRAC2	Fld(3, 20)	/* DRAM row addr bit count   */
+                	        		/* bank 0/1                  */
+#define MDCNFG_SA1110_CDB22	0x00800000	/* Mem Clock divide by 2 0/1 */
+#define MDCNFG_SA1110_TRP2	Fld(3, 24)	/* RAS precharge 0/1         */
+#define MDCNFG_SA1110_TDL2	Fld(2, 28)	/* Data input latch after CAS*/
+                	        		/* deassertion 0/1           */
+#define MDCNFG_SA1110_TWR2	Fld(2, 30)	/* SDRAM write recovery 0/1  */
+
+
+/*
+ * Static memory control registers
+ *
+ * Registers
+ *    MSC0      	Memory system: Static memory Control register 0
+ *              	(read/write).
+ *    MSC1      	Memory system: Static memory Control register 1
+ *              	(read/write).
+ *
+ * Clocks
+ *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
+ *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
+ */
+
+#define MSC0		__REG(0xa0000010)  /* Static memory Control reg. 0 */
+#define MSC1		__REG(0xa0000014)  /* Static memory Control reg. 1 */
+#define MSC2		__REG(0xa000002c)  /* Static memory Control reg. 2, not contiguous   */
+
+#define MSC_Bnk(Nb)	        	/* static memory Bank [0..3]       */ \
+                	Fld (16, ((Nb) Modulo 2)*16)
+#define MSC0_Bnk0	MSC_Bnk (0)	/* static memory Bank 0            */
+#define MSC0_Bnk1	MSC_Bnk (1)	/* static memory Bank 1            */
+#define MSC1_Bnk2	MSC_Bnk (2)	/* static memory Bank 2            */
+#define MSC1_Bnk3	MSC_Bnk (3)	/* static memory Bank 3            */
+
+#define MSC_RT  	Fld (2, 0)	/* ROM/static memory Type          */
+#define MSC_NonBrst	        	/*  Non-Burst static memory        */ \
+                	(0 << FShft (MSC_RT))
+#define MSC_SRAM	        	/*  32-bit byte-writable SRAM      */ \
+                	(1 << FShft (MSC_RT))
+#define MSC_Brst4	        	/*  Burst-of-4 static memory       */ \
+                	(2 << FShft (MSC_RT))
+#define MSC_Brst8	        	/*  Burst-of-8 static memory       */ \
+                	(3 << FShft (MSC_RT))
+#define MSC_RBW 	0x0004  	/* ROM/static memory Bus Width     */
+#define MSC_32BitStMem	(MSC_RBW*0)	/*  32-Bit Static Memory           */
+#define MSC_16BitStMem	(MSC_RBW*1)	/*  16-Bit Static Memory           */
+#define MSC_RDF 	Fld (5, 3)	/* ROM/static memory read Delay    */
+                	        	/* First access - 1(.5) [Tmem]     */
+#define MSC_1stRdAcc(Tcpu)      	/*  1st Read Access time (burst    */ \
+                	        	/*  static memory) [3..65 Tcpu]    */ \
+                	((((Tcpu) - 3)/2) << FShft (MSC_RDF))
+#define MSC_Ceil1stRdAcc(Tcpu)  	/*  Ceil. of 1stRdAcc [3..65 Tcpu] */ \
+                	((((Tcpu) - 2)/2) << FShft (MSC_RDF))
+#define MSC_RdAcc(Tcpu)	        	/*  Read Access time (non-burst    */ \
+                	        	/*  static memory) [2..64 Tcpu]    */ \
+                	((((Tcpu) - 2)/2) << FShft (MSC_RDF))
+#define MSC_CeilRdAcc(Tcpu)     	/*  Ceil. of RdAcc [2..64 Tcpu]    */ \
+                	((((Tcpu) - 1)/2) << FShft (MSC_RDF))
+#define MSC_RDN 	Fld (5, 8)	/* ROM/static memory read Delay    */
+                	        	/* Next access - 1 [Tmem]          */
+#define MSC_NxtRdAcc(Tcpu)      	/*  Next Read Access time (burst   */ \
+                	        	/*  static memory) [2..64 Tcpu]    */ \
+                	((((Tcpu) - 2)/2) << FShft (MSC_RDN))
+#define MSC_CeilNxtRdAcc(Tcpu)  	/*  Ceil. of NxtRdAcc [2..64 Tcpu] */ \
+                	((((Tcpu) - 1)/2) << FShft (MSC_RDN))
+#define MSC_WrAcc(Tcpu)	        	/*  Write Access time (non-burst   */ \
+                	        	/*  static memory) [2..64 Tcpu]    */ \
+                	((((Tcpu) - 2)/2) << FShft (MSC_RDN))
+#define MSC_CeilWrAcc(Tcpu)     	/*  Ceil. of WrAcc [2..64 Tcpu]    */ \
+                	((((Tcpu) - 1)/2) << FShft (MSC_RDN))
+#define MSC_RRR 	Fld (3, 13)	/* ROM/static memory RecoveRy      */
+                	        	/* time/2 [Tmem]                   */
+#define MSC_Rec(Tcpu)	        	/*  Recovery time [0..28 Tcpu]     */ \
+                	(((Tcpu)/4) << FShft (MSC_RRR))
+#define MSC_CeilRec(Tcpu)       	/*  Ceil. of Rec [0..28 Tcpu]      */ \
+                	((((Tcpu) + 3)/4) << FShft (MSC_RRR))
+
+
+/*
+ * Personal Computer Memory Card International Association (PCMCIA) control
+ * register
+ *
+ * Register
+ *    MECR      	Memory system: Expansion memory bus (PCMCIA)
+ *              	Configuration Register (read/write).
+ *
+ * Clocks
+ *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
+ *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
+ *    fbclk, Tbclk	Frequency, period of the PCMCIA clock (BCLK).
+ */
+
+                	        	/* Memory system:                  */
+#define MECR		__REG(0xA0000018)  /*  Expansion memory bus (PCMCIA) Configuration Reg.             */
+
+#define MECR_PCMCIA(Nb)	        	/* PCMCIA [0..1]                   */ \
+                	Fld (15, (Nb)*16)
+#define MECR_PCMCIA0	MECR_PCMCIA (0)	/* PCMCIA 0                        */
+#define MECR_PCMCIA1	MECR_PCMCIA (1)	/* PCMCIA 1                        */
+
+#define MECR_BSIO	Fld (5, 0)	/* BCLK Select I/O - 1 [Tmem]      */
+#define MECR_IOClk(Tcpu)        	/*  I/O Clock [2..64 Tcpu]         */ \
+                	((((Tcpu) - 2)/2) << FShft (MECR_BSIO))
+#define MECR_CeilIOClk(Tcpu)    	/*  Ceil. of IOClk [2..64 Tcpu]    */ \
+                	((((Tcpu) - 1)/2) << FShft (MECR_BSIO))
+#define MECR_BSA	Fld (5, 5)	/* BCLK Select Attribute - 1       */
+                	        	/* [Tmem]                          */
+#define MECR_AttrClk(Tcpu)      	/*  Attribute Clock [2..64 Tcpu]   */ \
+                	((((Tcpu) - 2)/2) << FShft (MECR_BSA))
+#define MECR_CeilAttrClk(Tcpu)  	/*  Ceil. of AttrClk [2..64 Tcpu]  */ \
+                	((((Tcpu) - 1)/2) << FShft (MECR_BSA))
+#define MECR_BSM	Fld (5, 10)	/* BCLK Select Memory - 1 [Tmem]   */
+#define MECR_MemClk(Tcpu)       	/*  Memory Clock [2..64 Tcpu]      */ \
+                	((((Tcpu) - 2)/2) << FShft (MECR_BSM))
+#define MECR_CeilMemClk(Tcpu)   	/*  Ceil. of MemClk [2..64 Tcpu]   */ \
+                	((((Tcpu) - 1)/2) << FShft (MECR_BSM))
+
+/*
+ * On SA1110 only
+ */
+
+#define MDREFR		__REG(0xA000001C)
+
+#define MDREFR_TRASR		Fld (4, 0)
+#define MDREFR_DRI		Fld (12, 4)
+#define MDREFR_E0PIN		(1 << 16)
+#define MDREFR_K0RUN		(1 << 17)
+#define MDREFR_K0DB2		(1 << 18)
+#define MDREFR_E1PIN		(1 << 20)
+#define MDREFR_K1RUN		(1 << 21)
+#define MDREFR_K1DB2		(1 << 22)
+#define MDREFR_K2RUN		(1 << 25)
+#define MDREFR_K2DB2		(1 << 26)
+#define MDREFR_EAPD		(1 << 28)
+#define MDREFR_KAPD		(1 << 29)
+#define MDREFR_SLFRSH		(1 << 31)
+
+
+/*
+ * Direct Memory Access (DMA) control registers
+ *
+ * Registers
+ *    DDAR0     	Direct Memory Access (DMA) Device Address Register
+ *              	channel 0 (read/write).
+ *    DCSR0     	Direct Memory Access (DMA) Control and Status
+ *              	Register channel 0 (read/write).
+ *    DBSA0     	Direct Memory Access (DMA) Buffer Start address
+ *              	register A channel 0 (read/write).
+ *    DBTA0     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register A channel 0 (read/write).
+ *    DBSB0     	Direct Memory Access (DMA) Buffer Start address
+ *              	register B channel 0 (read/write).
+ *    DBTB0     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register B channel 0 (read/write).
+ *
+ *    DDAR1     	Direct Memory Access (DMA) Device Address Register
+ *              	channel 1 (read/write).
+ *    DCSR1     	Direct Memory Access (DMA) Control and Status
+ *              	Register channel 1 (read/write).
+ *    DBSA1     	Direct Memory Access (DMA) Buffer Start address
+ *              	register A channel 1 (read/write).
+ *    DBTA1     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register A channel 1 (read/write).
+ *    DBSB1     	Direct Memory Access (DMA) Buffer Start address
+ *              	register B channel 1 (read/write).
+ *    DBTB1     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register B channel 1 (read/write).
+ *
+ *    DDAR2     	Direct Memory Access (DMA) Device Address Register
+ *              	channel 2 (read/write).
+ *    DCSR2     	Direct Memory Access (DMA) Control and Status
+ *              	Register channel 2 (read/write).
+ *    DBSA2     	Direct Memory Access (DMA) Buffer Start address
+ *              	register A channel 2 (read/write).
+ *    DBTA2     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register A channel 2 (read/write).
+ *    DBSB2     	Direct Memory Access (DMA) Buffer Start address
+ *              	register B channel 2 (read/write).
+ *    DBTB2     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register B channel 2 (read/write).
+ *
+ *    DDAR3     	Direct Memory Access (DMA) Device Address Register
+ *              	channel 3 (read/write).
+ *    DCSR3     	Direct Memory Access (DMA) Control and Status
+ *              	Register channel 3 (read/write).
+ *    DBSA3     	Direct Memory Access (DMA) Buffer Start address
+ *              	register A channel 3 (read/write).
+ *    DBTA3     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register A channel 3 (read/write).
+ *    DBSB3     	Direct Memory Access (DMA) Buffer Start address
+ *              	register B channel 3 (read/write).
+ *    DBTB3     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register B channel 3 (read/write).
+ *
+ *    DDAR4     	Direct Memory Access (DMA) Device Address Register
+ *              	channel 4 (read/write).
+ *    DCSR4     	Direct Memory Access (DMA) Control and Status
+ *              	Register channel 4 (read/write).
+ *    DBSA4     	Direct Memory Access (DMA) Buffer Start address
+ *              	register A channel 4 (read/write).
+ *    DBTA4     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register A channel 4 (read/write).
+ *    DBSB4     	Direct Memory Access (DMA) Buffer Start address
+ *              	register B channel 4 (read/write).
+ *    DBTB4     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register B channel 4 (read/write).
+ *
+ *    DDAR5     	Direct Memory Access (DMA) Device Address Register
+ *              	channel 5 (read/write).
+ *    DCSR5     	Direct Memory Access (DMA) Control and Status
+ *              	Register channel 5 (read/write).
+ *    DBSA5     	Direct Memory Access (DMA) Buffer Start address
+ *              	register A channel 5 (read/write).
+ *    DBTA5     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register A channel 5 (read/write).
+ *    DBSB5     	Direct Memory Access (DMA) Buffer Start address
+ *              	register B channel 5 (read/write).
+ *    DBTB5     	Direct Memory Access (DMA) Buffer Transfer count
+ *              	register B channel 5 (read/write).
+ */
+
+#define DMASp   	0x00000020	/* DMA control reg. Space [byte]   */
+
+#define DDAR(Nb)	__REG(0xB0000000 + (Nb)*DMASp)  /* DMA Device Address Reg. channel [0..5] */
+#define SetDCSR(Nb)	__REG(0xB0000004 + (Nb)*DMASp)  /* Set DMA Control & Status Reg. channel [0..5] (write) */
+#define ClrDCSR(Nb)	__REG(0xB0000008 + (Nb)*DMASp)  /* Clear DMA Control & Status Reg. channel [0..5] (write) */
+#define RdDCSR(Nb)	__REG(0xB000000C + (Nb)*DMASp)  /* Read DMA Control & Status Reg. channel [0..5] (read) */
+#define DBSA(Nb)	__REG(0xB0000010 + (Nb)*DMASp)  /* DMA Buffer Start address reg. A channel [0..5] */
+#define DBTA(Nb)	__REG(0xB0000014 + (Nb)*DMASp)  /* DMA Buffer Transfer count reg. A channel [0..5] */
+#define DBSB(Nb)	__REG(0xB0000018 + (Nb)*DMASp)  /* DMA Buffer Start address reg. B channel [0..5] */
+#define DBTB(Nb)	__REG(0xB000001C + (Nb)*DMASp)  /* DMA Buffer Transfer count reg. B channel [0..5] */
+
+#define DDAR_RW 	0x00000001	/* device data Read/Write          */
+#define DDAR_DevWr	(DDAR_RW*0)	/*  Device data Write              */
+                	        	/*  (memory -> device)             */
+#define DDAR_DevRd	(DDAR_RW*1)	/*  Device data Read               */
+                	        	/*  (device -> memory)             */
+#define DDAR_E  	0x00000002	/* big/little Endian device        */
+#define DDAR_LtlEnd	(DDAR_E*0)	/*  Little Endian device           */
+#define DDAR_BigEnd	(DDAR_E*1)	/*  Big Endian device              */
+#define DDAR_BS 	0x00000004	/* device Burst Size               */
+#define DDAR_Brst4	(DDAR_BS*0)	/*  Burst-of-4 device              */
+#define DDAR_Brst8	(DDAR_BS*1)	/*  Burst-of-8 device              */
+#define DDAR_DW 	0x00000008	/* device Data Width               */
+#define DDAR_8BitDev	(DDAR_DW*0)	/*  8-Bit Device                   */
+#define DDAR_16BitDev	(DDAR_DW*1)	/*  16-Bit Device                  */
+#define DDAR_DS 	Fld (4, 4)	/* Device Select                   */
+#define DDAR_Ser0UDCTr	        	/*  Ser. port 0 UDC Transmit       */ \
+                	(0x0 << FShft (DDAR_DS))
+#define DDAR_Ser0UDCRc	        	/*  Ser. port 0 UDC Receive        */ \
+                	(0x1 << FShft (DDAR_DS))
+#define DDAR_Ser1SDLCTr	        	/*  Ser. port 1 SDLC Transmit      */ \
+                	(0x2 << FShft (DDAR_DS))
+#define DDAR_Ser1SDLCRc	        	/*  Ser. port 1 SDLC Receive       */ \
+                	(0x3 << FShft (DDAR_DS))
+#define DDAR_Ser1UARTTr	        	/*  Ser. port 1 UART Transmit      */ \
+                	(0x4 << FShft (DDAR_DS))
+#define DDAR_Ser1UARTRc	        	/*  Ser. port 1 UART Receive       */ \
+                	(0x5 << FShft (DDAR_DS))
+#define DDAR_Ser2ICPTr	        	/*  Ser. port 2 ICP Transmit       */ \
+                	(0x6 << FShft (DDAR_DS))
+#define DDAR_Ser2ICPRc	        	/*  Ser. port 2 ICP Receive        */ \
+                	(0x7 << FShft (DDAR_DS))
+#define DDAR_Ser3UARTTr	        	/*  Ser. port 3 UART Transmit      */ \
+                	(0x8 << FShft (DDAR_DS))
+#define DDAR_Ser3UARTRc	        	/*  Ser. port 3 UART Receive       */ \
+                	(0x9 << FShft (DDAR_DS))
+#define DDAR_Ser4MCP0Tr	        	/*  Ser. port 4 MCP 0 Transmit     */ \
+                	        	/*  (audio)                        */ \
+                	(0xA << FShft (DDAR_DS))
+#define DDAR_Ser4MCP0Rc	        	/*  Ser. port 4 MCP 0 Receive      */ \
+                	        	/*  (audio)                        */ \
+                	(0xB << FShft (DDAR_DS))
+#define DDAR_Ser4MCP1Tr	        	/*  Ser. port 4 MCP 1 Transmit     */ \
+                	        	/*  (telecom)                      */ \
+                	(0xC << FShft (DDAR_DS))
+#define DDAR_Ser4MCP1Rc	        	/*  Ser. port 4 MCP 1 Receive      */ \
+                	        	/*  (telecom)                      */ \
+                	(0xD << FShft (DDAR_DS))
+#define DDAR_Ser4SSPTr	        	/*  Ser. port 4 SSP Transmit       */ \
+                	(0xE << FShft (DDAR_DS))
+#define DDAR_Ser4SSPRc	        	/*  Ser. port 4 SSP Receive        */ \
+                	(0xF << FShft (DDAR_DS))
+#define DDAR_DA 	Fld (24, 8)	/* Device Address                  */
+#define DDAR_DevAdd(Add)        	/*  Device Address                 */ \
+                	(((Add) & 0xF0000000) | \
+                	 (((Add) & 0X003FFFFC) << (FShft (DDAR_DA) - 2)))
+#define DDAR_Ser0UDCWr	        	/* Ser. port 0 UDC Write           */ \
+                	(DDAR_DevWr + DDAR_Brst8 + DDAR_8BitDev + \
+                	 DDAR_Ser0UDCTr + DDAR_DevAdd (__PREG(Ser0UDCDR)))
+#define DDAR_Ser0UDCRd	        	/* Ser. port 0 UDC Read            */ \
+                	(DDAR_DevRd + DDAR_Brst8 + DDAR_8BitDev + \
+                	 DDAR_Ser0UDCRc + DDAR_DevAdd (__PREG(Ser0UDCDR)))
+#define DDAR_Ser1UARTWr	        	/* Ser. port 1 UART Write          */ \
+                	(DDAR_DevWr + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser1UARTTr + DDAR_DevAdd (__PREG(Ser1UTDR)))
+#define DDAR_Ser1UARTRd	        	/* Ser. port 1 UART Read           */ \
+                	(DDAR_DevRd + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser1UARTRc + DDAR_DevAdd (__PREG(Ser1UTDR)))
+#define DDAR_Ser1SDLCWr	        	/* Ser. port 1 SDLC Write          */ \
+                	(DDAR_DevWr + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser1SDLCTr + DDAR_DevAdd (__PREG(Ser1SDDR)))
+#define DDAR_Ser1SDLCRd	        	/* Ser. port 1 SDLC Read           */ \
+                	(DDAR_DevRd + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser1SDLCRc + DDAR_DevAdd (__PREG(Ser1SDDR)))
+#define DDAR_Ser2UARTWr	        	/* Ser. port 2 UART Write          */ \
+                	(DDAR_DevWr + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser2ICPTr + DDAR_DevAdd (__PREG(Ser2UTDR)))
+#define DDAR_Ser2UARTRd	        	/* Ser. port 2 UART Read           */ \
+                	(DDAR_DevRd + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser2ICPRc + DDAR_DevAdd (__PREG(Ser2UTDR)))
+#define DDAR_Ser2HSSPWr	        	/* Ser. port 2 HSSP Write          */ \
+                	(DDAR_DevWr + DDAR_Brst8 + DDAR_8BitDev + \
+                	 DDAR_Ser2ICPTr + DDAR_DevAdd (__PREG(Ser2HSDR)))
+#define DDAR_Ser2HSSPRd	        	/* Ser. port 2 HSSP Read           */ \
+                	(DDAR_DevRd + DDAR_Brst8 + DDAR_8BitDev + \
+                	 DDAR_Ser2ICPRc + DDAR_DevAdd (__PREG(Ser2HSDR)))
+#define DDAR_Ser3UARTWr	        	/* Ser. port 3 UART Write          */ \
+                	(DDAR_DevWr + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser3UARTTr + DDAR_DevAdd (__PREG(Ser3UTDR)))
+#define DDAR_Ser3UARTRd	        	/* Ser. port 3 UART Read           */ \
+                	(DDAR_DevRd + DDAR_Brst4 + DDAR_8BitDev + \
+                	 DDAR_Ser3UARTRc + DDAR_DevAdd (__PREG(Ser3UTDR)))
+#define DDAR_Ser4MCP0Wr	        	/* Ser. port 4 MCP 0 Write (audio) */ \
+                	(DDAR_DevWr + DDAR_Brst4 + DDAR_16BitDev + \
+                	 DDAR_Ser4MCP0Tr + DDAR_DevAdd (__PREG(Ser4MCDR0)))
+#define DDAR_Ser4MCP0Rd	        	/* Ser. port 4 MCP 0 Read (audio)  */ \
+                	(DDAR_DevRd + DDAR_Brst4 + DDAR_16BitDev + \
+                	 DDAR_Ser4MCP0Rc + DDAR_DevAdd (__PREG(Ser4MCDR0)))
+#define DDAR_Ser4MCP1Wr	        	/* Ser. port 4 MCP 1 Write         */ \
+                	        	/* (telecom)                       */ \
+                	(DDAR_DevWr + DDAR_Brst4 + DDAR_16BitDev + \
+                	 DDAR_Ser4MCP1Tr + DDAR_DevAdd (__PREG(Ser4MCDR1)))
+#define DDAR_Ser4MCP1Rd	        	/* Ser. port 4 MCP 1 Read          */ \
+                	        	/* (telecom)                       */ \
+                	(DDAR_DevRd + DDAR_Brst4 + DDAR_16BitDev + \
+                	 DDAR_Ser4MCP1Rc + DDAR_DevAdd (__PREG(Ser4MCDR1)))
+#define DDAR_Ser4SSPWr	        	/* Ser. port 4 SSP Write (16 bits) */ \
+                	(DDAR_DevWr + DDAR_Brst4 + DDAR_16BitDev + \
+                	 DDAR_Ser4SSPTr + DDAR_DevAdd (__PREG(Ser4SSDR)))
+#define DDAR_Ser4SSPRd	        	/* Ser. port 4 SSP Read (16 bits)  */ \
+                	(DDAR_DevRd + DDAR_Brst4 + DDAR_16BitDev + \
+                	 DDAR_Ser4SSPRc + DDAR_DevAdd (__PREG(Ser4SSDR)))
+
+#define DCSR_RUN	0x00000001	/* DMA RUNing                      */
+#define DCSR_IE 	0x00000002	/* DMA Interrupt Enable            */
+#define DCSR_ERROR	0x00000004	/* DMA ERROR                       */
+#define DCSR_DONEA	0x00000008	/* DONE DMA transfer buffer A      */
+#define DCSR_STRTA	0x00000010	/* STaRTed DMA transfer buffer A   */
+#define DCSR_DONEB	0x00000020	/* DONE DMA transfer buffer B      */
+#define DCSR_STRTB	0x00000040	/* STaRTed DMA transfer buffer B   */
+#define DCSR_BIU	0x00000080	/* DMA Buffer In Use               */
+#define DCSR_BufA	(DCSR_BIU*0)	/*  DMA Buffer A in use            */
+#define DCSR_BufB	(DCSR_BIU*1)	/*  DMA Buffer B in use            */
+
+#define DBT_TC  	Fld (13, 0)	/* Transfer Count                  */
+#define DBTA_TCA	DBT_TC  	/* Transfer Count buffer A         */
+#define DBTB_TCB	DBT_TC  	/* Transfer Count buffer B         */
+
+
+/*
+ * Liquid Crystal Display (LCD) control registers
+ *
+ * Registers
+ *    LCCR0     	Liquid Crystal Display (LCD) Control Register 0
+ *              	(read/write).
+ *              	[Bits LDM, BAM, and ERM are only implemented in
+ *              	versions 2.0 (rev. = 8) and higher of the StrongARM
+ *              	SA-1100.]
+ *    LCSR      	Liquid Crystal Display (LCD) Status Register
+ *              	(read/write).
+ *              	[Bit LDD can be only read in versions 1.0 (rev. = 1)
+ *              	and 1.1 (rev. = 2) of the StrongARM SA-1100, it can be
+ *              	read and written (cleared) in versions 2.0 (rev. = 8)
+ *              	and higher.]
+ *    DBAR1     	Liquid Crystal Display (LCD) Direct Memory Access
+ *              	(DMA) Base Address Register channel 1 (read/write).
+ *    DCAR1     	Liquid Crystal Display (LCD) Direct Memory Access
+ *              	(DMA) Current Address Register channel 1 (read).
+ *    DBAR2     	Liquid Crystal Display (LCD) Direct Memory Access
+ *              	(DMA) Base Address Register channel 2 (read/write).
+ *    DCAR2     	Liquid Crystal Display (LCD) Direct Memory Access
+ *              	(DMA) Current Address Register channel 2 (read).
+ *    LCCR1     	Liquid Crystal Display (LCD) Control Register 1
+ *              	(read/write).
+ *              	[The LCCR1 register can be only written in
+ *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
+ *              	StrongARM SA-1100, it can be written and read in
+ *              	versions 2.0 (rev. = 8) and higher.]
+ *    LCCR2     	Liquid Crystal Display (LCD) Control Register 2
+ *              	(read/write).
+ *              	[The LCCR1 register can be only written in
+ *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
+ *              	StrongARM SA-1100, it can be written and read in
+ *              	versions 2.0 (rev. = 8) and higher.]
+ *    LCCR3     	Liquid Crystal Display (LCD) Control Register 3
+ *              	(read/write).
+ *              	[The LCCR1 register can be only written in
+ *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
+ *              	StrongARM SA-1100, it can be written and read in
+ *              	versions 2.0 (rev. = 8) and higher. Bit PCP is only
+ *              	implemented in versions 2.0 (rev. = 8) and higher of
+ *              	the StrongARM SA-1100.]
+ *
+ * Clocks
+ *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
+ *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
+ *    fpix, Tpix	Frequency, period of the pixel clock.
+ *    fln, Tln  	Frequency, period of the line clock.
+ *    fac, Tac  	Frequency, period of the AC bias clock.
+ */
+
+#define LCD_PEntrySp	2       	/* LCD Palette Entry Space [byte]  */
+#define LCD_4BitPSp	        	/* LCD 4-Bit pixel Palette Space   */ \
+                	        	/* [byte]                          */ \
+                	(16*LCD_PEntrySp)
+#define LCD_8BitPSp	        	/* LCD 8-Bit pixel Palette Space   */ \
+                	        	/* [byte]                          */ \
+                	(256*LCD_PEntrySp)
+#define LCD_12_16BitPSp	        	/* LCD 12/16-Bit pixel             */ \
+                	        	/* dummy-Palette Space [byte]      */ \
+                	(16*LCD_PEntrySp)
+
+#define LCD_PGrey	Fld (4, 0)	/* LCD Palette entry Grey value    */
+#define LCD_PBlue	Fld (4, 0)	/* LCD Palette entry Blue value    */
+#define LCD_PGreen	Fld (4, 4)	/* LCD Palette entry Green value   */
+#define LCD_PRed	Fld (4, 8)	/* LCD Palette entry Red value     */
+#define LCD_PBS 	Fld (2, 12)	/* LCD Pixel Bit Size              */
+#define LCD_4Bit	        	/*  LCD 4-Bit pixel mode           */ \
+                	(0 << FShft (LCD_PBS))
+#define LCD_8Bit	        	/*  LCD 8-Bit pixel mode           */ \
+                	(1 << FShft (LCD_PBS))
+#define LCD_12_16Bit	        	/*  LCD 12/16-Bit pixel mode       */ \
+                	(2 << FShft (LCD_PBS))
+
+#define LCD_Int0_0	0x0     	/* LCD Intensity =   0.0% =  0     */
+#define LCD_Int11_1	0x1     	/* LCD Intensity =  11.1% =  1/9   */
+#define LCD_Int20_0	0x2     	/* LCD Intensity =  20.0% =  1/5   */
+#define LCD_Int26_7	0x3     	/* LCD Intensity =  26.7% =  4/15  */
+#define LCD_Int33_3	0x4     	/* LCD Intensity =  33.3% =  3/9   */
+#define LCD_Int40_0	0x5     	/* LCD Intensity =  40.0% =  2/5   */
+#define LCD_Int44_4	0x6     	/* LCD Intensity =  44.4% =  4/9   */
+#define LCD_Int50_0	0x7     	/* LCD Intensity =  50.0% =  1/2   */
+#define LCD_Int55_6	0x8     	/* LCD Intensity =  55.6% =  5/9   */
+#define LCD_Int60_0	0x9     	/* LCD Intensity =  60.0% =  3/5   */
+#define LCD_Int66_7	0xA     	/* LCD Intensity =  66.7% =  6/9   */
+#define LCD_Int73_3	0xB     	/* LCD Intensity =  73.3% = 11/15  */
+#define LCD_Int80_0	0xC     	/* LCD Intensity =  80.0% =  4/5   */
+#define LCD_Int88_9	0xD     	/* LCD Intensity =  88.9% =  8/9   */
+#define LCD_Int100_0	0xE     	/* LCD Intensity = 100.0% =  1     */
+#define LCD_Int100_0A	0xF     	/* LCD Intensity = 100.0% =  1     */
+                	        	/* (Alternative)                   */
+
+#define LCCR0		__REG(0xB0100000)  /* LCD Control Reg. 0 */
+#define LCSR		__REG(0xB0100004)  /* LCD Status Reg. */
+#define DBAR1		__REG(0xB0100010)  /* LCD DMA Base Address Reg. channel 1 */
+#define DCAR1		__REG(0xB0100014)  /* LCD DMA Current Address Reg. channel 1 */
+#define DBAR2		__REG(0xB0100018)  /* LCD DMA Base Address Reg.  channel 2 */
+#define DCAR2		__REG(0xB010001C)  /* LCD DMA Current Address Reg. channel 2 */
+#define LCCR1		__REG(0xB0100020)  /* LCD Control Reg. 1 */
+#define LCCR2		__REG(0xB0100024)  /* LCD Control Reg. 2 */
+#define LCCR3		__REG(0xB0100028)  /* LCD Control Reg. 3 */
+
+#define LCCR0_LEN	0x00000001	/* LCD ENable                      */
+#define LCCR0_CMS	0x00000002	/* Color/Monochrome display Select */
+#define LCCR0_Color	(LCCR0_CMS*0)	/*  Color display                  */
+#define LCCR0_Mono	(LCCR0_CMS*1)	/*  Monochrome display             */
+#define LCCR0_SDS	0x00000004	/* Single/Dual panel display       */
+                	        	/* Select                          */
+#define LCCR0_Sngl	(LCCR0_SDS*0)	/*  Single panel display           */
+#define LCCR0_Dual	(LCCR0_SDS*1)	/*  Dual panel display             */
+#define LCCR0_LDM	0x00000008	/* LCD Disable done (LDD)          */
+                	        	/* interrupt Mask (disable)        */
+#define LCCR0_BAM	0x00000010	/* Base Address update (BAU)       */
+                	        	/* interrupt Mask (disable)        */
+#define LCCR0_ERM	0x00000020	/* LCD ERror (BER, IOL, IUL, IOU,  */
+                	        	/* IUU, OOL, OUL, OOU, and OUU)    */
+                	        	/* interrupt Mask (disable)        */
+#define LCCR0_PAS	0x00000080	/* Passive/Active display Select   */
+#define LCCR0_Pas	(LCCR0_PAS*0)	/*  Passive display (STN)          */
+#define LCCR0_Act	(LCCR0_PAS*1)	/*  Active display (TFT)           */
+#define LCCR0_BLE	0x00000100	/* Big/Little Endian select        */
+#define LCCR0_LtlEnd	(LCCR0_BLE*0)	/*  Little Endian frame buffer     */
+#define LCCR0_BigEnd	(LCCR0_BLE*1)	/*  Big Endian frame buffer        */
+#define LCCR0_DPD	0x00000200	/* Double Pixel Data (monochrome   */
+                	        	/* display mode)                   */
+#define LCCR0_4PixMono	(LCCR0_DPD*0)	/*  4-Pixel/clock Monochrome       */
+                	        	/*  display                        */
+#define LCCR0_8PixMono	(LCCR0_DPD*1)	/*  8-Pixel/clock Monochrome       */
+                	        	/*  display                        */
+#define LCCR0_PDD	Fld (8, 12)	/* Palette DMA request Delay       */
+                	        	/* [Tmem]                          */
+#define LCCR0_DMADel(Tcpu)      	/*  palette DMA request Delay      */ \
+                	        	/*  [0..510 Tcpu]                  */ \
+                	((Tcpu)/2 << FShft (LCCR0_PDD))
+
+#define LCSR_LDD	0x00000001	/* LCD Disable Done                */
+#define LCSR_BAU	0x00000002	/* Base Address Update (read)      */
+#define LCSR_BER	0x00000004	/* Bus ERror                       */
+#define LCSR_ABC	0x00000008	/* AC Bias clock Count             */
+#define LCSR_IOL	0x00000010	/* Input FIFO Over-run Lower       */
+                	        	/* panel                           */
+#define LCSR_IUL	0x00000020	/* Input FIFO Under-run Lower      */
+                	        	/* panel                           */
+#define LCSR_IOU	0x00000040	/* Input FIFO Over-run Upper       */
+                	        	/* panel                           */
+#define LCSR_IUU	0x00000080	/* Input FIFO Under-run Upper      */
+                	        	/* panel                           */
+#define LCSR_OOL	0x00000100	/* Output FIFO Over-run Lower      */
+                	        	/* panel                           */
+#define LCSR_OUL	0x00000200	/* Output FIFO Under-run Lower     */
+                	        	/* panel                           */
+#define LCSR_OOU	0x00000400	/* Output FIFO Over-run Upper      */
+                	        	/* panel                           */
+#define LCSR_OUU	0x00000800	/* Output FIFO Under-run Upper     */
+                	        	/* panel                           */
+
+#define LCCR1_PPL	Fld (6, 4)	/* Pixels Per Line/16 - 1          */
+#define LCCR1_DisWdth(Pixel)    	/*  Display Width [16..1024 pix.]  */ \
+                	(((Pixel) - 16)/16 << FShft (LCCR1_PPL))
+#define LCCR1_HSW	Fld (6, 10)	/* Horizontal Synchronization      */
+                	        	/* pulse Width - 1 [Tpix] (L_LCLK) */
+#define LCCR1_HorSnchWdth(Tpix) 	/*  Horizontal Synchronization     */ \
+                	        	/*  pulse Width [1..64 Tpix]       */ \
+                	(((Tpix) - 1) << FShft (LCCR1_HSW))
+#define LCCR1_ELW	Fld (8, 16)	/* End-of-Line pixel clock Wait    */
+                	        	/* count - 1 [Tpix]                */
+#define LCCR1_EndLnDel(Tpix)    	/*  End-of-Line Delay              */ \
+                	        	/*  [1..256 Tpix]                  */ \
+                	(((Tpix) - 1) << FShft (LCCR1_ELW))
+#define LCCR1_BLW	Fld (8, 24)	/* Beginning-of-Line pixel clock   */
+                	        	/* Wait count - 1 [Tpix]           */
+#define LCCR1_BegLnDel(Tpix)    	/*  Beginning-of-Line Delay        */ \
+                	        	/*  [1..256 Tpix]                  */ \
+                	(((Tpix) - 1) << FShft (LCCR1_BLW))
+
+#define LCCR2_LPP	Fld (10, 0)	/* Line Per Panel - 1              */
+#define LCCR2_DisHght(Line)     	/*  Display Height [1..1024 lines] */ \
+                	(((Line) - 1) << FShft (LCCR2_LPP))
+#define LCCR2_VSW	Fld (6, 10)	/* Vertical Synchronization pulse  */
+                	        	/* Width - 1 [Tln] (L_FCLK)        */
+#define LCCR2_VrtSnchWdth(Tln)  	/*  Vertical Synchronization pulse */ \
+                	        	/*  Width [1..64 Tln]              */ \
+                	(((Tln) - 1) << FShft (LCCR2_VSW))
+#define LCCR2_EFW	Fld (8, 16)	/* End-of-Frame line clock Wait    */
+                	        	/* count [Tln]                     */
+#define LCCR2_EndFrmDel(Tln)    	/*  End-of-Frame Delay             */ \
+                	        	/*  [0..255 Tln]                   */ \
+                	((Tln) << FShft (LCCR2_EFW))
+#define LCCR2_BFW	Fld (8, 24)	/* Beginning-of-Frame line clock   */
+                	        	/* Wait count [Tln]                */
+#define LCCR2_BegFrmDel(Tln)    	/*  Beginning-of-Frame Delay       */ \
+                	        	/*  [0..255 Tln]                   */ \
+                	((Tln) << FShft (LCCR2_BFW))
+
+#define LCCR3_PCD	Fld (8, 0)	/* Pixel Clock Divisor/2 - 2       */
+                	        	/* [1..255] (L_PCLK)               */
+                	        	/* fpix = fcpu/(2*(PCD + 2))       */
+                	        	/* Tpix = 2*(PCD + 2)*Tcpu         */
+#define LCCR3_PixClkDiv(Div)    	/*  Pixel Clock Divisor [6..514]   */ \
+                	(((Div) - 4)/2 << FShft (LCCR3_PCD))
+                	        	/*  fpix = fcpu/(2*Floor (Div/2))  */
+                	        	/*  Tpix = 2*Floor (Div/2)*Tcpu    */
+#define LCCR3_CeilPixClkDiv(Div)	/*  Ceil. of PixClkDiv [6..514]    */ \
+                	(((Div) - 3)/2 << FShft (LCCR3_PCD))
+                	        	/*  fpix = fcpu/(2*Ceil (Div/2))   */
+                	        	/*  Tpix = 2*Ceil (Div/2)*Tcpu     */
+#define LCCR3_ACB	Fld (8, 8)	/* AC Bias clock half period - 1   */
+                	        	/* [Tln] (L_BIAS)                  */
+#define LCCR3_ACBsDiv(Div)      	/*  AC Bias clock Divisor [2..512] */ \
+                	(((Div) - 2)/2 << FShft (LCCR3_ACB))
+                	        	/*  fac = fln/(2*Floor (Div/2))    */
+                	        	/*  Tac = 2*Floor (Div/2)*Tln      */
+#define LCCR3_CeilACBsDiv(Div)  	/*  Ceil. of ACBsDiv [2..512]      */ \
+                	(((Div) - 1)/2 << FShft (LCCR3_ACB))
+                	        	/*  fac = fln/(2*Ceil (Div/2))     */
+                	        	/*  Tac = 2*Ceil (Div/2)*Tln       */
+#define LCCR3_API	Fld (4, 16)	/* AC bias Pin transitions per     */
+                	        	/* Interrupt                       */
+#define LCCR3_ACBsCntOff        	/*  AC Bias clock transition Count */ \
+                	        	/*  Off                            */ \
+                	(0 << FShft (LCCR3_API))
+#define LCCR3_ACBsCnt(Trans)    	/*  AC Bias clock transition Count */ \
+                	        	/*  [1..15]                        */ \
+                	((Trans) << FShft (LCCR3_API))
+#define LCCR3_VSP	0x00100000	/* Vertical Synchronization pulse  */
+                	        	/* Polarity (L_FCLK)               */
+#define LCCR3_VrtSnchH	(LCCR3_VSP*0)	/*  Vertical Synchronization pulse */
+                	        	/*  active High                    */
+#define LCCR3_VrtSnchL	(LCCR3_VSP*1)	/*  Vertical Synchronization pulse */
+                	        	/*  active Low                     */
+#define LCCR3_HSP	0x00200000	/* Horizontal Synchronization      */
+                	        	/* pulse Polarity (L_LCLK)         */
+#define LCCR3_HorSnchH	(LCCR3_HSP*0)	/*  Horizontal Synchronization     */
+                	        	/*  pulse active High              */
+#define LCCR3_HorSnchL	(LCCR3_HSP*1)	/*  Horizontal Synchronization     */
+                	        	/*  pulse active Low               */
+#define LCCR3_PCP	0x00400000	/* Pixel Clock Polarity (L_PCLK)   */
+#define LCCR3_PixRsEdg	(LCCR3_PCP*0)	/*  Pixel clock Rising-Edge        */
+#define LCCR3_PixFlEdg	(LCCR3_PCP*1)	/*  Pixel clock Falling-Edge       */
+#define LCCR3_OEP	0x00800000	/* Output Enable Polarity (L_BIAS, */
+                	        	/* active display mode)            */
+#define LCCR3_OutEnH	(LCCR3_OEP*0)	/*  Output Enable active High      */
+#define LCCR3_OutEnL	(LCCR3_OEP*1)	/*  Output Enable active Low       */
+
+#ifndef __ASSEMBLY__
+extern unsigned int processor_id;
+#endif
+
+#define CPU_REVISION	(processor_id & 15)
+#define CPU_SA1110_A0	(0)
+#define CPU_SA1110_B0	(4)
+#define CPU_SA1110_B1	(5)
+#define CPU_SA1110_B2	(6)
+#define CPU_SA1110_B4	(8)
+
+#define CPU_SA1100_ID	(0x4401a110)
+#define CPU_SA1100_MASK	(0xfffffff0)
+#define CPU_SA1110_ID	(0x6901b110)
+#define CPU_SA1110_MASK	(0xfffffff0)
Index: build_tree/linux/include/asm/arch-sa1100/SA-1101.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/SA-1101.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/SA-1101.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,925 @@
+/*
+ * SA-1101.h
+ *
+ * Copyright (c) Peter Danielsson 1999
+ *
+ * Definition of constants related to the sa1101
+ * support chip for the sa1100
+ *
+ */
+
+
+/* Be sure that virtual mapping is defined right */
+#ifndef __ASM_ARCH_HARDWARE_H
+#error You must include hardware.h not SA-1101.h
+#endif
+
+#ifndef SA1101_BASE
+#error You must define SA-1101 physical base address
+#endif
+
+#ifndef LANGUAGE
+# ifdef __ASSEMBLY__
+#  define LANGUAGE Assembly
+# else
+#  define LANGUAGE C
+# endif
+#endif
+
+/*
+ * We have mapped the sa1101 depending on the value of SA1101_BASE.
+ * It then appears from 0xf4000000.
+ */
+
+#define SA1101_p2v( x )         ((x) - SA1101_BASE + 0xf4000000)
+#define SA1101_v2p( x )         ((x) - 0xf4000000  + SA1101_BASE)
+
+#ifndef SA1101_p2v
+#define SA1101_p2v(PhAdd)  (PhAdd)
+#endif
+
+#include <asm/arch/bitfield.h>
+
+#define C               0
+#define Assembly        1
+
+
+/*
+ * Memory map
+ */
+
+#define __SHMEM_CONTROL0	0x00000000
+#define __SYSTEM_CONTROL1	0x00000400
+#define __ARBITER		0x00020000
+#define __SYSTEM_CONTROL2	0x00040000
+#define __SYSTEM_CONTROL3	0x00060000
+#define __PARALLEL_PORT		0x00080000
+#define __VIDMEM_CONTROL	0x00100000
+#define __UPDATE_FIFO		0x00120000
+#define __SHMEM_CONTROL1	0x00140000
+#define __INTERRUPT_CONTROL	0x00160000
+#define __USB_CONTROL		0x00180000
+#define __TRACK_INTERFACE	0x001a0000
+#define __MOUSE_INTERFACE	0x001b0000
+#define __KEYPAD_INTERFACE	0x001c0000
+#define __PCMCIA_INTERFACE	0x001e0000
+#define	__VGA_CONTROL		0x00200000
+#define __GPIO_INTERFACE	0x00300000
+
+/*
+ * Macro that calculates real address for registers in the SA-1101
+ */
+
+#define _SA1101( x )    ((x) + SA1101_BASE)
+
+/*
+ * Interface and shared memory controller registers
+ *
+ * Registers
+ *	SKCR		SA-1101 control register (read/write)
+ *	SMCR		Shared Memory Controller Register
+ *	SNPR		Snoop Register
+ */
+
+#define _SKCR		_SA1101( 0x00000000 ) /* SA-1101 Control Reg. */
+#define _SMCR		_SA1101( 0x00140000 ) /* Shared Mem. Control Reg. */
+#define _SNPR		_SA1101( 0x00140400 ) /* Snoop Reg. */
+
+#if LANGUAGE == C
+#define SKCR		(*((volatile Word *) SA1101_p2v (_SKCR)))
+#define SMCR		(*((volatile Word *) SA1101_p2v (_SMCR)))
+#define SNPR		(*((volatile Word *) SA1101_p2v (_SNPR)))
+
+#define SKCR_PLLEn	  0x0001	  /* Enable On-Chip PLL */
+#define SKCR_BCLKEn	  0x0002	  /* Enables BCLK */
+#define SKCR_Sleep	  0x0004	  /* Sleep Mode */
+#define SKCR_IRefEn	  0x0008	  /* DAC Iref input enable */
+#define SKCR_VCOON	  0x0010	  /* VCO bias */
+#define SKCR_ScanTestEn	  0x0020	  /* Enables scan test */
+#define SKCR_ClockTestEn  0x0040	  /* Enables clock test */
+
+#define SMCR_DCAC	  Fld(2,0)	  /* Number of column address bits */
+#define SMCR_DRAC	  Fld(2,2)	  /* Number of row address bits */
+#define SMCR_ArbiterBias  0x0008	  /* favor video or USB */
+#define SMCR_TopVidMem	  Fld(4,5)	  /* Top 4 bits of vidmem addr. */
+
+#define SMCR_ColAdrBits( x )		  /* col. addr bits 8..11 */ \
+	(( (x) - 8 ) << FShft (SMCR_DCAC))
+#define SMCR_RowAdrBits( x )		  /* row addr bits 9..12 */\
+	(( (x) - 9 ) << FShft (SMCR_DRAC)
+
+#define SNPR_VFBstart	  Fld(12,0)	/* Video frame buffer addr */
+#define SNPR_VFBsize	  Fld(11,12)	/* Video frame buffer size */
+#define SNPR_WholeBank	  (1 << 23)	/* Whole bank bit */
+#define SNPR_BankSelect	  Fld(2,27)	/* Bank select */
+#define SNPR_SnoopEn	  (1 << 31)	/* Enable snoop operation */
+
+#define SNPR_Set_VFBsize( x )   /* set frame buffer size (in kb) */ \
+	( (x) << FShft (SNPR_VFBsize))
+#define SNPR_Select_Bank(x)     /* select bank 0 or 1 */  \
+	(( (x) + 1 ) << FShft (SNPR_BankSelect ))
+
+#endif /* LANGUAGE == C */
+
+/*
+ * Video Memory Controller
+ *
+ * Registers
+ *    VMCCR	Configuration register
+ *    VMCAR	VMC address register
+ *    VMCDR	VMC data register
+ *
+ */
+
+#define _VMCCR		_SA1101( 0x00100000 )	/* Configuration register */
+#define _VMCAR		_SA1101( 0x00101000 )	/* VMC address register */
+#define _VMCDR		_SA1101( 0x00101400 )	/* VMC data register */
+
+#if LANGUAGE == C
+#define VMCCR		(*((volatile Word *) SA1101_p2v (_VMCCR)))
+#define VMCAR		(*((volatile Word *) SA1101_p2v (_VMCAR)))
+#define VMCDR		(*((volatile Word *) SA1101_p2v (_VMCDR)))
+
+#define VMCCR_RefreshEn	    0x0000	  /* Enable memory refresh */
+#define VMCCR_Config	    0x0001	  /* DRAM size */
+#define VMCCR_RefPeriod	    Fld(2,3)	  /* Refresh period */
+#define VMCCR_StaleDataWait Fld(4,5)	  /* Stale FIFO data timeout counter */
+#define VMCCR_SleepState    (1<<9)	  /* State of interface pins in sleep*/
+#define VMCCR_RefTest	    (1<<10)	  /* refresh test */
+#define VMCCR_RefLow	    Fld(6,11)	  /* refresh low counter */
+#define VMCCR_RefHigh	    Fld(7,17)	  /* refresh high counter */
+#define VMCCR_SDTCTest	    Fld(7,24)	  /* stale data timeout counter */
+#define VMCCR_ForceSelfRef  (1<<31)	  /* Force self refresh */
+
+#endif LANGUAGE == C
+
+
+/* Update FIFO
+ *
+ * Registers
+ *    UFCR	Update FIFO Control Register
+ *    UFSR	Update FIFO Status Register
+ *    UFLVLR	update FIFO level register
+ *    UFDR	update FIFO data register
+ */
+
+#define _UFCR	_SA1101(0x00120000)   /* Update FIFO Control Reg. */
+#define _UFSR	_SA1101(0x00120400)   /* Update FIFO Status Reg. */	
+#define _UFLVLR	_SA1101(0x00120800)   /* Update FIFO level reg. */
+#define _UFDR	_SA1101(0x00120c00)   /* Update FIFO data reg. */
+
+#if LANGUAGE == C
+
+#define UFCR 	(*((volatile Word *) SA1101_p2v (_UFCR)))
+#define UFSR	(*((volatile Word *) SA1101_p2v (_UFSR)))
+#define UFLVLR	(*((volatile Word *) SA1101_p2v (_UFLVLR))) 
+#define UFDR	(*((volatile Word *) SA1101_p2v (_UFDR)))
+
+
+#define UFCR_FifoThreshhold	Fld(7,0)	/* Level for FifoGTn flag */
+
+#define UFSR_FifoGTnFlag	0x01		/* FifoGTn flag */#define UFSR_FifoEmpty		0x80		/* FIFO is empty */
+
+#endif /* LANGUAGE == C */
+
+/* System Controller
+ *
+ * Registers
+ *    SKPCR	Power Control Register
+ *    SKCDR	Clock Divider Register
+ *    DACDR1	DAC1 Data register
+ *    DACDR2	DAC2 Data register
+ */
+
+#define _SKPCR		_SA1101(0x00000400)
+#define _SKCDR		_SA1101(0x00040000)
+#define _DACDR1		_SA1101(0x00060000)
+#define _DACDR2		_SA1101(0x00060400)
+
+#if LANGUAGE == C
+#define SKPCR 	(*((volatile Word *) SA1101_p2v (_SKPCR)))
+#define SKCDR	(*((volatile Word *) SA1101_p2v (_SKCDR)))
+#define DACDR1	(*((volatile Word *) SA1101_p2v (_DACDR1)))
+#define DACDR2	(*((volatile Word *) SA1101_p2v (_DACDR2)))
+
+#define SKPCR_UCLKEn	     0x01    /* USB Enable */
+#define SKPCR_PCLKEn	     0x02    /* PS/2 Enable */
+#define SKPCR_ICLKEn	     0x04    /* Interrupt Controller Enable */
+#define SKPCR_VCLKEn	     0x08    /* Video Controller Enable */
+#define SKPCR_PICLKEn	     0x10    /* parallel port Enable */
+#define SKPCR_DCLKEn	     0x20    /* DACs Enable */
+#define SKPCR_nKPADEn	     0x40    /* Multiplexer */
+
+#define SKCDR_PLLMul	     Fld(7,0)	/* PLL Multiplier */
+#define SKCDR_VCLKEn	     Fld(2,7)	/* Video controller clock divider */
+#define SKDCR_BCLKEn	     (1<<9)	/* BCLK Divider */
+#define SKDCR_UTESTCLKEn     (1<<10)	/* Route USB clock during test mode */
+#define SKDCR_DivRValue	     Fld(6,11)	/* Input clock divider for PLL */
+#define SKDCR_DivNValue	     Fld(5,17)	/* Output clock divider for PLL */
+#define SKDCR_PLLRSH	     Fld(3,22)	/* PLL bandwidth control */
+#define SKDCR_ChargePump     (1<<25)	/* Charge pump control */
+#define SKDCR_ClkTestMode    (1<<26)	/* Clock output test mode */
+#define SKDCR_ClkTestEn	     (1<<27)	/* Test clock generator */
+#define SKDCR_ClkJitterCntl  Fld(3,28)	/* video clock jitter compensation */
+
+#define DACDR_DACCount	     Fld(8,0)	/* Count value */
+#define DACDR1_DACCount	     DACDR_DACCount
+#define DACDR2_DACCount	     DACDR_DACCount
+
+#endif /* LANGUAGE == C */
+
+/*
+ * Parallel Port Interface
+ *
+ * Registers
+ *    IEEE_Config	IEEE mode selection and programmable attributes
+ *    IEEE_Control	Controls the states of IEEE port control outputs
+ *    IEEE_Data		Forward transfer data register
+ *    IEEE_Addr		Forward transfer address register
+ *    IEEE_Status	Port IO signal status register
+ *    IEEE_IntStatus	Port interrupts status register
+ *    IEEE_FifoLevels   Rx and Tx FIFO interrupt generation levels
+ *    IEEE_InitTime	Forward timeout counter initial value
+ *    IEEE_TimerStatus	Forward timeout counter current value
+ *    IEEE_FifoReset	Reset forward transfer FIFO
+ *    IEEE_ReloadValue	Counter reload value
+ *    IEEE_TestControl	Control testmode
+ *    IEEE_TestDataIn	Test data register
+ *    IEEE_TestDataInEn	Enable test data
+ *    IEEE_TestCtrlIn	Test control signals
+ *    IEEE_TestCtrlInEn	Enable test control signals
+ *    IEEE_TestDataStat	Current data bus value
+ *
+ */
+
+/*
+ * The control registers are defined as offsets from a base address 
+ */
+ 
+#define _IEEE( x ) _SA1101( (x) + __PARALLEL_PORT )
+
+#define _IEEE_Config	    _IEEE( 0x0000 )
+#define _IEEE_Control	    _IEEE( 0x0400 )
+#define _IEEE_Data	    _IEEE( 0x4000 )
+#define _IEEE_Addr	    _IEEE( 0x0800 )
+#define _IEEE_Status	    _IEEE( 0x0c00 )
+#define _IEEE_IntStatus	    _IEEE( 0x1000 )
+#define _IEEE_FifoLevels    _IEEE( 0x1400 )
+#define _IEEE_InitTime	    _IEEE( 0x1800 )
+#define _IEEE_TimerStatus   _IEEE( 0x1c00 )
+#define _IEEE_FifoReset	    _IEEE( 0x2000 )
+#define _IEEE_ReloadValue   _IEEE( 0x3c00 )
+#define _IEEE_TestControl   _IEEE( 0x2400 )
+#define _IEEE_TestDataIn    _IEEE( 0x2800 )
+#define _IEEE_TestDataInEn  _IEEE( 0x2c00 )
+#define _IEEE_TestCtrlIn    _IEEE( 0x3000 )
+#define _IEEE_TestCtrlInEn  _IEEE( 0x3400 )
+#define _IEEE_TestDataStat  _IEEE( 0x3800 )
+ 
+
+#if LANGUAGE == C
+#define IEEE_Config	    (*((volatile Word *) SA1101_p2v (_IEEE_Config)))
+#define IEEE_Control	    (*((volatile Word *) SA1101_p2v (_IEEE_Control)))
+#define IEEE_Data	    (*((volatile Word *) SA1101_p2v (_IEEE_Data)))
+#define IEEE_Addr	    (*((volatile Word *) SA1101_p2v (_IEEE_Addr)))
+#define IEEE_Status	    (*((volatile Word *) SA1101_p2v (_IEEE_Status)))
+#define IEEE_IntStatus	    (*((volatile Word *) SA1101_p2v (_IEEE_IntStatus)))
+#define IEEE_FifoLevels	    (*((volatile Word *) SA1101_p2v (_IEEE_FifoLevels)))
+#define IEEE_InitTime	    (*((volatile Word *) SA1101_p2v (_IEEE_InitTime)))
+#define IEEE_TimerStatus    (*((volatile Word *) SA1101_p2v (_IEEE_TimerStatus)))
+#define IEEE_FifoReset	    (*((volatile Word *) SA1101_p2v (_IEEE_FifoReset)))
+#define IEEE_ReloadValue    (*((volatile Word *) SA1101_p2v (_IEEE_ReloadValue)))
+#define IEEE_TestControl    (*((volatile Word *) SA1101_p2v (_IEEE_TestControl)))
+#define IEEE_TestDataIn     (*((volatile Word *) SA1101_p2v (_IEEE_TestDataIn)))
+#define IEEE_TestDataInEn   (*((volatile Word *) SA1101_p2v (_IEEE_TestDataInEn)))
+#define IEEE_TestCtrlIn     (*((volatile Word *) SA1101_p2v (_IEEE_TestCtrlIn)))
+#define IEEE_TestCtrlInEn   (*((volatile Word *) SA1101_p2v (_IEEE_TestCtrlInEn)))
+#define IEEE_TestDataStat   (*((volatile Word *) SA1101_p2v (_IEEE_TestDataStat)))
+
+
+#define IEEE_Config_M	    Fld(3,0)	 /* Mode select */
+#define IEEE_Config_D	    0x04	 /* FIFO access enable */
+#define IEEE_Config_B	    0x08	 /* 9-bit word enable */
+#define IEEE_Config_T	    0x10	 /* Data transfer enable */
+#define IEEE_Config_A	    0x20	 /* Data transfer direction */
+#define IEEE_Config_E	    0x40	 /* Timer enable */
+#define IEEE_Control_A	    0x08	 /* AutoFd output */
+#define IEEE_Control_E	    0x04	 /* Selectin output */
+#define IEEE_Control_T	    0x02	 /* Strobe output */
+#define IEEE_Control_I	    0x01	 /* Port init output */
+#define IEEE_Data_C	    (1<<31)	 /* Byte count */
+#define IEEE_Data_Db	    Fld(9,16)	 /* Data byte 2 */
+#define IEEE_Data_Da	    Fld(9,0)	 /* Data byte 1 */
+#define IEEE_Addr_A	    Fld(8,0)	 /* forward address transfer byte */
+#define IEEE_Status_A	    0x0100	 /* nAutoFd port output status */
+#define IEEE_Status_E	    0x0080	 /* nSelectIn port output status */
+#define IEEE_Status_T	    0x0040	 /* nStrobe port output status */
+#define IEEE_Status_I	    0x0020	 /* nInit port output status */
+#define IEEE_Status_B	    0x0010	 /* Busy port inout status */
+#define IEEE_Status_S	    0x0008	 /* Select port input status */
+#define IEEE_Status_K	    0x0004	 /* nAck port input status */
+#define IEEE_Status_F	    0x0002	 /* nFault port input status */
+#define IEEE_Status_R	    0x0001	 /* pError port input status */
+
+#define IEEE_IntStatus_IntReqDat	 0x0100
+#define IEEE_IntStatus_IntReqEmp	 0x0080
+#define IEEE_IntStatus_IntReqInt	 0x0040
+#define IEEE_IntStatus_IntReqRav	 0x0020
+#define IEEE_IntStatus_IntReqTim	 0x0010
+#define IEEE_IntStatus_RevAddrComp	 0x0008
+#define IEEE_IntStatus_RevDataComp	 0x0004
+#define IEEE_IntStatus_FwdAddrComp	 0x0002
+#define IEEE_IntStatus_FwdDataComp	 0x0001
+#define IEEE_FifoLevels_RevFifoLevel	 2
+#define IEEE_FifoLevels_FwdFifoLevel	 1
+#define IEEE_InitTime_TimValInit	 Fld(22,0)
+#define IEEE_TimerStatus_TimValStat	 Fld(22,0)
+#define IEEE_ReloadValue_Reload		 Fld(4,0)
+
+#define IEEE_TestControl_RegClk		 0x04
+#define IEEE_TestControl_ClockSelect	 Fld(2,1)
+#define IEEE_TestControl_TimerTestModeEn 0x01
+#define IEEE_TestCtrlIn_PError		 0x10
+#define IEEE_TestCtrlIn_nFault		 0x08
+#define IEEE_TestCtrlIn_nAck		 0x04
+#define IEEE_TestCtrlIn_PSel		 0x02
+#define IEEE_TestCtrlIn_Busy		 0x01
+
+#endif /* LANGUAGE == C */
+
+/*
+ * VGA Controller
+ *
+ * Registers
+ *    VideoControl	Video Control Register
+ *    VgaTiming0	VGA Timing Register 0
+ *    VgaTiming1	VGA Timing Register 1
+ *    VgaTiming2	VGA Timing Register 2
+ *    VgaTiming3	VGA Timing Register 3
+ *    VgaBorder		VGA Border Color Register
+ *    VgaDBAR		VGADMA Base Address Register
+ *    VgaDCAR		VGADMA Channel Current Address Register
+ *    VgaStatus		VGA Status Register
+ *    VgaInterruptMask	VGA Interrupt Mask Register
+ *    VgaPalette	VGA Palette Registers
+ *    DacControl	DAC Control Register
+ *    VgaTest		VGA Controller Test Register
+ */
+
+#define _VGA( x )	_SA1101( ( x ) + __VGA_CONTROL )
+
+#define _VideoControl	    _VGA( 0x0000 )
+#define _VgaTiming0	    _VGA( 0x0400 )
+#define _VgaTiming1	    _VGA( 0x0800 )
+#define _VgaTiming2	    _VGA( 0x0c00 )
+#define _VgaTiming3	    _VGA( 0x1000 )
+#define _VgaBorder	    _VGA( 0x1400 )
+#define _VgaDBAR	    _VGA( 0x1800 )
+#define _VgaDCAR	    _VGA( 0x1c00 )
+#define _VgaStatus	    _VGA( 0x2000 )
+#define _VgaInterruptMask   _VGA( 0x2400 )
+#define _VgaPalette	    _VGA( 0x40000 )
+#define _DacControl	    _VGA( 0x3000 )
+#define _VgaTest	    _VGA( 0x2c00 )
+
+#if (LANGUAGE == C)
+#define VideoControl   (*((volatile Word *) SA1101_p2v (_VideoControl)))
+#define VgaTiming0     (*((volatile Word *) SA1101_p2v (_VgaTiming0)))
+#define VgaTiming1     (*((volatile Word *) SA1101_p2v (_VgaTiming1)))
+#define VgaTiming2     (*((volatile Word *) SA1101_p2v (_VgaTiming2)))
+#define VgaTiming3     (*((volatile Word *) SA1101_p2v (_VgaTiming3)))
+#define VgaBorder      (*((volatile Word *) SA1101_p2v (_VgaBorder)))
+#define VgaDBAR	       (*((volatile Word *) SA1101_p2v (_VgaDBAR)))
+#define VgaDCAR	       (*((volatile Word *) SA1101_p2v (_VgaDCAR)))
+#define VgaStatus      (*((volatile Word *) SA1101_p2v (_VgaStatus)))
+#define VgaInterruptMask (*((volatile Word *) SA1101_p2v (_VgaInterruptMask)))
+#define VgaPalette     (*((volatile Word *) SA1101_p2v (_VgaPalette)))
+#define DacControl     (*((volatile Word *) SA1101_p2v (_DacControl))
+#define VgaTest        (*((volatile Word *) SA1101_p2v (_VgaTest)))
+
+#define VideoControl_VgaEn    0x00000000
+#define VideoControl_BGR      0x00000001
+#define VideoControl_VCompVal Fld(2,2)
+#define VideoControl_VgaReq   Fld(4,4)
+#define VideoControl_VBurstL  Fld(4,8)
+#define VideoControl_VMode    (1<<12)
+#define VideoControl_PalRead  (1<<13)
+
+#define VgaTiming0_PPL	      Fld(6,2)
+#define VgaTiming0_HSW	      Fld(8,8)
+#define VgaTiming0_HFP	      Fld(8,16)
+#define VgaTiming0_HBP	      Fld(8,24)
+
+#define VgaTiming1_LPS	      Fld(10,0)
+#define VgaTiming1_VSW	      Fld(6,10)
+#define VgaTiming1_VFP	      Fld(8,16)
+#define VgaTiming1_VBP	      Fld(8,24)
+
+#define VgaTiming2_IVS	      0x01
+#define VgaTiming2_IHS	      0x02
+#define VgaTiming2_CVS	      0x04
+#define VgaTiming2_CHS	      0x08
+
+#define VgaTiming3_HBS	      Fld(8,0)
+#define VgaTiming3_HBE	      Fld(8,8)
+#define VgaTiming3_VBS	      Fld(8,16)
+#define VgaTiming3_VBE	      Fld(8,24)
+
+#define VgaBorder_BCOL	      Fld(24,0)
+
+#define VgaStatus_VFUF	      0x01
+#define VgaStatus_VNext	      0x02
+#define VgaStatus_VComp	      0x04
+
+#define VgaInterruptMask_VFUFMask   0x00
+#define VgaInterruptMask_VNextMask  0x01
+#define VgaInterruptMask_VCompMask  0x02
+
+#define VgaPalette_R	      Fld(8,0)
+#define VgaPalette_G	      Fld(8,8)
+#define VgaPalette_B	      Fld(8,16)
+
+#define DacControl_DACON      0x0001
+#define DacControl_COMPON     0x0002
+#define DacControl_PEDON      0x0004
+#define DacControl_RTrim      Fld(5,4)
+#define DacControl_GTrim      Fld(5,9)
+#define DacControl_BTrim      Fld(5,14)
+
+#define VgaTest_TDAC	      0x00
+#define VgaTest_Datatest      Fld(4,1)
+#define VgaTest_DACTESTDAC    0x10
+#define VgaTest_DACTESTOUT    Fld(3,5)
+
+#endif /* LANGUAGE == C */
+
+/*
+ * USB Host Interface Controller
+ *
+ * Registers
+ *    Revision
+ *    Control
+ *    CommandStatus
+ *    InterruptStatus
+ *    InterruptEnable
+ *    HCCA
+ *    PeriodCurrentED
+ *    ControlHeadED
+ *    BulkHeadED
+ *    BulkCurrentED
+ *    DoneHead
+ *    FmInterval
+ *    FmRemaining
+ *    FmNumber
+ *    PeriodicStart
+ *    LSThreshold
+ *    RhDescriptorA
+ *    RhDescriptorB
+ *    RhStatus
+ *    RhPortStatus
+ *    USBStatus
+ *    USBReset
+ *    USTAR
+ *    USWER
+ *    USRFR
+ *    USNFR
+ *    USTCSR
+ *    USSR
+ *    
+ */
+
+#define _USB( x )	_SA1101( ( x ) + __USB_CONTROL )
+
+
+#define _Revision	  _USB( 0x0000 )
+#define _Control	  _USB( 0x0888 )
+#define _CommandStatus	  _USB( 0x0c00 )
+#define _InterruptStatus  _USB( 0x1000 )
+#define _InterruptEnable  _USB( 0x1400 )
+#define _HCCA		  _USB( 0x1800 )
+#define _PeriodCurrentED  _USB( 0x1c00 )
+#define _ControlHeadED	  _USB( 0x2000 )
+#define _BulkHeadED	  _USB( 0x2800 )
+#define _BulkCurrentED	  _USB( 0x2c00 )
+#define _DoneHead	  _USB( 0x3000 )
+#define _FmInterval	  _USB( 0x3400 )
+#define _FmRemaining	  _USB( 0x3800 )
+#define _FmNumber	  _USB( 0x3c00 )
+#define _PeriodicStart	  _USB( 0x4000 )
+#define _LSThreshold	  _USB( 0x4400 )
+#define _RhDescriptorA	  _USB( 0x4800 )
+#define _RhDescriptorB	  _USB( 0x4c00 )
+#define _RhStatus	  _USB( 0x5000 )
+#define _RhPortStatus	  _USB( 0x5400 )
+#define _USBStatus	  _USB( 0x11800 )
+#define _USBReset	  _USB( 0x11c00 )
+
+#define _USTAR		  _USB( 0x10400 )
+#define _USWER		  _USB( 0x10800 )
+#define _USRFR		  _USB( 0x10c00 )
+#define _USNFR		  _USB( 0x11000 )
+#define _USTCSR		  _USB( 0x11400 )
+#define _USSR		  _USB( 0x11800 )
+
+
+#if (LANGUAGE == C)
+
+#define Revision	(*((volatile Word *) SA1101_p2v (_Revision)))
+#define Control		(*((volatile Word *) SA1101_p2v (_Control)))
+#define CommandStatus	(*((volatile Word *) SA1101_p2v (_CommandStatus)))
+#define InterruptStatus	(*((volatile Word *) SA1101_p2v (_InterruptStatus)))
+#define InterruptEnable	(*((volatile Word *) SA1101_p2v (_InterruptEnable)))
+#define HCCA		(*((volatile Word *) SA1101_p2v (_HCCA)))
+#define PeriodCurrentED	(*((volatile Word *) SA1101_p2v (_PeriodCurrentED)))
+#define ControlHeadED	(*((volatile Word *) SA1101_p2v (_ControlHeadED)))
+#define BulkHeadED	(*((volatile Word *) SA1101_p2v (_BulkHeadED)))
+#define BulkCurrentED	(*((volatile Word *) SA1101_p2v (_BulkCurrentED)))
+#define DoneHead	(*((volatile Word *) SA1101_p2v (_DoneHead)))
+#define FmInterval	(*((volatile Word *) SA1101_p2v (_FmInterval)))
+#define FmRemaining	(*((volatile Word *) SA1101_p2v (_FmRemaining)))
+#define FmNumber	(*((volatile Word *) SA1101_p2v (_FmNumber)))
+#define PeriodicStart	(*((volatile Word *) SA1101_p2v (_PeriodicStart)))
+#define LSThreshold	(*((volatile Word *) SA1101_p2v (_LSThreshold)))
+#define RhDescriptorA	(*((volatile Word *) SA1101_p2v (_RhDescriptorA)))
+#define RhDescriptorB	(*((volatile Word *) SA1101_p2v (_RhDescriptorB)))
+#define RhStatus	(*((volatile Word *) SA1101_p2v (_RhStatus)))
+#define RhPortStatus	(*((volatile Word *) SA1101_p2v (_RhPortStatus)))
+#define USBStatus	(*((volatile Word *) SA1101_p2v (_USBStatus)))
+#define USBReset	(*((volatile Word *) SA1101_p2v (_USBReset)))
+#define USTAR		(*((volatile Word *) SA1101_p2v (_USTAR)))
+#define USWER		(*((volatile Word *) SA1101_p2v (_USWER)))
+#define USRFR		(*((volatile Word *) SA1101_p2v (_USRFR)))
+#define USNFR		(*((volatile Word *) SA1101_p2v (_USNFR)))
+#define USTCSR		(*((volatile Word *) SA1101_p2v (_USTCSR)))
+#define USSR		(*((volatile Word *) SA1101_p2v (_USSR)))
+
+
+#define USBStatus_IrqHciRmtWkp	     (1<<7)
+#define USBStatus_IrqHciBuffAcc	     (1<<8)
+#define USBStatus_nIrqHciM	     (1<<9)
+#define USBStatus_nHciMFClr	     (1<<10)
+
+#define USBReset_ForceIfReset	     0x01
+#define USBReset_ForceHcReset	     0x02
+#define USBReset_ClkGenReset	     0x04
+
+#define USTCR_RdBstCntrl	     Fld(3,0)
+#define USTCR_ByteEnable	     Fld(4,3)
+#define USTCR_WriteEn		     (1<<7)
+#define USTCR_FifoCir		     (1<<8)
+#define USTCR_TestXferSel	     (1<<9)
+#define USTCR_FifoCirAtEnd	     (1<<10)
+#define USTCR_nSimScaleDownClk	     (1<<11)
+
+#define USSR_nAppMDEmpty	     0x01
+#define USSR_nAppMDFirst	     0x02
+#define USSR_nAppMDLast		     0x04
+#define USSR_nAppMDFull		     0x08
+#define USSR_nAppMAFull		     0x10
+#define USSR_XferReq		     0x20
+#define USSR_XferEnd		     0x40
+
+#endif /* LANGUAGE == C */
+
+
+/*
+ * Interrupt Controller
+ *
+ * Registers
+ *    INTTEST0		Test register 0
+ *    INTTEST1		Test register 1
+ *    INTENABLE0	Interrupt Enable register 0
+ *    INTENABLE1	Interrupt Enable register 1
+ *    INTPOL0		Interrupt Polarity selection 0
+ *    INTPOL1		Interrupt Polarity selection 1
+ *    INTTSTSEL		Interrupt source selection
+ *    INTSTATCLR0	Interrupt Status 0
+ *    INTSTATCLR1	Interrupt Status 1
+ *    INTSET0		Interrupt Set 0
+ *    INTSET1		Interrupt Set 1
+ */
+
+#define _INT( x )	_SA1101( ( x ) + __INTERRUPT_CONTROL)
+
+#define _INTTEST0	_INT( 0x1000 )
+#define _INTTEST1	_INT( 0x1400 )
+#define _INTENABLE0	_INT( 0x2000 )
+#define _INTENABLE1	_INT( 0x2400 )
+#define _INTPOL0	_INT( 0x3000 )
+#define _INTPOL1	_INT( 0x3400 )
+#define _INTTSTSEL     	_INT( 0x5000 )
+#define _INTSTATCLR0	_INT( 0x6000 )
+#define _INTSTATCLR1	_INT( 0x6400 )
+#define _INTSET0	_INT( 0x7000 )
+#define _INTSET1	_INT( 0x7400 )
+
+#if ( LANGUAGE == C )
+#define INTTEST0	(*((volatile Word *) SA1101_p2v (_INTTEST0)))
+#define INTTEST1	(*((volatile Word *) SA1101_p2v (_INTTEST1)))
+#define INTENABLE0	(*((volatile Word *) SA1101_p2v (_INTENABLE0)))
+#define INTENABLE1	(*((volatile Word *) SA1101_p2v (_INTENABLE1)))
+#define INTPOL0		(*((volatile Word *) SA1101_p2v (_INTPOL0)))
+#define INTPOL1		(*((volatile Word *) SA1101_p2v (_INTPOL1)))
+#define INTTSTSEL	(*((volatile Word *) SA1101_p2v (_INTTSTSEL)))
+#define INTSTATCLR0	(*((volatile Word *) SA1101_p2v (_INTSTATCLR0)))
+#define INTSTATCLR1	(*((volatile Word *) SA1101_p2v (_INTSTATCLR1)))
+#define INTSET0		(*((volatile Word *) SA1101_p2v (_INTSET0)))
+#define INTSET1		(*((volatile Word *) SA1101_p2v (_INTSET1)))
+
+#endif /* LANGUAGE == C */
+
+/*
+ * PS/2 Trackpad and Mouse Interfaces
+ *
+ * Registers   (prefix kbd applies to trackpad interface, mse to mouse)
+ *    KBDCR		Control Register
+ *    KBDSTAT		Status Register
+ *    KBDDATA		Transmit/Receive Data register
+ *    KBDCLKDIV		Clock Division Register
+ *    KBDPRECNT		Clock Precount Register
+ *    KBDTEST1		Test register 1
+ *    KBDTEST2		Test register 2
+ *    KBDTEST3		Test register 3
+ *    KBDTEST4		Test register 4
+ *    MSECR	
+ *    MSESTAT
+ *    MSEDATA
+ *    MSECLKDIV
+ *    MSEPRECNT
+ *    MSETEST1
+ *    MSETEST2
+ *    MSETEST3
+ *    MSETEST4
+ *     
+ */
+
+#define _KBD( x )	_SA1101( ( x ) + __TRACK_INTERFACE )
+#define _MSE( x )	_SA1101( ( x ) + __MOUSE_INTERFACE )
+
+#define _KBDCR		_KBD( 0x0000 )
+#define _KBDSTAT	_KBD( 0x0400 )
+#define _KBDDATA	_KBD( 0x0800 )
+#define _KBDCLKDIV	_KBD( 0x0c00 )
+#define _KBDPRECNT	_KBD( 0x1000 )
+#define	_KBDTEST1	_KBD( 0x2000 )
+#define _KBDTEST2	_KBD( 0x2400 )
+#define _KBDTEST3	_KBD( 0x2800 )
+#define _KBDTEST4	_KBD( 0x2c00 )
+#define _MSECR		_MSE( 0x0000 )
+#define _MSESTAT	_MSE( 0x0400 )
+#define _MSEDATA	_MSE( 0x0800 )
+#define _MSECLKDIV	_MSE( 0x0c00 )
+#define _MSEPRECNT	_MSE( 0x1000 )
+#define	_MSETEST1	_MSE( 0x2000 )
+#define _MSETEST2	_MSE( 0x2400 )
+#define _MSETEST3	_MSE( 0x2800 )
+#define _MSETEST4	_MSE( 0x2c00 )
+
+#if ( LANGUAGE == C )
+
+#define KBDCR	    (*((volatile Word *) SA1101_p2v (_KBDCR)))
+#define KBDSTAT	    (*((volatile Word *) SA1101_p2v (_KBDSTAT)))
+#define KBDDATA	    (*((volatile Word *) SA1101_p2v (_KBDDATA)))
+#define KBDCLKDIV   (*((volatile Word *) SA1101_p2v (_KBDCLKDIV)))
+#define KBDPRECNT   (*((volatile Word *) SA1101_p2v (_KBDPRECNT)))
+#define KBDTEST1    (*((volatile Word *) SA1101_p2v (_KBDTEST1)))
+#define KBDTEST2    (*((volatile Word *) SA1101_p2v (_KBDTEST2)))
+#define KBDTEST3    (*((volatile Word *) SA1101_p2v (_KBDTEST3)))
+#define KBDTEST4    (*((volatile Word *) SA1101_p2v (_KBDTEST4)))
+#define MSECR	    (*((volatile Word *) SA1101_p2v (_MSECR)))
+#define MSESTAT	    (*((volatile Word *) SA1101_p2v (_MSESTAT)))
+#define MSEDATA	    (*((volatile Word *) SA1101_p2v (_MSEDATA)))
+#define MSECLKDIV   (*((volatile Word *) SA1101_p2v (_MSECLKDIV)))
+#define MSEPRECNT   (*((volatile Word *) SA1101_p2v (_MSEPRECNT)))
+#define MSETEST1    (*((volatile Word *) SA1101_p2v (_MSETEST1)))
+#define MSETEST2    (*((volatile Word *) SA1101_p2v (_MSETEST2)))
+#define MSETEST3    (*((volatile Word *) SA1101_p2v (_MSETEST3)))
+#define MSETEST4    (*((volatile Word *) SA1101_p2v (_MSETEST4)))
+
+
+#define KBDCR_ENA		 0x08
+#define KBDCR_FKD		 0x02
+#define KBDCR_FKC		 0x01
+
+#define KBDSTAT_TXE		 0x80
+#define KBDSTAT_TXB		 0x40
+#define KBDSTAT_RXF		 0x20
+#define KBDSTAT_RXB		 0x10
+#define KBDSTAT_ENA		 0x08
+#define KBDSTAT_RXP		 0x04
+#define KBDSTAT_KBD		 0x02
+#define KBDSTAT_KBC		 0x01
+
+#define KBDCLKDIV_DivVal	 Fld(4,0)
+
+#define MSECR_ENA		 0x08
+#define MSECR_FKD		 0x02
+#define MSECR_FKC		 0x01
+
+#define MSESTAT_TXE		 0x80
+#define MSESTAT_TXB		 0x40
+#define MSESTAT_RXF		 0x20
+#define MSESTAT_RXB		 0x10
+#define MSESTAT_ENA		 0x08
+#define MSESTAT_RXP		 0x04	
+#define MSESTAT_MSD		 0x02
+#define MSESTAT_MSC		 0x01
+
+#define MSECLKDIV_DivVal	 Fld(4,0)
+
+#define KBDTEST1_CD		 0x80
+#define KBDTEST1_RC1		 0x40
+#define KBDTEST1_MC		 0x20
+#define KBDTEST1_C		 Fld(2,3)
+#define KBDTEST1_T2		 0x40
+#define KBDTEST1_T1		 0x20
+#define KBDTEST1_T0		 0x10
+#define KBDTEST2_TICBnRES	 0x08
+#define KBDTEST2_RKC		 0x04
+#define KBDTEST2_RKD		 0x02
+#define KBDTEST2_SEL		 0x01
+#define KBDTEST3_ms_16		 0x80
+#define KBDTEST3_us_64		 0x40
+#define KBDTEST3_us_16		 0x20
+#define KBDTEST3_DIV8		 0x10
+#define KBDTEST3_DIn		 0x08
+#define KBDTEST3_CIn		 0x04
+#define KBDTEST3_KD		 0x02
+#define KBDTEST3_KC		 0x01
+#define KBDTEST4_BC12		 0x80
+#define KBDTEST4_BC11		 0x40
+#define KBDTEST4_TRES		 0x20
+#define KBDTEST4_CLKOE		 0x10
+#define KBDTEST4_CRES		 0x08
+#define KBDTEST4_RXB		 0x04
+#define KBDTEST4_TXB		 0x02
+#define KBDTEST4_SRX		 0x01
+
+#define MSETEST1_CD		 0x80
+#define MSETEST1_RC1		 0x40
+#define MSETEST1_MC		 0x20
+#define MSETEST1_C		 Fld(2,3)
+#define MSETEST1_T2		 0x40
+#define MSETEST1_T1		 0x20
+#define MSETEST1_T0		 0x10
+#define MSETEST2_TICBnRES	 0x08
+#define MSETEST2_RKC		 0x04
+#define MSETEST2_RKD		 0x02
+#define MSETEST2_SEL		 0x01
+#define MSETEST3_ms_16		 0x80
+#define MSETEST3_us_64		 0x40
+#define MSETEST3_us_16		 0x20
+#define MSETEST3_DIV8		 0x10
+#define MSETEST3_DIn		 0x08
+#define MSETEST3_CIn		 0x04
+#define MSETEST3_KD		 0x02
+#define MSETEST3_KC		 0x01
+#define MSETEST4_BC12		 0x80
+#define MSETEST4_BC11		 0x40
+#define MSETEST4_TRES		 0x20
+#define MSETEST4_CLKOE		 0x10
+#define MSETEST4_CRES		 0x08
+#define MSETEST4_RXB		 0x04
+#define MSETEST4_TXB		 0x02
+#define MSETEST4_SRX		 0x01
+
+#endif  /* LANGUAGE == C */
+
+
+/*
+ * General-Purpose I/O Interface
+ *
+ * Registers
+ *    PADWR	Port A Data Write Register
+ *    PBDWR	Port B Data Write Register
+ *    PADRR	Port A Data Read Register
+ *    PBDRR	Port B Data Read Register
+ *    PADDR	Port A Data Direction Register
+ *    PBDDR	Port B Data Direction Register
+ *    PASSR	Port A Sleep State Register
+ *    PBSSR	Port B Sleep State Register
+ *
+ */
+
+#define _PIO( x )      _SA1101( ( x ) + __GPIO_INTERFACE )
+
+#define _PADWR	       _PIO( 0x0000 )
+#define _PBDWR	       _PIO( 0x0400 )
+#define _PADRR	       _PIO( 0x0000 )
+#define _PBDRR	       _PIO( 0x0400 )
+#define _PADDR	       _PIO( 0x0800 )
+#define _PBDDR	       _PIO( 0x0c00 )
+#define _PASSR	       _PIO( 0x1000 )
+#define _PBSSR	       _PIO( 0x1400 )
+
+
+#if ( LANGUAGE == C )
+
+
+#define PADWR	    (*((volatile Word *) SA1101_p2v (_PADWR)))
+#define PBDWR	    (*((volatile Word *) SA1101_p2v (_PBDWR)))
+#define PADRR	    (*((volatile Word *) SA1101_p2v (_PADRR)))
+#define PBDRR	    (*((volatile Word *) SA1101_p2v (_PBDRR)))
+#define PADDR	    (*((volatile Word *) SA1101_p2v (_PADDR)))
+#define PBDDR	    (*((volatile Word *) SA1101_p2v (_PBDDR)))
+#define PASSR	    (*((volatile Word *) SA1101_p2v (_PASSR)))
+#define PBSSR	    (*((volatile Word *) SA1101_p2v (_PBSSR)))
+
+#endif
+
+
+
+/*
+ * Keypad Interface
+ *
+ * Registers
+ *    PXDWR
+ *    PXDRR
+ *    PYDWR
+ *    PYDRR
+ *
+ */
+
+#define _KEYPAD( x )	_SA1101( ( x ) + __KEYPAD_INTERFACE ) 
+
+#define _PXDWR	   _KEYPAD( 0x0000 )
+#define _PXDRR	   _KEYPAD( 0x0000 )
+#define _PYDWR	   _KEYPAD( 0x0400 )
+#define _PYDRR	   _KEYPAD( 0x0400 )
+
+#if ( LANGUAGE == C )
+
+
+#define PXDWR	    (*((volatile Word *) SA1101_p2v (_PXDWR)))
+#define PXDRR	    (*((volatile Word *) SA1101_p2v (_PXDRR)))
+#define PYDWR	    (*((volatile Word *) SA1101_p2v (_PYDWR)))
+#define PYDRR	    (*((volatile Word *) SA1101_p2v (_PYDRR)))
+
+#endif
+
+
+
+/*
+ * PCMCIA Interface
+ *
+ * Registers
+ *    PCSR	Status Register
+ *    PCCR	Control Register
+ *    PCSSR	Sleep State Register
+ *
+ */
+
+#define _CARD( x )	_SA1101( ( x ) + __PCMCIA_INTERFACE )
+
+#define _PCSR	   _CARD( 0x0000 )
+#define _PCCR	   _CARD( 0x0400 )
+#define _PCSSR	   _CARD( 0x0800 )
+
+#if ( LANGUAGE == C )
+#define PCSR    (*((volatile Word *) SA1101_p2v (_PCSR)))
+#define PCCR	(*((volatile Word *) SA1101_p2v (_PCCR)))
+#define PCSSR	(*((volatile Word *) SA1101_p2v (_PCSSR)))
+
+#define PCSR_S0_ready		0x0001
+#define PCSR_S1_ready		0x0002
+#define PCSR_S0_detected	0x0004
+#define PCSR_S1_detected	0x0008
+#define PCSR_S0_VS1		0x0010
+#define PCSR_S0_VS2		0x0020
+#define PCSR_S1_VS1		0x0040
+#define PCSR_S1_VS2		0x0080
+#define PCSR_S0_WP		0x0100
+#define PCSR_S1_WP		0x0200
+#define PCSR_S0_BVD1_nSTSCHG	0x0400
+#define PCSR_S0_BVD2_nSPKR	0x0800
+#define PCSR_S1_BVD1_nSTSCHG	0x1000
+#define PCSR_S1_BVD2_nSPKR	0x2000
+
+#define PCCR_S0_VPP0		0x0001
+#define PCCR_S0_VPP1		0x0002
+#define PCCR_S0_VCC0		0x0004
+#define PCCR_S0_VCC1		0x0008
+#define PCCR_S1_VPP0		0x0010
+#define PCCR_S1_VPP1		0x0020
+#define PCCR_S1_VCC0		0x0040
+#define PCCR_S1_VCC1		0x0080
+#define PCCR_S0_reset		0x0100
+#define PCCR_S1_reset		0x0200
+#define PCCR_S0_float		0x0400
+#define PCCR_S1_float		0x0800
+
+#define PCSSR_S0_VCC0		0x0001
+#define PCSSR_S0_VCC1		0x0002
+#define PCSSR_S0_VPP0		0x0004
+#define PCSSR_S0_VPP1		0x0008
+#define PCSSR_S0_control	0x0010
+#define PCSSR_S1_VCC0		0x0020
+#define PCSSR_S1_VCC1		0x0040
+#define PCSSR_S1_VPP0		0x0080
+#define PCSSR_S1_VPP1		0x0100
+#define PCSSR_S1_control	0x0200
+
+#endif
+
+#undef C
+#undef Assembly
Index: build_tree/linux/include/asm/arch-sa1100/SA-1111.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/SA-1111.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/SA-1111.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,5 @@
+/*
+ * Moved to new location
+ */
+#warning using old SA-1111.h - update to <asm/hardware/sa1111.h>
+#include <asm/hardware/sa1111.h>
Index: build_tree/linux/include/asm/arch-sa1100/assabet.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/assabet.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/assabet.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,105 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/assabet.h
+ *
+ * Created 2000/06/05 by Nicolas Pitre <nico@cam.org>
+ *
+ * This file contains the hardware specific definitions for Assabet
+ * Only include this file from SA1100-specific files.
+ *
+ * 2000/05/23 John Dorsey <john+@cs.cmu.edu>
+ *      Definitions for Neponset added.
+ */
+#ifndef __ASM_ARCH_ASSABET_H
+#define __ASM_ARCH_ASSABET_H
+
+
+/* System Configuration Register flags */
+
+#define ASSABET_SCR_SDRAM_LOW	(1<<2)	/* SDRAM size (low bit) */
+#define ASSABET_SCR_SDRAM_HIGH	(1<<3)	/* SDRAM size (high bit) */
+#define ASSABET_SCR_FLASH_LOW	(1<<4)	/* Flash size (low bit) */
+#define ASSABET_SCR_FLASH_HIGH	(1<<5)	/* Flash size (high bit) */
+#define ASSABET_SCR_GFX		(1<<8)	/* Graphics Accelerator (0 = present) */
+#define ASSABET_SCR_SA1111	(1<<9)	/* Neponset (0 = present) */
+
+#define ASSABET_SCR_INIT	-1
+
+extern unsigned long SCR_value;
+
+#ifdef CONFIG_ASSABET_NEPONSET
+#define machine_has_neponset()  ((SCR_value & ASSABET_SCR_SA1111) == 0)
+#else
+#define machine_has_neponset()	(0)
+#endif
+
+/* Board Control Register */
+
+#define ASSABET_BCR_BASE  0xf1000000
+#define ASSABET_BCR (*(volatile unsigned int *)(ASSABET_BCR_BASE))
+
+#define ASSABET_BCR_CF_PWR	(1<<0)	/* Compact Flash Power (1 = 3.3v, 0 = off) */
+#define ASSABET_BCR_CF_RST	(1<<1)	/* Compact Flash Reset (1 = power up reset) */
+#define ASSABET_BCR_GFX_RST	(1<<1)	/* Graphics Accelerator Reset (0 = hold reset) */
+#define ASSABET_BCR_CODEC_RST	(1<<2)	/* 0 = Holds UCB1300, ADI7171, and UDA1341 in reset */
+#define ASSABET_BCR_IRDA_FSEL	(1<<3)	/* IRDA Frequency select (0 = SIR, 1 = MIR/ FIR) */
+#define ASSABET_BCR_IRDA_MD0	(1<<4)	/* Range/Power select */
+#define ASSABET_BCR_IRDA_MD1	(1<<5)	/* Range/Power select */
+#define ASSABET_BCR_STEREO_LB	(1<<6)	/* Stereo Loopback */
+#define ASSABET_BCR_CF_BUS_OFF	(1<<7)	/* Compact Flash bus (0 = on, 1 = off (float)) */
+#define ASSABET_BCR_AUDIO_ON	(1<<8)	/* Audio power on */
+#define ASSABET_BCR_LIGHT_ON	(1<<9)	/* Backlight */
+#define ASSABET_BCR_LCD_12RGB	(1<<10)	/* 0 = 16RGB, 1 = 12RGB */
+#define ASSABET_BCR_LCD_ON	(1<<11)	/* LCD power on */
+#define ASSABET_BCR_RS232EN	(1<<12)	/* RS232 transceiver enable */
+#define ASSABET_BCR_LED_RED	(1<<13)	/* D9 (0 = on, 1 = off) */
+#define ASSABET_BCR_LED_GREEN	(1<<14)	/* D8 (0 = on, 1 = off) */
+#define ASSABET_BCR_VIB_ON	(1<<15)	/* Vibration motor (quiet alert) */
+#define ASSABET_BCR_COM_DTR	(1<<16)	/* COMport Data Terminal Ready */
+#define ASSABET_BCR_COM_RTS	(1<<17)	/* COMport Request To Send */
+#define ASSABET_BCR_RAD_WU	(1<<18)	/* Radio wake up interrupt */
+#define ASSABET_BCR_SMB_EN	(1<<19)	/* System management bus enable */
+#define ASSABET_BCR_TV_IR_DEC	(1<<20)	/* TV IR Decode Enable (not implemented) */
+#define ASSABET_BCR_QMUTE	(1<<21)	/* Quick Mute */
+#define ASSABET_BCR_RAD_ON	(1<<22)	/* Radio Power On */
+#define ASSABET_BCR_SPK_OFF	(1<<23)	/* 1 = Speaker amplifier power off */
+
+#ifdef CONFIG_SA1100_ASSABET
+extern void ASSABET_BCR_frob(unsigned int mask, unsigned int set);
+#else
+#define ASSABET_BCR_frob(x,y)	do { } while (0)
+#endif
+
+#define ASSABET_BCR_set(x)	ASSABET_BCR_frob((x), (x))
+#define ASSABET_BCR_clear(x)	ASSABET_BCR_frob((x), 0)
+
+#define ASSABET_BSR_BASE	0xf1000000
+#define ASSABET_BSR (*(volatile unsigned int*)(ASSABET_BSR_BASE))
+
+#define ASSABET_BSR_RS232_VALID	(1 << 24)
+#define ASSABET_BSR_COM_DCD	(1 << 25)
+#define ASSABET_BSR_COM_CTS	(1 << 26)
+#define ASSABET_BSR_COM_DSR	(1 << 27)
+#define ASSABET_BSR_RAD_CTS	(1 << 28)
+#define ASSABET_BSR_RAD_DSR	(1 << 29)
+#define ASSABET_BSR_RAD_DCD	(1 << 30)
+#define ASSABET_BSR_RAD_RI	(1 << 31)
+
+
+/* GPIOs for which the generic definition doesn't say much */
+#define ASSABET_GPIO_RADIO_IRQ		GPIO_GPIO (14)	/* Radio interrupt request  */
+#define ASSABET_GPIO_PS_MODE_SYNC	GPIO_GPIO (16)	/* Power supply mode/sync   */
+#define ASSABET_GPIO_STEREO_64FS_CLK	GPIO_GPIO (19)	/* SSP UDA1341 clock input  */
+#define ASSABET_GPIO_CF_IRQ		GPIO_GPIO (21)	/* CF IRQ   */
+#define ASSABET_GPIO_CF_CD		GPIO_GPIO (22)	/* CF CD */
+#define ASSABET_GPIO_CF_BVD2		GPIO_GPIO (24)	/* CF BVD */
+#define ASSABET_GPIO_GFX_IRQ		GPIO_GPIO (24)	/* Graphics IRQ */
+#define ASSABET_GPIO_CF_BVD1		GPIO_GPIO (25)	/* CF BVD */
+#define ASSABET_GPIO_BATT_LOW		GPIO_GPIO (26)	/* Low battery */
+#define ASSABET_GPIO_RCLK		GPIO_GPIO (26)	/* CCLK/2  */
+
+#define ASSABET_IRQ_GPIO_CF_IRQ		IRQ_GPIO21
+#define ASSABET_IRQ_GPIO_CF_CD		IRQ_GPIO22
+#define ASSABET_IRQ_GPIO_CF_BVD2	IRQ_GPIO24
+#define ASSABET_IRQ_GPIO_CF_BVD1	IRQ_GPIO25
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/badge4.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/badge4.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/badge4.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,75 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/badge4.h
+ *
+ *   Tim Connors <connors@hpl.hp.com>
+ *   Christopher Hoover <ch@hpl.hp.com>
+ *
+ * Copyright (C) 2002 Hewlett-Packard Company
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#error "include <asm/hardware.h> instead"
+#endif
+
+#define BADGE4_SA1111_BASE		(0x48000000)
+
+/* GPIOs on the BadgePAD 4 */
+#define BADGE4_GPIO_INT_1111		GPIO_GPIO0   /* SA-1111 IRQ */
+
+#define BADGE4_GPIO_INT_VID		GPIO_GPIO1   /* Video expansion */
+#define BADGE4_GPIO_LGP2		GPIO_GPIO2   /* GPIO_LDD8 */
+#define BADGE4_GPIO_LGP3		GPIO_GPIO3   /* GPIO_LDD9 */
+#define BADGE4_GPIO_LGP4		GPIO_GPIO4   /* GPIO_LDD10 */
+#define BADGE4_GPIO_LGP5		GPIO_GPIO5   /* GPIO_LDD11 */
+#define BADGE4_GPIO_LGP6		GPIO_GPIO6   /* GPIO_LDD12 */
+#define BADGE4_GPIO_LGP7		GPIO_GPIO7   /* GPIO_LDD13 */
+#define BADGE4_GPIO_LGP8		GPIO_GPIO8   /* GPIO_LDD14 */
+#define BADGE4_GPIO_LGP9		GPIO_GPIO9   /* GPIO_LDD15 */
+#define BADGE4_GPIO_GPA_VID		GPIO_GPIO10  /* Video expansion */
+#define BADGE4_GPIO_GPB_VID		GPIO_GPIO11  /* Video expansion */
+#define BADGE4_GPIO_GPC_VID		GPIO_GPIO12  /* Video expansion */
+
+#define BADGE4_GPIO_UART_HS1		GPIO_GPIO13
+#define BADGE4_GPIO_UART_HS2		GPIO_GPIO14
+
+#define BADGE4_GPIO_MUXSEL0		GPIO_GPIO15
+#define BADGE4_GPIO_TESTPT_J7		GPIO_GPIO16
+
+#define BADGE4_GPIO_SDSDA		GPIO_GPIO17  /* SDRAM SPD Data */
+#define BADGE4_GPIO_SDSCL		GPIO_GPIO18  /* SDRAM SPD Clock */
+#define BADGE4_GPIO_SDTYP0		GPIO_GPIO19  /* SDRAM Type Control */
+#define BADGE4_GPIO_SDTYP1		GPIO_GPIO20  /* SDRAM Type Control */
+
+#define BADGE4_GPIO_BGNT_1111		GPIO_GPIO21  /* GPIO_MBGNT */
+#define BADGE4_GPIO_BREQ_1111		GPIO_GPIO22  /* GPIO_TREQA */
+
+#define BADGE4_GPIO_TESTPT_J6		GPIO_GPIO23
+
+#define BADGE4_GPIO_PCMEN5V		GPIO_GPIO24  /* 5V power */
+
+#define BADGE4_GPIO_SA1111_NRST		GPIO_GPIO25  /* SA-1111 nRESET */
+
+#define BADGE4_GPIO_TESTPT_J5		GPIO_GPIO26
+
+#define BADGE4_GPIO_CLK_1111		GPIO_GPIO27  /* GPIO_32_768kHz */
+
+/* Interrupts on the BadgePAD 4 */
+#define BADGE4_IRQ_GPIO_SA1111		IRQ_GPIO0    /* SA-1111 interrupt */
+
+
+/* PCM5ENV Usage tracking */
+
+#define BADGE4_5V_PCMCIA_SOCK0		(1<<0)
+#define BADGE4_5V_PCMCIA_SOCK1		(1<<1)
+#define BADGE4_5V_PCMCIA_SOCK(n)	(1<<(n))
+#define BADGE4_5V_USB			(1<<2)
+#define BADGE4_5V_INITIALLY		(1<<3)
+
+#ifndef __ASSEMBLY__
+extern void badge4_set_5V(unsigned subsystem, int on);
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/bitfield.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/bitfield.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/bitfield.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,113 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+                	(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+                	((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
Index: build_tree/linux/include/asm/arch-sa1100/cerf.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/cerf.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/cerf.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ * include/asm-arm/arch-sa1100/cerf.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Apr-2003 : Removed some old PDA crud [FB]
+ */
+#ifndef _INCLUDE_CERF_H_
+#define _INCLUDE_CERF_H_
+
+
+#define CERF_ETH_IO			0xf0000000
+#define CERF_ETH_IRQ IRQ_GPIO26
+
+#define CERF_GPIO_CF_BVD2		GPIO_GPIO (19)
+#define CERF_GPIO_CF_BVD1		GPIO_GPIO (20)
+#define CERF_GPIO_CF_RESET		GPIO_GPIO (21)
+#define CERF_GPIO_CF_IRQ		GPIO_GPIO (22)
+#define CERF_GPIO_CF_CD			GPIO_GPIO (23)
+
+#define CERF_IRQ_GPIO_CF_BVD2		IRQ_GPIO19
+#define CERF_IRQ_GPIO_CF_BVD1		IRQ_GPIO20
+#define CERF_IRQ_GPIO_CF_IRQ		IRQ_GPIO22
+#define CERF_IRQ_GPIO_CF_CD		IRQ_GPIO23
+
+#endif // _INCLUDE_CERF_H_
Index: build_tree/linux/include/asm/arch-sa1100/collie.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/collie.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/collie.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,84 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/collie.h
+ *
+ * This file contains the hardware specific definitions for Assabet
+ * Only include this file from SA1100-specific files.
+ *
+ * ChangeLog:
+ *   04-06-2001 Lineo Japan, Inc.
+ *   04-16-2001 SHARP Corporation
+ *   07-07-2002 Chris Larson <clarson@digi.com>
+ *
+ */
+#ifndef __ASM_ARCH_COLLIE_H
+#define __ASM_ARCH_COLLIE_H
+
+
+#define COLLIE_SCP_CHARGE_ON	SCOOP_GPCR_PA11
+#define COLLIE_SCP_DIAG_BOOT1	SCOOP_GPCR_PA12
+#define COLLIE_SCP_DIAG_BOOT2	SCOOP_GPCR_PA13
+#define COLLIE_SCP_MUTE_L	SCOOP_GPCR_PA14
+#define COLLIE_SCP_MUTE_R	SCOOP_GPCR_PA15
+#define COLLIE_SCP_5VON		SCOOP_GPCR_PA16
+#define COLLIE_SCP_AMP_ON	SCOOP_GPCR_PA17
+#define COLLIE_SCP_VPEN		SCOOP_GPCR_PA18
+#define COLLIE_SCP_LB_VOL_CHG	SCOOP_GPCR_PA19
+
+#define COLLIE_SCOOP_IO_DIR	( COLLIE_SCP_CHARGE_ON | COLLIE_SCP_MUTE_L | COLLIE_SCP_MUTE_R | \
+				COLLIE_SCP_5VON | COLLIE_SCP_AMP_ON | COLLIE_SCP_VPEN | \
+				COLLIE_SCP_LB_VOL_CHG )
+#define COLLIE_SCOOP_IO_OUT	( COLLIE_SCP_MUTE_L | COLLIE_SCP_MUTE_R | COLLIE_SCP_VPEN | \
+				COLLIE_SCP_CHARGE_ON )
+
+/* GPIOs for which the generic definition doesn't say much */
+
+#define COLLIE_GPIO_ON_KEY		GPIO_GPIO (0)
+#define COLLIE_GPIO_AC_IN		GPIO_GPIO (1)
+#define COLLIE_GPIO_CF_IRQ		GPIO_GPIO (14)
+#define COLLIE_GPIO_nREMOCON_INT	GPIO_GPIO (15)
+#define COLLIE_GPIO_UCB1x00_RESET	GPIO_GPIO (16)
+#define COLLIE_GPIO_CO			GPIO_GPIO (20)
+#define COLLIE_GPIO_MCP_CLK		GPIO_GPIO (21)
+#define COLLIE_GPIO_CF_CD		GPIO_GPIO (22)
+#define COLLIE_GPIO_UCB1x00_IRQ		GPIO_GPIO (23)
+#define COLLIE_GPIO_WAKEUP		GPIO_GPIO (24)
+#define COLLIE_GPIO_GA_INT		GPIO_GPIO (25)
+#define COLLIE_GPIO_MAIN_BAT_LOW	GPIO_GPIO (26)
+
+/* Interrupts */
+
+#define COLLIE_IRQ_GPIO_ON_KEY		IRQ_GPIO0
+#define COLLIE_IRQ_GPIO_AC_IN		IRQ_GPIO1
+#define COLLIE_IRQ_GPIO_CF_IRQ		IRQ_GPIO14
+#define COLLIE_IRQ_GPIO_nREMOCON_INT	IRQ_GPIO15
+#define COLLIE_IRQ_GPIO_CO		IRQ_GPIO20
+#define COLLIE_IRQ_GPIO_CF_CD		IRQ_GPIO22
+#define COLLIE_IRQ_GPIO_UCB1x00_IRQ	IRQ_GPIO23
+#define COLLIE_IRQ_GPIO_WAKEUP		IRQ_GPIO24
+#define COLLIE_IRQ_GPIO_GA_INT		IRQ_GPIO25
+#define COLLIE_IRQ_GPIO_MAIN_BAT_LOW	IRQ_GPIO26
+
+#define COLLIE_LCM_IRQ_GPIO_RTS		IRQ_LOCOMO_GPIO0
+#define COLLIE_LCM_IRQ_GPIO_CTS		IRQ_LOCOMO_GPIO1
+#define COLLIE_LCM_IRQ_GPIO_DSR		IRQ_LOCOMO_GPIO2
+#define COLLIE_LCM_IRQ_GPIO_DTR		IRQ_LOCOMO_GPIO3
+#define COLLIE_LCM_IRQ_GPIO_nSD_DETECT	IRQ_LOCOMO_GPIO13
+#define COLLIE_LCM_IRQ_GPIO_nSD_WP	IRQ_LOCOMO_GPIO14
+
+/* GPIO's on the TC35143AF (Toshiba Analog Frontend) */
+#define COLLIE_TC35143_GPIO_VERSION0    UCB_IO_0	/* GPIO0=Version                 */
+#define COLLIE_TC35143_GPIO_TBL_CHK     UCB_IO_1	/* GPIO1=TBL_CHK                 */
+#define COLLIE_TC35143_GPIO_VPEN_ON     UCB_IO_2	/* GPIO2=VPNE_ON                 */
+#define COLLIE_TC35143_GPIO_IR_ON       UCB_IO_3	/* GPIO3=IR_ON                   */
+#define COLLIE_TC35143_GPIO_AMP_ON      UCB_IO_4	/* GPIO4=AMP_ON                  */
+#define COLLIE_TC35143_GPIO_VERSION1    UCB_IO_5	/* GPIO5=Version                 */
+#define COLLIE_TC35143_GPIO_FS8KLPF     UCB_IO_5	/* GPIO5=fs 8k LPF               */
+#define COLLIE_TC35143_GPIO_BUZZER_BIAS UCB_IO_6	/* GPIO6=BUZZER BIAS             */
+#define COLLIE_TC35143_GPIO_MBAT_ON     UCB_IO_7	/* GPIO7=MBAT_ON                 */
+#define COLLIE_TC35143_GPIO_BBAT_ON     UCB_IO_8	/* GPIO8=BBAT_ON                 */
+#define COLLIE_TC35143_GPIO_TMP_ON      UCB_IO_9	/* GPIO9=TMP_ON                  */
+#define COLLIE_TC35143_GPIO_IN		( UCB_IO_0 | UCB_IO_2 | UCB_IO_5 )
+#define COLLIE_TC35143_GPIO_OUT		( UCB_IO_1 | UCB_IO_3 | UCB_IO_4 | UCB_IO_6 | \
+					UCB_IO_7 | UCB_IO_8 | UCB_IO_9 )
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,58 @@
+/* linux/include/asm-arm/arch-sa1100/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+#include <asm/hardware.h>
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x80000000	@ physical base address
+		movne	\rx, #0xf8000000	@ virtual address
+
+		@ We probe for the active serial port here, coherently with
+		@ the comment in include/asm-arm/arch-sa1100/uncompress.h.
+		@ We assume r1 can be clobbered.
+
+		@ see if Ser3 is active
+		add	\rx, \rx, #0x00050000
+		ldr	r1, [\rx, #UTCR3]
+		tst	r1, #UTCR3_TXE
+
+		@ if Ser3 is inactive, then try Ser1
+		addeq	\rx, \rx, #(0x00010000 - 0x00050000)
+		ldreq	r1, [\rx, #UTCR3]
+		tsteq	r1, #UTCR3_TXE
+
+		@ if Ser1 is inactive, then try Ser2
+		addeq	\rx, \rx, #(0x00030000 - 0x00010000)
+		ldreq	r1, [\rx, #UTCR3]
+		tsteq	r1, #UTCR3_TXE
+
+		@ if all ports are inactive, then there is nothing we can do
+		moveq	pc, lr
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #UTDR]
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldr	\rd, [\rx, #UTSR1]
+		tst	\rd, #UTSR1_TNF
+		beq	1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+1001:		ldr	\rd, [\rx, #UTSR1]
+		tst	\rd, #UTSR1_TBY
+		bne	1001b
+		.endm
Index: build_tree/linux/include/asm/arch-sa1100/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,117 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/dma.h
+ *
+ * Generic SA1100 DMA support
+ *
+ * Copyright (C) 2000 Nicolas Pitre
+ *
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include "hardware.h"
+
+
+/*
+ * The SA1100 has six internal DMA channels.
+ */
+#define SA1100_DMA_CHANNELS	6
+
+/*
+ * Maximum physical DMA buffer size
+ */
+#define MAX_DMA_SIZE		0x1fff
+#define CUT_DMA_SIZE		0x1000
+
+/*
+ * All possible SA1100 devices a DMA channel can be attached to.
+ */
+typedef enum {
+	DMA_Ser0UDCWr  = DDAR_Ser0UDCWr,   /* Ser. port 0 UDC Write */
+	DMA_Ser0UDCRd  = DDAR_Ser0UDCRd,   /* Ser. port 0 UDC Read */
+	DMA_Ser1UARTWr = DDAR_Ser1UARTWr,  /* Ser. port 1 UART Write */
+	DMA_Ser1UARTRd = DDAR_Ser1UARTRd,  /* Ser. port 1 UART Read */
+	DMA_Ser1SDLCWr = DDAR_Ser1SDLCWr,  /* Ser. port 1 SDLC Write */
+	DMA_Ser1SDLCRd = DDAR_Ser1SDLCRd,  /* Ser. port 1 SDLC Read */
+	DMA_Ser2UARTWr = DDAR_Ser2UARTWr,  /* Ser. port 2 UART Write */
+	DMA_Ser2UARTRd = DDAR_Ser2UARTRd,  /* Ser. port 2 UART Read */
+	DMA_Ser2HSSPWr = DDAR_Ser2HSSPWr,  /* Ser. port 2 HSSP Write */
+	DMA_Ser2HSSPRd = DDAR_Ser2HSSPRd,  /* Ser. port 2 HSSP Read */
+	DMA_Ser3UARTWr = DDAR_Ser3UARTWr,  /* Ser. port 3 UART Write */
+	DMA_Ser3UARTRd = DDAR_Ser3UARTRd,  /* Ser. port 3 UART Read */
+	DMA_Ser4MCP0Wr = DDAR_Ser4MCP0Wr,  /* Ser. port 4 MCP 0 Write (audio) */
+	DMA_Ser4MCP0Rd = DDAR_Ser4MCP0Rd,  /* Ser. port 4 MCP 0 Read (audio) */
+	DMA_Ser4MCP1Wr = DDAR_Ser4MCP1Wr,  /* Ser. port 4 MCP 1 Write */
+	DMA_Ser4MCP1Rd = DDAR_Ser4MCP1Rd,  /* Ser. port 4 MCP 1 Read */
+	DMA_Ser4SSPWr  = DDAR_Ser4SSPWr,   /* Ser. port 4 SSP Write (16 bits) */
+	DMA_Ser4SSPRd  = DDAR_Ser4SSPRd    /* Ser. port 4 SSP Read (16 bits) */
+} dma_device_t;
+
+typedef struct {
+	volatile u_long DDAR;
+	volatile u_long SetDCSR;
+	volatile u_long ClrDCSR;
+	volatile u_long RdDCSR;
+	volatile dma_addr_t DBSA;
+	volatile u_long DBTA;
+	volatile dma_addr_t DBSB;
+	volatile u_long DBTB;
+} dma_regs_t;
+
+typedef void (*dma_callback_t)(void *data);
+
+/*
+ * DMA function prototypes
+ */
+
+extern int sa1100_request_dma( dma_device_t device, const char *device_id,
+			       dma_callback_t callback, void *data,
+			       dma_regs_t **regs );
+extern void sa1100_free_dma( dma_regs_t *regs );
+extern int sa1100_start_dma( dma_regs_t *regs, dma_addr_t dma_ptr, u_int size );
+extern dma_addr_t sa1100_get_dma_pos(dma_regs_t *regs);
+extern void sa1100_reset_dma(dma_regs_t *regs);
+
+/**
+ * 	sa1100_stop_dma - stop DMA in progress
+ * 	@regs: identifier for the channel to use
+ *
+ * 	This stops DMA without clearing buffer pointers. Unlike
+ * 	sa1100_clear_dma() this allows subsequent use of sa1100_resume_dma()
+ * 	or sa1100_get_dma_pos().
+ *
+ * 	The @regs identifier is provided by a successful call to
+ * 	sa1100_request_dma().
+ **/
+
+#define sa1100_stop_dma(regs)	((regs)->ClrDCSR = DCSR_IE|DCSR_RUN)
+
+/**
+ * 	sa1100_resume_dma - resume DMA on a stopped channel
+ * 	@regs: identifier for the channel to use
+ *
+ * 	This resumes DMA on a channel previously stopped with
+ * 	sa1100_stop_dma().
+ *
+ * 	The @regs identifier is provided by a successful call to
+ * 	sa1100_request_dma().
+ **/
+
+#define sa1100_resume_dma(regs)	((regs)->SetDCSR = DCSR_IE|DCSR_RUN)
+
+/**
+ * 	sa1100_clear_dma - clear DMA pointers
+ * 	@regs: identifier for the channel to use
+ *
+ * 	This clear any DMA state so the DMA engine is ready to restart
+ * 	with new buffers through sa1100_start_dma(). Any buffers in flight
+ * 	are discarded.
+ *
+ * 	The @regs identifier is provided by a successful call to
+ * 	sa1100_request_dma().
+ **/
+
+#define sa1100_clear_dma(regs)	((regs)->ClrDCSR = DCSR_IE|DCSR_RUN|DCSR_STRTA|DCSR_STRTB)
+
+#endif /* _ASM_ARCH_DMA_H */
Index: build_tree/linux/include/asm/arch-sa1100/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,47 @@
+/*
+ * include/asm-arm/arch-sa1100/entry-macro.S
+ *
+ * Low-level IRQ helper macros for SA1100-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+ 		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	r4, #0xfa000000			@ ICIP = 0xfa050000
+		add	r4, r4, #0x00050000
+		ldr	\irqstat, [r4]			@ get irqs
+		ldr	\irqnr, [r4, #4]		@ ICMR = 0xfa050004
+		ands	\irqstat, \irqstat, \irqnr
+		mov	\irqnr, #0
+		beq	1001f
+		tst	\irqstat, #0xff
+		moveq	\irqstat, \irqstat, lsr #8
+		addeq	\irqnr, \irqnr, #8
+		tsteq	\irqstat, #0xff
+		moveq	\irqstat, \irqstat, lsr #8
+		addeq	\irqnr, \irqnr, #8
+		tsteq	\irqstat, #0xff
+		moveq	\irqstat, \irqstat, lsr #8
+		addeq	\irqnr, \irqnr, #8
+		tst	\irqstat, #0x0f
+		moveq	\irqstat, \irqstat, lsr #4
+		addeq	\irqnr, \irqnr, #4
+		tst	\irqstat, #0x03
+		moveq	\irqstat, \irqstat, lsr #2
+		addeq	\irqnr, \irqnr, #2
+		tst	\irqstat, #0x01
+		addeqs	\irqnr, \irqnr, #1
+1001:
+		.endm
+
Index: build_tree/linux/include/asm/arch-sa1100/gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,75 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/gpio.h
+ *
+ * SA1100 GPIO wrappers for arch-neutral GPIO calls
+ *
+ * Written by Philipp Zabel <philipp.zabel@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __ASM_ARCH_SA1100_GPIO_H
+#define __ASM_ARCH_SA1100_GPIO_H
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+	return;
+}
+
+extern int gpio_direction_input(unsigned gpio);
+extern int gpio_direction_output(unsigned gpio, int value);
+
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return GPLR & GPIO_GPIO(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	if (value)
+		GPSR = GPIO_GPIO(gpio);
+	else
+		GPCR = GPIO_GPIO(gpio);
+}
+
+#include <asm-generic/gpio.h>			/* cansleep wrappers */
+
+static inline unsigned gpio_to_irq(unsigned gpio)
+{
+	if (gpio < 11)
+		return IRQ_GPIO0 + gpio;
+	else
+		return IRQ_GPIO11 - 11 + gpio;
+}
+
+static inline unsigned irq_to_gpio(unsigned irq)
+{
+	if (irq < IRQ_GPIO11_27)
+		return irq - IRQ_GPIO0;
+	else
+		return irq - IRQ_GPIO11 + 11;
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/h3600.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/h3600.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/h3600.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,164 @@
+/*
+ *
+ * Definitions for H3600 Handheld Computer
+ *
+ * Copyright 2000 Compaq Computer Corporation.
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * COMPAQ COMPUTER CORPORATION MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+ * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+ * FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ * Author: Jamey Hicks.
+ *
+ * History:
+ *
+ * 2001-10-??	Andrew Christian   Added support for iPAQ H3800
+ *
+ */
+
+#ifndef _INCLUDE_H3600_H_
+#define _INCLUDE_H3600_H_
+
+/* generalized support for H3xxx series Compaq Pocket PC's */
+#define machine_is_h3xxx() (machine_is_h3100() || machine_is_h3600() || machine_is_h3800())
+
+/* Physical memory regions corresponding to chip selects */
+#define H3600_EGPIO_PHYS     (SA1100_CS5_PHYS + 0x01000000)
+#define H3600_BANK_2_PHYS    SA1100_CS2_PHYS
+#define H3600_BANK_4_PHYS    SA1100_CS4_PHYS
+
+/* Virtual memory regions corresponding to chip selects 2 & 4 (used on sleeves) */
+#define H3600_EGPIO_VIRT     0xf0000000
+#define H3600_BANK_2_VIRT    0xf1000000
+#define H3600_BANK_4_VIRT    0xf3800000
+
+/*
+   Machine-independent GPIO definitions
+   --- these are common across all current iPAQ platforms
+*/
+
+#define GPIO_H3600_NPOWER_BUTTON	GPIO_GPIO (0)	/* Also known as the "off button"  */
+
+#define GPIO_H3600_PCMCIA_CD1		GPIO_GPIO (10)
+#define GPIO_H3600_PCMCIA_IRQ1		GPIO_GPIO (11)
+
+/* UDA1341 L3 Interface */
+#define GPIO_H3600_L3_DATA		GPIO_GPIO (14)
+#define GPIO_H3600_L3_MODE		GPIO_GPIO (15)
+#define GPIO_H3600_L3_CLOCK		GPIO_GPIO (16)
+
+#define GPIO_H3600_PCMCIA_CD0		GPIO_GPIO (17)
+#define GPIO_H3600_SYS_CLK		GPIO_GPIO (19)
+#define GPIO_H3600_PCMCIA_IRQ0		GPIO_GPIO (21)
+
+#define GPIO_H3600_COM_DCD		GPIO_GPIO (23)
+#define GPIO_H3600_OPT_IRQ		GPIO_GPIO (24)
+#define GPIO_H3600_COM_CTS		GPIO_GPIO (25)
+#define GPIO_H3600_COM_RTS		GPIO_GPIO (26)
+
+#define IRQ_GPIO_H3600_NPOWER_BUTTON	IRQ_GPIO0
+#define IRQ_GPIO_H3600_PCMCIA_CD1	IRQ_GPIO10
+#define IRQ_GPIO_H3600_PCMCIA_IRQ1	IRQ_GPIO11
+#define IRQ_GPIO_H3600_PCMCIA_CD0	IRQ_GPIO17
+#define IRQ_GPIO_H3600_PCMCIA_IRQ0	IRQ_GPIO21
+#define IRQ_GPIO_H3600_COM_DCD		IRQ_GPIO23
+#define IRQ_GPIO_H3600_OPT_IRQ		IRQ_GPIO24
+#define IRQ_GPIO_H3600_COM_CTS		IRQ_GPIO25
+
+
+#ifndef __ASSEMBLY__
+
+enum ipaq_egpio_type {
+	IPAQ_EGPIO_LCD_POWER,	  /* Power to the LCD panel */
+	IPAQ_EGPIO_CODEC_NRESET,  /* Clear to reset the audio codec (remember to return high) */
+	IPAQ_EGPIO_AUDIO_ON,	  /* Audio power */
+	IPAQ_EGPIO_QMUTE,	  /* Audio muting */
+	IPAQ_EGPIO_OPT_NVRAM_ON,  /* Non-volatile RAM on extension sleeves (SPI interface) */
+	IPAQ_EGPIO_OPT_ON,	  /* Power to extension sleeves */
+	IPAQ_EGPIO_CARD_RESET,	  /* Reset PCMCIA cards on extension sleeve (???) */
+	IPAQ_EGPIO_OPT_RESET,	  /* Reset option pack (???) */
+	IPAQ_EGPIO_IR_ON,	  /* IR sensor/emitter power */
+	IPAQ_EGPIO_IR_FSEL,	  /* IR speed selection 1->fast, 0->slow */
+	IPAQ_EGPIO_RS232_ON,	  /* Maxim RS232 chip power */
+	IPAQ_EGPIO_VPP_ON,	  /* Turn on power to flash programming */
+	IPAQ_EGPIO_LCD_ENABLE,	  /* Enable/disable LCD controller */
+};
+
+struct ipaq_model_ops {
+	const char     *generic_name;
+	void	      (*control)(enum ipaq_egpio_type, int);
+	unsigned long (*read)(void);
+	void	      (*blank_callback)(int blank);
+	int	      (*pm_callback)(int req);	    /* Primary model callback */
+	int	      (*pm_callback_aux)(int req);  /* Secondary callback (used by HAL modules) */
+};
+
+extern struct ipaq_model_ops ipaq_model_ops;
+
+static __inline__ const char * h3600_generic_name(void)
+{
+	return ipaq_model_ops.generic_name;
+}
+
+static __inline__ void assign_h3600_egpio(enum ipaq_egpio_type x, int level)
+{
+	if (ipaq_model_ops.control)
+		ipaq_model_ops.control(x,level);
+}
+
+static __inline__ void clr_h3600_egpio(enum ipaq_egpio_type x)
+{
+	if (ipaq_model_ops.control)
+		ipaq_model_ops.control(x,0);
+}
+
+static __inline__ void set_h3600_egpio(enum ipaq_egpio_type x)
+{
+	if (ipaq_model_ops.control)
+		ipaq_model_ops.control(x,1);
+}
+
+static __inline__ unsigned long read_h3600_egpio(void)
+{
+	if (ipaq_model_ops.read)
+		return ipaq_model_ops.read();
+	return 0;
+}
+
+static __inline__ int  h3600_register_blank_callback(void (*f)(int))
+{
+	ipaq_model_ops.blank_callback = f;
+	return 0;
+}
+
+static __inline__ void h3600_unregister_blank_callback(void (*f)(int))
+{
+	ipaq_model_ops.blank_callback = NULL;
+}
+
+
+static __inline__ int  h3600_register_pm_callback(int (*f)(int))
+{
+	ipaq_model_ops.pm_callback_aux = f;
+	return 0;
+}
+
+static __inline__ void h3600_unregister_pm_callback(int (*f)(int))
+{
+	ipaq_model_ops.pm_callback_aux = NULL;
+}
+
+static __inline__ int h3600_power_management(int req)
+{
+	if (ipaq_model_ops.pm_callback)
+		return ipaq_model_ops.pm_callback(req);
+	return 0;
+}
+
+#endif /* ASSEMBLY */
+
+#endif /* _INCLUDE_H3600_H_ */
Index: build_tree/linux/include/asm/arch-sa1100/h3600_gpio.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/h3600_gpio.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/h3600_gpio.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,540 @@
+/*
+ *
+ * Definitions for H3600 Handheld Computer
+ *
+ * Copyright 2000 Compaq Computer Corporation.
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * COMPAQ COMPUTER CORPORATION MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+ * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+ * FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ * Author: Jamey Hicks.
+ *
+ * History:
+ *
+ * 2001-10-??   Andrew Christian   Added support for iPAQ H3800
+ *
+ */
+
+#ifndef _INCLUDE_H3600_GPIO_H_
+#define _INCLUDE_H3600_GPIO_H_
+
+/*
+ * GPIO lines that are common across ALL iPAQ models are in "h3600.h"
+ * This file contains machine-specific definitions
+ */
+
+#define GPIO_H3600_SUSPEND              GPIO_GPIO (0)
+/* GPIO[2:9] used by LCD on H3600/3800, used as GPIO on H3100 */
+#define GPIO_H3100_BT_ON		GPIO_GPIO (2)
+#define GPIO_H3100_GPIO3		GPIO_GPIO (3)
+#define GPIO_H3100_QMUTE		GPIO_GPIO (4)
+#define GPIO_H3100_LCD_3V_ON		GPIO_GPIO (5)
+#define GPIO_H3100_AUD_ON		GPIO_GPIO (6)
+#define GPIO_H3100_AUD_PWR_ON		GPIO_GPIO (7)
+#define GPIO_H3100_IR_ON		GPIO_GPIO (8)
+#define GPIO_H3100_IR_FSEL		GPIO_GPIO (9)
+
+/* for H3600, audio sample rate clock generator */
+#define GPIO_H3600_CLK_SET0		GPIO_GPIO (12)
+#define GPIO_H3600_CLK_SET1		GPIO_GPIO (13)
+
+#define GPIO_H3600_ACTION_BUTTON	GPIO_GPIO (18)
+#define GPIO_H3600_SOFT_RESET           GPIO_GPIO (20)   /* Also known as BATT_FAULT */
+#define GPIO_H3600_OPT_LOCK		GPIO_GPIO (22)
+#define GPIO_H3600_OPT_DET		GPIO_GPIO (27)
+
+/* H3800 specific pins */
+#define GPIO_H3800_AC_IN                GPIO_GPIO (12)
+#define GPIO_H3800_COM_DSR              GPIO_GPIO (13)
+#define GPIO_H3800_MMC_INT              GPIO_GPIO (18)
+#define GPIO_H3800_NOPT_IND             GPIO_GPIO (20)   /* Almost exactly the same as GPIO_H3600_OPT_DET */
+#define GPIO_H3800_OPT_BAT_FAULT        GPIO_GPIO (22)
+#define GPIO_H3800_CLK_OUT              GPIO_GPIO (27)
+
+/****************************************************/
+
+#define IRQ_GPIO_H3600_ACTION_BUTTON    IRQ_GPIO18
+#define IRQ_GPIO_H3600_OPT_DET		IRQ_GPIO27
+
+#define IRQ_GPIO_H3800_MMC_INT          IRQ_GPIO18
+#define IRQ_GPIO_H3800_NOPT_IND         IRQ_GPIO20 /* almost same as OPT_DET */
+
+/* H3100 / 3600 EGPIO pins */
+#define EGPIO_H3600_VPP_ON		(1 << 0)
+#define EGPIO_H3600_CARD_RESET		(1 << 1)   /* reset the attached pcmcia/compactflash card.  active high. */
+#define EGPIO_H3600_OPT_RESET		(1 << 2)   /* reset the attached option pack.  active high. */
+#define EGPIO_H3600_CODEC_NRESET	(1 << 3)   /* reset the onboard UDA1341.  active low. */
+#define EGPIO_H3600_OPT_NVRAM_ON	(1 << 4)   /* apply power to optionpack nvram, active high. */
+#define EGPIO_H3600_OPT_ON		(1 << 5)   /* full power to option pack.  active high. */
+#define EGPIO_H3600_LCD_ON		(1 << 6)   /* enable 3.3V to LCD.  active high. */
+#define EGPIO_H3600_RS232_ON		(1 << 7)   /* UART3 transceiver force on.  Active high. */
+
+/* H3600 only EGPIO pins */
+#define EGPIO_H3600_LCD_PCI		(1 << 8)   /* LCD control IC enable.  active high. */
+#define EGPIO_H3600_IR_ON		(1 << 9)   /* apply power to IR module.  active high. */
+#define EGPIO_H3600_AUD_AMP_ON		(1 << 10)  /* apply power to audio power amp.  active high. */
+#define EGPIO_H3600_AUD_PWR_ON		(1 << 11)  /* apply power to reset of audio circuit.  active high. */
+#define EGPIO_H3600_QMUTE		(1 << 12)  /* mute control for onboard UDA1341.  active high. */
+#define EGPIO_H3600_IR_FSEL		(1 << 13)  /* IR speed select: 1->fast, 0->slow */
+#define EGPIO_H3600_LCD_5V_ON		(1 << 14)  /* enable 5V to LCD. active high. */
+#define EGPIO_H3600_LVDD_ON		(1 << 15)  /* enable 9V and -6.5V to LCD. */
+
+/********************* H3800, ASIC #2 ********************/
+
+#define _H3800_ASIC2_Base            (H3600_EGPIO_VIRT)
+#define H3800_ASIC2_OFFSET(s,x,y)    \
+    (*((volatile s *) (_H3800_ASIC2_Base + _H3800_ASIC2_ ## x ## _Base + _H3800_ASIC2_ ## x ## _ ## y)))
+#define H3800_ASIC2_NOFFSET(s,x,n,y) \
+    (*((volatile s *) (_H3800_ASIC2_Base + _H3800_ASIC2_ ## x ## _ ## n ## _Base + _H3800_ASIC2_ ## x ## _ ## y)))
+
+#define _H3800_ASIC2_GPIO_Base                 0x0000
+#define _H3800_ASIC2_GPIO_Direction            0x0000    /* R/W, 16 bits 1:input, 0:output */
+#define _H3800_ASIC2_GPIO_InterruptType        0x0004    /* R/W, 12 bits 1:edge, 0:level          */
+#define _H3800_ASIC2_GPIO_InterruptEdgeType    0x0008    /* R/W, 12 bits 1:rising, 0:falling */
+#define _H3800_ASIC2_GPIO_InterruptLevelType   0x000C    /* R/W, 12 bits 1:high, 0:low  */
+#define _H3800_ASIC2_GPIO_InterruptClear       0x0010    /* W,   12 bits */
+#define _H3800_ASIC2_GPIO_InterruptFlag        0x0010    /* R,   12 bits - reads int status */
+#define _H3800_ASIC2_GPIO_Data                 0x0014    /* R/W, 16 bits */
+#define _H3800_ASIC2_GPIO_BattFaultOut         0x0018    /* R/W, 16 bit - sets level on batt fault */
+#define _H3800_ASIC2_GPIO_InterruptEnable      0x001c    /* R/W, 12 bits 1:enable interrupt */
+#define _H3800_ASIC2_GPIO_Alternate            0x003c    /* R/W, 12+1 bits - set alternate functions */
+
+#define H3800_ASIC2_GPIO_Direction          H3800_ASIC2_OFFSET( u16, GPIO, Direction )
+#define H3800_ASIC2_GPIO_InterruptType      H3800_ASIC2_OFFSET( u16, GPIO, InterruptType )
+#define H3800_ASIC2_GPIO_InterruptEdgeType  H3800_ASIC2_OFFSET( u16, GPIO, InterruptEdgeType )
+#define H3800_ASIC2_GPIO_InterruptLevelType H3800_ASIC2_OFFSET( u16, GPIO, InterruptLevelType )
+#define H3800_ASIC2_GPIO_InterruptClear     H3800_ASIC2_OFFSET( u16, GPIO, InterruptClear )
+#define H3800_ASIC2_GPIO_InterruptFlag      H3800_ASIC2_OFFSET( u16, GPIO, InterruptFlag )
+#define H3800_ASIC2_GPIO_Data               H3800_ASIC2_OFFSET( u16, GPIO, Data )
+#define H3800_ASIC2_GPIO_BattFaultOut       H3800_ASIC2_OFFSET( u16, GPIO, BattFaultOut )
+#define H3800_ASIC2_GPIO_InterruptEnable    H3800_ASIC2_OFFSET( u16, GPIO, InterruptEnable )
+#define H3800_ASIC2_GPIO_Alternate          H3800_ASIC2_OFFSET( u16, GPIO, Alternate )
+
+#define GPIO_H3800_ASIC2_IN_Y1_N          (1 << 0)   /* Output: Touchscreen Y1 */
+#define GPIO_H3800_ASIC2_IN_X0            (1 << 1)   /* Output: Touchscreen X0 */
+#define GPIO_H3800_ASIC2_IN_Y0            (1 << 2)   /* Output: Touchscreen Y0 */
+#define GPIO_H3800_ASIC2_IN_X1_N          (1 << 3)   /* Output: Touchscreen X1 */
+#define GPIO_H3800_ASIC2_BT_RST           (1 << 4)   /* Output: Bluetooth reset */
+#define GPIO_H3800_ASIC2_PEN_IRQ          (1 << 5)   /* Input : Pen down        */
+#define GPIO_H3800_ASIC2_SD_DETECT        (1 << 6)   /* Input : SD detect */
+#define GPIO_H3800_ASIC2_EAR_IN_N         (1 << 7)   /* Input : Audio jack plug inserted */
+#define GPIO_H3800_ASIC2_OPT_PCM_RESET    (1 << 8)   /* Output: */
+#define GPIO_H3800_ASIC2_OPT_RESET        (1 << 9)   /* Output: */
+#define GPIO_H3800_ASIC2_USB_DETECT_N     (1 << 10)  /* Input : */
+#define GPIO_H3800_ASIC2_SD_CON_SLT       (1 << 11)  /* Input : */
+
+#define _H3800_ASIC2_KPIO_Base                 0x0200
+#define _H3800_ASIC2_KPIO_Direction            0x0000    /* R/W, 12 bits 1:input, 0:output */
+#define _H3800_ASIC2_KPIO_InterruptType        0x0004    /* R/W, 12 bits 1:edge, 0:level          */
+#define _H3800_ASIC2_KPIO_InterruptEdgeType    0x0008    /* R/W, 12 bits 1:rising, 0:falling */
+#define _H3800_ASIC2_KPIO_InterruptLevelType   0x000C    /* R/W, 12 bits 1:high, 0:low  */
+#define _H3800_ASIC2_KPIO_InterruptClear       0x0010    /* W,   20 bits - 8 special */
+#define _H3800_ASIC2_KPIO_InterruptFlag        0x0010    /* R,   20 bits - 8 special - reads int status */
+#define _H3800_ASIC2_KPIO_Data                 0x0014    /* R/W, 16 bits */
+#define _H3800_ASIC2_KPIO_BattFaultOut         0x0018    /* R/W, 16 bit - sets level on batt fault */
+#define _H3800_ASIC2_KPIO_InterruptEnable      0x001c    /* R/W, 20 bits - 8 special */
+#define _H3800_ASIC2_KPIO_Alternate            0x003c    /* R/W, 6 bits */
+
+#define H3800_ASIC2_KPIO_Direction          H3800_ASIC2_OFFSET( u16, KPIO, Direction )
+#define H3800_ASIC2_KPIO_InterruptType      H3800_ASIC2_OFFSET( u16, KPIO, InterruptType )
+#define H3800_ASIC2_KPIO_InterruptEdgeType  H3800_ASIC2_OFFSET( u16, KPIO, InterruptEdgeType )
+#define H3800_ASIC2_KPIO_InterruptLevelType H3800_ASIC2_OFFSET( u16, KPIO, InterruptLevelType )
+#define H3800_ASIC2_KPIO_InterruptClear     H3800_ASIC2_OFFSET( u32, KPIO, InterruptClear )
+#define H3800_ASIC2_KPIO_InterruptFlag      H3800_ASIC2_OFFSET( u32, KPIO, InterruptFlag )
+#define H3800_ASIC2_KPIO_Data               H3800_ASIC2_OFFSET( u16, KPIO, Data )
+#define H3800_ASIC2_KPIO_BattFaultOut       H3800_ASIC2_OFFSET( u16, KPIO, BattFaultOut )
+#define H3800_ASIC2_KPIO_InterruptEnable    H3800_ASIC2_OFFSET( u32, KPIO, InterruptEnable )
+#define H3800_ASIC2_KPIO_Alternate          H3800_ASIC2_OFFSET( u16, KPIO, Alternate )
+
+#define H3800_ASIC2_KPIO_SPI_INT        ( 1 << 16 )
+#define H3800_ASIC2_KPIO_OWM_INT        ( 1 << 17 )
+#define H3800_ASIC2_KPIO_ADC_INT        ( 1 << 18 )
+#define H3800_ASIC2_KPIO_UART_0_INT     ( 1 << 19 )
+#define H3800_ASIC2_KPIO_UART_1_INT     ( 1 << 20 )
+#define H3800_ASIC2_KPIO_TIMER_0_INT    ( 1 << 21 )
+#define H3800_ASIC2_KPIO_TIMER_1_INT    ( 1 << 22 )
+#define H3800_ASIC2_KPIO_TIMER_2_INT    ( 1 << 23 )
+
+#define KPIO_H3800_ASIC2_RECORD_BTN_N     (1 << 0)   /* Record button */
+#define KPIO_H3800_ASIC2_KEY_5W1_N        (1 << 1)   /* Keypad */
+#define KPIO_H3800_ASIC2_KEY_5W2_N        (1 << 2)   /* */
+#define KPIO_H3800_ASIC2_KEY_5W3_N        (1 << 3)   /* */
+#define KPIO_H3800_ASIC2_KEY_5W4_N        (1 << 4)   /* */
+#define KPIO_H3800_ASIC2_KEY_5W5_N        (1 << 5)   /* */
+#define KPIO_H3800_ASIC2_KEY_LEFT_N       (1 << 6)   /* */
+#define KPIO_H3800_ASIC2_KEY_RIGHT_N      (1 << 7)   /* */
+#define KPIO_H3800_ASIC2_KEY_AP1_N        (1 << 8)   /* Old "Calendar" */
+#define KPIO_H3800_ASIC2_KEY_AP2_N        (1 << 9)   /* Old "Schedule" */
+#define KPIO_H3800_ASIC2_KEY_AP3_N        (1 << 10)  /* Old "Q"        */
+#define KPIO_H3800_ASIC2_KEY_AP4_N        (1 << 11)  /* Old "Undo"     */
+
+/* Alternate KPIO functions (set by default) */
+#define KPIO_ALT_H3800_ASIC2_KEY_5W1_N        (1 << 1)   /* Action key */
+#define KPIO_ALT_H3800_ASIC2_KEY_5W2_N        (1 << 2)   /* J1 of keypad input */
+#define KPIO_ALT_H3800_ASIC2_KEY_5W3_N        (1 << 3)   /* J2 of keypad input */
+#define KPIO_ALT_H3800_ASIC2_KEY_5W4_N        (1 << 4)   /* J3 of keypad input */
+#define KPIO_ALT_H3800_ASIC2_KEY_5W5_N        (1 << 5)   /* J4 of keypad input */
+
+#define _H3800_ASIC2_SPI_Base                  0x0400
+#define _H3800_ASIC2_SPI_Control               0x0000    /* R/W 8 bits */
+#define _H3800_ASIC2_SPI_Data                  0x0004    /* R/W 8 bits */
+#define _H3800_ASIC2_SPI_ChipSelectDisabled    0x0008    /* W   8 bits */
+
+#define H3800_ASIC2_SPI_Control             H3800_ASIC2_OFFSET( u8, SPI, Control )
+#define H3800_ASIC2_SPI_Data                H3800_ASIC2_OFFSET( u8, SPI, Data )
+#define H3800_ASIC2_SPI_ChipSelectDisabled  H3800_ASIC2_OFFSET( u8, SPI, ChipSelectDisabled )
+
+#define _H3800_ASIC2_PWM_0_Base                0x0600
+#define _H3800_ASIC2_PWM_1_Base                0x0700
+#define _H3800_ASIC2_PWM_TimeBase              0x0000    /* R/W 6 bits */
+#define _H3800_ASIC2_PWM_PeriodTime            0x0004    /* R/W 12 bits */
+#define _H3800_ASIC2_PWM_DutyTime              0x0008    /* R/W 12 bits */
+
+#define H3800_ASIC2_PWM_0_TimeBase          H3800_ASIC2_NOFFSET(  u8, PWM, 0, TimeBase )
+#define H3800_ASIC2_PWM_0_PeriodTime        H3800_ASIC2_NOFFSET( u16, PWM, 0, PeriodTime )
+#define H3800_ASIC2_PWM_0_DutyTime          H3800_ASIC2_NOFFSET( u16, PWM, 0, DutyTime )
+
+#define H3800_ASIC2_PWM_1_TimeBase          H3800_ASIC2_NOFFSET(  u8, PWM, 1, TimeBase )
+#define H3800_ASIC2_PWM_1_PeriodTime        H3800_ASIC2_NOFFSET( u16, PWM, 1, PeriodTime )
+#define H3800_ASIC2_PWM_1_DutyTime          H3800_ASIC2_NOFFSET( u16, PWM, 1, DutyTime )
+
+#define H3800_ASIC2_PWM_TIMEBASE_MASK             0xf    /* Low 4 bits sets time base, max = 8 */
+#define H3800_ASIC2_PWM_TIMEBASE_ENABLE    ( 1 << 4 )    /* Enable clock */
+#define H3800_ASIC2_PWM_TIMEBASE_CLEAR     ( 1 << 5 )    /* Clear the PWM */
+
+#define _H3800_ASIC2_LED_0_Base                0x0800
+#define _H3800_ASIC2_LED_1_Base                0x0880
+#define _H3800_ASIC2_LED_2_Base                0x0900
+#define _H3800_ASIC2_LED_TimeBase              0x0000    /* R/W  7 bits */
+#define _H3800_ASIC2_LED_PeriodTime            0x0004    /* R/W 12 bits */
+#define _H3800_ASIC2_LED_DutyTime              0x0008    /* R/W 12 bits */
+#define _H3800_ASIC2_LED_AutoStopCount         0x000c    /* R/W 16 bits */
+
+#define H3800_ASIC2_LED_0_TimeBase          H3800_ASIC2_NOFFSET(  u8, LED, 0, TimeBase )
+#define H3800_ASIC2_LED_0_PeriodTime        H3800_ASIC2_NOFFSET( u16, LED, 0, PeriodTime )
+#define H3800_ASIC2_LED_0_DutyTime          H3800_ASIC2_NOFFSET( u16, LED, 0, DutyTime )
+#define H3800_ASIC2_LED_0_AutoStopClock     H3800_ASIC2_NOFFSET( u16, LED, 0, AutoStopClock )
+
+#define H3800_ASIC2_LED_1_TimeBase          H3800_ASIC2_NOFFSET(  u8, LED, 1, TimeBase )
+#define H3800_ASIC2_LED_1_PeriodTime        H3800_ASIC2_NOFFSET( u16, LED, 1, PeriodTime )
+#define H3800_ASIC2_LED_1_DutyTime          H3800_ASIC2_NOFFSET( u16, LED, 1, DutyTime )
+#define H3800_ASIC2_LED_1_AutoStopClock     H3800_ASIC2_NOFFSET( u16, LED, 1, AutoStopClock )
+
+#define H3800_ASIC2_LED_2_TimeBase          H3800_ASIC2_NOFFSET(  u8, LED, 2, TimeBase )
+#define H3800_ASIC2_LED_2_PeriodTime        H3800_ASIC2_NOFFSET( u16, LED, 2, PeriodTime )
+#define H3800_ASIC2_LED_2_DutyTime          H3800_ASIC2_NOFFSET( u16, LED, 2, DutyTime )
+#define H3800_ASIC2_LED_2_AutoStopClock     H3800_ASIC2_NOFFSET( u16, LED, 2, AutoStopClock )
+
+#define H3800_ASIC2_LED_TIMEBASE_MASK            0x0f    /* Low 4 bits sets time base, max = 13 */
+#define H3800_ASIC2_LED_TIMEBASE_BLINK     ( 1 << 4 )    /* Enable blinking */
+#define H3800_ASIC2_LED_TIMEBASE_AUTOSTOP  ( 1 << 5 )
+#define H3800_ASIC2_LED_TIMEBASE_ALWAYS    ( 1 << 6 )    /* Enable blink always */
+
+#define _H3800_ASIC2_UART_0_Base               0x0A00
+#define _H3800_ASIC2_UART_1_Base               0x0C00
+#define _H3800_ASIC2_UART_Receive              0x0000    /* R    8 bits */
+#define _H3800_ASIC2_UART_Transmit             0x0000    /*   W  8 bits */
+#define _H3800_ASIC2_UART_IntEnable            0x0004    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_IntVerify            0x0008    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_FIFOControl          0x000c    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_LineControl          0x0010    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_ModemStatus          0x0014    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_LineStatus           0x0018    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_ScratchPad           0x001c    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_DivisorLatchL        0x0020    /* R/W  8 bits */
+#define _H3800_ASIC2_UART_DivisorLatchH        0x0024    /* R/W  8 bits */
+
+#define H3800_ASIC2_UART_0_Receive          H3800_ASIC2_NOFFSET(  u8, UART, 0, Receive )
+#define H3800_ASIC2_UART_0_Transmit         H3800_ASIC2_NOFFSET(  u8, UART, 0, Transmit )
+#define H3800_ASIC2_UART_0_IntEnable        H3800_ASIC2_NOFFSET(  u8, UART, 0, IntEnable )
+#define H3800_ASIC2_UART_0_IntVerify        H3800_ASIC2_NOFFSET(  u8, UART, 0, IntVerify )
+#define H3800_ASIC2_UART_0_FIFOControl      H3800_ASIC2_NOFFSET(  u8, UART, 0, FIFOControl )
+#define H3800_ASIC2_UART_0_LineControl      H3800_ASIC2_NOFFSET(  u8, UART, 0, LineControl )
+#define H3800_ASIC2_UART_0_ModemStatus      H3800_ASIC2_NOFFSET(  u8, UART, 0, ModemStatus )
+#define H3800_ASIC2_UART_0_LineStatus       H3800_ASIC2_NOFFSET(  u8, UART, 0, LineStatus )
+#define H3800_ASIC2_UART_0_ScratchPad       H3800_ASIC2_NOFFSET(  u8, UART, 0, ScratchPad )
+#define H3800_ASIC2_UART_0_DivisorLatchL    H3800_ASIC2_NOFFSET(  u8, UART, 0, DivisorLatchL )
+#define H3800_ASIC2_UART_0_DivisorLatchH    H3800_ASIC2_NOFFSET(  u8, UART, 0, DivisorLatchH )
+
+#define H3800_ASIC2_UART_1_Receive          H3800_ASIC2_NOFFSET(  u8, UART, 1, Receive )
+#define H3800_ASIC2_UART_1_Transmit         H3800_ASIC2_NOFFSET(  u8, UART, 1, Transmit )
+#define H3800_ASIC2_UART_1_IntEnable        H3800_ASIC2_NOFFSET(  u8, UART, 1, IntEnable )
+#define H3800_ASIC2_UART_1_IntVerify        H3800_ASIC2_NOFFSET(  u8, UART, 1, IntVerify )
+#define H3800_ASIC2_UART_1_FIFOControl      H3800_ASIC2_NOFFSET(  u8, UART, 1, FIFOControl )
+#define H3800_ASIC2_UART_1_LineControl      H3800_ASIC2_NOFFSET(  u8, UART, 1, LineControl )
+#define H3800_ASIC2_UART_1_ModemStatus      H3800_ASIC2_NOFFSET(  u8, UART, 1, ModemStatus )
+#define H3800_ASIC2_UART_1_LineStatus       H3800_ASIC2_NOFFSET(  u8, UART, 1, LineStatus )
+#define H3800_ASIC2_UART_1_ScratchPad       H3800_ASIC2_NOFFSET(  u8, UART, 1, ScratchPad )
+#define H3800_ASIC2_UART_1_DivisorLatchL    H3800_ASIC2_NOFFSET(  u8, UART, 1, DivisorLatchL )
+#define H3800_ASIC2_UART_1_DivisorLatchH    H3800_ASIC2_NOFFSET(  u8, UART, 1, DivisorLatchH )
+
+#define _H3800_ASIC2_TIMER_Base                0x0E00
+#define _H3800_ASIC2_TIMER_Command             0x0000    /* R/W  8 bits */
+
+#define H3800_ASIC2_TIMER_Command           H3800_ASIC2_OFFSET( u8, Timer, Command )
+
+#define H3800_ASIC2_TIMER_GAT_0            ( 1 << 0 )    /* Gate enable, counter 0 */
+#define H3800_ASIC2_TIMER_GAT_1            ( 1 << 1 )    /* Gate enable, counter 1 */
+#define H3800_ASIC2_TIMER_GAT_2            ( 1 << 2 )    /* Gate enable, counter 2 */
+#define H3800_ASIC2_TIMER_CLK_0            ( 1 << 3 )    /* Clock enable, counter 0 */
+#define H3800_ASIC2_TIMER_CLK_1            ( 1 << 4 )    /* Clock enable, counter 1 */
+#define H3800_ASIC2_TIMER_CLK_2            ( 1 << 5 )    /* Clock enable, counter 2 */
+#define H3800_ASIC2_TIMER_MODE_0           ( 1 << 6 )    /* Mode 0 enable, counter 0 */
+#define H3800_ASIC2_TIMER_MODE_1           ( 1 << 7 )    /* Mode 0 enable, counter 1 */
+
+#define _H3800_ASIC2_CLOCK_Base                0x1000
+#define _H3800_ASIC2_CLOCK_Enable              0x0000    /* R/W  18 bits */
+
+#define H3800_ASIC2_CLOCK_Enable            H3800_ASIC2_OFFSET( u32, CLOCK, Enable )
+
+#define H3800_ASIC2_CLOCK_AUDIO_1              0x0001    /* Enable 4.1 MHz clock for 8Khz and 4khz sample rate */
+#define H3800_ASIC2_CLOCK_AUDIO_2              0x0002    /* Enable 12.3 MHz clock for 48Khz and 32khz sample rate */
+#define H3800_ASIC2_CLOCK_AUDIO_3              0x0004    /* Enable 5.6 MHz clock for 11 kHZ sample rate */
+#define H3800_ASIC2_CLOCK_AUDIO_4              0x0008    /* Enable 11.289 MHz clock for 44 and 22 kHz sample rate */
+#define H3800_ASIC2_CLOCK_ADC              ( 1 << 4 )    /* 1.024 MHz clock to ADC */
+#define H3800_ASIC2_CLOCK_SPI              ( 1 << 5 )    /* 4.096 MHz clock to SPI */
+#define H3800_ASIC2_CLOCK_OWM              ( 1 << 6 )    /* 4.096 MHz clock to OWM */
+#define H3800_ASIC2_CLOCK_PWM              ( 1 << 7 )    /* 2.048 MHz clock to PWM */
+#define H3800_ASIC2_CLOCK_UART_1           ( 1 << 8 )    /* 24.576 MHz clock to UART1 (turn off bit 16) */
+#define H3800_ASIC2_CLOCK_UART_0           ( 1 << 9 )    /* 24.576 MHz clock to UART0 (turn off bit 17) */
+#define H3800_ASIC2_CLOCK_SD_1             ( 1 << 10 )   /* 16.934 MHz to SD */
+#define H3800_ASIC2_CLOCK_SD_2             ( 2 << 10 )   /* 24.576 MHz to SD */
+#define H3800_ASIC2_CLOCK_SD_3             ( 3 << 10 )   /* 33.869 MHz to SD */
+#define H3800_ASIC2_CLOCK_SD_4             ( 4 << 10 )   /* 49.152 MHz to SD */
+#define H3800_ASIC2_CLOCK_EX0              ( 1 << 13 )   /* Enable 32.768 kHz crystal */
+#define H3800_ASIC2_CLOCK_EX1              ( 1 << 14 )   /* Enable 24.576 MHz crystal */
+#define H3800_ASIC2_CLOCK_EX2              ( 1 << 15 )   /* Enable 33.869 MHz crystal */
+#define H3800_ASIC2_CLOCK_SLOW_UART_1      ( 1 << 16 )   /* Enable 3.686 MHz to UART1 (turn off bit 8) */
+#define H3800_ASIC2_CLOCK_SLOW_UART_0      ( 1 << 17 )   /* Enable 3.686 MHz to UART0 (turn off bit 9) */
+
+#define _H3800_ASIC2_ADC_Base                  0x1200
+#define _H3800_ASIC2_ADC_Multiplexer           0x0000    /* R/W 4 bits - low 3 bits set channel */
+#define _H3800_ASIC2_ADC_ControlStatus         0x0004    /* R/W 8 bits */
+#define _H3800_ASIC2_ADC_Data                  0x0008    /* R   10 bits */
+
+#define H3800_ASIC2_ADC_Multiplexer       H3800_ASIC2_OFFSET(  u8, ADC, Multiplexer )
+#define H3800_ASIC2_ADC_ControlStatus     H3800_ASIC2_OFFSET(  u8, ADC, ControlStatus )
+#define H3800_ASIC2_ADC_Data              H3800_ASIC2_OFFSET( u16, ADC, Data )
+
+#define H3600_ASIC2_ADC_MUX_CHANNEL_MASK         0x07    /* Low 3 bits sets channel.  max = 4 */
+#define H3600_ASIC2_ADC_MUX_CLKEN          ( 1 << 3 )    /* Enable clock */
+
+#define H3600_ASIC2_ADC_CSR_ADPS_MASK            0x0f    /* Low 4 bits sets prescale, max = 8 */
+#define H3600_ASIC2_ADC_CSR_FREE_RUN       ( 1 << 4 )
+#define H3600_ASIC2_ADC_CSR_INT_ENABLE     ( 1 << 5 )
+#define H3600_ASIC2_ADC_CSR_START          ( 1 << 6 )    /* Set to start conversion.  Goes to 0 when done */
+#define H3600_ASIC2_ADC_CSR_ENABLE         ( 1 << 7 )    /* 1:power up ADC, 0:power down */
+
+
+#define _H3800_ASIC2_INTR_Base                 0x1600
+#define _H3800_ASIC2_INTR_MaskAndFlag          0x0000    /* R/(W) 8bits */
+#define _H3800_ASIC2_INTR_ClockPrescale        0x0004    /* R/(W) 5bits */
+#define _H3800_ASIC2_INTR_TimerSet             0x0008    /* R/(W) 8bits */
+
+#define H3800_ASIC2_INTR_MaskAndFlag      H3800_ASIC2_OFFSET( u8, INTR, MaskAndFlag )
+#define H3800_ASIC2_INTR_ClockPrescale    H3800_ASIC2_OFFSET( u8, INTR, ClockPrescale )
+#define H3800_ASIC2_INTR_TimerSet         H3800_ASIC2_OFFSET( u8, INTR, TimerSet )
+
+#define H3800_ASIC2_INTR_GLOBAL_MASK       ( 1 << 0 )    /* Global interrupt mask */
+#define H3800_ASIC2_INTR_POWER_ON_RESET    ( 1 << 1 )    /* 01: Power on reset (bits 1 & 2 ) */
+#define H3800_ASIC2_INTR_EXTERNAL_RESET    ( 2 << 1 )    /* 10: External reset (bits 1 & 2 ) */
+#define H3800_ASIC2_INTR_MASK_UART_0       ( 1 << 4 )
+#define H3800_ASIC2_INTR_MASK_UART_1       ( 1 << 5 )
+#define H3800_ASIC2_INTR_MASK_TIMER        ( 1 << 6 )
+#define H3800_ASIC2_INTR_MASK_OWM          ( 1 << 7 )
+
+#define H3800_ASIC2_INTR_CLOCK_PRESCALE          0x0f    /* 4 bits, max 14 */
+#define H3800_ASIC2_INTR_SET               ( 1 << 4 )    /* Time base enable */
+
+
+#define _H3800_ASIC2_OWM_Base                  0x1800
+#define _H3800_ASIC2_OWM_Command               0x0000    /* R/W 4 bits command register */
+#define _H3800_ASIC2_OWM_Data                  0x0004    /* R/W 8 bits, transmit / receive buffer */
+#define _H3800_ASIC2_OWM_Interrupt             0x0008    /* R/W Command register */
+#define _H3800_ASIC2_OWM_InterruptEnable       0x000c    /* R/W Command register */
+#define _H3800_ASIC2_OWM_ClockDivisor          0x0010    /* R/W 5 bits of divisor and pre-scale */
+
+#define H3800_ASIC2_OWM_Command            H3800_ASIC2_OFFSET( u8, OWM, Command )
+#define H3800_ASIC2_OWM_Data               H3800_ASIC2_OFFSET( u8, OWM, Data )
+#define H3800_ASIC2_OWM_Interrupt          H3800_ASIC2_OFFSET( u8, OWM, Interrupt )
+#define H3800_ASIC2_OWM_InterruptEnable    H3800_ASIC2_OFFSET( u8, OWM, InterruptEnable )
+#define H3800_ASIC2_OWM_ClockDivisor       H3800_ASIC2_OFFSET( u8, OWM, ClockDivisor )
+
+#define H3800_ASIC2_OWM_CMD_ONE_WIRE_RESET ( 1 << 0 )    /* Set to force reset on 1-wire bus */
+#define H3800_ASIC2_OWM_CMD_SRA            ( 1 << 1 )    /* Set to switch to Search ROM accelerator mode */
+#define H3800_ASIC2_OWM_CMD_DQ_OUTPUT      ( 1 << 2 )    /* Write only - forces bus low */
+#define H3800_ASIC2_OWM_CMD_DQ_INPUT       ( 1 << 3 )    /* Read only - reflects state of bus */
+
+#define H3800_ASIC2_OWM_INT_PD             ( 1 << 0 )    /* Presence detect */
+#define H3800_ASIC2_OWM_INT_PDR            ( 1 << 1 )    /* Presence detect result */
+#define H3800_ASIC2_OWM_INT_TBE            ( 1 << 2 )    /* Transmit buffer empty */
+#define H3800_ASIC2_OWM_INT_TEMT           ( 1 << 3 )    /* Transmit shift register empty */
+#define H3800_ASIC2_OWM_INT_RBF            ( 1 << 4 )    /* Receive buffer full */
+
+#define H3800_ASIC2_OWM_INTEN_EPD          ( 1 << 0 )    /* Enable receive buffer full interrupt */
+#define H3800_ASIC2_OWM_INTEN_IAS          ( 1 << 1 )    /* Enable transmit shift register empty interrupt */
+#define H3800_ASIC2_OWM_INTEN_ETBE         ( 1 << 2 )    /* Enable transmit buffer empty interrupt */
+#define H3800_ASIC2_OWM_INTEN_ETMT         ( 1 << 3 )    /* INTR active state */
+#define H3800_ASIC2_OWM_INTEN_ERBF         ( 1 << 4 )    /* Enable presence detect interrupt */
+
+#define _H3800_ASIC2_FlashCtl_Base             0x1A00
+
+/****************************************************/
+/* H3800, ASIC #1
+ * This ASIC is accesed through ASIC #2, and
+ * mapped into the 1c00 - 1f00 region
+ */
+
+#define H3800_ASIC1_OFFSET(s,x,y)   \
+     (*((volatile s *) (_H3800_ASIC2_Base + _H3800_ASIC1_ ## x ## _Base + (_H3800_ASIC1_ ## x ## _ ## y << 1))))
+
+#define _H3800_ASIC1_MMC_Base             0x1c00
+
+#define _H3800_ASIC1_MMC_StartStopClock     0x00    /* R/W 8bit                                  */
+#define _H3800_ASIC1_MMC_Status             0x02    /* R   See below, default 0x0040             */
+#define _H3800_ASIC1_MMC_ClockRate          0x04    /* R/W 8bit, low 3 bits are clock divisor    */
+#define _H3800_ASIC1_MMC_SPIRegister        0x08    /* R/W 8bit, see below                       */
+#define _H3800_ASIC1_MMC_CmdDataCont        0x0a    /* R/W 8bit, write to start MMC adapter      */
+#define _H3800_ASIC1_MMC_ResponseTimeout    0x0c    /* R/W 8bit, clocks before response timeout  */
+#define _H3800_ASIC1_MMC_ReadTimeout        0x0e    /* R/W 16bit, clocks before received data timeout */
+#define _H3800_ASIC1_MMC_BlockLength        0x10    /* R/W 10bit */
+#define _H3800_ASIC1_MMC_NumOfBlocks        0x12    /* R/W 16bit, in block mode, number of blocks  */
+#define _H3800_ASIC1_MMC_InterruptMask      0x1a    /* R/W 8bit */
+#define _H3800_ASIC1_MMC_CommandNumber      0x1c    /* R/W 6 bits */
+#define _H3800_ASIC1_MMC_ArgumentH          0x1e    /* R/W 16 bits  */
+#define _H3800_ASIC1_MMC_ArgumentL          0x20    /* R/W 16 bits */
+#define _H3800_ASIC1_MMC_ResFifo            0x22    /* R   8 x 16 bits - contains response FIFO */
+#define _H3800_ASIC1_MMC_BufferPartFull     0x28    /* R/W 8 bits */
+
+#define H3800_ASIC1_MMC_StartStopClock    H3800_ASIC1_OFFSET(  u8, MMC, StartStopClock )
+#define H3800_ASIC1_MMC_Status            H3800_ASIC1_OFFSET( u16, MMC, Status )
+#define H3800_ASIC1_MMC_ClockRate         H3800_ASIC1_OFFSET(  u8, MMC, ClockRate )
+#define H3800_ASIC1_MMC_SPIRegister       H3800_ASIC1_OFFSET(  u8, MMC, SPIRegister )
+#define H3800_ASIC1_MMC_CmdDataCont       H3800_ASIC1_OFFSET(  u8, MMC, CmdDataCont )
+#define H3800_ASIC1_MMC_ResponseTimeout   H3800_ASIC1_OFFSET(  u8, MMC, ResponseTimeout )
+#define H3800_ASIC1_MMC_ReadTimeout       H3800_ASIC1_OFFSET( u16, MMC, ReadTimeout )
+#define H3800_ASIC1_MMC_BlockLength       H3800_ASIC1_OFFSET( u16, MMC, BlockLength )
+#define H3800_ASIC1_MMC_NumOfBlocks       H3800_ASIC1_OFFSET( u16, MMC, NumOfBlocks )
+#define H3800_ASIC1_MMC_InterruptMask     H3800_ASIC1_OFFSET(  u8, MMC, InterruptMask )
+#define H3800_ASIC1_MMC_CommandNumber     H3800_ASIC1_OFFSET(  u8, MMC, CommandNumber )
+#define H3800_ASIC1_MMC_ArgumentH         H3800_ASIC1_OFFSET( u16, MMC, ArgumentH )
+#define H3800_ASIC1_MMC_ArgumentL         H3800_ASIC1_OFFSET( u16, MMC, ArgumentL )
+#define H3800_ASIC1_MMC_ResFifo           H3800_ASIC1_OFFSET( u16, MMC, ResFifo )
+#define H3800_ASIC1_MMC_BufferPartFull    H3800_ASIC1_OFFSET(  u8, MMC, BufferPartFull )
+
+#define H3800_ASIC1_MMC_STOP_CLOCK                   (1 << 0)   /* Write to "StartStopClock" register */
+#define H3800_ASIC1_MMC_START_CLOCK                  (1 << 1)
+
+#define H3800_ASIC1_MMC_STATUS_READ_TIMEOUT          (1 << 0)
+#define H3800_ASIC1_MMC_STATUS_RESPONSE_TIMEOUT      (1 << 1)
+#define H3800_ASIC1_MMC_STATUS_CRC_WRITE_ERROR       (1 << 2)
+#define H3800_ASIC1_MMC_STATUS_CRC_READ_ERROR        (1 << 3)
+#define H3800_ASIC1_MMC_STATUS_SPI_READ_ERROR        (1 << 4)  /* SPI data token error received */
+#define H3800_ASIC1_MMC_STATUS_CRC_RESPONSE_ERROR    (1 << 5)
+#define H3800_ASIC1_MMC_STATUS_FIFO_EMPTY            (1 << 6)
+#define H3800_ASIC1_MMC_STATUS_FIFO_FULL             (1 << 7)
+#define H3800_ASIC1_MMC_STATUS_CLOCK_ENABLE          (1 << 8)  /* MultiMediaCard clock stopped */
+#define H3800_ASIC1_MMC_STATUS_DATA_TRANSFER_DONE    (1 << 11) /* Write operation, indicates transfer finished */
+#define H3800_ASIC1_MMC_STATUS_END_PROGRAM           (1 << 12) /* End write and read operations */
+#define H3800_ASIC1_MMC_STATUS_END_COMMAND_RESPONSE  (1 << 13) /* End command response */
+
+#define H3800_ASIC1_MMC_SPI_REG_SPI_ENABLE           (1 << 0)  /* Enables SPI mode */
+#define H3800_ASIC1_MMC_SPI_REG_CRC_ON               (1 << 1)  /* 1:turn on CRC    */
+#define H3800_ASIC1_MMC_SPI_REG_SPI_CS_ENABLE        (1 << 2)  /* 1:turn on SPI CS */
+#define H3800_ASIC1_MMC_SPI_REG_CS_ADDRESS_MASK      0x38      /* Bits 3,4,5 are the SPI CS relative address */
+
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_FORMAT_NO_RESPONSE  0x00
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_FORMAT_R1           0x01
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_FORMAT_R2           0x02
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_FORMAT_R3           0x03
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_DATA_ENABLE         (1 << 2)  /* This command contains a data transfer */
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_WRITE               (1 << 3)  /* This data transfer is a write */
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_STREAM_MODE         (1 << 4)  /* This data transfer is in stream mode */
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_BUSY_BIT            (1 << 5)  /* Busy signal expected after current cmd */
+#define H3800_ASIC1_MMC_CMD_DATA_CONT_INITIALIZE          (1 << 6)  /* Enables the 80 bits for initializing card */
+
+#define H3800_ASIC1_MMC_INT_MASK_DATA_TRANSFER_DONE       (1 << 0)
+#define H3800_ASIC1_MMC_INT_MASK_PROGRAM_DONE             (1 << 1)
+#define H3800_ASIC1_MMC_INT_MASK_END_COMMAND_RESPONSE     (1 << 2)
+#define H3800_ASIC1_MMC_INT_MASK_BUFFER_READY             (1 << 3)
+
+#define H3800_ASIC1_MMC_BUFFER_PART_FULL                  (1 << 0)
+
+/********* GPIO **********/
+
+#define _H3800_ASIC1_GPIO_Base        0x1e00
+
+#define _H3800_ASIC1_GPIO_Mask          0x30    /* R/W 0:don't mask, 1:mask interrupt */
+#define _H3800_ASIC1_GPIO_Direction     0x32    /* R/W 0:input, 1:output              */
+#define _H3800_ASIC1_GPIO_Out           0x34    /* R/W 0:output low, 1:output high    */
+#define _H3800_ASIC1_GPIO_TriggerType   0x36    /* R/W 0:level, 1:edge                */
+#define _H3800_ASIC1_GPIO_EdgeTrigger   0x38    /* R/W 0:falling, 1:rising            */
+#define _H3800_ASIC1_GPIO_LevelTrigger  0x3A    /* R/W 0:low, 1:high level detect     */
+#define _H3800_ASIC1_GPIO_LevelStatus   0x3C    /* R/W 0:none, 1:detect               */
+#define _H3800_ASIC1_GPIO_EdgeStatus    0x3E    /* R/W 0:none, 1:detect               */
+#define _H3800_ASIC1_GPIO_State         0x40    /* R   See masks below  (default 0)         */
+#define _H3800_ASIC1_GPIO_Reset         0x42    /* R/W See masks below  (default 0x04)      */
+#define _H3800_ASIC1_GPIO_SleepMask     0x44    /* R/W 0:don't mask, 1:mask trigger in sleep mode  */
+#define _H3800_ASIC1_GPIO_SleepDir      0x46    /* R/W direction 0:input, 1:output in sleep mode    */
+#define _H3800_ASIC1_GPIO_SleepOut      0x48    /* R/W level 0:low, 1:high in sleep mode           */
+#define _H3800_ASIC1_GPIO_Status        0x4A    /* R   Pin status                                  */
+#define _H3800_ASIC1_GPIO_BattFaultDir  0x4C    /* R/W direction 0:input, 1:output in batt_fault   */
+#define _H3800_ASIC1_GPIO_BattFaultOut  0x4E    /* R/W level 0:low, 1:high in batt_fault           */
+
+#define H3800_ASIC1_GPIO_Mask         H3800_ASIC1_OFFSET( u16, GPIO, Mask )
+#define H3800_ASIC1_GPIO_Direction    H3800_ASIC1_OFFSET( u16, GPIO, Direction )
+#define H3800_ASIC1_GPIO_Out          H3800_ASIC1_OFFSET( u16, GPIO, Out )
+#define H3800_ASIC1_GPIO_TriggerType  H3800_ASIC1_OFFSET( u16, GPIO, TriggerType )
+#define H3800_ASIC1_GPIO_EdgeTrigger  H3800_ASIC1_OFFSET( u16, GPIO, EdgeTrigger )
+#define H3800_ASIC1_GPIO_LevelTrigger H3800_ASIC1_OFFSET( u16, GPIO, LevelTrigger )
+#define H3800_ASIC1_GPIO_LevelStatus  H3800_ASIC1_OFFSET( u16, GPIO, LevelStatus )
+#define H3800_ASIC1_GPIO_EdgeStatus   H3800_ASIC1_OFFSET( u16, GPIO, EdgeStatus )
+#define H3800_ASIC1_GPIO_State        H3800_ASIC1_OFFSET(  u8, GPIO, State )
+#define H3800_ASIC1_GPIO_Reset        H3800_ASIC1_OFFSET(  u8, GPIO, Reset )
+#define H3800_ASIC1_GPIO_SleepMask    H3800_ASIC1_OFFSET( u16, GPIO, SleepMask )
+#define H3800_ASIC1_GPIO_SleepDir     H3800_ASIC1_OFFSET( u16, GPIO, SleepDir )
+#define H3800_ASIC1_GPIO_SleepOut     H3800_ASIC1_OFFSET( u16, GPIO, SleepOut )
+#define H3800_ASIC1_GPIO_Status       H3800_ASIC1_OFFSET( u16, GPIO, Status )
+#define H3800_ASIC1_GPIO_BattFaultDir H3800_ASIC1_OFFSET( u16, GPIO, BattFaultDir )
+#define H3800_ASIC1_GPIO_BattFaultOut H3800_ASIC1_OFFSET( u16, GPIO, BattFaultOut )
+
+#define H3800_ASIC1_GPIO_STATE_MASK            (1 << 0)
+#define H3800_ASIC1_GPIO_STATE_DIRECTION       (1 << 1)
+#define H3800_ASIC1_GPIO_STATE_OUT             (1 << 2)
+#define H3800_ASIC1_GPIO_STATE_TRIGGER_TYPE    (1 << 3)
+#define H3800_ASIC1_GPIO_STATE_EDGE_TRIGGER    (1 << 4)
+#define H3800_ASIC1_GPIO_STATE_LEVEL_TRIGGER   (1 << 5)
+
+#define H3800_ASIC1_GPIO_RESET_SOFTWARE        (1 << 0)
+#define H3800_ASIC1_GPIO_RESET_AUTO_SLEEP      (1 << 1)
+#define H3800_ASIC1_GPIO_RESET_FIRST_PWR_ON    (1 << 2)
+
+/* These are all outputs */
+#define GPIO_H3800_ASIC1_IR_ON_N          (1 << 0)   /* Apply power to the IR Module */
+#define GPIO_H3800_ASIC1_SD_PWR_ON        (1 << 1)   /* Secure Digital power on */
+#define GPIO_H3800_ASIC1_RS232_ON         (1 << 2)   /* Turn on power to the RS232 chip ? */
+#define GPIO_H3800_ASIC1_PULSE_GEN        (1 << 3)   /* Goes to speaker / earphone */
+#define GPIO_H3800_ASIC1_CH_TIMER         (1 << 4)   /* */
+#define GPIO_H3800_ASIC1_LCD_5V_ON        (1 << 5)   /* Enables LCD_5V */
+#define GPIO_H3800_ASIC1_LCD_ON           (1 << 6)   /* Enables LCD_3V */
+#define GPIO_H3800_ASIC1_LCD_PCI          (1 << 7)   /* Connects to PDWN on LCD controller */
+#define GPIO_H3800_ASIC1_VGH_ON           (1 << 8)   /* Drives VGH on the LCD (+9??) */
+#define GPIO_H3800_ASIC1_VGL_ON           (1 << 9)   /* Drivers VGL on the LCD (-6??) */
+#define GPIO_H3800_ASIC1_FL_PWR_ON        (1 << 10)  /* Frontlight power on */
+#define GPIO_H3800_ASIC1_BT_PWR_ON        (1 << 11)  /* Bluetooth power on */
+#define GPIO_H3800_ASIC1_SPK_ON           (1 << 12)  /* */
+#define GPIO_H3800_ASIC1_EAR_ON_N         (1 << 13)  /* */
+#define GPIO_H3800_ASIC1_AUD_PWR_ON       (1 << 14)  /* */
+
+/* Write enable for the flash */
+
+#define _H3800_ASIC1_FlashWP_Base         0x1F00
+#define _H3800_ASIC1_FlashWP_VPP_ON         0x00    /* R   1: write, 0: protect */
+#define H3800_ASIC1_FlashWP_VPP_ON       H3800_ASIC1_OFFSET( u8, FlashWP, VPP_ON )
+
+#endif /* _INCLUDE_H3600_GPIO_H_ */
Index: build_tree/linux/include/asm/arch-sa1100/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/hardware.h
+ *
+ * Copyright (C) 1998 Nicolas Pitre <nico@cam.org>
+ *
+ * This file contains the hardware definitions for SA1100 architecture
+ *
+ * 2000/05/23 John Dorsey <john+@cs.cmu.edu>
+ *      Definitions for SA1111 added.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+
+#define UNCACHEABLE_ADDR	0xfa050000
+
+
+/*
+ * SA1100 internal I/O mappings
+ *
+ * We have the following mapping:
+ *      phys            virt
+ *      80000000        f8000000
+ *      90000000        fa000000
+ *      a0000000        fc000000
+ *      b0000000        fe000000
+ */
+
+#define VIO_BASE        0xf8000000	/* virtual start of IO space */
+#define VIO_SHIFT       3		/* x = IO space shrink power */
+#define PIO_START       0x80000000	/* physical start of IO space */
+
+#define io_p2v( x )             \
+   ( (((x)&0x00ffffff) | (((x)&0x30000000)>>VIO_SHIFT)) + VIO_BASE )
+#define io_v2p( x )             \
+   ( (((x)&0x00ffffff) | (((x)&(0x30000000>>VIO_SHIFT))<<VIO_SHIFT)) + PIO_START )
+
+#ifndef __ASSEMBLY__
+
+# define __REG(x)	(*((volatile unsigned long *)io_p2v(x)))
+# define __PREG(x)	(io_v2p((unsigned long)&(x)))
+
+#else
+
+# define __REG(x)	io_p2v(x)
+# define __PREG(x)	io_v2p(x)
+
+#endif
+
+#include "SA-1100.h"
+
+#ifdef CONFIG_SA1101
+#include "SA-1101.h"
+#endif
+
+#endif  /* _ASM_ARCH_HARDWARE_H */
Index: build_tree/linux/include/asm/arch-sa1100/ide.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/ide.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/ide.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,75 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/ide.h
+ *
+ * Copyright (c) 1998 Hugo Fiennes & Nicolas Pitre
+ *
+ * 18-aug-2000: Cleanup by Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
+ *              Get rid of the special ide_init_hwif_ports() functions
+ *              and make a generalised function that can be used by all
+ *              architectures.
+ */
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+#error "This code is broken and needs update to match with current ide support"
+
+
+/*
+ * Set up a hw structure for a specified data port, control port and IRQ.
+ * This should follow whatever the default interface uses.
+ */
+static inline void ide_init_hwif_ports(hw_regs_t *hw, unsigned long data_port,
+				       unsigned long ctrl_port, int *irq)
+{
+	unsigned long reg = data_port;
+	int i;
+	int regincr = 1;
+
+	/* The Empeg board has the first two address lines unused */
+	if (machine_is_empeg())
+		regincr = 1 << 2;
+
+	/* The LART doesn't use A0 for IDE */
+	if (machine_is_lart())
+		regincr = 1 << 1;
+
+	memset(hw, 0, sizeof(*hw));
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += regincr;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+
+	if (irq)
+		*irq = 0;
+}
+
+/*
+ * This registers the standard ports for this architecture with the IDE
+ * driver.
+ */
+static __inline__ void
+ide_init_default_hwifs(void)
+{
+    if (machine_is_lart()) {
+#ifdef CONFIG_SA1100_LART
+        hw_regs_t hw;
+
+        /* Enable GPIO as interrupt line */
+        GPDR &= ~LART_GPIO_IDE;
+	set_irq_type(LART_IRQ_IDE, IRQT_RISING);
+
+        /* set PCMCIA interface timing */
+        MECR = 0x00060006;
+
+        /* init the interface */
+	ide_init_hwif_ports(&hw, PCMCIA_IO_0_BASE + 0x0000, PCMCIA_IO_0_BASE + 0x1000, NULL);
+        hw.irq = LART_IRQ_IDE;
+        ide_register_hw(&hw);
+#endif
+    }
+}
Index: build_tree/linux/include/asm/arch-sa1100/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/io.h
+ *
+ * Copyright (C) 1997-1999 Russell King
+ *
+ * Modifications:
+ *  06-12-1997	RMK	Created.
+ *  07-04-1999	RMK	Major cleanup
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many 
+ * drivers out there that might just work if we fake them...
+ */
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+#define __io(a)			__io(a)
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,197 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/irqs.h
+ *
+ * Copyright (C) 1996 Russell King
+ * Copyright (C) 1998 Deborah Wallach (updates for SA1100/Brutus).
+ * Copyright (C) 1999 Nicolas Pitre (full GPIO irq isolation)
+ *
+ * 2001/11/14	RMK	Cleaned up and standardised a lot of the IRQs.
+ */
+
+#define	IRQ_GPIO0		0
+#define	IRQ_GPIO1		1
+#define	IRQ_GPIO2		2
+#define	IRQ_GPIO3		3
+#define	IRQ_GPIO4		4
+#define	IRQ_GPIO5		5
+#define	IRQ_GPIO6		6
+#define	IRQ_GPIO7		7
+#define	IRQ_GPIO8		8
+#define	IRQ_GPIO9		9
+#define	IRQ_GPIO10		10
+#define	IRQ_GPIO11_27		11
+#define	IRQ_LCD  		12	/* LCD controller           */
+#define	IRQ_Ser0UDC		13	/* Ser. port 0 UDC          */
+#define	IRQ_Ser1SDLC		14	/* Ser. port 1 SDLC         */
+#define	IRQ_Ser1UART		15	/* Ser. port 1 UART         */
+#define	IRQ_Ser2ICP		16	/* Ser. port 2 ICP          */
+#define	IRQ_Ser3UART		17	/* Ser. port 3 UART         */
+#define	IRQ_Ser4MCP		18	/* Ser. port 4 MCP          */
+#define	IRQ_Ser4SSP		19	/* Ser. port 4 SSP          */
+#define	IRQ_DMA0 		20	/* DMA controller channel 0 */
+#define	IRQ_DMA1 		21	/* DMA controller channel 1 */
+#define	IRQ_DMA2 		22	/* DMA controller channel 2 */
+#define	IRQ_DMA3 		23	/* DMA controller channel 3 */
+#define	IRQ_DMA4 		24	/* DMA controller channel 4 */
+#define	IRQ_DMA5 		25	/* DMA controller channel 5 */
+#define	IRQ_OST0 		26	/* OS Timer match 0         */
+#define	IRQ_OST1 		27	/* OS Timer match 1         */
+#define	IRQ_OST2 		28	/* OS Timer match 2         */
+#define	IRQ_OST3 		29	/* OS Timer match 3         */
+#define	IRQ_RTC1Hz		30	/* RTC 1 Hz clock           */
+#define	IRQ_RTCAlrm		31	/* RTC Alarm                */
+
+#define	IRQ_GPIO11		32
+#define	IRQ_GPIO12		33
+#define	IRQ_GPIO13		34
+#define	IRQ_GPIO14		35
+#define	IRQ_GPIO15		36
+#define	IRQ_GPIO16		37
+#define	IRQ_GPIO17		38
+#define	IRQ_GPIO18		39
+#define	IRQ_GPIO19		40
+#define	IRQ_GPIO20		41
+#define	IRQ_GPIO21		42
+#define	IRQ_GPIO22		43
+#define	IRQ_GPIO23		44
+#define	IRQ_GPIO24		45
+#define	IRQ_GPIO25		46
+#define	IRQ_GPIO26		47
+#define	IRQ_GPIO27		48
+
+/*
+ * The next 16 interrupts are for board specific purposes.  Since
+ * the kernel can only run on one machine at a time, we can re-use
+ * these.  If you need more, increase IRQ_BOARD_END, but keep it
+ * within sensible limits.  IRQs 49 to 64 are available.
+ */
+#define IRQ_BOARD_START		49
+#define IRQ_BOARD_END		65
+
+#define IRQ_SA1111_START	(IRQ_BOARD_END)
+#define IRQ_GPAIN0		(IRQ_BOARD_END + 0)
+#define IRQ_GPAIN1		(IRQ_BOARD_END + 1)
+#define IRQ_GPAIN2		(IRQ_BOARD_END + 2)
+#define IRQ_GPAIN3		(IRQ_BOARD_END + 3)
+#define IRQ_GPBIN0		(IRQ_BOARD_END + 4)
+#define IRQ_GPBIN1		(IRQ_BOARD_END + 5)
+#define IRQ_GPBIN2		(IRQ_BOARD_END + 6)
+#define IRQ_GPBIN3		(IRQ_BOARD_END + 7)
+#define IRQ_GPBIN4		(IRQ_BOARD_END + 8)
+#define IRQ_GPBIN5		(IRQ_BOARD_END + 9)
+#define IRQ_GPCIN0		(IRQ_BOARD_END + 10)
+#define IRQ_GPCIN1		(IRQ_BOARD_END + 11)
+#define IRQ_GPCIN2		(IRQ_BOARD_END + 12)
+#define IRQ_GPCIN3		(IRQ_BOARD_END + 13)
+#define IRQ_GPCIN4		(IRQ_BOARD_END + 14)
+#define IRQ_GPCIN5		(IRQ_BOARD_END + 15)
+#define IRQ_GPCIN6		(IRQ_BOARD_END + 16)
+#define IRQ_GPCIN7		(IRQ_BOARD_END + 17)
+#define IRQ_MSTXINT		(IRQ_BOARD_END + 18)
+#define IRQ_MSRXINT		(IRQ_BOARD_END + 19)
+#define IRQ_MSSTOPERRINT	(IRQ_BOARD_END + 20)
+#define IRQ_TPTXINT		(IRQ_BOARD_END + 21)
+#define IRQ_TPRXINT		(IRQ_BOARD_END + 22)
+#define IRQ_TPSTOPERRINT	(IRQ_BOARD_END + 23)
+#define SSPXMTINT		(IRQ_BOARD_END + 24)
+#define SSPRCVINT		(IRQ_BOARD_END + 25)
+#define SSPROR			(IRQ_BOARD_END + 26)
+#define AUDXMTDMADONEA		(IRQ_BOARD_END + 32)
+#define AUDRCVDMADONEA		(IRQ_BOARD_END + 33)
+#define AUDXMTDMADONEB		(IRQ_BOARD_END + 34)
+#define AUDRCVDMADONEB		(IRQ_BOARD_END + 35)
+#define AUDTFSR			(IRQ_BOARD_END + 36)
+#define AUDRFSR			(IRQ_BOARD_END + 37)
+#define AUDTUR			(IRQ_BOARD_END + 38)
+#define AUDROR			(IRQ_BOARD_END + 39)
+#define AUDDTS			(IRQ_BOARD_END + 40)
+#define AUDRDD			(IRQ_BOARD_END + 41)
+#define AUDSTO			(IRQ_BOARD_END + 42)
+#define IRQ_USBPWR		(IRQ_BOARD_END + 43)
+#define IRQ_HCIM		(IRQ_BOARD_END + 44)
+#define IRQ_HCIBUFFACC		(IRQ_BOARD_END + 45)
+#define IRQ_HCIRMTWKP		(IRQ_BOARD_END + 46)
+#define IRQ_NHCIMFCIR		(IRQ_BOARD_END + 47)
+#define IRQ_USB_PORT_RESUME	(IRQ_BOARD_END + 48)
+#define IRQ_S0_READY_NINT	(IRQ_BOARD_END + 49)
+#define IRQ_S1_READY_NINT	(IRQ_BOARD_END + 50)
+#define IRQ_S0_CD_VALID		(IRQ_BOARD_END + 51)
+#define IRQ_S1_CD_VALID		(IRQ_BOARD_END + 52)
+#define IRQ_S0_BVD1_STSCHG	(IRQ_BOARD_END + 53)
+#define IRQ_S1_BVD1_STSCHG	(IRQ_BOARD_END + 54)
+
+#define IRQ_LOCOMO_START	(IRQ_BOARD_END)
+#define IRQ_LOCOMO_KEY		(IRQ_BOARD_END + 0)
+#define IRQ_LOCOMO_GPIO0	(IRQ_BOARD_END + 1)
+#define IRQ_LOCOMO_GPIO1	(IRQ_BOARD_END + 2)
+#define IRQ_LOCOMO_GPIO2	(IRQ_BOARD_END + 3)
+#define IRQ_LOCOMO_GPIO3	(IRQ_BOARD_END + 4)
+#define IRQ_LOCOMO_GPIO4	(IRQ_BOARD_END + 5)
+#define IRQ_LOCOMO_GPIO5	(IRQ_BOARD_END + 6)
+#define IRQ_LOCOMO_GPIO6	(IRQ_BOARD_END + 7)
+#define IRQ_LOCOMO_GPIO7	(IRQ_BOARD_END + 8)
+#define IRQ_LOCOMO_GPIO8	(IRQ_BOARD_END + 9)
+#define IRQ_LOCOMO_GPIO9	(IRQ_BOARD_END + 10)
+#define IRQ_LOCOMO_GPIO10	(IRQ_BOARD_END + 11)
+#define IRQ_LOCOMO_GPIO11	(IRQ_BOARD_END + 12)
+#define IRQ_LOCOMO_GPIO12	(IRQ_BOARD_END + 13)
+#define IRQ_LOCOMO_GPIO13	(IRQ_BOARD_END + 14)
+#define IRQ_LOCOMO_GPIO14	(IRQ_BOARD_END + 15)
+#define IRQ_LOCOMO_GPIO15	(IRQ_BOARD_END + 16)
+#define IRQ_LOCOMO_LT		(IRQ_BOARD_END + 17)
+#define IRQ_LOCOMO_SPI_RFR	(IRQ_BOARD_END + 18)
+#define IRQ_LOCOMO_SPI_RFW	(IRQ_BOARD_END + 19)
+#define IRQ_LOCOMO_SPI_OVRN	(IRQ_BOARD_END + 20)
+#define IRQ_LOCOMO_SPI_TEND	(IRQ_BOARD_END + 21)
+
+/*
+ * Figure out the MAX IRQ number.
+ *
+ * If we have an SA1111, the max IRQ is S1_BVD1_STSCHG+1.
+ * If we have an LoCoMo, the max IRQ is IRQ_LOCOMO_SPI_TEND+1
+ * Otherwise, we have the standard IRQs only.
+ */
+#ifdef CONFIG_SA1111
+#define NR_IRQS			(IRQ_S1_BVD1_STSCHG + 1)
+#elif defined(CONFIG_SA1100_H3800)
+#define NR_IRQS			(IRQ_BOARD_END)
+#elif defined(CONFIG_SHARP_LOCOMO)
+#define NR_IRQS			(IRQ_LOCOMO_SPI_TEND + 1)
+#else
+#define NR_IRQS			(IRQ_BOARD_START)
+#endif
+
+/*
+ * Board specific IRQs.  Define them here.
+ * Do not surround them with ifdefs.
+ */
+#define IRQ_NEPONSET_SMC9196	(IRQ_BOARD_START + 0)
+#define IRQ_NEPONSET_USAR	(IRQ_BOARD_START + 1)
+#define IRQ_NEPONSET_SA1111	(IRQ_BOARD_START + 2)
+
+/* LoCoMo Interrupts (CONFIG_SHARP_LOCOMO) */
+#define IRQ_LOCOMO_KEY_BASE	(IRQ_BOARD_START + 0)
+#define IRQ_LOCOMO_GPIO_BASE	(IRQ_BOARD_START + 1)
+#define IRQ_LOCOMO_LT_BASE	(IRQ_BOARD_START + 2)
+#define IRQ_LOCOMO_SPI_BASE	(IRQ_BOARD_START + 3)
+
+/* H3800-specific IRQs (CONFIG_SA1100_H3800) */
+#define H3800_KPIO_IRQ_START    (IRQ_BOARD_START)
+#define IRQ_H3800_KEY           (IRQ_BOARD_START + 0)
+#define IRQ_H3800_SPI           (IRQ_BOARD_START + 1)
+#define IRQ_H3800_OWM           (IRQ_BOARD_START + 2)
+#define IRQ_H3800_ADC           (IRQ_BOARD_START + 3)
+#define IRQ_H3800_UART_0        (IRQ_BOARD_START + 4)
+#define IRQ_H3800_UART_1        (IRQ_BOARD_START + 5)
+#define IRQ_H3800_TIMER_0       (IRQ_BOARD_START + 6)
+#define IRQ_H3800_TIMER_1       (IRQ_BOARD_START + 7)
+#define IRQ_H3800_TIMER_2       (IRQ_BOARD_START + 8)
+#define H3800_KPIO_IRQ_COUNT    9
+
+#define H3800_GPIO_IRQ_START    (IRQ_BOARD_START + 9)
+#define IRQ_H3800_PEN           (IRQ_BOARD_START + 9)
+#define IRQ_H3800_SD_DETECT     (IRQ_BOARD_START + 10)
+#define IRQ_H3800_EAR_IN        (IRQ_BOARD_START + 11)
+#define IRQ_H3800_USB_DETECT    (IRQ_BOARD_START + 12)
+#define IRQ_H3800_SD_CON_SLT    (IRQ_BOARD_START + 13)
+#define H3800_GPIO_IRQ_COUNT    5
Index: build_tree/linux/include/asm/arch-sa1100/lart.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/lart.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/lart.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,13 @@
+#ifndef _INCLUDE_LART_H
+#define _INCLUDE_LART_H
+
+#define LART_GPIO_ETH0			GPIO_GPIO0
+#define LART_IRQ_ETH0			IRQ_GPIO0
+
+#define LART_GPIO_IDE			GPIO_GPIO1
+#define LART_IRQ_IDE			IRQ_GPIO1
+
+#define LART_GPIO_UCB1200		GPIO_GPIO18
+#define LART_IRQ_UCB1200		IRQ_GPIO18
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/mcp.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/mcp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/mcp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/arch-sa1100/mcp.h
+ *
+ *  Copyright (C) 2005 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_ARCH_MCP_H
+#define __ASM_ARM_ARCH_MCP_H
+
+#include <linux/types.h>
+
+struct mcp_plat_data {
+	u32 mccr0;
+	u32 mccr1;
+	unsigned int sclk_rate;
+};
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,68 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/memory.h
+ *
+ * Copyright (C) 1999-2000 Nicolas Pitre <nico@cam.org>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/sizes.h>
+
+/*
+ * Physical DRAM offset is 0xc0000000 on the SA1100
+ */
+#define PHYS_OFFSET	UL(0xc0000000)
+
+#ifndef __ASSEMBLY__
+
+#ifdef CONFIG_SA1111
+void sa1111_adjust_zones(int node, unsigned long *size, unsigned long *holes);
+
+#define arch_adjust_zones(node, size, holes) \
+	sa1111_adjust_zones(node, size, holes)
+
+#define ISA_DMA_THRESHOLD	(PHYS_OFFSET + SZ_1M - 1)
+
+#endif
+#endif
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ *
+ * On the SA1100, bus addresses are equivalent to physical addresses.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+/*
+ * Because of the wide memory address space between physical RAM banks on the 
+ * SA1100, it's much convenient to use Linux's NUMA support to implement our 
+ * memory map representation.  Assuming all memory nodes have equal access 
+ * characteristics, we then have generic discontiguous memory support.
+ *
+ * Of course, all this isn't mandatory for SA1100 implementations with only
+ * one used memory bank.  For those, simply undefine CONFIG_DISCONTIGMEM.
+ *
+ * The nodes are matched with the physical memory bank addresses which are 
+ * incidentally the same as virtual addresses.
+ * 
+ * 	node 0:  0xc0000000 - 0xc7ffffff
+ * 	node 1:  0xc8000000 - 0xcfffffff
+ * 	node 2:  0xd0000000 - 0xd7ffffff
+ * 	node 3:  0xd8000000 - 0xdfffffff
+ */
+#define NODE_MEM_SIZE_BITS	27
+
+/*
+ * Cache flushing area - SA1100 zero bank
+ */
+#define FLUSH_BASE_PHYS		0xe0000000
+#define FLUSH_BASE		0xf5000000
+#define FLUSH_BASE_MINICACHE	0xf5100000
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/mtd-xip.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/mtd-xip.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/mtd-xip.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * MTD primitives for XIP support. Architecture specific functions
+ *
+ * Do not include this file directly. It's included from linux/mtd/xip.h
+ * 
+ * Author:	Nicolas Pitre
+ * Created:	Nov 2, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * $Id: xip.h,v 1.2 2004/12/01 15:49:10 nico Exp $
+ */
+
+#ifndef __ARCH_SA1100_MTD_XIP_H__
+#define __ARCH_SA1100_MTD_XIP_H__
+
+#define xip_irqpending()	(ICIP & ICMR)
+
+/* we sample OSCR and convert desired delta to usec (1/4 ~= 1000000/3686400) */
+#define xip_currtime()		(OSCR)
+#define xip_elapsed_since(x)	(signed)((OSCR - (x)) / 4)
+
+#endif /* __ARCH_SA1100_MTD_XIP_H__ */
Index: build_tree/linux/include/asm/arch-sa1100/neponset.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/neponset.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/neponset.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,74 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/neponset.h
+ *
+ * Created 2000/06/05 by Nicolas Pitre <nico@cam.org>
+ *
+ * This file contains the hardware specific definitions for Assabet
+ * Only include this file from SA1100-specific files.
+ *
+ * 2000/05/23 John Dorsey <john+@cs.cmu.edu>
+ *      Definitions for Neponset added.
+ */
+#ifndef __ASM_ARCH_NEPONSET_H
+#define __ASM_ARCH_NEPONSET_H
+
+/*
+ * Neponset definitions: 
+ */
+
+#define NEPONSET_CPLD_BASE      (0x10000000)
+#define Nep_p2v( x )            ((x) - NEPONSET_CPLD_BASE + 0xf3000000)
+#define Nep_v2p( x )            ((x) - 0xf3000000 + NEPONSET_CPLD_BASE)
+
+#define _IRR                    0x10000024      /* Interrupt Reason Register */
+#define _AUD_CTL                0x100000c0      /* Audio controls (RW)       */
+#define _MDM_CTL_0              0x100000b0      /* Modem control 0 (RW)      */
+#define _MDM_CTL_1              0x100000b4      /* Modem control 1 (RW)      */
+#define _NCR_0	                0x100000a0      /* Control Register (RW)     */
+#define _KP_X_OUT               0x10000090      /* Keypad row write (RW)     */
+#define _KP_Y_IN                0x10000080      /* Keypad column read (RO)   */
+#define _SWPK                   0x10000020      /* Switch pack (RO)          */
+#define _WHOAMI                 0x10000000      /* System ID Register (RO)   */
+
+#define _LEDS                   0x10000010      /* LEDs [31:0] (WO)          */
+
+#define IRR                     (*((volatile u_char *) Nep_p2v(_IRR)))
+#define AUD_CTL                 (*((volatile u_char *) Nep_p2v(_AUD_CTL)))
+#define MDM_CTL_0               (*((volatile u_char *) Nep_p2v(_MDM_CTL_0)))
+#define MDM_CTL_1               (*((volatile u_char *) Nep_p2v(_MDM_CTL_1)))
+#define NCR_0			(*((volatile u_char *) Nep_p2v(_NCR_0)))
+#define KP_X_OUT                (*((volatile u_char *) Nep_p2v(_KP_X_OUT)))
+#define KP_Y_IN                 (*((volatile u_char *) Nep_p2v(_KP_Y_IN)))
+#define SWPK                    (*((volatile u_char *) Nep_p2v(_SWPK)))
+#define WHOAMI                  (*((volatile u_char *) Nep_p2v(_WHOAMI)))
+
+#define LEDS                    (*((volatile Word   *) Nep_p2v(_LEDS)))
+
+#define IRR_ETHERNET		(1<<0)
+#define IRR_USAR		(1<<1)
+#define IRR_SA1111		(1<<2)
+
+#define AUD_SEL_1341            (1<<0)
+#define AUD_MUTE_1341           (1<<1)
+
+#define MDM_CTL0_RTS1		(1 << 0)
+#define MDM_CTL0_DTR1		(1 << 1)
+#define MDM_CTL0_RTS2		(1 << 2)
+#define MDM_CTL0_DTR2		(1 << 3)
+
+#define MDM_CTL1_CTS1		(1 << 0)
+#define MDM_CTL1_DSR1		(1 << 1)
+#define MDM_CTL1_DCD1		(1 << 2)
+#define MDM_CTL1_CTS2		(1 << 3)
+#define MDM_CTL1_DSR2		(1 << 4)
+#define MDM_CTL1_DCD2		(1 << 5)
+
+#define NCR_GP01_OFF		(1<<0)
+#define NCR_TP_PWR_EN		(1<<1)
+#define NCR_MS_PWR_EN		(1<<2)
+#define NCR_ENET_OSC_EN		(1<<3)
+#define NCR_SPI_KB_WK_UP	(1<<4)
+#define NCR_A0VPP		(1<<5)
+#define NCR_A1VPP		(1<<6)
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/shannon.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/shannon.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/shannon.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,43 @@
+#ifndef _INCLUDE_SHANNON_H
+#define _INCLUDE_SHANNON_H
+
+/* taken from comp.os.inferno Tue, 12 Sep 2000 09:21:50 GMT,
+ * written by <forsyth@vitanuova.com> */
+
+#define SHANNON_GPIO_SPI_FLASH		GPIO_GPIO (0)	/* Output - Driven low, enables SPI to flash */
+#define SHANNON_GPIO_SPI_DSP		GPIO_GPIO (1)	/* Output - Driven low, enables SPI to DSP */
+/* lcd lower = GPIO 2-9 */
+#define SHANNON_GPIO_SPI_OUTPUT		GPIO_GPIO (10)	/* Output - SPI output to DSP */
+#define SHANNON_GPIO_SPI_INPUT		GPIO_GPIO (11)	/* Input  - SPI input from DSP */
+#define SHANNON_GPIO_SPI_CLOCK		GPIO_GPIO (12)	/* Output - Clock for SPI */
+#define SHANNON_GPIO_SPI_FRAME		GPIO_GPIO (13)	/* Output - Frame marker - not used */
+#define SHANNON_GPIO_SPI_RTS		GPIO_GPIO (14)	/* Input  - SPI Ready to Send */
+#define SHANNON_IRQ_GPIO_SPI_RTS	IRQ_GPIO14
+#define SHANNON_GPIO_SPI_CTS		GPIO_GPIO (15)	/* Output - SPI Clear to Send */
+#define SHANNON_GPIO_IRQ_CODEC		GPIO_GPIO (16)	/* in, irq from ucb1200 */
+#define SHANNON_IRQ_GPIO_IRQ_CODEC	IRQ_GPIO16
+#define SHANNON_GPIO_DSP_RESET		GPIO_GPIO (17)	/* Output - Drive low to reset the DSP */
+#define SHANNON_GPIO_CODEC_RESET	GPIO_GPIO (18)	/* Output - Drive low to reset the UCB1x00 */
+#define SHANNON_GPIO_U3_RTS		GPIO_GPIO (19)	/* ?? */
+#define SHANNON_GPIO_U3_CTS		GPIO_GPIO (20)	/* ?? */
+#define SHANNON_GPIO_SENSE_12V		GPIO_GPIO (21)	/* Input, 12v flash unprotect detected */
+#define SHANNON_GPIO_DISP_EN		GPIO_GPIO (22)	/* out */
+/* XXX GPIO 23 unaccounted for */
+#define SHANNON_GPIO_EJECT_0		GPIO_GPIO (24)	/* in */
+#define SHANNON_IRQ_GPIO_EJECT_0	IRQ_GPIO24
+#define SHANNON_GPIO_EJECT_1		GPIO_GPIO (25)	/* in */
+#define SHANNON_IRQ_GPIO_EJECT_1	IRQ_GPIO25
+#define SHANNON_GPIO_RDY_0		GPIO_GPIO (26)	/* in */
+#define SHANNON_IRQ_GPIO_RDY_0		IRQ_GPIO26
+#define SHANNON_GPIO_RDY_1		GPIO_GPIO (27)	/* in */
+#define SHANNON_IRQ_GPIO_RDY_1		IRQ_GPIO27
+
+/* MCP UCB codec GPIO pins... */
+
+#define SHANNON_UCB_GPIO_BACKLIGHT	9
+#define SHANNON_UCB_GPIO_BRIGHT_MASK  	7
+#define SHANNON_UCB_GPIO_BRIGHT		6
+#define SHANNON_UCB_GPIO_CONTRAST_MASK	0x3f
+#define SHANNON_UCB_GPIO_CONTRAST	0
+
+#endif
Index: build_tree/linux/include/asm/arch-sa1100/simpad.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/simpad.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/simpad.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,112 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/simpad.h
+ *
+ * based of assabet.h same as HUW_Webpanel
+ *
+ * This file contains the hardware specific definitions for SIMpad
+ *
+ * 2001/05/14 Juergen Messerer <juergen.messerer@freesurf.ch>
+ */
+
+#ifndef __ASM_ARCH_SIMPAD_H
+#define __ASM_ARCH_SIMPAD_H
+
+
+#define GPIO_UART1_RTS	GPIO_GPIO14
+#define GPIO_UART1_DTR	GPIO_GPIO7
+#define GPIO_UART1_CTS	GPIO_GPIO8
+#define GPIO_UART1_DCD	GPIO_GPIO23
+#define GPIO_UART1_DSR	GPIO_GPIO6
+
+#define GPIO_UART3_RTS	GPIO_GPIO12
+#define GPIO_UART3_DTR	GPIO_GPIO16
+#define GPIO_UART3_CTS	GPIO_GPIO13
+#define GPIO_UART3_DCD	GPIO_GPIO18
+#define GPIO_UART3_DSR	GPIO_GPIO17
+
+#define GPIO_POWER_BUTTON	GPIO_GPIO0
+#define GPIO_UCB1300_IRQ	GPIO_GPIO22	/* UCB GPIO and touchscreen */
+
+#define IRQ_UART1_CTS	IRQ_GPIO15
+#define IRQ_UART1_DCD	GPIO_GPIO23
+#define IRQ_UART1_DSR	GPIO_GPIO6
+#define IRQ_UART3_CTS	GPIO_GPIO13
+#define IRQ_UART3_DCD	GPIO_GPIO18
+#define IRQ_UART3_DSR	GPIO_GPIO17
+
+#define IRQ_GPIO_UCB1300_IRQ IRQ_GPIO22
+#define IRQ_GPIO_POWER_BUTTON IRQ_GPIO0
+
+
+/*---  PCMCIA  ---*/
+#define GPIO_CF_CD              GPIO_GPIO24
+#define GPIO_CF_IRQ             GPIO_GPIO1
+#define IRQ_GPIO_CF_IRQ         IRQ_GPIO1
+#define IRQ_GPIO_CF_CD          IRQ_GPIO24
+
+/*--- SmartCard ---*/
+#define GPIO_SMART_CARD		GPIO_GPIO10
+#define IRQ_GPIO_SMARD_CARD	IRQ_GPIO10
+
+// CS3 Latch is write only, a shadow is necessary
+
+#define CS3BUSTYPE unsigned volatile long
+#define CS3_BASE        0xf1000000
+
+#define VCC_5V_EN       0x0001 // For 5V PCMCIA
+#define VCC_3V_EN       0x0002 // FOR 3.3V PCMCIA
+#define EN1             0x0004 // This is only for EPROM's
+#define EN0             0x0008 // Both should be enable for 3.3V or 5V
+#define DISPLAY_ON      0x0010
+#define PCMCIA_BUFF_DIS 0x0020
+#define MQ_RESET        0x0040
+#define PCMCIA_RESET    0x0080
+#define DECT_POWER_ON   0x0100
+#define IRDA_SD         0x0200 // Shutdown for powersave
+#define RS232_ON        0x0400
+#define SD_MEDIAQ       0x0800 // Shutdown for powersave
+#define LED2_ON         0x1000
+#define IRDA_MODE       0x2000 // Fast/Slow IrDA mode
+#define ENABLE_5V       0x4000 // Enable 5V circuit
+#define RESET_SIMCARD   0x8000
+
+#define RS232_ENABLE    0x0440
+#define PCMCIAMASK      0x402f
+
+
+struct simpad_battery {
+	unsigned char ac_status;	/* line connected yes/no */
+	unsigned char status;		/* battery loading yes/no */
+	unsigned char percentage;	/* percentage loaded */
+	unsigned short life;		/* life till empty */
+};
+
+/* These should match the apm_bios.h definitions */
+#define SIMPAD_AC_STATUS_AC_OFFLINE      0x00
+#define SIMPAD_AC_STATUS_AC_ONLINE       0x01
+#define SIMPAD_AC_STATUS_AC_BACKUP       0x02   /* What does this mean? */
+#define SIMPAD_AC_STATUS_AC_UNKNOWN      0xff
+
+/* These bitfields are rarely "or'd" together */
+#define SIMPAD_BATT_STATUS_HIGH          0x01
+#define SIMPAD_BATT_STATUS_LOW           0x02
+#define SIMPAD_BATT_STATUS_CRITICAL      0x04
+#define SIMPAD_BATT_STATUS_CHARGING      0x08
+#define SIMPAD_BATT_STATUS_CHARGE_MAIN   0x10
+#define SIMPAD_BATT_STATUS_DEAD          0x20   /* Battery will not charge */
+#define SIMPAD_BATT_NOT_INSTALLED        0x20   /* For expansion pack batteries */
+#define SIMPAD_BATT_STATUS_FULL          0x40   /* Battery fully charged (and connected to AC) */
+#define SIMPAD_BATT_STATUS_NOBATT        0x80
+#define SIMPAD_BATT_STATUS_UNKNOWN       0xff
+
+extern int simpad_get_battery(struct simpad_battery* );
+
+#endif // __ASM_ARCH_SIMPAD_H
+
+
+
+
+
+
+
+
Index: build_tree/linux/include/asm/arch-sa1100/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,22 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/system.h
+ *
+ * Copyright (c) 1999 Nicolas Pitre <nico@cam.org>
+ */
+#include <asm/hardware.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	if (mode == 's') {
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+	} else {
+		/* Use on-chip reset capability */
+		RSRR = RSRR_SWR;
+	}
+}
Index: build_tree/linux/include/asm/arch-sa1100/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,12 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/timex.h
+ *
+ * SA1100 architecture timex specifications
+ *
+ * Copyright (C) 1998 
+ */
+
+/*
+ * SA1100 timer
+ */
+#define CLOCK_TICK_RATE		3686400
Index: build_tree/linux/include/asm/arch-sa1100/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,50 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/uncompress.h
+ *
+ * (C) 1999 Nicolas Pitre <nico@cam.org>
+ *
+ * Reorganised to be machine independent.
+ */
+
+#include "hardware.h"
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ */
+
+#define UART(x)		(*(volatile unsigned long *)(serial_port + (x)))
+
+static void putc(int c)
+{
+	unsigned long serial_port;
+
+	do {
+		serial_port = _Ser3UTCR0;
+		if (UART(UTCR3) & UTCR3_TXE) break;
+		serial_port = _Ser1UTCR0;
+		if (UART(UTCR3) & UTCR3_TXE) break;
+		serial_port = _Ser2UTCR0;
+		if (UART(UTCR3) & UTCR3_TXE) break;
+		return;
+	} while (0);
+
+	/* wait for space in the UART's transmitter */
+	while (!(UART(UTSR1) & UTSR1_TNF))
+		barrier();
+
+	/* send the character out. */
+	UART(UTDR) = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * Nothing to do for these
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-sa1100/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-sa1100/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-sa1100/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,4 @@
+/*
+ * linux/include/asm-arm/arch-sa1100/vmalloc.h
+ */
+#define VMALLOC_END       (0xe8000000)
Index: build_tree/linux/include/asm/arch-shark/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-shark/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,31 @@
+/* linux/include/asm-arm/arch-shark/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mov	\rx, #0xe0000000
+		orr	\rx, \rx, #0x000003f8
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx]
+		.endm
+
+		.macro	busyuart,rd,rx
+		mov	\rd, #0
+1001:		add	\rd, \rd, #1
+		teq	\rd, #0x10000
+		bne	1001b
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
Index: build_tree/linux/include/asm/arch-shark/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,18 @@
+/*
+ * linux/include/asm-arm/arch-shark/dma.h
+ *
+ * by Alexander Schulz
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+/* Use only the lowest 4MB, nothing else works.
+ * The rest is not DMAable. See dev /  .properties
+ * in OpenFirmware.
+ */
+#define MAX_DMA_ADDRESS		0xC0400000
+#define MAX_DMA_CHANNELS	8
+#define DMA_ISA_CASCADE         4
+
+#endif /* _ASM_ARCH_DMA_H */
+
Index: build_tree/linux/include/asm/arch-shark/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-shark/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,41 @@
+/*
+ * include/asm-arm/arch-shark/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Shark platform
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	r4, #0xe0000000
+
+		mov	\irqstat, #0x0C
+		strb	\irqstat, [r4, #0x20]		@outb(0x0C, 0x20) /* Poll command */
+		ldrb	\irqnr, [r4, #0x20]		@irq = inb(0x20) & 7
+		and	\irqstat, \irqnr, #0x80
+		teq	\irqstat, #0
+		beq	43f
+		and	\irqnr, \irqnr, #7
+		teq	\irqnr, #2
+		bne	44f
+43:		mov	\irqstat, #0x0C
+		strb	\irqstat, [r4, #0xa0]		@outb(0x0C, 0xA0) /* Poll command */
+		ldrb	\irqnr, [r4, #0xa0]		@irq = (inb(0xA0) & 7) + 8
+		and	\irqstat, \irqnr, #0x80
+		teq	\irqstat, #0
+		beq	44f
+		and	\irqnr, \irqnr, #7
+		add	\irqnr, \irqnr, #8
+44:		teq	\irqstat, #0
+		.endm
+
Index: build_tree/linux/include/asm/arch-shark/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,51 @@
+/*
+ * linux/include/asm-arm/arch-shark/hardware.h
+ *
+ * by Alexander Schulz
+ *
+ * derived from:
+ * linux/include/asm-arm/arch-ebsa110/hardware.h
+ * Copyright (C) 1996-1999 Russell King.
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#ifndef __ASSEMBLY__
+
+/*
+ * Mapping areas
+ */
+#define IO_BASE			0xe0000000
+
+#else
+
+#define IO_BASE			0
+
+#endif
+
+#define IO_SIZE			0x08000000
+#define IO_START		0x40000000
+#define ROMCARD_SIZE		0x08000000
+#define ROMCARD_START		0x10000000
+
+#define PCIO_BASE		0xe0000000
+
+
+/* defines for the Framebuffer */
+#define FB_START		0x06000000
+#define FB_SIZE			0x01000000
+
+#define UNCACHEABLE_ADDR        0xdf010000
+
+#define SEQUOIA_LED_GREEN       (1<<6)
+#define SEQUOIA_LED_AMBER       (1<<5)
+#define SEQUOIA_LED_BACK        (1<<7)
+
+#define pcibios_assign_all_busses()     1
+
+#define PCIBIOS_MIN_IO          0x6000
+#define PCIBIOS_MIN_MEM         0x50000000
+#define PCIMEM_BASE		0xe8000000
+
+#endif
+
Index: build_tree/linux/include/asm/arch-shark/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,56 @@
+/*
+ * linux/include/asm-arm/arch-shark/io.h
+ *
+ * by Alexander Schulz
+ *
+ * derived from:
+ * linux/include/asm-arm/arch-ebsa110/io.h
+ * Copyright (C) 1997,1998 Russell King
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We use two different types of addressing - PC style addresses, and ARM
+ * addresses.  PC style accesses the PC hardware with the normal PC IO
+ * addresses, eg 0x3f8 for serial#1.  ARM addresses are 0x80000000+
+ * and are translated to the start of IO.
+ */
+#define __PORT_PCIO(x)	(!((x) & 0x80000000))
+
+#define __io(a)                 ((void __iomem *)(PCIO_BASE + (a)))
+
+
+static inline unsigned int __ioaddr (unsigned int port)			\
+{										\
+	if (__PORT_PCIO(port))							\
+		return (unsigned int)(PCIO_BASE + (port));			\
+	else									\
+		return (unsigned int)(IO_BASE + (port));			\
+}
+
+#define __mem_pci(addr) (addr)
+
+/*
+ * Translated address IO functions
+ *
+ * IO address has already been translated to a virtual address
+ */
+#define outb_t(v,p)								\
+	(*(volatile unsigned char *)(p) = (v))
+
+#define inb_t(p)								\
+	(*(volatile unsigned char *)(p))
+
+#define outl_t(v,p)								\
+	(*(volatile unsigned long *)(p) = (v))
+
+#define inl_t(p)								\
+	(*(volatile unsigned long *)(p))
+
+#endif
Index: build_tree/linux/include/asm/arch-shark/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,13 @@
+/*
+ * linux/include/asm-arm/arch-shark/irqs.h
+ *
+ * by Alexander Schulz
+ */
+
+#define NR_IRQS			16
+
+#define IRQ_ISA_KEYBOARD	 1
+#define RTC_IRQ			 8
+#define I8042_KBD_IRQ		 1
+#define I8042_AUX_IRQ		12
+#define IRQ_HARDDISK            14
Index: build_tree/linux/include/asm/arch-shark/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,48 @@
+/*
+ * linux/include/asm-arm/arch-shark/memory.h
+ *
+ * by Alexander Schulz
+ *
+ * derived from:
+ * linux/include/asm-arm/arch-ebsa110/memory.h
+ * Copyright (c) 1996-1999 Russell King.
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/sizes.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET     UL(0x08000000)
+
+#ifndef __ASSEMBLY__
+
+static inline void __arch_adjust_zones(int node, unsigned long *zone_size, unsigned long *zhole_size) 
+{
+  if (node != 0) return;
+  /* Only the first 4 MB (=1024 Pages) are usable for DMA */
+  zone_size[1] = zone_size[0] - 1024;
+  zone_size[0] = 1024;
+  zhole_size[1] = zhole_size[0];
+  zhole_size[0] = 0;
+}
+
+#define arch_adjust_zones(node, size, holes) \
+	__arch_adjust_zones(node, size, holes)
+
+#define ISA_DMA_THRESHOLD	(PHYS_OFFSET + SZ_4M - 1)
+
+#endif
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+/*
+ * Cache flushing area
+ */
+#define FLUSH_BASE_PHYS		0x80000000
+#define FLUSH_BASE		0xdf000000
+
+#endif
Index: build_tree/linux/include/asm/arch-shark/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ * linux/include/asm-arm/arch-shark/system.h
+ *
+ * by Alexander Schulz
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/io.h>
+
+static void arch_reset(char mode)
+{
+	short temp;
+	local_irq_disable();
+	/* Reset the Machine via pc[3] of the sequoia chipset */
+	outw(0x09,0x24);
+	temp=inw(0x26);
+	temp = temp | (1<<3) | (1<<10);
+	outw(0x09,0x24);
+	outw(temp,0x26);
+
+}
+
+static inline void arch_idle(void)
+{
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-shark/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,7 @@
+/*
+ * linux/include/asm-arm/arch-shark/timex.h
+ *
+ * by Alexander Schulz
+ */
+
+#define CLOCK_TICK_RATE 1193180
Index: build_tree/linux/include/asm/arch-shark/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,51 @@
+/*
+ * linux/include/asm-arm/arch-shark/uncompress.h
+ * by Alexander Schulz
+ *
+ * derived from:
+ * linux/include/asm-arm/arch-ebsa285/uncompress.h
+ * Copyright (C) 1996,1997,1998 Russell King
+ */
+
+#define SERIAL_BASE ((volatile unsigned char *)0x400003f8)
+
+static inline void putc(int c)
+{
+	int t;
+
+	SERIAL_BASE[0] = c;
+	t=0x10000;
+	while (t--);
+}
+
+static inline void flush(void)
+{
+}
+
+#ifdef DEBUG
+static void putn(unsigned long z)
+{
+	int i;
+	char x;
+
+	putc('0');
+	putc('x');
+	for (i=0;i<8;i++) {
+		x='0'+((z>>((7-i)*4))&0xf);
+		if (x>'9') x=x-'0'+'A'-10;
+		putc(x);
+	}
+}
+
+static void putr()
+{
+	putc('\n');
+	putc('\r');
+}
+#endif
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-shark/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-shark/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-shark/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,4 @@
+/*
+ * linux/include/asm-arm/arch-shark/vmalloc.h
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
Index: build_tree/linux/include/asm/arch-versatile/debug-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/debug-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/debug-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/* linux/include/asm-arm/arch-versatile/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx,      #0x10000000
+		movne	\rx,      #0xf1000000	@ virtual base
+		orr	\rx, \rx, #0x001F0000
+		orr	\rx, \rx, #0x00001000
+		.endm
+
+#include <asm/hardware/debug-pl01x.S>
Index: build_tree/linux/include/asm/arch-versatile/dma.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/dma.h
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
Index: build_tree/linux/include/asm/arch-versatile/entry-macro.S
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/entry-macro.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/entry-macro.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,44 @@
+/*
+ * include/asm-arm/arch-versatile/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Versatile platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <asm/hardware.h>
+#include <asm/hardware/vic.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =IO_ADDRESS(VERSATILE_VIC_BASE)
+		ldr	\irqstat, [\base, #VIC_IRQ_STATUS]	@ get masked status
+		mov	\irqnr, #0
+		teq	\irqstat, #0
+		beq	1003f
+
+1001:		tst	\irqstat, #15
+		bne	1002f
+		add	\irqnr, \irqnr, #4
+		movs	\irqstat, \irqstat, lsr #4
+		bne	1001b
+1002:		tst	\irqstat, #1
+		bne	1003f
+		add	\irqnr, \irqnr, #1
+		movs	\irqstat, \irqstat, lsr #1
+		bne	1002b
+1003:		/* EQ will be set if no irqs pending */
+
+@		clz	\irqnr, \irqstat
+@1003:		/* EQ will be set if we reach MAXIRQNUM */
+		.endm
+
Index: build_tree/linux/include/asm/arch-versatile/hardware.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/hardware.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/hardware.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,52 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/hardware.h
+ *
+ *  This file contains the hardware definitions of the Versatile boards.
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <asm/arch/platform.h>
+
+/*
+ * PCI space virtual addresses
+ */
+#define VERSATILE_PCI_VIRT_BASE		(void __iomem *)0xe8000000ul
+#define VERSATILE_PCI_CFG_VIRT_BASE	(void __iomem *)0xe9000000ul
+
+#if 0
+#define VERSATILE_PCI_VIRT_MEM_BASE0	0xf4000000
+#define VERSATILE_PCI_VIRT_MEM_BASE1	0xf5000000
+#define VERSATILE_PCI_VIRT_MEM_BASE2	0xf6000000
+
+#define PCIO_BASE			VERSATILE_PCI_VIRT_MEM_BASE0
+#define PCIMEM_BASE			VERSATILE_PCI_VIRT_MEM_BASE1
+#endif
+
+/* CIK guesswork */
+#define PCIBIOS_MIN_IO			0x44000000
+#define PCIBIOS_MIN_MEM			0x50000000
+
+#define pcibios_assign_all_busses()     1
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x)		(((x) & 0x0fffffff) + (((x) >> 4) & 0x0f000000) + 0xf0000000)
+
+#endif
Index: build_tree/linux/include/asm/arch-versatile/io.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/io.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/io.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+#define __io(a)	__io(a)
+#define __mem_pci(a)		(a)
+
+#endif
Index: build_tree/linux/include/asm/arch-versatile/irqs.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/irqs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/irqs.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,211 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/irqs.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/arch/platform.h>
+
+/* 
+ *  IRQ interrupts definitions are the same the INT definitions
+ *  held within platform.h
+ */
+#define IRQ_VIC_START		0
+#define IRQ_WDOGINT		(IRQ_VIC_START + INT_WDOGINT)
+#define IRQ_SOFTINT		(IRQ_VIC_START + INT_SOFTINT)
+#define IRQ_COMMRx		(IRQ_VIC_START + INT_COMMRx)
+#define IRQ_COMMTx		(IRQ_VIC_START + INT_COMMTx)
+#define IRQ_TIMERINT0_1		(IRQ_VIC_START + INT_TIMERINT0_1)
+#define IRQ_TIMERINT2_3		(IRQ_VIC_START + INT_TIMERINT2_3)
+#define IRQ_GPIOINT0		(IRQ_VIC_START + INT_GPIOINT0)
+#define IRQ_GPIOINT1		(IRQ_VIC_START + INT_GPIOINT1)
+#define IRQ_GPIOINT2		(IRQ_VIC_START + INT_GPIOINT2)
+#define IRQ_GPIOINT3		(IRQ_VIC_START + INT_GPIOINT3)
+#define IRQ_RTCINT		(IRQ_VIC_START + INT_RTCINT)
+#define IRQ_SSPINT		(IRQ_VIC_START + INT_SSPINT)
+#define IRQ_UARTINT0		(IRQ_VIC_START + INT_UARTINT0)
+#define IRQ_UARTINT1		(IRQ_VIC_START + INT_UARTINT1)
+#define IRQ_UARTINT2		(IRQ_VIC_START + INT_UARTINT2)
+#define IRQ_SCIINT		(IRQ_VIC_START + INT_SCIINT)
+#define IRQ_CLCDINT		(IRQ_VIC_START + INT_CLCDINT)
+#define IRQ_DMAINT		(IRQ_VIC_START + INT_DMAINT)
+#define IRQ_PWRFAILINT 		(IRQ_VIC_START + INT_PWRFAILINT)
+#define IRQ_MBXINT		(IRQ_VIC_START + INT_MBXINT)
+#define IRQ_GNDINT		(IRQ_VIC_START + INT_GNDINT)
+#define IRQ_VICSOURCE21		(IRQ_VIC_START + INT_VICSOURCE21)
+#define IRQ_VICSOURCE22		(IRQ_VIC_START + INT_VICSOURCE22)
+#define IRQ_VICSOURCE23		(IRQ_VIC_START + INT_VICSOURCE23)
+#define IRQ_VICSOURCE24		(IRQ_VIC_START + INT_VICSOURCE24)
+#define IRQ_VICSOURCE25		(IRQ_VIC_START + INT_VICSOURCE25)
+#define IRQ_VICSOURCE26		(IRQ_VIC_START + INT_VICSOURCE26)
+#define IRQ_VICSOURCE27		(IRQ_VIC_START + INT_VICSOURCE27)
+#define IRQ_VICSOURCE28		(IRQ_VIC_START + INT_VICSOURCE28)
+#define IRQ_VICSOURCE29		(IRQ_VIC_START + INT_VICSOURCE29)
+#define IRQ_VICSOURCE30		(IRQ_VIC_START + INT_VICSOURCE30)
+#define IRQ_VICSOURCE31		(IRQ_VIC_START + INT_VICSOURCE31)
+#define IRQ_VIC_END		(IRQ_VIC_START + 31)
+
+#define IRQMASK_WDOGINT		INTMASK_WDOGINT
+#define IRQMASK_SOFTINT		INTMASK_SOFTINT
+#define IRQMASK_COMMRx 		INTMASK_COMMRx
+#define IRQMASK_COMMTx 		INTMASK_COMMTx
+#define IRQMASK_TIMERINT0_1	INTMASK_TIMERINT0_1
+#define IRQMASK_TIMERINT2_3	INTMASK_TIMERINT2_3
+#define IRQMASK_GPIOINT0	INTMASK_GPIOINT0
+#define IRQMASK_GPIOINT1	INTMASK_GPIOINT1
+#define IRQMASK_GPIOINT2	INTMASK_GPIOINT2
+#define IRQMASK_GPIOINT3	INTMASK_GPIOINT3
+#define IRQMASK_RTCINT 		INTMASK_RTCINT
+#define IRQMASK_SSPINT 		INTMASK_SSPINT
+#define IRQMASK_UARTINT0	INTMASK_UARTINT0
+#define IRQMASK_UARTINT1	INTMASK_UARTINT1
+#define IRQMASK_UARTINT2	INTMASK_UARTINT2
+#define IRQMASK_SCIINT 		INTMASK_SCIINT
+#define IRQMASK_CLCDINT		INTMASK_CLCDINT
+#define IRQMASK_DMAINT 		INTMASK_DMAINT
+#define IRQMASK_PWRFAILINT	INTMASK_PWRFAILINT
+#define IRQMASK_MBXINT 		INTMASK_MBXINT
+#define IRQMASK_GNDINT 		INTMASK_GNDINT
+#define IRQMASK_VICSOURCE21	INTMASK_VICSOURCE21
+#define IRQMASK_VICSOURCE22	INTMASK_VICSOURCE22
+#define IRQMASK_VICSOURCE23	INTMASK_VICSOURCE23
+#define IRQMASK_VICSOURCE24	INTMASK_VICSOURCE24
+#define IRQMASK_VICSOURCE25	INTMASK_VICSOURCE25
+#define IRQMASK_VICSOURCE26	INTMASK_VICSOURCE26
+#define IRQMASK_VICSOURCE27	INTMASK_VICSOURCE27
+#define IRQMASK_VICSOURCE28	INTMASK_VICSOURCE28
+#define IRQMASK_VICSOURCE29	INTMASK_VICSOURCE29
+#define IRQMASK_VICSOURCE30	INTMASK_VICSOURCE30
+#define IRQMASK_VICSOURCE31	INTMASK_VICSOURCE31
+
+/* 
+ *  FIQ interrupts definitions are the same the INT definitions.
+ */
+#define FIQ_WDOGINT		INT_WDOGINT
+#define FIQ_SOFTINT		INT_SOFTINT
+#define FIQ_COMMRx		INT_COMMRx
+#define FIQ_COMMTx		INT_COMMTx
+#define FIQ_TIMERINT0_1		INT_TIMERINT0_1
+#define FIQ_TIMERINT2_3		INT_TIMERINT2_3
+#define FIQ_GPIOINT0		INT_GPIOINT0
+#define FIQ_GPIOINT1		INT_GPIOINT1
+#define FIQ_GPIOINT2		INT_GPIOINT2
+#define FIQ_GPIOINT3		INT_GPIOINT3
+#define FIQ_RTCINT		INT_RTCINT
+#define FIQ_SSPINT		INT_SSPINT
+#define FIQ_UARTINT0		INT_UARTINT0
+#define FIQ_UARTINT1		INT_UARTINT1
+#define FIQ_UARTINT2		INT_UARTINT2
+#define FIQ_SCIINT		INT_SCIINT
+#define FIQ_CLCDINT		INT_CLCDINT
+#define FIQ_DMAINT		INT_DMAINT
+#define FIQ_PWRFAILINT 		INT_PWRFAILINT
+#define FIQ_MBXINT		INT_MBXINT
+#define FIQ_GNDINT		INT_GNDINT
+#define FIQ_VICSOURCE21		INT_VICSOURCE21
+#define FIQ_VICSOURCE22		INT_VICSOURCE22
+#define FIQ_VICSOURCE23		INT_VICSOURCE23
+#define FIQ_VICSOURCE24		INT_VICSOURCE24
+#define FIQ_VICSOURCE25		INT_VICSOURCE25
+#define FIQ_VICSOURCE26		INT_VICSOURCE26
+#define FIQ_VICSOURCE27		INT_VICSOURCE27
+#define FIQ_VICSOURCE28		INT_VICSOURCE28
+#define FIQ_VICSOURCE29		INT_VICSOURCE29
+#define FIQ_VICSOURCE30		INT_VICSOURCE30
+#define FIQ_VICSOURCE31		INT_VICSOURCE31
+
+
+#define FIQMASK_WDOGINT		INTMASK_WDOGINT
+#define FIQMASK_SOFTINT		INTMASK_SOFTINT
+#define FIQMASK_COMMRx 		INTMASK_COMMRx
+#define FIQMASK_COMMTx 		INTMASK_COMMTx
+#define FIQMASK_TIMERINT0_1	INTMASK_TIMERINT0_1
+#define FIQMASK_TIMERINT2_3	INTMASK_TIMERINT2_3
+#define FIQMASK_GPIOINT0	INTMASK_GPIOINT0
+#define FIQMASK_GPIOINT1	INTMASK_GPIOINT1
+#define FIQMASK_GPIOINT2	INTMASK_GPIOINT2
+#define FIQMASK_GPIOINT3	INTMASK_GPIOINT3
+#define FIQMASK_RTCINT 		INTMASK_RTCINT
+#define FIQMASK_SSPINT 		INTMASK_SSPINT
+#define FIQMASK_UARTINT0	INTMASK_UARTINT0
+#define FIQMASK_UARTINT1	INTMASK_UARTINT1
+#define FIQMASK_UARTINT2	INTMASK_UARTINT2
+#define FIQMASK_SCIINT 		INTMASK_SCIINT
+#define FIQMASK_CLCDINT		INTMASK_CLCDINT
+#define FIQMASK_DMAINT 		INTMASK_DMAINT
+#define FIQMASK_PWRFAILINT	INTMASK_PWRFAILINT
+#define FIQMASK_MBXINT 		INTMASK_MBXINT
+#define FIQMASK_GNDINT 		INTMASK_GNDINT
+#define FIQMASK_VICSOURCE21	INTMASK_VICSOURCE21
+#define FIQMASK_VICSOURCE22	INTMASK_VICSOURCE22
+#define FIQMASK_VICSOURCE23	INTMASK_VICSOURCE23
+#define FIQMASK_VICSOURCE24	INTMASK_VICSOURCE24
+#define FIQMASK_VICSOURCE25	INTMASK_VICSOURCE25
+#define FIQMASK_VICSOURCE26	INTMASK_VICSOURCE26
+#define FIQMASK_VICSOURCE27	INTMASK_VICSOURCE27
+#define FIQMASK_VICSOURCE28	INTMASK_VICSOURCE28
+#define FIQMASK_VICSOURCE29	INTMASK_VICSOURCE29
+#define FIQMASK_VICSOURCE30	INTMASK_VICSOURCE30
+#define FIQMASK_VICSOURCE31	INTMASK_VICSOURCE31
+
+/*
+ * Secondary interrupt controller
+ */
+#define IRQ_SIC_START		32
+#define IRQ_SIC_MMCI0B 		(IRQ_SIC_START + SIC_INT_MMCI0B)
+#define IRQ_SIC_MMCI1B 		(IRQ_SIC_START + SIC_INT_MMCI1B)
+#define IRQ_SIC_KMI0		(IRQ_SIC_START + SIC_INT_KMI0)
+#define IRQ_SIC_KMI1		(IRQ_SIC_START + SIC_INT_KMI1)
+#define IRQ_SIC_SCI3		(IRQ_SIC_START + SIC_INT_SCI3)
+#define IRQ_SIC_UART3		(IRQ_SIC_START + SIC_INT_UART3)
+#define IRQ_SIC_CLCD		(IRQ_SIC_START + SIC_INT_CLCD)
+#define IRQ_SIC_TOUCH		(IRQ_SIC_START + SIC_INT_TOUCH)
+#define IRQ_SIC_KEYPAD 		(IRQ_SIC_START + SIC_INT_KEYPAD)
+#define IRQ_SIC_DoC		(IRQ_SIC_START + SIC_INT_DoC)
+#define IRQ_SIC_MMCI0A 		(IRQ_SIC_START + SIC_INT_MMCI0A)
+#define IRQ_SIC_MMCI1A 		(IRQ_SIC_START + SIC_INT_MMCI1A)
+#define IRQ_SIC_AACI		(IRQ_SIC_START + SIC_INT_AACI)
+#define IRQ_SIC_ETH		(IRQ_SIC_START + SIC_INT_ETH)
+#define IRQ_SIC_USB		(IRQ_SIC_START + SIC_INT_USB)
+#define IRQ_SIC_PCI0		(IRQ_SIC_START + SIC_INT_PCI0)
+#define IRQ_SIC_PCI1		(IRQ_SIC_START + SIC_INT_PCI1)
+#define IRQ_SIC_PCI2		(IRQ_SIC_START + SIC_INT_PCI2)
+#define IRQ_SIC_PCI3		(IRQ_SIC_START + SIC_INT_PCI3)
+#define IRQ_SIC_END		63
+
+#define SIC_IRQMASK_MMCI0B	SIC_INTMASK_MMCI0B
+#define SIC_IRQMASK_MMCI1B	SIC_INTMASK_MMCI1B
+#define SIC_IRQMASK_KMI0	SIC_INTMASK_KMI0
+#define SIC_IRQMASK_KMI1	SIC_INTMASK_KMI1
+#define SIC_IRQMASK_SCI3	SIC_INTMASK_SCI3
+#define SIC_IRQMASK_UART3	SIC_INTMASK_UART3
+#define SIC_IRQMASK_CLCD	SIC_INTMASK_CLCD
+#define SIC_IRQMASK_TOUCH	SIC_INTMASK_TOUCH
+#define SIC_IRQMASK_KEYPAD	SIC_INTMASK_KEYPAD
+#define SIC_IRQMASK_DoC		SIC_INTMASK_DoC
+#define SIC_IRQMASK_MMCI0A	SIC_INTMASK_MMCI0A
+#define SIC_IRQMASK_MMCI1A	SIC_INTMASK_MMCI1A
+#define SIC_IRQMASK_AACI	SIC_INTMASK_AACI
+#define SIC_IRQMASK_ETH		SIC_INTMASK_ETH
+#define SIC_IRQMASK_USB		SIC_INTMASK_USB
+#define SIC_IRQMASK_PCI0	SIC_INTMASK_PCI0
+#define SIC_IRQMASK_PCI1	SIC_INTMASK_PCI1
+#define SIC_IRQMASK_PCI2	SIC_INTMASK_PCI2
+#define SIC_IRQMASK_PCI3	SIC_INTMASK_PCI3
+
+#define NR_IRQS			64
Index: build_tree/linux/include/asm/arch-versatile/memory.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/memory.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/memory.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/memory.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
+#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+
+#endif
Index: build_tree/linux/include/asm/arch-versatile/platform.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/platform.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/platform.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,510 @@
+/*
+ * linux/include/asm-arm/arch-versatile/platform.h
+ *
+ * Copyright (c) ARM Limited 2003.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __address_h
+#define __address_h                     1
+
+/*
+ * Memory definitions
+ */
+#define VERSATILE_BOOT_ROM_LO          0x30000000		/* DoC Base (64Mb)...*/
+#define VERSATILE_BOOT_ROM_HI          0x30000000
+#define VERSATILE_BOOT_ROM_BASE        VERSATILE_BOOT_ROM_HI	 /*  Normal position */
+#define VERSATILE_BOOT_ROM_SIZE        SZ_64M
+
+#define VERSATILE_SSRAM_BASE           /* VERSATILE_SSMC_BASE ? */
+#define VERSATILE_SSRAM_SIZE           SZ_2M
+
+#define VERSATILE_FLASH_BASE           0x34000000
+#define VERSATILE_FLASH_SIZE           SZ_64M
+
+/* 
+ *  SDRAM
+ */
+#define VERSATILE_SDRAM_BASE           0x00000000
+
+/* 
+ *  Logic expansion modules
+ * 
+ */
+
+
+/* ------------------------------------------------------------------------
+ *  Versatile Registers
+ * ------------------------------------------------------------------------
+ * 
+ */
+#define VERSATILE_SYS_ID_OFFSET               0x00
+#define VERSATILE_SYS_SW_OFFSET               0x04
+#define VERSATILE_SYS_LED_OFFSET              0x08
+#define VERSATILE_SYS_OSC0_OFFSET             0x0C
+
+#if defined(CONFIG_ARCH_VERSATILE_PB)
+#define VERSATILE_SYS_OSC1_OFFSET             0x10
+#define VERSATILE_SYS_OSC2_OFFSET             0x14
+#define VERSATILE_SYS_OSC3_OFFSET             0x18
+#define VERSATILE_SYS_OSC4_OFFSET             0x1C
+#elif defined(CONFIG_MACH_VERSATILE_AB)
+#define VERSATILE_SYS_OSC1_OFFSET             0x1C
+#endif
+
+#define VERSATILE_SYS_OSCCLCD_OFFSET          0x1c
+
+#define VERSATILE_SYS_LOCK_OFFSET             0x20
+#define VERSATILE_SYS_100HZ_OFFSET            0x24
+#define VERSATILE_SYS_CFGDATA1_OFFSET         0x28
+#define VERSATILE_SYS_CFGDATA2_OFFSET         0x2C
+#define VERSATILE_SYS_FLAGS_OFFSET            0x30
+#define VERSATILE_SYS_FLAGSSET_OFFSET         0x30
+#define VERSATILE_SYS_FLAGSCLR_OFFSET         0x34
+#define VERSATILE_SYS_NVFLAGS_OFFSET          0x38
+#define VERSATILE_SYS_NVFLAGSSET_OFFSET       0x38
+#define VERSATILE_SYS_NVFLAGSCLR_OFFSET       0x3C
+#define VERSATILE_SYS_RESETCTL_OFFSET         0x40
+#define VERSATILE_SYS_PCICTL_OFFSET           0x44
+#define VERSATILE_SYS_MCI_OFFSET              0x48
+#define VERSATILE_SYS_FLASH_OFFSET            0x4C
+#define VERSATILE_SYS_CLCD_OFFSET             0x50
+#define VERSATILE_SYS_CLCDSER_OFFSET          0x54
+#define VERSATILE_SYS_BOOTCS_OFFSET           0x58
+#define VERSATILE_SYS_24MHz_OFFSET            0x5C
+#define VERSATILE_SYS_MISC_OFFSET             0x60
+#define VERSATILE_SYS_TEST_OSC0_OFFSET        0x80
+#define VERSATILE_SYS_TEST_OSC1_OFFSET        0x84
+#define VERSATILE_SYS_TEST_OSC2_OFFSET        0x88
+#define VERSATILE_SYS_TEST_OSC3_OFFSET        0x8C
+#define VERSATILE_SYS_TEST_OSC4_OFFSET        0x90
+
+#define VERSATILE_SYS_BASE                    0x10000000
+#define VERSATILE_SYS_ID                      (VERSATILE_SYS_BASE + VERSATILE_SYS_ID_OFFSET)
+#define VERSATILE_SYS_SW                      (VERSATILE_SYS_BASE + VERSATILE_SYS_SW_OFFSET)
+#define VERSATILE_SYS_LED                     (VERSATILE_SYS_BASE + VERSATILE_SYS_LED_OFFSET)
+#define VERSATILE_SYS_OSC0                    (VERSATILE_SYS_BASE + VERSATILE_SYS_OSC0_OFFSET)
+#define VERSATILE_SYS_OSC1                    (VERSATILE_SYS_BASE + VERSATILE_SYS_OSC1_OFFSET)
+
+#if defined(CONFIG_ARCH_VERSATILE_PB)
+#define VERSATILE_SYS_OSC2                    (VERSATILE_SYS_BASE + VERSATILE_SYS_OSC2_OFFSET)
+#define VERSATILE_SYS_OSC3                    (VERSATILE_SYS_BASE + VERSATILE_SYS_OSC3_OFFSET)
+#define VERSATILE_SYS_OSC4                    (VERSATILE_SYS_BASE + VERSATILE_SYS_OSC4_OFFSET)
+#endif
+
+#define VERSATILE_SYS_LOCK                    (VERSATILE_SYS_BASE + VERSATILE_SYS_LOCK_OFFSET)
+#define VERSATILE_SYS_100HZ                   (VERSATILE_SYS_BASE + VERSATILE_SYS_100HZ_OFFSET)
+#define VERSATILE_SYS_CFGDATA1                (VERSATILE_SYS_BASE + VERSATILE_SYS_CFGDATA1_OFFSET)
+#define VERSATILE_SYS_CFGDATA2                (VERSATILE_SYS_BASE + VERSATILE_SYS_CFGDATA2_OFFSET)
+#define VERSATILE_SYS_FLAGS                   (VERSATILE_SYS_BASE + VERSATILE_SYS_FLAGS_OFFSET)
+#define VERSATILE_SYS_FLAGSSET                (VERSATILE_SYS_BASE + VERSATILE_SYS_FLAGSSET_OFFSET)
+#define VERSATILE_SYS_FLAGSCLR                (VERSATILE_SYS_BASE + VERSATILE_SYS_FLAGSCLR_OFFSET)
+#define VERSATILE_SYS_NVFLAGS                 (VERSATILE_SYS_BASE + VERSATILE_SYS_NVFLAGS_OFFSET)
+#define VERSATILE_SYS_NVFLAGSSET              (VERSATILE_SYS_BASE + VERSATILE_SYS_NVFLAGSSET_OFFSET)
+#define VERSATILE_SYS_NVFLAGSCLR              (VERSATILE_SYS_BASE + VERSATILE_SYS_NVFLAGSCLR_OFFSET)
+#define VERSATILE_SYS_RESETCTL                (VERSATILE_SYS_BASE + VERSATILE_SYS_RESETCTL_OFFSET)
+#define VERSATILE_SYS_PCICTL                  (VERSATILE_SYS_BASE + VERSATILE_SYS_PCICTL_OFFSET)
+#define VERSATILE_SYS_MCI                     (VERSATILE_SYS_BASE + VERSATILE_SYS_MCI_OFFSET)
+#define VERSATILE_SYS_FLASH                   (VERSATILE_SYS_BASE + VERSATILE_SYS_FLASH_OFFSET)
+#define VERSATILE_SYS_CLCD                    (VERSATILE_SYS_BASE + VERSATILE_SYS_CLCD_OFFSET)
+#define VERSATILE_SYS_CLCDSER                 (VERSATILE_SYS_BASE + VERSATILE_SYS_CLCDSER_OFFSET)
+#define VERSATILE_SYS_BOOTCS                  (VERSATILE_SYS_BASE + VERSATILE_SYS_BOOTCS_OFFSET)
+#define VERSATILE_SYS_24MHz                   (VERSATILE_SYS_BASE + VERSATILE_SYS_24MHz_OFFSET)
+#define VERSATILE_SYS_MISC                    (VERSATILE_SYS_BASE + VERSATILE_SYS_MISC_OFFSET)
+#define VERSATILE_SYS_TEST_OSC0               (VERSATILE_SYS_BASE + VERSATILE_SYS_TEST_OSC0_OFFSET)
+#define VERSATILE_SYS_TEST_OSC1               (VERSATILE_SYS_BASE + VERSATILE_SYS_TEST_OSC1_OFFSET)
+#define VERSATILE_SYS_TEST_OSC2               (VERSATILE_SYS_BASE + VERSATILE_SYS_TEST_OSC2_OFFSET)
+#define VERSATILE_SYS_TEST_OSC3               (VERSATILE_SYS_BASE + VERSATILE_SYS_TEST_OSC3_OFFSET)
+#define VERSATILE_SYS_TEST_OSC4               (VERSATILE_SYS_BASE + VERSATILE_SYS_TEST_OSC4_OFFSET)
+
+/* 
+ * Values for VERSATILE_SYS_RESET_CTRL
+ */
+#define VERSATILE_SYS_CTRL_RESET_CONFIGCLR    0x01
+#define VERSATILE_SYS_CTRL_RESET_CONFIGINIT   0x02
+#define VERSATILE_SYS_CTRL_RESET_DLLRESET     0x03
+#define VERSATILE_SYS_CTRL_RESET_PLLRESET     0x04
+#define VERSATILE_SYS_CTRL_RESET_POR          0x05
+#define VERSATILE_SYS_CTRL_RESET_DoC          0x06
+
+#define VERSATILE_SYS_CTRL_LED         (1 << 0)
+
+
+/* ------------------------------------------------------------------------
+ *  Versatile control registers
+ * ------------------------------------------------------------------------
+ */
+
+/* 
+ * VERSATILE_IDFIELD
+ *
+ * 31:24 = manufacturer (0x41 = ARM)
+ * 23:16 = architecture (0x08 = AHB system bus, ASB processor bus)
+ * 15:12 = FPGA (0x3 = XVC600 or XVC600E)
+ * 11:4  = build value
+ * 3:0   = revision number (0x1 = rev B (AHB))
+ */
+
+/*
+ * VERSATILE_SYS_LOCK
+ *     control access to SYS_OSCx, SYS_CFGDATAx, SYS_RESETCTL, 
+ *     SYS_CLD, SYS_BOOTCS
+ */
+#define VERSATILE_SYS_LOCK_LOCKED    (1 << 16)
+#define VERSATILE_SYS_LOCKVAL_MASK	0xFFFF		/* write 0xA05F to enable write access */
+
+/*
+ * VERSATILE_SYS_FLASH
+ */
+#define VERSATILE_FLASHPROG_FLVPPEN	(1 << 0)	/* Enable writing to flash */
+
+/*
+ * VERSATILE_INTREG
+ *     - used to acknowledge and control MMCI and UART interrupts 
+ */
+#define VERSATILE_INTREG_WPROT        0x00    /* MMC protection status (no interrupt generated) */
+#define VERSATILE_INTREG_RI0          0x01    /* Ring indicator UART0 is asserted,              */
+#define VERSATILE_INTREG_CARDIN       0x08    /* MMCI card in detect                            */
+                                                /* write 1 to acknowledge and clear               */
+#define VERSATILE_INTREG_RI1          0x02    /* Ring indicator UART1 is asserted,              */
+#define VERSATILE_INTREG_CARDINSERT   0x03    /* Signal insertion of MMC card                   */
+
+/*
+ * VERSATILE peripheral addresses
+ */
+#define VERSATILE_PCI_CORE_BASE        0x10001000	/* PCI core control */
+#define VERSATILE_I2C_BASE             0x10002000	/* I2C control */
+#define VERSATILE_SIC_BASE             0x10003000	/* Secondary interrupt controller */
+#define VERSATILE_AACI_BASE            0x10004000	/* Audio */
+#define VERSATILE_MMCI0_BASE           0x10005000	/* MMC interface */
+#define VERSATILE_KMI0_BASE            0x10006000	/* KMI interface */
+#define VERSATILE_KMI1_BASE            0x10007000	/* KMI 2nd interface */
+#define VERSATILE_CHAR_LCD_BASE        0x10008000	/* Character LCD */
+#define VERSATILE_UART3_BASE           0x10009000	/* UART 3 */
+#define VERSATILE_SCI1_BASE            0x1000A000
+#define VERSATILE_MMCI1_BASE           0x1000B000    /* MMC Interface */
+	/* 0x1000C000 - 0x1000CFFF = reserved */
+#define VERSATILE_ETH_BASE             0x10010000	/* Ethernet */
+#define VERSATILE_USB_BASE             0x10020000	/* USB */
+	/* 0x10030000 - 0x100FFFFF = reserved */
+#define VERSATILE_SMC_BASE             0x10100000	/* SMC */
+#define VERSATILE_MPMC_BASE            0x10110000	/* MPMC */
+#define VERSATILE_CLCD_BASE            0x10120000	/* CLCD */
+#define VERSATILE_DMAC_BASE            0x10130000	/* DMA controller */
+#define VERSATILE_VIC_BASE             0x10140000	/* Vectored interrupt controller */
+#define VERSATILE_PERIPH_BASE          0x10150000    /* off-chip peripherals alias from */
+                                                /* 0x10000000 - 0x100FFFFF */
+#define VERSATILE_AHBM_BASE            0x101D0000	/* AHB monitor */
+#define VERSATILE_SCTL_BASE            0x101E0000	/* System controller */
+#define VERSATILE_WATCHDOG_BASE        0x101E1000	/* Watchdog */
+#define VERSATILE_TIMER0_1_BASE        0x101E2000	/* Timer 0 and 1 */
+#define VERSATILE_TIMER2_3_BASE        0x101E3000	/* Timer 2 and 3 */
+#define VERSATILE_GPIO0_BASE           0x101E4000	/* GPIO port 0 */
+#define VERSATILE_GPIO1_BASE           0x101E5000    /* GPIO port 1 */
+#define VERSATILE_GPIO2_BASE           0x101E6000	/* GPIO port 2 */
+#define VERSATILE_GPIO3_BASE           0x101E7000	/* GPIO port 3 */
+#define VERSATILE_RTC_BASE             0x101E8000	/* Real Time Clock */
+	/* 0x101E9000 - reserved */
+#define VERSATILE_SCI_BASE             0x101F0000	/* Smart card controller */
+#define VERSATILE_UART0_BASE           0x101F1000	/* Uart 0 */
+#define VERSATILE_UART1_BASE           0x101F2000	/* Uart 1 */
+#define VERSATILE_UART2_BASE           0x101F3000	/* Uart 2 */
+#define VERSATILE_SSP_BASE             0x101F4000	/* Synchronous Serial Port */
+
+#define VERSATILE_SSMC_BASE            0x20000000	/* SSMC */
+#define VERSATILE_IB2_BASE             0x24000000	/* IB2 module */
+#define VERSATILE_MBX_BASE             0x40000000	/* MBX */
+
+/* PCI space */
+#define VERSATILE_PCI_BASE             0x41000000	/* PCI Interface */
+#define VERSATILE_PCI_CFG_BASE	       0x42000000
+#define VERSATILE_PCI_MEM_BASE0        0x44000000
+#define VERSATILE_PCI_MEM_BASE1        0x50000000
+#define VERSATILE_PCI_MEM_BASE2        0x60000000
+/* Sizes of above maps */
+#define VERSATILE_PCI_BASE_SIZE	       0x01000000
+#define VERSATILE_PCI_CFG_BASE_SIZE    0x02000000
+#define VERSATILE_PCI_MEM_BASE0_SIZE   0x0c000000	/* 32Mb */
+#define VERSATILE_PCI_MEM_BASE1_SIZE   0x10000000	/* 256Mb */
+#define VERSATILE_PCI_MEM_BASE2_SIZE   0x10000000	/* 256Mb */
+
+#define VERSATILE_SDRAM67_BASE         0x70000000	/* SDRAM banks 6 and 7 */
+#define VERSATILE_LT_BASE              0x80000000	/* Logic Tile expansion */
+
+/*
+ * Disk on Chip
+ */
+#define VERSATILE_DOC_BASE             0x2C000000
+#define VERSATILE_DOC_SIZE             (16 << 20)
+#define VERSATILE_DOC_PAGE_SIZE        512
+#define VERSATILE_DOC_TOTAL_PAGES     (DOC_SIZE / PAGE_SIZE)
+
+#define ERASE_UNIT_PAGES    32
+#define START_PAGE          0x80
+
+/* 
+ *  LED settings, bits [7:0]
+ */
+#define VERSATILE_SYS_LED0             (1 << 0)
+#define VERSATILE_SYS_LED1             (1 << 1)
+#define VERSATILE_SYS_LED2             (1 << 2)
+#define VERSATILE_SYS_LED3             (1 << 3)
+#define VERSATILE_SYS_LED4             (1 << 4)
+#define VERSATILE_SYS_LED5             (1 << 5)
+#define VERSATILE_SYS_LED6             (1 << 6)
+#define VERSATILE_SYS_LED7             (1 << 7)
+
+#define ALL_LEDS                  0xFF
+
+#define LED_BANK                  VERSATILE_SYS_LED
+
+/* 
+ * Control registers
+ */
+#define VERSATILE_IDFIELD_OFFSET	0x0	/* Versatile build information */
+#define VERSATILE_FLASHPROG_OFFSET	0x4	/* Flash devices */
+#define VERSATILE_INTREG_OFFSET		0x8	/* Interrupt control */
+#define VERSATILE_DECODE_OFFSET		0xC	/* Fitted logic modules */
+
+
+/* ------------------------------------------------------------------------
+ *  Versatile Interrupt Controller - control registers
+ * ------------------------------------------------------------------------
+ * 
+ *  Offsets from interrupt controller base 
+ * 
+ *  System Controller interrupt controller base is
+ * 
+ * 	VERSATILE_IC_BASE
+ * 
+ *  Core Module interrupt controller base is
+ * 
+ * 	VERSATILE_SYS_IC 
+ * 
+ */
+/* VIC definitions in include/asm-arm/hardware/vic.h */
+
+#define SIC_IRQ_STATUS                  0
+#define SIC_IRQ_RAW_STATUS              0x04
+#define SIC_IRQ_ENABLE                  0x08
+#define SIC_IRQ_ENABLE_SET              0x08
+#define SIC_IRQ_ENABLE_CLEAR            0x0C
+#define SIC_INT_SOFT_SET                0x10
+#define SIC_INT_SOFT_CLEAR              0x14
+#define SIC_INT_PIC_ENABLE              0x20	/* read status of pass through mask */
+#define SIC_INT_PIC_ENABLES             0x20	/* set interrupt pass through bits */
+#define SIC_INT_PIC_ENABLEC             0x24	/* Clear interrupt pass through bits */
+
+/* ------------------------------------------------------------------------
+ *  Interrupts - bit assignment (primary)
+ * ------------------------------------------------------------------------
+ */
+
+#define INT_WDOGINT                     0	/* Watchdog timer */
+#define INT_SOFTINT                     1	/* Software interrupt */
+#define INT_COMMRx                      2	/* Debug Comm Rx interrupt */
+#define INT_COMMTx                      3	/* Debug Comm Tx interrupt */
+#define INT_TIMERINT0_1                 4	/* Timer 0 and 1 */
+#define INT_TIMERINT2_3                 5	/* Timer 2 and 3 */
+#define INT_GPIOINT0                    6	/* GPIO 0 */
+#define INT_GPIOINT1                    7	/* GPIO 1 */
+#define INT_GPIOINT2                    8	/* GPIO 2 */
+#define INT_GPIOINT3                    9	/* GPIO 3 */
+#define INT_RTCINT                      10	/* Real Time Clock */
+#define INT_SSPINT                      11	/* Synchronous Serial Port */
+#define INT_UARTINT0                    12	/* UART 0 on development chip */
+#define INT_UARTINT1                    13	/* UART 1 on development chip */
+#define INT_UARTINT2                    14	/* UART 2 on development chip */
+#define INT_SCIINT                      15	/* Smart Card Interface */
+#define INT_CLCDINT                     16	/* CLCD controller */
+#define INT_DMAINT                      17	/* DMA controller */
+#define INT_PWRFAILINT                  18	/* Power failure */
+#define INT_MBXINT                      19	/* Graphics processor */
+#define INT_GNDINT                      20	/* Reserved */
+	/* External interrupt signals from logic tiles or secondary controller */
+#define INT_VICSOURCE21                 21	/* Disk on Chip */
+#define INT_VICSOURCE22                 22	/* MCI0A */
+#define INT_VICSOURCE23                 23	/* MCI1A */
+#define INT_VICSOURCE24                 24	/* AACI */
+#define INT_VICSOURCE25                 25	/* Ethernet */
+#define INT_VICSOURCE26                 26	/* USB */
+#define INT_VICSOURCE27                 27	/* PCI 0 */
+#define INT_VICSOURCE28                 28	/* PCI 1 */
+#define INT_VICSOURCE29                 29	/* PCI 2 */
+#define INT_VICSOURCE30                 30	/* PCI 3 */
+#define INT_VICSOURCE31                 31	/* SIC source */
+
+/* 
+ *  Interrupt bit positions
+ * 
+ */
+#define INTMASK_WDOGINT                 (1 << INT_WDOGINT)
+#define INTMASK_SOFTINT                 (1 << INT_SOFTINT)
+#define INTMASK_COMMRx                  (1 << INT_COMMRx)
+#define INTMASK_COMMTx                  (1 << INT_COMMTx)
+#define INTMASK_TIMERINT0_1             (1 << INT_TIMERINT0_1)
+#define INTMASK_TIMERINT2_3             (1 << INT_TIMERINT2_3)
+#define INTMASK_GPIOINT0                (1 << INT_GPIOINT0)
+#define INTMASK_GPIOINT1                (1 << INT_GPIOINT1)
+#define INTMASK_GPIOINT2                (1 << INT_GPIOINT2)
+#define INTMASK_GPIOINT3                (1 << INT_GPIOINT3)
+#define INTMASK_RTCINT                  (1 << INT_RTCINT)
+#define INTMASK_SSPINT                  (1 << INT_SSPINT)
+#define INTMASK_UARTINT0                (1 << INT_UARTINT0)
+#define INTMASK_UARTINT1                (1 << INT_UARTINT1)
+#define INTMASK_UARTINT2                (1 << INT_UARTINT2)
+#define INTMASK_SCIINT                  (1 << INT_SCIINT)
+#define INTMASK_CLCDINT                 (1 << INT_CLCDINT)
+#define INTMASK_DMAINT                  (1 << INT_DMAINT)
+#define INTMASK_PWRFAILINT              (1 << INT_PWRFAILINT)
+#define INTMASK_MBXINT                  (1 << INT_MBXINT)
+#define INTMASK_GNDINT                  (1 << INT_GNDINT)
+#define INTMASK_VICSOURCE21             (1 << INT_VICSOURCE21)
+#define INTMASK_VICSOURCE22             (1 << INT_VICSOURCE22)
+#define INTMASK_VICSOURCE23             (1 << INT_VICSOURCE23)
+#define INTMASK_VICSOURCE24             (1 << INT_VICSOURCE24)
+#define INTMASK_VICSOURCE25             (1 << INT_VICSOURCE25)
+#define INTMASK_VICSOURCE26             (1 << INT_VICSOURCE26)
+#define INTMASK_VICSOURCE27             (1 << INT_VICSOURCE27)
+#define INTMASK_VICSOURCE28             (1 << INT_VICSOURCE28)
+#define INTMASK_VICSOURCE29             (1 << INT_VICSOURCE29)
+#define INTMASK_VICSOURCE30             (1 << INT_VICSOURCE30)
+#define INTMASK_VICSOURCE31             (1 << INT_VICSOURCE31)
+
+
+#define VERSATILE_SC_VALID_INT               0x003FFFFF
+
+#define MAXIRQNUM                       31
+#define MAXFIQNUM                       31
+#define MAXSWINUM                       31
+
+/* ------------------------------------------------------------------------
+ *  Interrupts - bit assignment (secondary)
+ * ------------------------------------------------------------------------
+ */
+#define SIC_INT_MMCI0B                  1	/* Multimedia Card 0B */
+#define SIC_INT_MMCI1B                  2	/* Multimedia Card 1B */
+#define SIC_INT_KMI0                    3	/* Keyboard/Mouse port 0 */
+#define SIC_INT_KMI1                    4	/* Keyboard/Mouse port 1 */
+#define SIC_INT_SCI3                    5	/* Smart Card interface */
+#define SIC_INT_UART3                   6	/* UART 3 empty or data available */
+#define SIC_INT_CLCD                    7	/* Character LCD */
+#define SIC_INT_TOUCH                   8	/* Touchscreen */
+#define SIC_INT_KEYPAD                  9	/* Key pressed on display keypad */
+	/* 10:20 - reserved */
+#define SIC_INT_DoC                     21	/* Disk on Chip memory controller */
+#define SIC_INT_MMCI0A                  22	/* MMC 0A */
+#define SIC_INT_MMCI1A                  23	/* MMC 1A */
+#define SIC_INT_AACI                    24	/* Audio Codec */
+#define SIC_INT_ETH                     25	/* Ethernet controller */
+#define SIC_INT_USB                     26	/* USB controller */
+#define SIC_INT_PCI0                    27
+#define SIC_INT_PCI1                    28
+#define SIC_INT_PCI2                    29
+#define SIC_INT_PCI3                    30
+
+
+#define SIC_INTMASK_MMCI0B              (1 << SIC_INT_MMCI0B)
+#define SIC_INTMASK_MMCI1B              (1 << SIC_INT_MMCI1B)
+#define SIC_INTMASK_KMI0                (1 << SIC_INT_KMI0)
+#define SIC_INTMASK_KMI1                (1 << SIC_INT_KMI1)
+#define SIC_INTMASK_SCI3                (1 << SIC_INT_SCI3)
+#define SIC_INTMASK_UART3               (1 << SIC_INT_UART3)
+#define SIC_INTMASK_CLCD                (1 << SIC_INT_CLCD)
+#define SIC_INTMASK_TOUCH               (1 << SIC_INT_TOUCH)
+#define SIC_INTMASK_KEYPAD              (1 << SIC_INT_KEYPAD)
+#define SIC_INTMASK_DoC                 (1 << SIC_INT_DoC)
+#define SIC_INTMASK_MMCI0A              (1 << SIC_INT_MMCI0A)
+#define SIC_INTMASK_MMCI1A              (1 << SIC_INT_MMCI1A)
+#define SIC_INTMASK_AACI                (1 << SIC_INT_AACI)
+#define SIC_INTMASK_ETH                 (1 << SIC_INT_ETH)
+#define SIC_INTMASK_USB                 (1 << SIC_INT_USB)
+#define SIC_INTMASK_PCI0                (1 << SIC_INT_PCI0)
+#define SIC_INTMASK_PCI1                (1 << SIC_INT_PCI1)
+#define SIC_INTMASK_PCI2                (1 << SIC_INT_PCI2)
+#define SIC_INTMASK_PCI3                (1 << SIC_INT_PCI3)
+/* 
+ *  Application Flash
+ * 
+ */
+#define FLASH_BASE                      VERSATILE_FLASH_BASE
+#define FLASH_SIZE                      VERSATILE_FLASH_SIZE
+#define FLASH_END                       (FLASH_BASE + FLASH_SIZE - 1)
+#define FLASH_BLOCK_SIZE                SZ_128K
+
+/* 
+ *  Boot Flash
+ * 
+ */
+#define EPROM_BASE                      VERSATILE_BOOT_ROM_HI
+#define EPROM_SIZE                      VERSATILE_BOOT_ROM_SIZE
+#define EPROM_END                       (EPROM_BASE + EPROM_SIZE - 1)
+
+/* 
+ *  Clean base - dummy
+ * 
+ */
+#define CLEAN_BASE                      EPROM_BASE
+
+/*
+ * System controller bit assignment
+ */
+#define VERSATILE_REFCLK	0
+#define VERSATILE_TIMCLK	1
+
+#define VERSATILE_TIMER1_EnSel	15
+#define VERSATILE_TIMER2_EnSel	17
+#define VERSATILE_TIMER3_EnSel	19
+#define VERSATILE_TIMER4_EnSel	21
+
+
+#define MAX_TIMER                       2
+#define MAX_PERIOD                      699050
+#define TICKS_PER_uSEC                  1
+
+/* 
+ *  These are useconds NOT ticks.  
+ * 
+ */
+#define mSEC_1                          1000
+#define mSEC_5                          (mSEC_1 * 5)
+#define mSEC_10                         (mSEC_1 * 10)
+#define mSEC_25                         (mSEC_1 * 25)
+#define SEC_1                           (mSEC_1 * 1000)
+
+#define VERSATILE_CSR_BASE             0x10000000
+#define VERSATILE_CSR_SIZE             0x10000000
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+/*
+ * IB2 Versatile/AB expansion board definitions
+ */
+#define VERSATILE_IB2_CAMERA_BANK	VERSATILE_IB2_BASE
+#define VERSATILE_IB2_KBD_DATAREG	(VERSATILE_IB2_BASE + 0x01000000)
+
+/* VICINTSOURCE27 */
+#define VERSATILE_IB2_INT_BASE		(VERSATILE_IB2_BASE + 0x02000000)
+#define VERSATILE_IB2_IER		(VERSATILE_IB2_INT_BASE + 0)
+#define VERSATILE_IB2_ISR		(VERSATILE_IB2_INT_BASE + 4)
+
+#define VERSATILE_IB2_CTL_BASE		(VERSATILE_IB2_BASE + 0x03000000)
+#define VERSATILE_IB2_CTRL		(VERSATILE_IB2_CTL_BASE + 0)
+#define VERSATILE_IB2_STAT		(VERSATILE_IB2_CTL_BASE + 4)
+#endif
+
+#endif
+
+/* 	END */
Index: build_tree/linux/include/asm/arch-versatile/system.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/system.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/system.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/system.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	u32 val;
+
+	val = __raw_readl(IO_ADDRESS(VERSATILE_SYS_RESETCTL)) & ~0x7;
+	val |= 0x105;
+
+	__raw_writel(0xa05f, IO_ADDRESS(VERSATILE_SYS_LOCK));
+	__raw_writel(val, IO_ADDRESS(VERSATILE_SYS_RESETCTL));
+	__raw_writel(0, IO_ADDRESS(VERSATILE_SYS_LOCK));
+}
+
+#endif
Index: build_tree/linux/include/asm/arch-versatile/timex.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/timex.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/timex.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/timex.h
+ *
+ *  Versatile architecture timex specifications
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE		(50000000 / 16)
Index: build_tree/linux/include/asm/arch-versatile/uncompress.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/uncompress.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/uncompress.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/uncompress.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define AMBA_UART_DR	(*(volatile unsigned char *)0x101F1000)
+#define AMBA_UART_LCRH	(*(volatile unsigned char *)0x101F102C)
+#define AMBA_UART_CR	(*(volatile unsigned char *)0x101F1030)
+#define AMBA_UART_FR	(*(volatile unsigned char *)0x101F1018)
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	while (AMBA_UART_FR & (1 << 5))
+		barrier();
+
+	AMBA_UART_DR = c;
+}
+
+static inline void flush(void)
+{
+	while (AMBA_UART_FR & (1 << 3))
+		barrier();
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: build_tree/linux/include/asm/arch-versatile/vmalloc.h
diff -u /dev/null build_tree/linux/include/asm/arch-versatile/vmalloc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/arch-versatile/vmalloc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+/*
+ *  linux/include/asm-arm/arch-versatile/vmalloc.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(PAGE_OFFSET + 0x18000000)
Index: build_tree/linux/include/asm/hardware/arm_scu.h
diff -u /dev/null build_tree/linux/include/asm/hardware/arm_scu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/arm_scu.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,15 @@
+#ifndef ASMARM_HARDWARE_ARM_SCU_H
+#define ASMARM_HARDWARE_ARM_SCU_H
+
+#include <asm/arch/scu.h>
+
+/*
+ * SCU registers
+ */
+#define SCU_CTRL		0x00
+#define SCU_CONFIG		0x04
+#define SCU_CPU_STATUS		0x08
+#define SCU_INVALIDATE		0x0c
+#define SCU_FPGA_REVISION	0x10
+
+#endif
Index: build_tree/linux/include/asm/hardware/arm_timer.h
diff -u /dev/null build_tree/linux/include/asm/hardware/arm_timer.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/arm_timer.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,21 @@
+#ifndef __ASM_ARM_HARDWARE_ARM_TIMER_H
+#define __ASM_ARM_HARDWARE_ARM_TIMER_H
+
+#define TIMER_LOAD	0x00
+#define TIMER_VALUE	0x04
+#define TIMER_CTRL	0x08
+#define TIMER_CTRL_ONESHOT	(1 << 0)
+#define TIMER_CTRL_32BIT	(1 << 1)
+#define TIMER_CTRL_DIV1		(0 << 2)
+#define TIMER_CTRL_DIV16	(1 << 2)
+#define TIMER_CTRL_DIV256	(2 << 2)
+#define TIMER_CTRL_IE		(1 << 5)	/* Interrupt Enable (versatile only) */
+#define TIMER_CTRL_PERIODIC	(1 << 6)
+#define TIMER_CTRL_ENABLE	(1 << 7)
+
+#define TIMER_INTCLR	0x0c
+#define TIMER_RIS	0x10
+#define TIMER_MIS	0x14
+#define TIMER_BGLOAD	0x18
+
+#endif
Index: build_tree/linux/include/asm/hardware/arm_twd.h
diff -u /dev/null build_tree/linux/include/asm/hardware/arm_twd.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/arm_twd.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,16 @@
+#ifndef __ASM_HARDWARE_TWD_H
+#define __ASM_HARDWARE_TWD_H
+
+#define TWD_TIMER_LOAD 		0x00
+#define TWD_TIMER_COUNTER		0x04
+#define TWD_TIMER_CONTROL		0x08
+#define TWD_TIMER_INTSTAT		0x0C
+
+#define TWD_WDOG_LOAD			0x20
+#define TWD_WDOG_COUNTER		0x24
+#define TWD_WDOG_CONTROL		0x28
+#define TWD_WDOG_INTSTAT		0x2C
+#define TWD_WDOG_RESETSTAT		0x30
+#define TWD_WDOG_DISABLE		0x34
+
+#endif
Index: build_tree/linux/include/asm/hardware/cache-l2x0.h
diff -u /dev/null build_tree/linux/include/asm/hardware/cache-l2x0.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/cache-l2x0.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,56 @@
+/*
+ * include/asm-arm/hardware/cache-l2x0.h
+ *
+ * Copyright (C) 2007 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARM_HARDWARE_L2X0_H
+#define __ASM_ARM_HARDWARE_L2X0_H
+
+#define L2X0_CACHE_ID			0x000
+#define L2X0_CACHE_TYPE			0x004
+#define L2X0_CTRL			0x100
+#define L2X0_AUX_CTRL			0x104
+#define L2X0_EVENT_CNT_CTRL		0x200
+#define L2X0_EVENT_CNT1_CFG		0x204
+#define L2X0_EVENT_CNT0_CFG		0x208
+#define L2X0_EVENT_CNT1_VAL		0x20C
+#define L2X0_EVENT_CNT0_VAL		0x210
+#define L2X0_INTR_MASK			0x214
+#define L2X0_MASKED_INTR_STAT		0x218
+#define L2X0_RAW_INTR_STAT		0x21C
+#define L2X0_INTR_CLEAR			0x220
+#define L2X0_CACHE_SYNC			0x730
+#define L2X0_INV_LINE_PA		0x770
+#define L2X0_INV_WAY			0x77C
+#define L2X0_CLEAN_LINE_PA		0x7B0
+#define L2X0_CLEAN_LINE_IDX		0x7B8
+#define L2X0_CLEAN_WAY			0x7BC
+#define L2X0_CLEAN_INV_LINE_PA		0x7F0
+#define L2X0_CLEAN_INV_LINE_IDX		0x7F8
+#define L2X0_CLEAN_INV_WAY		0x7FC
+#define L2X0_LOCKDOWN_WAY_D		0x900
+#define L2X0_LOCKDOWN_WAY_I		0x904
+#define L2X0_TEST_OPERATION		0xF00
+#define L2X0_LINE_DATA			0xF10
+#define L2X0_LINE_TAG			0xF30
+#define L2X0_DEBUG_CTRL			0xF40
+
+#ifndef __ASSEMBLY__
+extern void __init l2x0_init(void __iomem *base, __u32 aux_val, __u32 aux_mask);
+#endif
+
+#endif
Index: build_tree/linux/include/asm/hardware/clps7111.h
diff -u /dev/null build_tree/linux/include/asm/hardware/clps7111.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/clps7111.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,184 @@
+/*
+ *  linux/include/asm-arm/hardware/clps7111.h
+ *
+ *  This file contains the hardware definitions of the CLPS7111 internal
+ *  registers.
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_HARDWARE_CLPS7111_H
+#define __ASM_HARDWARE_CLPS7111_H
+
+#define CLPS7111_PHYS_BASE	(0x80000000)
+
+#ifndef __ASSEMBLY__
+#define clps_readb(off)		__raw_readb(CLPS7111_BASE + (off))
+#define clps_readw(off)		__raw_readw(CLPS7111_BASE + (off))
+#define clps_readl(off)		__raw_readl(CLPS7111_BASE + (off))
+#define clps_writeb(val,off)	__raw_writeb(val, CLPS7111_BASE + (off))
+#define clps_writew(val,off)	__raw_writew(val, CLPS7111_BASE + (off))
+#define clps_writel(val,off)	__raw_writel(val, CLPS7111_BASE + (off))
+#endif
+
+#define PADR		(0x0000)
+#define PBDR		(0x0001)
+#define PDDR		(0x0003)
+#define PADDR		(0x0040)
+#define PBDDR		(0x0041)
+#define PDDDR		(0x0043)
+#define PEDR		(0x0080)
+#define PEDDR		(0x00c0)
+#define SYSCON1		(0x0100)
+#define SYSFLG1		(0x0140)
+#define MEMCFG1		(0x0180)
+#define MEMCFG2		(0x01c0)
+#define DRFPR		(0x0200)
+#define INTSR1		(0x0240)
+#define INTMR1		(0x0280)
+#define LCDCON		(0x02c0)
+#define TC1D            (0x0300)
+#define TC2D		(0x0340)
+#define RTCDR		(0x0380)
+#define RTCMR		(0x03c0)
+#define PMPCON		(0x0400)
+#define CODR		(0x0440)
+#define UARTDR1		(0x0480)
+#define UBRLCR1		(0x04c0)
+#define SYNCIO		(0x0500)
+#define PALLSW		(0x0540)
+#define PALMSW		(0x0580)
+#define STFCLR		(0x05c0)
+#define BLEOI		(0x0600)
+#define MCEOI		(0x0640)
+#define TEOI		(0x0680)
+#define TC1EOI		(0x06c0)
+#define TC2EOI		(0x0700)
+#define RTCEOI		(0x0740)
+#define UMSEOI		(0x0780)
+#define COEOI		(0x07c0)
+#define HALT		(0x0800)
+#define STDBY		(0x0840)
+
+#define FBADDR		(0x1000)
+#define SYSCON2		(0x1100)
+#define SYSFLG2		(0x1140)
+#define INTSR2		(0x1240)
+#define INTMR2		(0x1280)
+#define UARTDR2		(0x1480)
+#define UBRLCR2		(0x14c0)
+#define SS2DR		(0x1500)
+#define SRXEOF		(0x1600)
+#define SS2POP		(0x16c0)
+#define KBDEOI		(0x1700)
+
+/* common bits: SYSCON1 / SYSCON2 */
+#define SYSCON_UARTEN		(1 << 8)
+
+#define SYSCON1_KBDSCAN(x)	((x) & 15)
+#define SYSCON1_KBDSCANMASK	(15)
+#define SYSCON1_TC1M		(1 << 4)
+#define SYSCON1_TC1S		(1 << 5)
+#define SYSCON1_TC2M		(1 << 6)
+#define SYSCON1_TC2S		(1 << 7)
+#define SYSCON1_UART1EN		SYSCON_UARTEN
+#define SYSCON1_BZTOG		(1 << 9)
+#define SYSCON1_BZMOD		(1 << 10)
+#define SYSCON1_DBGEN		(1 << 11)
+#define SYSCON1_LCDEN		(1 << 12)
+#define SYSCON1_CDENTX		(1 << 13)
+#define SYSCON1_CDENRX		(1 << 14)
+#define SYSCON1_SIREN		(1 << 15)
+#define SYSCON1_ADCKSEL(x)	(((x) & 3) << 16)
+#define SYSCON1_ADCKSEL_MASK	(3 << 16)
+#define SYSCON1_EXCKEN		(1 << 18)
+#define SYSCON1_WAKEDIS		(1 << 19)
+#define SYSCON1_IRTXM		(1 << 20)
+
+/* common bits: SYSFLG1 / SYSFLG2 */
+#define SYSFLG_UBUSY		(1 << 11)
+#define SYSFLG_URXFE		(1 << 22)
+#define SYSFLG_UTXFF		(1 << 23)
+
+#define SYSFLG1_MCDR		(1 << 0)
+#define SYSFLG1_DCDET		(1 << 1)
+#define SYSFLG1_WUDR		(1 << 2)
+#define SYSFLG1_WUON		(1 << 3)
+#define SYSFLG1_CTS		(1 << 8)
+#define SYSFLG1_DSR		(1 << 9)
+#define SYSFLG1_DCD		(1 << 10)
+#define SYSFLG1_UBUSY		SYSFLG_UBUSY
+#define SYSFLG1_NBFLG		(1 << 12)
+#define SYSFLG1_RSTFLG		(1 << 13)
+#define SYSFLG1_PFFLG		(1 << 14)
+#define SYSFLG1_CLDFLG		(1 << 15)
+#define SYSFLG1_URXFE		SYSFLG_URXFE
+#define SYSFLG1_UTXFF		SYSFLG_UTXFF
+#define SYSFLG1_CRXFE		(1 << 24)
+#define SYSFLG1_CTXFF		(1 << 25)
+#define SYSFLG1_SSIBUSY		(1 << 26)
+#define SYSFLG1_ID		(1 << 29)
+
+#define SYSFLG2_SSRXOF		(1 << 0)
+#define SYSFLG2_RESVAL		(1 << 1)
+#define SYSFLG2_RESFRM		(1 << 2)
+#define SYSFLG2_SS2RXFE		(1 << 3)
+#define SYSFLG2_SS2TXFF		(1 << 4)
+#define SYSFLG2_SS2TXUF		(1 << 5)
+#define SYSFLG2_CKMODE		(1 << 6)
+#define SYSFLG2_UBUSY		SYSFLG_UBUSY
+#define SYSFLG2_URXFE		SYSFLG_URXFE
+#define SYSFLG2_UTXFF		SYSFLG_UTXFF
+
+#define LCDCON_GSEN		(1 << 30)
+#define LCDCON_GSMD		(1 << 31)
+
+#define SYSCON2_SERSEL		(1 << 0)
+#define SYSCON2_KBD6		(1 << 1)
+#define SYSCON2_DRAMZ		(1 << 2)
+#define SYSCON2_KBWEN		(1 << 3)
+#define SYSCON2_SS2TXEN		(1 << 4)
+#define SYSCON2_PCCARD1		(1 << 5)
+#define SYSCON2_PCCARD2		(1 << 6)
+#define SYSCON2_SS2RXEN		(1 << 7)
+#define SYSCON2_UART2EN		SYSCON_UARTEN
+#define SYSCON2_SS2MAEN		(1 << 9)
+#define SYSCON2_OSTB		(1 << 12)
+#define SYSCON2_CLKENSL		(1 << 13)
+#define SYSCON2_BUZFREQ		(1 << 14)
+
+/* common bits: UARTDR1 / UARTDR2 */
+#define UARTDR_FRMERR		(1 << 8)
+#define UARTDR_PARERR		(1 << 9)
+#define UARTDR_OVERR		(1 << 10)
+
+/* common bits: UBRLCR1 / UBRLCR2 */
+#define UBRLCR_BAUD_MASK	((1 << 12) - 1)
+#define UBRLCR_BREAK		(1 << 12)
+#define UBRLCR_PRTEN		(1 << 13)
+#define UBRLCR_EVENPRT		(1 << 14)
+#define UBRLCR_XSTOP		(1 << 15)
+#define UBRLCR_FIFOEN		(1 << 16)
+#define UBRLCR_WRDLEN5		(0 << 17)
+#define UBRLCR_WRDLEN6		(1 << 17)
+#define UBRLCR_WRDLEN7		(2 << 17)
+#define UBRLCR_WRDLEN8		(3 << 17)
+#define UBRLCR_WRDLEN_MASK	(3 << 17)
+
+#define SYNCIO_SMCKEN		(1 << 13)
+#define SYNCIO_TXFRMEN		(1 << 14)
+
+#endif /* __ASM_HARDWARE_CLPS7111_H */
Index: build_tree/linux/include/asm/hardware/cs89712.h
diff -u /dev/null build_tree/linux/include/asm/hardware/cs89712.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/cs89712.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-arm/hardware/cs89712.h
+ *
+ *  This file contains the hardware definitions of the CS89712
+ *  additional internal registers.
+ *
+ *  Copyright (C) 2001 Thomas Gleixner autronix automation <gleixner@autronix.de>
+ *			
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_HARDWARE_CS89712_H
+#define __ASM_HARDWARE_CS89712_H
+
+/*
+*	CS89712 additional registers
+*/
+                                  
+#define PCDR			0x0002	/* Port C Data register ---------------------------- */
+#define PCDDR			0x0042	/* Port C Data Direction register ------------------ */
+#define SDCONF			0x2300  /* SDRAM Configuration register ---------------------*/
+#define SDRFPR			0x2340  /* SDRAM Refresh period register --------------------*/
+
+#define SDCONF_ACTIVE		(1 << 10)
+#define SDCONF_CLKCTL		(1 << 9)
+#define SDCONF_WIDTH_4		(0 << 7)
+#define SDCONF_WIDTH_8		(1 << 7)
+#define SDCONF_WIDTH_16		(2 << 7)
+#define SDCONF_WIDTH_32		(3 << 7)
+#define SDCONF_SIZE_16		(0 << 5)
+#define SDCONF_SIZE_64		(1 << 5)
+#define SDCONF_SIZE_128		(2 << 5)
+#define SDCONF_SIZE_256		(3 << 5)
+#define SDCONF_CASLAT_2		(2)
+#define SDCONF_CASLAT_3		(3)
+
+#endif /* __ASM_HARDWARE_CS89712_H */
Index: build_tree/linux/include/asm/hardware/debug-8250.S
diff -u /dev/null build_tree/linux/include/asm/hardware/debug-8250.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/debug-8250.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/*
+ * linux/include/asm-arm/hardware/debug-8250.S
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/serial_reg.h>
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx, #UART_TX << UART_SHIFT]
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldrb	\rd, [\rx, #UART_LSR << UART_SHIFT]
+		and	\rd, \rd, #UART_LSR_TEMT | UART_LSR_THRE
+		teq	\rd, #UART_LSR_TEMT | UART_LSR_THRE
+		bne	1002b
+		.endm
+
+		.macro	waituart,rd,rx
+#ifdef FLOW_CONTROL
+1001:		ldrb	\rd, [\rx, #UART_MSR << UART_SHIFT]
+		tst	\rd, #UART_MSR_CTS
+		beq	1001b
+#endif
+		.endm
Index: build_tree/linux/include/asm/hardware/debug-pl01x.S
diff -u /dev/null build_tree/linux/include/asm/hardware/debug-pl01x.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/debug-pl01x.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,29 @@
+/* linux/include/asm-arm/hardware/debug-pl01x.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+#include <linux/amba/serial.h>
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx, #UART01x_DR]
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldr	\rd, [\rx, #UART01x_FR]
+		tst	\rd, #UART01x_FR_TXFF
+		bne	1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+1001:		ldr	\rd, [\rx, #UART01x_FR]
+		tst	\rd, #UART01x_FR_BUSY
+		bne	1001b
+		.endm
Index: build_tree/linux/include/asm/hardware/dec21285.h
diff -u /dev/null build_tree/linux/include/asm/hardware/dec21285.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/dec21285.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,147 @@
+/*
+ *  linux/include/asm-arm/hardware/dec21285.h
+ *
+ *  Copyright (C) 1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  DC21285 registers
+ */
+#define DC21285_PCI_IACK		0x79000000
+#define DC21285_ARMCSR_BASE		0x42000000
+#define DC21285_PCI_TYPE_0_CONFIG	0x7b000000
+#define DC21285_PCI_TYPE_1_CONFIG	0x7a000000
+#define DC21285_OUTBOUND_WRITE_FLUSH	0x78000000
+#define DC21285_FLASH			0x41000000
+#define DC21285_PCI_IO			0x7c000000
+#define DC21285_PCI_MEM			0x80000000
+
+#ifndef __ASSEMBLY__
+#include <asm/hardware.h>
+#define DC21285_IO(x)		((volatile unsigned long *)(ARMCSR_BASE+(x)))
+#else
+#define DC21285_IO(x)		(x)
+#endif
+
+#define CSR_PCICMD		DC21285_IO(0x0004)
+#define CSR_CLASSREV		DC21285_IO(0x0008)
+#define CSR_PCICACHELINESIZE	DC21285_IO(0x000c)
+#define CSR_PCICSRBASE		DC21285_IO(0x0010)
+#define CSR_PCICSRIOBASE	DC21285_IO(0x0014)
+#define CSR_PCISDRAMBASE	DC21285_IO(0x0018)
+#define CSR_PCIROMBASE		DC21285_IO(0x0030)
+#define CSR_MBOX0		DC21285_IO(0x0050)
+#define CSR_MBOX1		DC21285_IO(0x0054)
+#define CSR_MBOX2		DC21285_IO(0x0058)
+#define CSR_MBOX3		DC21285_IO(0x005c)
+#define CSR_DOORBELL		DC21285_IO(0x0060)
+#define CSR_DOORBELL_SETUP	DC21285_IO(0x0064)
+#define CSR_ROMWRITEREG		DC21285_IO(0x0068)
+#define CSR_CSRBASEMASK		DC21285_IO(0x00f8)
+#define CSR_CSRBASEOFFSET	DC21285_IO(0x00fc)
+#define CSR_SDRAMBASEMASK	DC21285_IO(0x0100)
+#define CSR_SDRAMBASEOFFSET	DC21285_IO(0x0104)
+#define CSR_ROMBASEMASK		DC21285_IO(0x0108)
+#define CSR_SDRAMTIMING		DC21285_IO(0x010c)
+#define CSR_SDRAMADDRSIZE0	DC21285_IO(0x0110)
+#define CSR_SDRAMADDRSIZE1	DC21285_IO(0x0114)
+#define CSR_SDRAMADDRSIZE2	DC21285_IO(0x0118)
+#define CSR_SDRAMADDRSIZE3	DC21285_IO(0x011c)
+#define CSR_I2O_INFREEHEAD	DC21285_IO(0x0120)
+#define CSR_I2O_INPOSTTAIL	DC21285_IO(0x0124)
+#define CSR_I2O_OUTPOSTHEAD	DC21285_IO(0x0128)
+#define CSR_I2O_OUTFREETAIL	DC21285_IO(0x012c)
+#define CSR_I2O_INFREECOUNT	DC21285_IO(0x0130)
+#define CSR_I2O_OUTPOSTCOUNT	DC21285_IO(0x0134)
+#define CSR_I2O_INPOSTCOUNT	DC21285_IO(0x0138)
+#define CSR_SA110_CNTL		DC21285_IO(0x013c)
+#define SA110_CNTL_INITCMPLETE		(1 << 0)
+#define SA110_CNTL_ASSERTSERR		(1 << 1)
+#define SA110_CNTL_RXSERR		(1 << 3)
+#define SA110_CNTL_SA110DRAMPARITY	(1 << 4)
+#define SA110_CNTL_PCISDRAMPARITY	(1 << 5)
+#define SA110_CNTL_DMASDRAMPARITY	(1 << 6)
+#define SA110_CNTL_DISCARDTIMER		(1 << 8)
+#define SA110_CNTL_PCINRESET		(1 << 9)
+#define SA110_CNTL_I2O_256		(0 << 10)
+#define SA110_CNTL_I20_512		(1 << 10)
+#define SA110_CNTL_I2O_1024		(2 << 10)
+#define SA110_CNTL_I2O_2048		(3 << 10)
+#define SA110_CNTL_I2O_4096		(4 << 10)
+#define SA110_CNTL_I2O_8192		(5 << 10)
+#define SA110_CNTL_I2O_16384		(6 << 10)
+#define SA110_CNTL_I2O_32768		(7 << 10)
+#define SA110_CNTL_WATCHDOG		(1 << 13)
+#define SA110_CNTL_ROMWIDTH_UNDEF	(0 << 14)
+#define SA110_CNTL_ROMWIDTH_16		(1 << 14)
+#define SA110_CNTL_ROMWIDTH_32		(2 << 14)
+#define SA110_CNTL_ROMWIDTH_8		(3 << 14)
+#define SA110_CNTL_ROMACCESSTIME(x)	((x)<<16)
+#define SA110_CNTL_ROMBURSTTIME(x)	((x)<<20)
+#define SA110_CNTL_ROMTRISTATETIME(x)	((x)<<24)
+#define SA110_CNTL_XCSDIR(x)		((x)<<28)
+#define SA110_CNTL_PCICFN		(1 << 31)
+
+/*
+ * footbridge_cfn_mode() is used when we want
+ * to check whether we are the central function
+ */
+#define __footbridge_cfn_mode() (*CSR_SA110_CNTL & SA110_CNTL_PCICFN)
+#if defined(CONFIG_FOOTBRIDGE_HOST) && defined(CONFIG_FOOTBRIDGE_ADDIN)
+#define footbridge_cfn_mode() __footbridge_cfn_mode()
+#elif defined(CONFIG_FOOTBRIDGE_HOST)
+#define footbridge_cfn_mode() (1)
+#else
+#define footbridge_cfn_mode() (0)
+#endif
+
+#define CSR_PCIADDR_EXTN	DC21285_IO(0x0140)
+#define CSR_PREFETCHMEMRANGE	DC21285_IO(0x0144)
+#define CSR_XBUS_CYCLE		DC21285_IO(0x0148)
+#define CSR_XBUS_IOSTROBE	DC21285_IO(0x014c)
+#define CSR_DOORBELL_PCI	DC21285_IO(0x0150)
+#define CSR_DOORBELL_SA110	DC21285_IO(0x0154)
+#define CSR_UARTDR		DC21285_IO(0x0160)
+#define CSR_RXSTAT		DC21285_IO(0x0164)
+#define CSR_H_UBRLCR		DC21285_IO(0x0168)
+#define CSR_M_UBRLCR		DC21285_IO(0x016c)
+#define CSR_L_UBRLCR		DC21285_IO(0x0170)
+#define CSR_UARTCON		DC21285_IO(0x0174)
+#define CSR_UARTFLG		DC21285_IO(0x0178)
+#define CSR_IRQ_STATUS		DC21285_IO(0x0180)
+#define CSR_IRQ_RAWSTATUS	DC21285_IO(0x0184)
+#define CSR_IRQ_ENABLE		DC21285_IO(0x0188)
+#define CSR_IRQ_DISABLE		DC21285_IO(0x018c)
+#define CSR_IRQ_SOFT		DC21285_IO(0x0190)
+#define CSR_FIQ_STATUS		DC21285_IO(0x0280)
+#define CSR_FIQ_RAWSTATUS	DC21285_IO(0x0284)
+#define CSR_FIQ_ENABLE		DC21285_IO(0x0288)
+#define CSR_FIQ_DISABLE		DC21285_IO(0x028c)
+#define CSR_FIQ_SOFT		DC21285_IO(0x0290)
+#define CSR_TIMER1_LOAD		DC21285_IO(0x0300)
+#define CSR_TIMER1_VALUE	DC21285_IO(0x0304)
+#define CSR_TIMER1_CNTL		DC21285_IO(0x0308)
+#define CSR_TIMER1_CLR		DC21285_IO(0x030c)
+#define CSR_TIMER2_LOAD		DC21285_IO(0x0320)
+#define CSR_TIMER2_VALUE	DC21285_IO(0x0324)
+#define CSR_TIMER2_CNTL		DC21285_IO(0x0328)
+#define CSR_TIMER2_CLR		DC21285_IO(0x032c)
+#define CSR_TIMER3_LOAD		DC21285_IO(0x0340)
+#define CSR_TIMER3_VALUE	DC21285_IO(0x0344)
+#define CSR_TIMER3_CNTL		DC21285_IO(0x0348)
+#define CSR_TIMER3_CLR		DC21285_IO(0x034c)
+#define CSR_TIMER4_LOAD		DC21285_IO(0x0360)
+#define CSR_TIMER4_VALUE	DC21285_IO(0x0364)
+#define CSR_TIMER4_CNTL		DC21285_IO(0x0368)
+#define CSR_TIMER4_CLR		DC21285_IO(0x036c)
+
+#define TIMER_CNTL_ENABLE	(1 << 7)
+#define TIMER_CNTL_AUTORELOAD	(1 << 6)
+#define TIMER_CNTL_DIV1		(0)
+#define TIMER_CNTL_DIV16	(1 << 2)
+#define TIMER_CNTL_DIV256	(2 << 2)
+#define TIMER_CNTL_CNTEXT	(3 << 2)
+
+
Index: build_tree/linux/include/asm/hardware/entry-macro-iomd.S
diff -u /dev/null build_tree/linux/include/asm/hardware/entry-macro-iomd.S:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/entry-macro-iomd.S	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,145 @@
+/*
+ * include/asm-arm/hardware/entry-macro-iomd.S
+ *
+ * Low-level IRQ helper macros for IOC/IOMD based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+/* IOC / IOMD based hardware */
+#include <asm/hardware/iomd.h>
+
+		.equ	ioc_base_high, IOC_BASE & 0xff000000
+		.equ	ioc_base_low, IOC_BASE & 0x00ff0000
+		.macro	disable_fiq
+		mov	r12, #ioc_base_high
+		.if	ioc_base_low
+		orr	r12, r12, #ioc_base_low
+		.endif
+		strb	r12, [r12, #0x38]	@ Disable FIQ register
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov	r4, #ioc_base_high		@ point at IOC
+		.if	ioc_base_low
+		orr	r4, r4, #ioc_base_low
+		.endif
+		ldrb	\irqstat, [r4, #IOMD_IRQREQB]	@ get high priority first
+		ldr	\base, =irq_prio_h
+		teq	\irqstat, #0
+#ifdef IOMD_BASE
+		ldreqb	\irqstat, [r4, #IOMD_DMAREQ]	@ get dma
+		addeq	\base, \base, #256		@ irq_prio_h table size
+		teqeq	\irqstat, #0
+		bne	2406f
+#endif
+		ldreqb	\irqstat, [r4, #IOMD_IRQREQA]	@ get low priority
+		addeq	\base, \base, #256		@ irq_prio_d table size
+		teqeq	\irqstat, #0
+#ifdef IOMD_IRQREQC
+		ldreqb	\irqstat, [r4, #IOMD_IRQREQC]
+		addeq	\base, \base, #256		@ irq_prio_l table size
+		teqeq	\irqstat, #0
+#endif
+#ifdef IOMD_IRQREQD
+		ldreqb	\irqstat, [r4, #IOMD_IRQREQD]
+		addeq	\base, \base, #256		@ irq_prio_lc table size
+		teqeq	\irqstat, #0
+#endif
+2406:		ldrneb	\irqnr, [\base, \irqstat]	@ get IRQ number
+		.endm
+
+/*
+ * Interrupt table (incorporates priority).  Please note that we
+ * rely on the order of these tables (see above code).
+ */
+		.align	5
+irq_prio_h:	.byte	 0, 8, 9, 8,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	12, 8, 9, 8,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	14,14,14,14,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	14,14,14,14,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	15,15,15,15,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	15,15,15,15,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	15,15,15,15,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	15,15,15,15,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+		.byte	13,13,13,13,10,10,10,10,11,11,11,11,10,10,10,10
+#ifdef IOMD_BASE
+irq_prio_d:	.byte	 0,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	20,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	22,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	22,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	23,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	23,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	22,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	22,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+		.byte	21,16,17,16,18,16,17,16,19,16,17,16,18,16,17,16
+#endif
+irq_prio_l:	.byte	 0, 0, 1, 0, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3
+		.byte	 4, 0, 1, 0, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3
+		.byte	 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
+		.byte	 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
+		.byte	 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3
+		.byte	 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3
+		.byte	 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
+		.byte	 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		.byte	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+#ifdef IOMD_IRQREQC
+irq_prio_lc:	.byte	24,24,25,24,26,26,26,26,27,27,27,27,27,27,27,27
+		.byte	28,24,25,24,26,26,26,26,27,27,27,27,27,27,27,27
+		.byte	29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29
+		.byte	29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29
+		.byte	30,30,30,30,30,30,30,30,27,27,27,27,27,27,27,27
+		.byte	30,30,30,30,30,30,30,30,27,27,27,27,27,27,27,27
+		.byte	29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29
+		.byte	29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+		.byte	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
+#endif
+#ifdef IOMD_IRQREQD
+irq_prio_ld:	.byte	40,40,41,40,42,42,42,42,43,43,43,43,43,43,43,43
+		.byte	44,40,41,40,42,42,42,42,43,43,43,43,43,43,43,43
+		.byte	45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
+		.byte	45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
+		.byte	46,46,46,46,46,46,46,46,43,43,43,43,43,43,43,43
+		.byte	46,46,46,46,46,46,46,46,43,43,43,43,43,43,43,43
+		.byte	45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
+		.byte	45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+		.byte	47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47
+#endif
+
Index: build_tree/linux/include/asm/hardware/ep7211.h
diff -u /dev/null build_tree/linux/include/asm/hardware/ep7211.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/ep7211.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/hardware/ep7211.h
+ *
+ *  This file contains the hardware definitions of the EP7211 internal
+ *  registers.
+ *
+ *  Copyright (C) 2001 Blue Mug, Inc.  All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_HARDWARE_EP7211_H
+#define __ASM_HARDWARE_EP7211_H
+
+#include <asm/hardware/clps7111.h>
+
+/*
+ * define EP7211_BASE to be the base address of the region
+ * you want to access.
+ */
+
+#define EP7211_PHYS_BASE	(0x80000000)
+
+/*
+ * XXX miket@bluemug.com: need to introduce EP7211 registers (those not
+ * present in 7212) here.
+ */
+
+#endif /* __ASM_HARDWARE_EP7211_H */
Index: build_tree/linux/include/asm/hardware/ep7212.h
diff -u /dev/null build_tree/linux/include/asm/hardware/ep7212.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/ep7212.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,83 @@
+/*
+ *  linux/include/asm-arm/hardware/ep7212.h
+ *
+ *  This file contains the hardware definitions of the EP7212 internal
+ *  registers.
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_HARDWARE_EP7212_H
+#define __ASM_HARDWARE_EP7212_H
+
+/*
+ * define EP7212_BASE to be the base address of the region
+ * you want to access.
+ */
+
+#define EP7212_PHYS_BASE	(0x80000000)
+
+#ifndef __ASSEMBLY__
+#define ep_readl(off)		__raw_readl(EP7212_BASE + (off))
+#define ep_writel(val,off)	__raw_writel(val, EP7212_BASE + (off))
+#endif
+
+/*
+ * These registers are specific to the EP7212 only
+ */
+#define DAIR			0x2000
+#define DAIR0			0x2040
+#define DAIDR1			0x2080
+#define DAIDR2			0x20c0
+#define DAISR			0x2100
+#define SYSCON3			0x2200
+#define INTSR3			0x2240
+#define INTMR3			0x2280
+#define LEDFLSH			0x22c0
+
+#define DAIR_DAIEN		(1 << 16)
+#define DAIR_ECS		(1 << 17)
+#define DAIR_LCTM		(1 << 19)
+#define DAIR_LCRM		(1 << 20)
+#define DAIR_RCTM		(1 << 21)
+#define DAIR_RCRM		(1 << 22)
+#define DAIR_LBM		(1 << 23)
+
+#define DAIDR2_FIFOEN		(1 << 15)
+#define DAIDR2_FIFOLEFT		(0x0d << 16)
+#define DAIDR2_FIFORIGHT	(0x11 << 16)
+
+#define DAISR_RCTS		(1 << 0)
+#define DAISR_RCRS		(1 << 1)
+#define DAISR_LCTS		(1 << 2)
+#define DAISR_LCRS		(1 << 3)
+#define DAISR_RCTU		(1 << 4)
+#define DAISR_RCRO		(1 << 5)
+#define DAISR_LCTU		(1 << 6)
+#define DAISR_LCRO		(1 << 7)
+#define DAISR_RCNF		(1 << 8)
+#define DAISR_RCNE		(1 << 9)
+#define DAISR_LCNF		(1 << 10)
+#define DAISR_LCNE		(1 << 11)
+#define DAISR_FIFO		(1 << 12)
+
+#define SYSCON3_ADCCON		(1 << 0)
+#define SYSCON3_DAISEL		(1 << 3)
+#define SYSCON3_ADCCKNSEN	(1 << 4)
+#define SYSCON3_FASTWAKE	(1 << 8)
+#define SYSCON3_DAIEN		(1 << 9)
+
+#endif /* __ASM_HARDWARE_EP7212_H */
Index: build_tree/linux/include/asm/hardware/gic.h
diff -u /dev/null build_tree/linux/include/asm/hardware/gic.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/gic.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,42 @@
+/*
+ *  linux/include/asm-arm/hardware/gic.h
+ *
+ *  Copyright (C) 2002 ARM Limited, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_HARDWARE_GIC_H
+#define __ASM_ARM_HARDWARE_GIC_H
+
+#include <linux/compiler.h>
+
+#define GIC_CPU_CTRL			0x00
+#define GIC_CPU_PRIMASK			0x04
+#define GIC_CPU_BINPOINT		0x08
+#define GIC_CPU_INTACK			0x0c
+#define GIC_CPU_EOI			0x10
+#define GIC_CPU_RUNNINGPRI		0x14
+#define GIC_CPU_HIGHPRI			0x18
+
+#define GIC_DIST_CTRL			0x000
+#define GIC_DIST_CTR			0x004
+#define GIC_DIST_ENABLE_SET		0x100
+#define GIC_DIST_ENABLE_CLEAR		0x180
+#define GIC_DIST_PENDING_SET		0x200
+#define GIC_DIST_PENDING_CLEAR		0x280
+#define GIC_DIST_ACTIVE_BIT		0x300
+#define GIC_DIST_PRI			0x400
+#define GIC_DIST_TARGET			0x800
+#define GIC_DIST_CONFIG			0xc00
+#define GIC_DIST_SOFTINT		0xf00
+
+#ifndef __ASSEMBLY__
+void gic_dist_init(unsigned int gic_nr, void __iomem *base, unsigned int irq_start);
+void gic_cpu_init(unsigned int gic_nr, void __iomem *base);
+void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
+void gic_raise_softirq(cpumask_t cpumask, unsigned int irq);
+#endif
+
+#endif
Index: build_tree/linux/include/asm/hardware/icst307.h
diff -u /dev/null build_tree/linux/include/asm/hardware/icst307.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/icst307.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,38 @@
+/*
+ *  linux/include/asm-arm/hardware/icst307.h
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Support functions for calculating clocks/divisors for the ICS307
+ *  clock generators.  See http://www.icst.com/ for more information
+ *  on these devices.
+ *
+ *  This file is similar to the icst525.h file
+ */
+#ifndef ASMARM_HARDWARE_ICST307_H
+#define ASMARM_HARDWARE_ICST307_H
+
+struct icst307_params {
+	unsigned long	ref;
+	unsigned long	vco_max;	/* inclusive */
+	unsigned short	vd_min;		/* inclusive */
+	unsigned short	vd_max;		/* inclusive */
+	unsigned char	rd_min;		/* inclusive */
+	unsigned char	rd_max;		/* inclusive */
+};
+
+struct icst307_vco {
+	unsigned short	v;
+	unsigned char	r;
+	unsigned char	s;
+};
+
+unsigned long icst307_khz(const struct icst307_params *p, struct icst307_vco vco);
+struct icst307_vco icst307_khz_to_vco(const struct icst307_params *p, unsigned long freq);
+struct icst307_vco icst307_ps_to_vco(const struct icst307_params *p, unsigned long period);
+
+#endif
Index: build_tree/linux/include/asm/hardware/icst525.h
diff -u /dev/null build_tree/linux/include/asm/hardware/icst525.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/icst525.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/hardware/icst525.h
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Support functions for calculating clocks/divisors for the ICST525
+ *  clock generators.  See http://www.icst.com/ for more information
+ *  on these devices.
+ */
+#ifndef ASMARM_HARDWARE_ICST525_H
+#define ASMARM_HARDWARE_ICST525_H
+
+struct icst525_params {
+	unsigned long	ref;
+	unsigned long	vco_max;	/* inclusive */
+	unsigned short	vd_min;		/* inclusive */
+	unsigned short	vd_max;		/* inclusive */
+	unsigned char	rd_min;		/* inclusive */
+	unsigned char	rd_max;		/* inclusive */
+};
+
+struct icst525_vco {
+	unsigned short	v;
+	unsigned char	r;
+	unsigned char	s;
+};
+
+unsigned long icst525_khz(const struct icst525_params *p, struct icst525_vco vco);
+struct icst525_vco icst525_khz_to_vco(const struct icst525_params *p, unsigned long freq);
+struct icst525_vco icst525_ps_to_vco(const struct icst525_params *p, unsigned long period);
+
+#endif
Index: build_tree/linux/include/asm/hardware/ioc.h
diff -u /dev/null build_tree/linux/include/asm/hardware/ioc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/ioc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,72 @@
+/*
+ *  linux/include/asm-arm/hardware/ioc.h
+ *
+ *  Copyright (C) Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Use these macros to read/write the IOC.  All it does is perform the actual
+ *  read/write.
+ */
+#ifndef __ASMARM_HARDWARE_IOC_H
+#define __ASMARM_HARDWARE_IOC_H
+
+#ifndef __ASSEMBLY__
+
+/*
+ * We use __raw_base variants here so that we give the compiler the
+ * chance to keep IOC_BASE in a register.
+ */
+#define ioc_readb(off)		__raw_readb(IOC_BASE + (off))
+#define ioc_writeb(val,off)	__raw_writeb(val, IOC_BASE + (off))
+
+#endif
+
+#define IOC_CONTROL	(0x00)
+#define IOC_KARTTX	(0x04)
+#define IOC_KARTRX	(0x04)
+
+#define IOC_IRQSTATA	(0x10)
+#define IOC_IRQREQA	(0x14)
+#define IOC_IRQCLRA	(0x14)
+#define IOC_IRQMASKA	(0x18)
+
+#define IOC_IRQSTATB	(0x20)
+#define IOC_IRQREQB	(0x24)
+#define IOC_IRQMASKB	(0x28)
+
+#define IOC_FIQSTAT	(0x30)
+#define IOC_FIQREQ	(0x34)
+#define IOC_FIQMASK	(0x38)
+
+#define IOC_T0CNTL	(0x40)
+#define IOC_T0LTCHL	(0x40)
+#define IOC_T0CNTH	(0x44)
+#define IOC_T0LTCHH	(0x44)
+#define IOC_T0GO	(0x48)
+#define IOC_T0LATCH	(0x4c)
+
+#define IOC_T1CNTL	(0x50)
+#define IOC_T1LTCHL	(0x50)
+#define IOC_T1CNTH	(0x54)
+#define IOC_T1LTCHH	(0x54)
+#define IOC_T1GO	(0x58)
+#define IOC_T1LATCH	(0x5c)
+
+#define IOC_T2CNTL	(0x60)
+#define IOC_T2LTCHL	(0x60)
+#define IOC_T2CNTH	(0x64)
+#define IOC_T2LTCHH	(0x64)
+#define IOC_T2GO	(0x68)
+#define IOC_T2LATCH	(0x6c)
+
+#define IOC_T3CNTL	(0x70)
+#define IOC_T3LTCHL	(0x70)
+#define IOC_T3CNTH	(0x74)
+#define IOC_T3LTCHH	(0x74)
+#define IOC_T3GO	(0x78)
+#define IOC_T3LATCH	(0x7c)
+
+#endif
Index: build_tree/linux/include/asm/hardware/iomd.h
diff -u /dev/null build_tree/linux/include/asm/hardware/iomd.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/iomd.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,226 @@
+/*
+ *  linux/include/asm-arm/hardware/iomd.h
+ *
+ *  Copyright (C) 1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This file contains information out the IOMD ASIC used in the
+ *  Acorn RiscPC and subsequently integrated into the CLPS7500 chips.
+ */
+#ifndef __ASMARM_HARDWARE_IOMD_H
+#define __ASMARM_HARDWARE_IOMD_H
+
+
+#ifndef __ASSEMBLY__
+
+/*
+ * We use __raw_base variants here so that we give the compiler the
+ * chance to keep IOC_BASE in a register.
+ */
+#define iomd_readb(off)		__raw_readb(IOMD_BASE + (off))
+#define iomd_readl(off)		__raw_readl(IOMD_BASE + (off))
+#define iomd_writeb(val,off)	__raw_writeb(val, IOMD_BASE + (off))
+#define iomd_writel(val,off)	__raw_writel(val, IOMD_BASE + (off))
+
+#endif
+
+#define IOMD_CONTROL	(0x000)
+#define IOMD_KARTTX	(0x004)
+#define IOMD_KARTRX	(0x004)
+#define IOMD_KCTRL	(0x008)
+
+#ifdef CONFIG_ARCH_CLPS7500
+#define IOMD_IOLINES	(0x00C)
+#endif
+
+#define IOMD_IRQSTATA	(0x010)
+#define IOMD_IRQREQA	(0x014)
+#define IOMD_IRQCLRA	(0x014)
+#define IOMD_IRQMASKA	(0x018)
+
+#ifdef CONFIG_ARCH_CLPS7500
+#define IOMD_SUSMODE	(0x01C)
+#endif
+
+#define IOMD_IRQSTATB	(0x020)
+#define IOMD_IRQREQB	(0x024)
+#define IOMD_IRQMASKB	(0x028)
+
+#define IOMD_FIQSTAT	(0x030)
+#define IOMD_FIQREQ	(0x034)
+#define IOMD_FIQMASK	(0x038)
+
+#ifdef CONFIG_ARCH_CLPS7500
+#define IOMD_CLKCTL	(0x03C)
+#endif
+
+#define IOMD_T0CNTL	(0x040)
+#define IOMD_T0LTCHL	(0x040)
+#define IOMD_T0CNTH	(0x044)
+#define IOMD_T0LTCHH	(0x044)
+#define IOMD_T0GO	(0x048)
+#define IOMD_T0LATCH	(0x04c)
+
+#define IOMD_T1CNTL	(0x050)
+#define IOMD_T1LTCHL	(0x050)
+#define IOMD_T1CNTH	(0x054)
+#define IOMD_T1LTCHH	(0x054)
+#define IOMD_T1GO	(0x058)
+#define IOMD_T1LATCH	(0x05c)
+
+#ifdef CONFIG_ARCH_CLPS7500
+#define IOMD_IRQSTATC	(0x060)
+#define IOMD_IRQREQC	(0x064)
+#define IOMD_IRQMASKC	(0x068)
+
+#define IOMD_VIDMUX	(0x06c)
+
+#define IOMD_IRQSTATD	(0x070)
+#define IOMD_IRQREQD	(0x074)
+#define IOMD_IRQMASKD	(0x078)
+#endif
+
+#define IOMD_ROMCR0	(0x080)
+#define IOMD_ROMCR1	(0x084)
+#ifdef CONFIG_ARCH_RPC
+#define IOMD_DRAMCR	(0x088)
+#endif
+#define IOMD_REFCR	(0x08C)
+
+#define IOMD_FSIZE	(0x090)
+#define IOMD_ID0	(0x094)
+#define IOMD_ID1	(0x098)
+#define IOMD_VERSION	(0x09C)
+
+#ifdef CONFIG_ARCH_RPC
+#define IOMD_MOUSEX	(0x0A0)
+#define IOMD_MOUSEY	(0x0A4)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7500
+#define IOMD_MSEDAT	(0x0A8)
+#define IOMD_MSECTL	(0x0Ac)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+#define IOMD_DMATCR	(0x0C0)
+#endif
+#define IOMD_IOTCR	(0x0C4)
+#define IOMD_ECTCR	(0x0C8)
+#ifdef CONFIG_ARCH_RPC
+#define IOMD_DMAEXT	(0x0CC)
+#endif
+#ifdef CONFIG_ARCH_CLPS7500
+#define IOMD_ASTCR	(0x0CC)
+#define IOMD_DRAMCR	(0x0D0)
+#define IOMD_SELFREF	(0x0D4)
+#define IOMD_ATODICR	(0x0E0)
+#define IOMD_ATODSR	(0x0E4)
+#define IOMD_ATODCC	(0x0E8)
+#define IOMD_ATODCNT1	(0x0EC)
+#define IOMD_ATODCNT2	(0x0F0)
+#define IOMD_ATODCNT3	(0x0F4)
+#define IOMD_ATODCNT4	(0x0F8)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+#define DMA_EXT_IO0	1
+#define DMA_EXT_IO1	2
+#define DMA_EXT_IO2	4
+#define DMA_EXT_IO3	8
+
+#define IOMD_IO0CURA	(0x100)
+#define IOMD_IO0ENDA	(0x104)
+#define IOMD_IO0CURB	(0x108)
+#define IOMD_IO0ENDB	(0x10C)
+#define IOMD_IO0CR	(0x110)
+#define IOMD_IO0ST	(0x114)
+
+#define IOMD_IO1CURA	(0x120)
+#define IOMD_IO1ENDA	(0x124)
+#define IOMD_IO1CURB	(0x128)
+#define IOMD_IO1ENDB	(0x12C)
+#define IOMD_IO1CR	(0x130)
+#define IOMD_IO1ST	(0x134)
+
+#define IOMD_IO2CURA	(0x140)
+#define IOMD_IO2ENDA	(0x144)
+#define IOMD_IO2CURB	(0x148)
+#define IOMD_IO2ENDB	(0x14C)
+#define IOMD_IO2CR	(0x150)
+#define IOMD_IO2ST	(0x154)
+
+#define IOMD_IO3CURA	(0x160)
+#define IOMD_IO3ENDA	(0x164)
+#define IOMD_IO3CURB	(0x168)
+#define IOMD_IO3ENDB	(0x16C)
+#define IOMD_IO3CR	(0x170)
+#define IOMD_IO3ST	(0x174)
+#endif
+
+#define IOMD_SD0CURA	(0x180)
+#define IOMD_SD0ENDA	(0x184)
+#define IOMD_SD0CURB	(0x188)
+#define IOMD_SD0ENDB	(0x18C)
+#define IOMD_SD0CR	(0x190)
+#define IOMD_SD0ST	(0x194)
+
+#ifdef CONFIG_ARCH_RPC
+#define IOMD_SD1CURA	(0x1A0)
+#define IOMD_SD1ENDA	(0x1A4)
+#define IOMD_SD1CURB	(0x1A8)
+#define IOMD_SD1ENDB	(0x1AC)
+#define IOMD_SD1CR	(0x1B0)
+#define IOMD_SD1ST	(0x1B4)
+#endif
+
+#define IOMD_CURSCUR	(0x1C0)
+#define IOMD_CURSINIT	(0x1C4)
+
+#define IOMD_VIDCUR	(0x1D0)
+#define IOMD_VIDEND	(0x1D4)
+#define IOMD_VIDSTART	(0x1D8)
+#define IOMD_VIDINIT	(0x1DC)
+#define IOMD_VIDCR	(0x1E0)
+
+#define IOMD_DMASTAT	(0x1F0)
+#define IOMD_DMAREQ	(0x1F4)
+#define IOMD_DMAMASK	(0x1F8)
+
+#define DMA_END_S	(1 << 31)
+#define DMA_END_L	(1 << 30)
+
+#define DMA_CR_C	0x80
+#define DMA_CR_D	0x40
+#define DMA_CR_E	0x20
+
+#define DMA_ST_OFL	4
+#define DMA_ST_INT	2
+#define DMA_ST_AB	1
+
+/*
+ * DMA (MEMC) compatibility
+ */
+#define HALF_SAM	vram_half_sam
+#define VDMA_ALIGNMENT	(HALF_SAM * 2)
+#define VDMA_XFERSIZE	(HALF_SAM)
+#define VDMA_INIT	IOMD_VIDINIT
+#define VDMA_START	IOMD_VIDSTART
+#define VDMA_END	IOMD_VIDEND
+
+#ifndef __ASSEMBLY__
+extern unsigned int vram_half_sam;
+#define video_set_dma(start,end,offset)				\
+do {								\
+	outl (SCREEN_START + start, VDMA_START);		\
+	outl (SCREEN_START + end - VDMA_XFERSIZE, VDMA_END);	\
+	if (offset >= end - VDMA_XFERSIZE)			\
+		offset |= 0x40000000;				\
+	outl (SCREEN_START + offset, VDMA_INIT);		\
+} while (0)
+#endif
+
+#endif
Index: build_tree/linux/include/asm/hardware/iop3xx.h
diff -u /dev/null build_tree/linux/include/asm/hardware/iop3xx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/iop3xx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,324 @@
+/*
+ * include/asm-arm/hardware/iop3xx.h
+ *
+ * Intel IOP32X and IOP33X register definitions
+ *
+ * Author: Rory Bolt <rorybolt@pacbell.net>
+ * Copyright (C) 2002 Rory Bolt
+ * Copyright (C) 2004 Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __IOP3XX_H
+#define __IOP3XX_H
+
+/*
+ * IOP3XX GPIO handling
+ */
+#define GPIO_IN			0
+#define GPIO_OUT		1
+#define GPIO_LOW		0
+#define GPIO_HIGH		1
+#define IOP3XX_GPIO_LINE(x)	(x)
+
+#ifndef __ASSEMBLY__
+extern void gpio_line_config(int line, int direction);
+extern int  gpio_line_get(int line);
+extern void gpio_line_set(int line, int value);
+#endif
+
+
+/*
+ * IOP3XX processor registers
+ */
+#define IOP3XX_PERIPHERAL_PHYS_BASE	0xffffe000
+#define IOP3XX_PERIPHERAL_VIRT_BASE	0xfeffe000
+#define IOP3XX_PERIPHERAL_SIZE		0x00002000
+#define IOP3XX_PERIPHERAL_UPPER_PA (IOP3XX_PERIPHERAL_PHYS_BASE +\
+					IOP3XX_PERIPHERAL_SIZE - 1)
+#define IOP3XX_PERIPHERAL_UPPER_VA (IOP3XX_PERIPHERAL_VIRT_BASE +\
+					IOP3XX_PERIPHERAL_SIZE - 1)
+#define IOP3XX_PMMR_PHYS_TO_VIRT(addr) (u32) ((u32) addr -\
+					(IOP3XX_PERIPHERAL_PHYS_BASE\
+					- IOP3XX_PERIPHERAL_VIRT_BASE))
+#define IOP3XX_REG_ADDR(reg)		(IOP3XX_PERIPHERAL_VIRT_BASE + (reg))
+
+/* Address Translation Unit  */
+#define IOP3XX_ATUVID		(volatile u16 *)IOP3XX_REG_ADDR(0x0100)
+#define IOP3XX_ATUDID		(volatile u16 *)IOP3XX_REG_ADDR(0x0102)
+#define IOP3XX_ATUCMD		(volatile u16 *)IOP3XX_REG_ADDR(0x0104)
+#define IOP3XX_ATUSR		(volatile u16 *)IOP3XX_REG_ADDR(0x0106)
+#define IOP3XX_ATURID		(volatile u8  *)IOP3XX_REG_ADDR(0x0108)
+#define IOP3XX_ATUCCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0109)
+#define IOP3XX_ATUCLSR		(volatile u8  *)IOP3XX_REG_ADDR(0x010c)
+#define IOP3XX_ATULT		(volatile u8  *)IOP3XX_REG_ADDR(0x010d)
+#define IOP3XX_ATUHTR		(volatile u8  *)IOP3XX_REG_ADDR(0x010e)
+#define IOP3XX_ATUBIST		(volatile u8  *)IOP3XX_REG_ADDR(0x010f)
+#define IOP3XX_IABAR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0110)
+#define IOP3XX_IAUBAR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0114)
+#define IOP3XX_IABAR1		(volatile u32 *)IOP3XX_REG_ADDR(0x0118)
+#define IOP3XX_IAUBAR1		(volatile u32 *)IOP3XX_REG_ADDR(0x011c)
+#define IOP3XX_IABAR2		(volatile u32 *)IOP3XX_REG_ADDR(0x0120)
+#define IOP3XX_IAUBAR2		(volatile u32 *)IOP3XX_REG_ADDR(0x0124)
+#define IOP3XX_ASVIR		(volatile u16 *)IOP3XX_REG_ADDR(0x012c)
+#define IOP3XX_ASIR		(volatile u16 *)IOP3XX_REG_ADDR(0x012e)
+#define IOP3XX_ERBAR		(volatile u32 *)IOP3XX_REG_ADDR(0x0130)
+#define IOP3XX_ATUILR		(volatile u8  *)IOP3XX_REG_ADDR(0x013c)
+#define IOP3XX_ATUIPR		(volatile u8  *)IOP3XX_REG_ADDR(0x013d)
+#define IOP3XX_ATUMGNT		(volatile u8  *)IOP3XX_REG_ADDR(0x013e)
+#define IOP3XX_ATUMLAT		(volatile u8  *)IOP3XX_REG_ADDR(0x013f)
+#define IOP3XX_IALR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0140)
+#define IOP3XX_IATVR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0144)
+#define IOP3XX_ERLR		(volatile u32 *)IOP3XX_REG_ADDR(0x0148)
+#define IOP3XX_ERTVR		(volatile u32 *)IOP3XX_REG_ADDR(0x014c)
+#define IOP3XX_IALR1		(volatile u32 *)IOP3XX_REG_ADDR(0x0150)
+#define IOP3XX_IALR2		(volatile u32 *)IOP3XX_REG_ADDR(0x0154)
+#define IOP3XX_IATVR2		(volatile u32 *)IOP3XX_REG_ADDR(0x0158)
+#define IOP3XX_OIOWTVR		(volatile u32 *)IOP3XX_REG_ADDR(0x015c)
+#define IOP3XX_OMWTVR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0160)
+#define IOP3XX_OUMWTVR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0164)
+#define IOP3XX_OMWTVR1		(volatile u32 *)IOP3XX_REG_ADDR(0x0168)
+#define IOP3XX_OUMWTVR1		(volatile u32 *)IOP3XX_REG_ADDR(0x016c)
+#define IOP3XX_OUDWTVR		(volatile u32 *)IOP3XX_REG_ADDR(0x0178)
+#define IOP3XX_ATUCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0180)
+#define IOP3XX_PCSR		(volatile u32 *)IOP3XX_REG_ADDR(0x0184)
+#define IOP3XX_ATUISR		(volatile u32 *)IOP3XX_REG_ADDR(0x0188)
+#define IOP3XX_ATUIMR		(volatile u32 *)IOP3XX_REG_ADDR(0x018c)
+#define IOP3XX_IABAR3		(volatile u32 *)IOP3XX_REG_ADDR(0x0190)
+#define IOP3XX_IAUBAR3		(volatile u32 *)IOP3XX_REG_ADDR(0x0194)
+#define IOP3XX_IALR3		(volatile u32 *)IOP3XX_REG_ADDR(0x0198)
+#define IOP3XX_IATVR3		(volatile u32 *)IOP3XX_REG_ADDR(0x019c)
+#define IOP3XX_OCCAR		(volatile u32 *)IOP3XX_REG_ADDR(0x01a4)
+#define IOP3XX_OCCDR		(volatile u32 *)IOP3XX_REG_ADDR(0x01ac)
+#define IOP3XX_PDSCR		(volatile u32 *)IOP3XX_REG_ADDR(0x01bc)
+#define IOP3XX_PMCAPID		(volatile u8  *)IOP3XX_REG_ADDR(0x01c0)
+#define IOP3XX_PMNEXT		(volatile u8  *)IOP3XX_REG_ADDR(0x01c1)
+#define IOP3XX_APMCR		(volatile u16 *)IOP3XX_REG_ADDR(0x01c2)
+#define IOP3XX_APMCSR		(volatile u16 *)IOP3XX_REG_ADDR(0x01c4)
+#define IOP3XX_PCIXCAPID	(volatile u8  *)IOP3XX_REG_ADDR(0x01e0)
+#define IOP3XX_PCIXNEXT		(volatile u8  *)IOP3XX_REG_ADDR(0x01e1)
+#define IOP3XX_PCIXCMD		(volatile u16 *)IOP3XX_REG_ADDR(0x01e2)
+#define IOP3XX_PCIXSR		(volatile u32 *)IOP3XX_REG_ADDR(0x01e4)
+#define IOP3XX_PCIIRSR		(volatile u32 *)IOP3XX_REG_ADDR(0x01ec)
+
+/* Messaging Unit  */
+#define IOP3XX_IMR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0310)
+#define IOP3XX_IMR1		(volatile u32 *)IOP3XX_REG_ADDR(0x0314)
+#define IOP3XX_OMR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0318)
+#define IOP3XX_OMR1		(volatile u32 *)IOP3XX_REG_ADDR(0x031c)
+#define IOP3XX_IDR		(volatile u32 *)IOP3XX_REG_ADDR(0x0320)
+#define IOP3XX_IISR		(volatile u32 *)IOP3XX_REG_ADDR(0x0324)
+#define IOP3XX_IIMR		(volatile u32 *)IOP3XX_REG_ADDR(0x0328)
+#define IOP3XX_ODR		(volatile u32 *)IOP3XX_REG_ADDR(0x032c)
+#define IOP3XX_OISR		(volatile u32 *)IOP3XX_REG_ADDR(0x0330)
+#define IOP3XX_OIMR		(volatile u32 *)IOP3XX_REG_ADDR(0x0334)
+#define IOP3XX_MUCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0350)
+#define IOP3XX_QBAR		(volatile u32 *)IOP3XX_REG_ADDR(0x0354)
+#define IOP3XX_IFHPR		(volatile u32 *)IOP3XX_REG_ADDR(0x0360)
+#define IOP3XX_IFTPR		(volatile u32 *)IOP3XX_REG_ADDR(0x0364)
+#define IOP3XX_IPHPR		(volatile u32 *)IOP3XX_REG_ADDR(0x0368)
+#define IOP3XX_IPTPR		(volatile u32 *)IOP3XX_REG_ADDR(0x036c)
+#define IOP3XX_OFHPR		(volatile u32 *)IOP3XX_REG_ADDR(0x0370)
+#define IOP3XX_OFTPR		(volatile u32 *)IOP3XX_REG_ADDR(0x0374)
+#define IOP3XX_OPHPR		(volatile u32 *)IOP3XX_REG_ADDR(0x0378)
+#define IOP3XX_OPTPR		(volatile u32 *)IOP3XX_REG_ADDR(0x037c)
+#define IOP3XX_IAR		(volatile u32 *)IOP3XX_REG_ADDR(0x0380)
+
+/* DMA Controller  */
+#define IOP3XX_DMA0_CCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0400)
+#define IOP3XX_DMA0_CSR		(volatile u32 *)IOP3XX_REG_ADDR(0x0404)
+#define IOP3XX_DMA0_DAR		(volatile u32 *)IOP3XX_REG_ADDR(0x040c)
+#define IOP3XX_DMA0_NDAR	(volatile u32 *)IOP3XX_REG_ADDR(0x0410)
+#define IOP3XX_DMA0_PADR	(volatile u32 *)IOP3XX_REG_ADDR(0x0414)
+#define IOP3XX_DMA0_PUADR	(volatile u32 *)IOP3XX_REG_ADDR(0x0418)
+#define IOP3XX_DMA0_LADR	(volatile u32 *)IOP3XX_REG_ADDR(0x041c)
+#define IOP3XX_DMA0_BCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0420)
+#define IOP3XX_DMA0_DCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0424)
+#define IOP3XX_DMA1_CCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0440)
+#define IOP3XX_DMA1_CSR		(volatile u32 *)IOP3XX_REG_ADDR(0x0444)
+#define IOP3XX_DMA1_DAR		(volatile u32 *)IOP3XX_REG_ADDR(0x044c)
+#define IOP3XX_DMA1_NDAR	(volatile u32 *)IOP3XX_REG_ADDR(0x0450)
+#define IOP3XX_DMA1_PADR	(volatile u32 *)IOP3XX_REG_ADDR(0x0454)
+#define IOP3XX_DMA1_PUADR	(volatile u32 *)IOP3XX_REG_ADDR(0x0458)
+#define IOP3XX_DMA1_LADR	(volatile u32 *)IOP3XX_REG_ADDR(0x045c)
+#define IOP3XX_DMA1_BCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0460)
+#define IOP3XX_DMA1_DCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0464)
+
+/* Peripheral bus interface  */
+#define IOP3XX_PBCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0680)
+#define IOP3XX_PBISR		(volatile u32 *)IOP3XX_REG_ADDR(0x0684)
+#define IOP3XX_PBBAR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0688)
+#define IOP3XX_PBLR0		(volatile u32 *)IOP3XX_REG_ADDR(0x068c)
+#define IOP3XX_PBBAR1		(volatile u32 *)IOP3XX_REG_ADDR(0x0690)
+#define IOP3XX_PBLR1		(volatile u32 *)IOP3XX_REG_ADDR(0x0694)
+#define IOP3XX_PBBAR2		(volatile u32 *)IOP3XX_REG_ADDR(0x0698)
+#define IOP3XX_PBLR2		(volatile u32 *)IOP3XX_REG_ADDR(0x069c)
+#define IOP3XX_PBBAR3		(volatile u32 *)IOP3XX_REG_ADDR(0x06a0)
+#define IOP3XX_PBLR3		(volatile u32 *)IOP3XX_REG_ADDR(0x06a4)
+#define IOP3XX_PBBAR4		(volatile u32 *)IOP3XX_REG_ADDR(0x06a8)
+#define IOP3XX_PBLR4		(volatile u32 *)IOP3XX_REG_ADDR(0x06ac)
+#define IOP3XX_PBBAR5		(volatile u32 *)IOP3XX_REG_ADDR(0x06b0)
+#define IOP3XX_PBLR5		(volatile u32 *)IOP3XX_REG_ADDR(0x06b4)
+#define IOP3XX_PMBR0		(volatile u32 *)IOP3XX_REG_ADDR(0x06c0)
+#define IOP3XX_PMBR1		(volatile u32 *)IOP3XX_REG_ADDR(0x06e0)
+#define IOP3XX_PMBR2		(volatile u32 *)IOP3XX_REG_ADDR(0x06e4)
+
+/* Peripheral performance monitoring unit  */
+#define IOP3XX_GTMR		(volatile u32 *)IOP3XX_REG_ADDR(0x0700)
+#define IOP3XX_ESR		(volatile u32 *)IOP3XX_REG_ADDR(0x0704)
+#define IOP3XX_EMISR		(volatile u32 *)IOP3XX_REG_ADDR(0x0708)
+#define IOP3XX_GTSR		(volatile u32 *)IOP3XX_REG_ADDR(0x0710)
+/* PERCR0 DOESN'T EXIST - index from 1! */
+#define IOP3XX_PERCR0		(volatile u32 *)IOP3XX_REG_ADDR(0x0710)
+
+/* General Purpose I/O  */
+#define IOP3XX_GPOE		(volatile u32 *)IOP3XX_GPIO_REG(0x0000)
+#define IOP3XX_GPID		(volatile u32 *)IOP3XX_GPIO_REG(0x0004)
+#define IOP3XX_GPOD		(volatile u32 *)IOP3XX_GPIO_REG(0x0008)
+
+/* Timers  */
+#define IOP3XX_TU_TMR0		(volatile u32 *)IOP3XX_TIMER_REG(0x0000)
+#define IOP3XX_TU_TMR1		(volatile u32 *)IOP3XX_TIMER_REG(0x0004)
+#define IOP3XX_TU_TCR0		(volatile u32 *)IOP3XX_TIMER_REG(0x0008)
+#define IOP3XX_TU_TCR1		(volatile u32 *)IOP3XX_TIMER_REG(0x000c)
+#define IOP3XX_TU_TRR0		(volatile u32 *)IOP3XX_TIMER_REG(0x0010)
+#define IOP3XX_TU_TRR1		(volatile u32 *)IOP3XX_TIMER_REG(0x0014)
+#define IOP3XX_TU_TISR		(volatile u32 *)IOP3XX_TIMER_REG(0x0018)
+#define IOP3XX_TU_WDTCR		(volatile u32 *)IOP3XX_TIMER_REG(0x001c)
+#define IOP_TMR_EN	    0x02
+#define IOP_TMR_RELOAD	    0x04
+#define IOP_TMR_PRIVILEGED 0x08
+#define IOP_TMR_RATIO_1_1  0x00
+
+/* Application accelerator unit  */
+#define IOP3XX_AAU_ACR		(volatile u32 *)IOP3XX_REG_ADDR(0x0800)
+#define IOP3XX_AAU_ASR		(volatile u32 *)IOP3XX_REG_ADDR(0x0804)
+#define IOP3XX_AAU_ADAR		(volatile u32 *)IOP3XX_REG_ADDR(0x0808)
+#define IOP3XX_AAU_ANDAR	(volatile u32 *)IOP3XX_REG_ADDR(0x080c)
+#define IOP3XX_AAU_SAR1		(volatile u32 *)IOP3XX_REG_ADDR(0x0810)
+#define IOP3XX_AAU_SAR2		(volatile u32 *)IOP3XX_REG_ADDR(0x0814)
+#define IOP3XX_AAU_SAR3		(volatile u32 *)IOP3XX_REG_ADDR(0x0818)
+#define IOP3XX_AAU_SAR4		(volatile u32 *)IOP3XX_REG_ADDR(0x081c)
+#define IOP3XX_AAU_DAR		(volatile u32 *)IOP3XX_REG_ADDR(0x0820)
+#define IOP3XX_AAU_ABCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0824)
+#define IOP3XX_AAU_ADCR		(volatile u32 *)IOP3XX_REG_ADDR(0x0828)
+#define IOP3XX_AAU_SAR5		(volatile u32 *)IOP3XX_REG_ADDR(0x082c)
+#define IOP3XX_AAU_SAR6		(volatile u32 *)IOP3XX_REG_ADDR(0x0830)
+#define IOP3XX_AAU_SAR7		(volatile u32 *)IOP3XX_REG_ADDR(0x0834)
+#define IOP3XX_AAU_SAR8		(volatile u32 *)IOP3XX_REG_ADDR(0x0838)
+#define IOP3XX_AAU_EDCR0	(volatile u32 *)IOP3XX_REG_ADDR(0x083c)
+#define IOP3XX_AAU_SAR9		(volatile u32 *)IOP3XX_REG_ADDR(0x0840)
+#define IOP3XX_AAU_SAR10	(volatile u32 *)IOP3XX_REG_ADDR(0x0844)
+#define IOP3XX_AAU_SAR11	(volatile u32 *)IOP3XX_REG_ADDR(0x0848)
+#define IOP3XX_AAU_SAR12	(volatile u32 *)IOP3XX_REG_ADDR(0x084c)
+#define IOP3XX_AAU_SAR13	(volatile u32 *)IOP3XX_REG_ADDR(0x0850)
+#define IOP3XX_AAU_SAR14	(volatile u32 *)IOP3XX_REG_ADDR(0x0854)
+#define IOP3XX_AAU_SAR15	(volatile u32 *)IOP3XX_REG_ADDR(0x0858)
+#define IOP3XX_AAU_SAR16	(volatile u32 *)IOP3XX_REG_ADDR(0x085c)
+#define IOP3XX_AAU_EDCR1	(volatile u32 *)IOP3XX_REG_ADDR(0x0860)
+#define IOP3XX_AAU_SAR17	(volatile u32 *)IOP3XX_REG_ADDR(0x0864)
+#define IOP3XX_AAU_SAR18	(volatile u32 *)IOP3XX_REG_ADDR(0x0868)
+#define IOP3XX_AAU_SAR19	(volatile u32 *)IOP3XX_REG_ADDR(0x086c)
+#define IOP3XX_AAU_SAR20	(volatile u32 *)IOP3XX_REG_ADDR(0x0870)
+#define IOP3XX_AAU_SAR21	(volatile u32 *)IOP3XX_REG_ADDR(0x0874)
+#define IOP3XX_AAU_SAR22	(volatile u32 *)IOP3XX_REG_ADDR(0x0878)
+#define IOP3XX_AAU_SAR23	(volatile u32 *)IOP3XX_REG_ADDR(0x087c)
+#define IOP3XX_AAU_SAR24	(volatile u32 *)IOP3XX_REG_ADDR(0x0880)
+#define IOP3XX_AAU_EDCR2	(volatile u32 *)IOP3XX_REG_ADDR(0x0884)
+#define IOP3XX_AAU_SAR25	(volatile u32 *)IOP3XX_REG_ADDR(0x0888)
+#define IOP3XX_AAU_SAR26	(volatile u32 *)IOP3XX_REG_ADDR(0x088c)
+#define IOP3XX_AAU_SAR27	(volatile u32 *)IOP3XX_REG_ADDR(0x0890)
+#define IOP3XX_AAU_SAR28	(volatile u32 *)IOP3XX_REG_ADDR(0x0894)
+#define IOP3XX_AAU_SAR29	(volatile u32 *)IOP3XX_REG_ADDR(0x0898)
+#define IOP3XX_AAU_SAR30	(volatile u32 *)IOP3XX_REG_ADDR(0x089c)
+#define IOP3XX_AAU_SAR31	(volatile u32 *)IOP3XX_REG_ADDR(0x08a0)
+#define IOP3XX_AAU_SAR32	(volatile u32 *)IOP3XX_REG_ADDR(0x08a4)
+
+/* I2C bus interface unit  */
+#define IOP3XX_ICR0		(volatile u32 *)IOP3XX_REG_ADDR(0x1680)
+#define IOP3XX_ISR0		(volatile u32 *)IOP3XX_REG_ADDR(0x1684)
+#define IOP3XX_ISAR0		(volatile u32 *)IOP3XX_REG_ADDR(0x1688)
+#define IOP3XX_IDBR0		(volatile u32 *)IOP3XX_REG_ADDR(0x168c)
+#define IOP3XX_IBMR0		(volatile u32 *)IOP3XX_REG_ADDR(0x1694)
+#define IOP3XX_ICR1		(volatile u32 *)IOP3XX_REG_ADDR(0x16a0)
+#define IOP3XX_ISR1		(volatile u32 *)IOP3XX_REG_ADDR(0x16a4)
+#define IOP3XX_ISAR1		(volatile u32 *)IOP3XX_REG_ADDR(0x16a8)
+#define IOP3XX_IDBR1		(volatile u32 *)IOP3XX_REG_ADDR(0x16ac)
+#define IOP3XX_IBMR1		(volatile u32 *)IOP3XX_REG_ADDR(0x16b4)
+
+
+/*
+ * IOP3XX I/O and Mem space regions for PCI autoconfiguration
+ */
+#define IOP3XX_PCI_MEM_WINDOW_SIZE	0x04000000
+#define IOP3XX_PCI_LOWER_MEM_PA		0x80000000
+#define IOP3XX_PCI_LOWER_MEM_BA		(*IOP3XX_OMWTVR0)
+
+#define IOP3XX_PCI_IO_WINDOW_SIZE	0x00010000
+#define IOP3XX_PCI_LOWER_IO_PA		0x90000000
+#define IOP3XX_PCI_LOWER_IO_VA		0xfe000000
+#define IOP3XX_PCI_LOWER_IO_BA		(*IOP3XX_OIOWTVR)
+#define IOP3XX_PCI_UPPER_IO_PA		(IOP3XX_PCI_LOWER_IO_PA +\
+					IOP3XX_PCI_IO_WINDOW_SIZE - 1)
+#define IOP3XX_PCI_UPPER_IO_VA		(IOP3XX_PCI_LOWER_IO_VA +\
+					IOP3XX_PCI_IO_WINDOW_SIZE - 1)
+#define IOP3XX_PCI_IO_PHYS_TO_VIRT(addr) (((u32) addr -\
+					IOP3XX_PCI_LOWER_IO_PA) +\
+					IOP3XX_PCI_LOWER_IO_VA)
+
+
+#ifndef __ASSEMBLY__
+void iop3xx_map_io(void);
+void iop_init_cp6_handler(void);
+void iop_init_time(unsigned long tickrate);
+unsigned long iop_gettimeoffset(void);
+
+static inline void write_tmr0(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c0, c1, 0" : : "r" (val));
+}
+
+static inline void write_tmr1(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c1, c1, 0" : : "r" (val));
+}
+
+static inline u32 read_tcr0(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c2, c1, 0" : "=r" (val));
+	return val;
+}
+
+static inline u32 read_tcr1(void)
+{
+	u32 val;
+	asm volatile("mrc p6, 0, %0, c3, c1, 0" : "=r" (val));
+	return val;
+}
+
+static inline void write_trr0(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c4, c1, 0" : : "r" (val));
+}
+
+static inline void write_trr1(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c5, c1, 0" : : "r" (val));
+}
+
+static inline void write_tisr(u32 val)
+{
+	asm volatile("mcr p6, 0, %0, c6, c1, 0" : : "r" (val));
+}
+
+extern struct platform_device iop3xx_i2c0_device;
+extern struct platform_device iop3xx_i2c1_device;
+
+#endif
+
+
+#endif
Index: build_tree/linux/include/asm/hardware/linkup-l1110.h
diff -u /dev/null build_tree/linux/include/asm/hardware/linkup-l1110.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/linkup-l1110.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,48 @@
+/*
+*
+* Definitions for H3600 Handheld Computer
+*
+* Copyright 2001 Compaq Computer Corporation.
+*
+* Use consistent with the GNU GPL is permitted,
+* provided that this copyright notice is
+* preserved in its entirety in all copies and derived works.
+*
+* COMPAQ COMPUTER CORPORATION MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+* AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+* FITNESS FOR ANY PARTICULAR PURPOSE.
+*
+* Author: Jamey Hicks.
+*
+*/
+
+/* LinkUp Systems PCCard/CompactFlash Interface for SA-1100 */
+
+/* PC Card Status Register */
+#define LINKUP_PRS_S1	(1 << 0) /* voltage control bits S1-S4 */
+#define LINKUP_PRS_S2	(1 << 1)
+#define LINKUP_PRS_S3	(1 << 2)
+#define LINKUP_PRS_S4	(1 << 3)
+#define LINKUP_PRS_BVD1	(1 << 4)
+#define LINKUP_PRS_BVD2	(1 << 5)
+#define LINKUP_PRS_VS1	(1 << 6)
+#define LINKUP_PRS_VS2	(1 << 7)
+#define LINKUP_PRS_RDY	(1 << 8)
+#define LINKUP_PRS_CD1	(1 << 9)
+#define LINKUP_PRS_CD2	(1 << 10)
+
+/* PC Card Command Register */
+#define LINKUP_PRC_S1	(1 << 0)
+#define LINKUP_PRC_S2	(1 << 1)
+#define LINKUP_PRC_S3	(1 << 2)
+#define LINKUP_PRC_S4	(1 << 3)
+#define LINKUP_PRC_RESET (1 << 4)
+#define LINKUP_PRC_APOE	(1 << 5) /* Auto Power Off Enable: clears S1-S4 when either nCD goes high */
+#define LINKUP_PRC_CFE	(1 << 6) /* CompactFlash mode Enable: addresses A[10:0] only, A[25:11] high */
+#define LINKUP_PRC_SOE	(1 << 7) /* signal output driver enable */
+#define LINKUP_PRC_SSP	(1 << 8) /* sock select polarity: 0 for socket 0, 1 for socket 1 */
+#define LINKUP_PRC_MBZ	(1 << 15) /* must be zero */
+
+struct linkup_l1110 {
+	volatile short prc;
+};
Index: build_tree/linux/include/asm/hardware/locomo.h
diff -u /dev/null build_tree/linux/include/asm/hardware/locomo.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/locomo.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,214 @@
+/*
+ * linux/include/asm-arm/hardware/locomo.h
+ *
+ * This file contains the definitions for the LoCoMo G/A Chip
+ *
+ * (C) Copyright 2004 John Lenz
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Based on sa1111.h
+ */
+#ifndef _ASM_ARCH_LOCOMO
+#define _ASM_ARCH_LOCOMO
+
+#define locomo_writel(val,addr)	({ *(volatile u16 *)(addr) = (val); })
+#define locomo_readl(addr)	(*(volatile u16 *)(addr))
+
+/* LOCOMO version */
+#define LOCOMO_VER	0x00
+
+/* Pin status */
+#define LOCOMO_ST	0x04
+
+/* Pin status */
+#define LOCOMO_C32K	0x08
+
+/* Interrupt controller */
+#define LOCOMO_ICR	0x0C
+
+/* MCS decoder for boot selecting */
+#define LOCOMO_MCSX0	0x10
+#define LOCOMO_MCSX1	0x14
+#define LOCOMO_MCSX2	0x18
+#define LOCOMO_MCSX3	0x1c
+
+/* Touch panel controller */
+#define LOCOMO_ASD	0x20		/* AD start delay */
+#define LOCOMO_HSD	0x28		/* HSYS delay */
+#define LOCOMO_HSC	0x2c		/* HSYS period */
+#define LOCOMO_TADC	0x30		/* tablet ADC clock */
+
+
+/* Long time timer */
+#define LOCOMO_LTC	0xd8		/* LTC interrupt setting */
+#define LOCOMO_LTINT	0xdc		/* LTC interrupt */
+
+/* DAC control signal for LCD (COMADJ ) */
+#define LOCOMO_DAC		0xe0
+/* DAC control */
+#define	LOCOMO_DAC_SCLOEB	0x08	/* SCL pin output data       */
+#define	LOCOMO_DAC_TEST		0x04	/* Test bit                  */
+#define	LOCOMO_DAC_SDA		0x02	/* SDA pin level (read-only) */
+#define	LOCOMO_DAC_SDAOEB	0x01	/* SDA pin output data       */
+
+/* SPI interface */
+#define LOCOMO_SPI	0x60
+#define LOCOMO_SPIMD	0x00		/* SPI mode setting */
+#define LOCOMO_SPICT	0x04		/* SPI mode control */
+#define LOCOMO_SPIST	0x08		/* SPI status */
+#define LOCOMO_SPIIS	0x10		/* SPI interrupt status */
+#define LOCOMO_SPIWE	0x14		/* SPI interrupt status write enable */
+#define LOCOMO_SPIIE	0x18		/* SPI interrupt enable */
+#define LOCOMO_SPIIR	0x1c		/* SPI interrupt request */
+#define LOCOMO_SPITD	0x20		/* SPI transfer data write */
+#define LOCOMO_SPIRD	0x24		/* SPI receive data read */
+#define LOCOMO_SPITS	0x28		/* SPI transfer data shift */
+#define LOCOMO_SPIRS	0x2C		/* SPI receive data shift */
+#define	LOCOMO_SPI_TEND	(1 << 3)	/* Transfer end bit */
+#define	LOCOMO_SPI_OVRN	(1 << 2)	/* Over Run bit */
+#define	LOCOMO_SPI_RFW	(1 << 1)	/* write buffer bit */
+#define	LOCOMO_SPI_RFR	(1)		/* read buffer bit */
+
+/* GPIO */
+#define LOCOMO_GPD		0x90	/* GPIO direction */
+#define LOCOMO_GPE		0x94	/* GPIO input enable */
+#define LOCOMO_GPL		0x98	/* GPIO level */
+#define LOCOMO_GPO		0x9c	/* GPIO out data setteing */
+#define LOCOMO_GRIE		0xa0	/* GPIO rise detection */
+#define LOCOMO_GFIE		0xa4	/* GPIO fall detection */
+#define LOCOMO_GIS		0xa8	/* GPIO edge detection status */
+#define LOCOMO_GWE		0xac	/* GPIO status write enable */
+#define LOCOMO_GIE		0xb0	/* GPIO interrupt enable */
+#define LOCOMO_GIR		0xb4	/* GPIO interrupt request */
+#define	LOCOMO_GPIO(Nb)		(0x01 << (Nb))
+#define LOCOMO_GPIO_RTS		LOCOMO_GPIO(0)
+#define LOCOMO_GPIO_CTS		LOCOMO_GPIO(1)
+#define LOCOMO_GPIO_DSR		LOCOMO_GPIO(2)
+#define LOCOMO_GPIO_DTR		LOCOMO_GPIO(3)
+#define LOCOMO_GPIO_LCD_VSHA_ON	LOCOMO_GPIO(4)
+#define LOCOMO_GPIO_LCD_VSHD_ON	LOCOMO_GPIO(5)
+#define LOCOMO_GPIO_LCD_VEE_ON	LOCOMO_GPIO(6)
+#define LOCOMO_GPIO_LCD_MOD	LOCOMO_GPIO(7)
+#define LOCOMO_GPIO_DAC_ON	LOCOMO_GPIO(8)
+#define LOCOMO_GPIO_FL_VR	LOCOMO_GPIO(9)
+#define LOCOMO_GPIO_DAC_SDATA	LOCOMO_GPIO(10)
+#define LOCOMO_GPIO_DAC_SCK	LOCOMO_GPIO(11)
+#define LOCOMO_GPIO_DAC_SLOAD	LOCOMO_GPIO(12)
+
+/* Start the definitions of the devices.  Each device has an initial
+ * base address and a series of offsets from that base address. */
+
+/* Keyboard controller */
+#define LOCOMO_KEYBOARD		0x40
+#define LOCOMO_KIB		0x00	/* KIB level */
+#define LOCOMO_KSC		0x04	/* KSTRB control */
+#define LOCOMO_KCMD		0x08	/* KSTRB command */
+#define LOCOMO_KIC		0x0c	/* Key interrupt */
+
+/* Front light adjustment controller */
+#define LOCOMO_FRONTLIGHT	0xc8
+#define LOCOMO_ALS		0x00	/* Adjust light cycle */
+#define LOCOMO_ALD		0x04	/* Adjust light duty */
+
+#define LOCOMO_ALC_EN		0x8000
+
+/* Backlight controller: TFT signal */
+#define LOCOMO_BACKLIGHT	0x38
+#define LOCOMO_TC		0x00		/* TFT control signal */
+#define LOCOMO_CPSD		0x04		/* CPS delay */
+
+/* Audio controller */
+#define LOCOMO_AUDIO		0x54
+#define LOCOMO_ACC		0x00	/* Audio clock */
+#define LOCOMO_PAIF		0x7C	/* PCM audio interface */
+/* Audio clock */
+#define	LOCOMO_ACC_XON		0x80
+#define	LOCOMO_ACC_XEN		0x40
+#define	LOCOMO_ACC_XSEL0	0x00
+#define	LOCOMO_ACC_XSEL1	0x20
+#define	LOCOMO_ACC_MCLKEN	0x10
+#define	LOCOMO_ACC_64FSEN	0x08
+#define	LOCOMO_ACC_CLKSEL000	0x00	/* mclk  2 */
+#define	LOCOMO_ACC_CLKSEL001	0x01	/* mclk  3 */
+#define	LOCOMO_ACC_CLKSEL010	0x02	/* mclk  4 */
+#define	LOCOMO_ACC_CLKSEL011	0x03	/* mclk  6 */
+#define	LOCOMO_ACC_CLKSEL100	0x04	/* mclk  8 */
+#define	LOCOMO_ACC_CLKSEL101	0x05	/* mclk 12 */
+/* PCM audio interface */
+#define	LOCOMO_PAIF_SCINV	0x20
+#define	LOCOMO_PAIF_SCEN	0x10
+#define	LOCOMO_PAIF_LRCRST	0x08
+#define	LOCOMO_PAIF_LRCEVE	0x04
+#define	LOCOMO_PAIF_LRCINV	0x02
+#define	LOCOMO_PAIF_LRCEN	0x01
+
+/* LED controller */
+#define LOCOMO_LED		0xe8
+#define LOCOMO_LPT0		0x00
+#define LOCOMO_LPT1		0x04
+/* LED control */
+#define LOCOMO_LPT_TOFH		0x80
+#define LOCOMO_LPT_TOFL		0x08
+#define LOCOMO_LPT_TOH(TOH)	((TOH & 0x7) << 4)
+#define LOCOMO_LPT_TOL(TOL)	((TOL & 0x7))
+
+extern struct bus_type locomo_bus_type;
+
+#define LOCOMO_DEVID_KEYBOARD	0
+#define LOCOMO_DEVID_FRONTLIGHT	1
+#define LOCOMO_DEVID_BACKLIGHT	2
+#define LOCOMO_DEVID_AUDIO	3
+#define LOCOMO_DEVID_LED	4
+#define LOCOMO_DEVID_UART	5
+#define LOCOMO_DEVID_SPI		6
+
+struct locomo_dev {
+	struct device	dev;
+	unsigned int	devid;
+	unsigned int	irq[1];
+
+	void		*mapbase;
+	unsigned long	length;
+
+	u64		dma_mask;
+};
+
+#define LOCOMO_DEV(_d)	container_of((_d), struct locomo_dev, dev)
+
+#define locomo_get_drvdata(d)	dev_get_drvdata(&(d)->dev)
+#define locomo_set_drvdata(d,p)	dev_set_drvdata(&(d)->dev, p)
+
+struct locomo_driver {
+	struct device_driver	drv;
+	unsigned int		devid;
+	int (*probe)(struct locomo_dev *);
+	int (*remove)(struct locomo_dev *);
+	int (*suspend)(struct locomo_dev *, pm_message_t);
+	int (*resume)(struct locomo_dev *);
+};
+
+#define LOCOMO_DRV(_d)	container_of((_d), struct locomo_driver, drv)
+
+#define LOCOMO_DRIVER_NAME(_ldev) ((_ldev)->dev.driver->name)
+
+void locomo_lcd_power(struct locomo_dev *, int, unsigned int);
+
+int locomo_driver_register(struct locomo_driver *);
+void locomo_driver_unregister(struct locomo_driver *);
+
+/* GPIO control functions */
+void locomo_gpio_set_dir(struct device *dev, unsigned int bits, unsigned int dir);
+int locomo_gpio_read_level(struct device *dev, unsigned int bits);
+int locomo_gpio_read_output(struct device *dev, unsigned int bits);
+void locomo_gpio_write(struct device *dev, unsigned int bits, unsigned int set);
+
+
+/* M62332 control function */
+void locomo_m62332_senddata(struct locomo_dev *ldev, unsigned int dac_data, int channel);
+
+/* Frontlight control */
+void locomo_frontlight_set(struct locomo_dev *dev, int duty, int vr, int bpwf);
+
+#endif
Index: build_tree/linux/include/asm/hardware/memc.h
diff -u /dev/null build_tree/linux/include/asm/hardware/memc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/memc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ *  linux/include/asm-arm/hardware/memc.h
+ *
+ *  Copyright (C) Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define VDMA_ALIGNMENT	PAGE_SIZE
+#define VDMA_XFERSIZE	16
+#define VDMA_INIT	0
+#define VDMA_START	1
+#define VDMA_END	2
+
+#ifndef __ASSEMBLY__
+extern void memc_write(unsigned int reg, unsigned long val);
+
+#define video_set_dma(start,end,offset)				\
+do {								\
+	memc_write (VDMA_START, (start >> 2));			\
+	memc_write (VDMA_END, (end - VDMA_XFERSIZE) >> 2);	\
+	memc_write (VDMA_INIT, (offset >> 2));			\
+} while (0)
+
+#endif
Index: build_tree/linux/include/asm/hardware/pci_v3.h
diff -u /dev/null build_tree/linux/include/asm/hardware/pci_v3.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/pci_v3.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,186 @@
+/*
+ *  linux/include/asm-arm/hardware/pci_v3.h
+ *
+ *  Internal header file PCI V3 chip
+ *
+ *  Copyright (C) ARM Limited
+ *  Copyright (C) 2000-2001 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef ASM_ARM_HARDWARE_PCI_V3_H
+#define ASM_ARM_HARDWARE_PCI_V3_H
+
+/* -------------------------------------------------------------------------------
+ *  V3 Local Bus to PCI Bridge definitions
+ * -------------------------------------------------------------------------------
+ *  Registers (these are taken from page 129 of the EPC User's Manual Rev 1.04
+ *  All V3 register names are prefaced by V3_ to avoid clashing with any other
+ *  PCI definitions.  Their names match the user's manual.
+ * 
+ *  I'm assuming that I20 is disabled.
+ * 
+ */
+#define V3_PCI_VENDOR                   0x00000000
+#define V3_PCI_DEVICE                   0x00000002
+#define V3_PCI_CMD                      0x00000004
+#define V3_PCI_STAT                     0x00000006
+#define V3_PCI_CC_REV                   0x00000008
+#define V3_PCI_HDR_CFG                  0x0000000C
+#define V3_PCI_IO_BASE                  0x00000010
+#define V3_PCI_BASE0                    0x00000014
+#define V3_PCI_BASE1                    0x00000018
+#define V3_PCI_SUB_VENDOR               0x0000002C
+#define V3_PCI_SUB_ID                   0x0000002E
+#define V3_PCI_ROM                      0x00000030
+#define V3_PCI_BPARAM                   0x0000003C
+#define V3_PCI_MAP0                     0x00000040
+#define V3_PCI_MAP1                     0x00000044
+#define V3_PCI_INT_STAT                 0x00000048
+#define V3_PCI_INT_CFG                  0x0000004C 
+#define V3_LB_BASE0                     0x00000054
+#define V3_LB_BASE1                     0x00000058
+#define V3_LB_MAP0                      0x0000005E
+#define V3_LB_MAP1                      0x00000062
+#define V3_LB_BASE2                     0x00000064
+#define V3_LB_MAP2                      0x00000066
+#define V3_LB_SIZE                      0x00000068
+#define V3_LB_IO_BASE                   0x0000006E
+#define V3_FIFO_CFG                     0x00000070
+#define V3_FIFO_PRIORITY                0x00000072
+#define V3_FIFO_STAT                    0x00000074
+#define V3_LB_ISTAT                     0x00000076
+#define V3_LB_IMASK                     0x00000077
+#define V3_SYSTEM                       0x00000078
+#define V3_LB_CFG                       0x0000007A
+#define V3_PCI_CFG                      0x0000007C
+#define V3_DMA_PCI_ADR0                 0x00000080
+#define V3_DMA_PCI_ADR1                 0x00000090
+#define V3_DMA_LOCAL_ADR0               0x00000084
+#define V3_DMA_LOCAL_ADR1               0x00000094
+#define V3_DMA_LENGTH0                  0x00000088
+#define V3_DMA_LENGTH1                  0x00000098
+#define V3_DMA_CSR0                     0x0000008B
+#define V3_DMA_CSR1                     0x0000009B
+#define V3_DMA_CTLB_ADR0                0x0000008C
+#define V3_DMA_CTLB_ADR1                0x0000009C
+#define V3_DMA_DELAY                    0x000000E0
+#define V3_MAIL_DATA                    0x000000C0
+#define V3_PCI_MAIL_IEWR                0x000000D0
+#define V3_PCI_MAIL_IERD                0x000000D2
+#define V3_LB_MAIL_IEWR                 0x000000D4
+#define V3_LB_MAIL_IERD                 0x000000D6
+#define V3_MAIL_WR_STAT                 0x000000D8
+#define V3_MAIL_RD_STAT                 0x000000DA
+#define V3_QBA_MAP                      0x000000DC
+
+/*  PCI COMMAND REGISTER bits
+ */
+#define V3_COMMAND_M_FBB_EN             (1 << 9)
+#define V3_COMMAND_M_SERR_EN            (1 << 8)
+#define V3_COMMAND_M_PAR_EN             (1 << 6)
+#define V3_COMMAND_M_MASTER_EN          (1 << 2)
+#define V3_COMMAND_M_MEM_EN             (1 << 1)
+#define V3_COMMAND_M_IO_EN              (1 << 0)
+
+/*  SYSTEM REGISTER bits
+ */
+#define V3_SYSTEM_M_RST_OUT             (1 << 15)
+#define V3_SYSTEM_M_LOCK                (1 << 14)
+
+/*  PCI_CFG bits
+ */
+#define V3_PCI_CFG_M_I2O_EN		(1 << 15)
+#define V3_PCI_CFG_M_IO_REG_DIS		(1 << 14)
+#define V3_PCI_CFG_M_IO_DIS		(1 << 13)
+#define V3_PCI_CFG_M_EN3V		(1 << 12)
+#define V3_PCI_CFG_M_RETRY_EN           (1 << 10)
+#define V3_PCI_CFG_M_AD_LOW1            (1 << 9)
+#define V3_PCI_CFG_M_AD_LOW0            (1 << 8)
+
+/*  PCI_BASE register bits (PCI -> Local Bus)
+ */
+#define V3_PCI_BASE_M_ADR_BASE          0xFFF00000
+#define V3_PCI_BASE_M_ADR_BASEL         0x000FFF00
+#define V3_PCI_BASE_M_PREFETCH          (1 << 3)
+#define V3_PCI_BASE_M_TYPE              (3 << 1)
+#define V3_PCI_BASE_M_IO                (1 << 0)
+
+/*  PCI MAP register bits (PCI -> Local bus)
+ */
+#define V3_PCI_MAP_M_MAP_ADR            0xFFF00000
+#define V3_PCI_MAP_M_RD_POST_INH        (1 << 15)
+#define V3_PCI_MAP_M_ROM_SIZE           (3 << 10)
+#define V3_PCI_MAP_M_SWAP               (3 << 8)
+#define V3_PCI_MAP_M_ADR_SIZE           0x000000F0
+#define V3_PCI_MAP_M_REG_EN             (1 << 1)
+#define V3_PCI_MAP_M_ENABLE             (1 << 0)
+
+/*
+ *  LB_BASE0,1 register bits (Local bus -> PCI)
+ */
+#define V3_LB_BASE_ADR_BASE		0xfff00000
+#define V3_LB_BASE_SWAP			(3 << 8)
+#define V3_LB_BASE_ADR_SIZE		(15 << 4)
+#define V3_LB_BASE_PREFETCH		(1 << 3)
+#define V3_LB_BASE_ENABLE		(1 << 0)
+
+#define V3_LB_BASE_ADR_SIZE_1MB		(0 << 4)
+#define V3_LB_BASE_ADR_SIZE_2MB		(1 << 4)
+#define V3_LB_BASE_ADR_SIZE_4MB		(2 << 4)
+#define V3_LB_BASE_ADR_SIZE_8MB		(3 << 4)
+#define V3_LB_BASE_ADR_SIZE_16MB	(4 << 4)
+#define V3_LB_BASE_ADR_SIZE_32MB	(5 << 4)
+#define V3_LB_BASE_ADR_SIZE_64MB	(6 << 4)
+#define V3_LB_BASE_ADR_SIZE_128MB	(7 << 4)
+#define V3_LB_BASE_ADR_SIZE_256MB	(8 << 4)
+#define V3_LB_BASE_ADR_SIZE_512MB	(9 << 4)
+#define V3_LB_BASE_ADR_SIZE_1GB		(10 << 4)
+#define V3_LB_BASE_ADR_SIZE_2GB		(11 << 4)
+
+#define v3_addr_to_lb_base(a)	((a) & V3_LB_BASE_ADR_BASE)
+
+/*
+ *  LB_MAP0,1 register bits (Local bus -> PCI)
+ */
+#define V3_LB_MAP_MAP_ADR		0xfff0
+#define V3_LB_MAP_TYPE			(7 << 1)
+#define V3_LB_MAP_AD_LOW_EN		(1 << 0)
+
+#define V3_LB_MAP_TYPE_IACK		(0 << 1)
+#define V3_LB_MAP_TYPE_IO		(1 << 1)
+#define V3_LB_MAP_TYPE_MEM		(3 << 1)
+#define V3_LB_MAP_TYPE_CONFIG		(5 << 1)
+#define V3_LB_MAP_TYPE_MEM_MULTIPLE	(6 << 1)
+
+#define v3_addr_to_lb_map(a)	(((a) >> 16) & V3_LB_MAP_MAP_ADR)
+
+/*
+ *  LB_BASE2 register bits (Local bus -> PCI IO)
+ */
+#define V3_LB_BASE2_ADR_BASE		0xff00
+#define V3_LB_BASE2_SWAP		(3 << 6)
+#define V3_LB_BASE2_ENABLE		(1 << 0)
+
+#define v3_addr_to_lb_base2(a)	(((a) >> 16) & V3_LB_BASE2_ADR_BASE)
+
+/*
+ *  LB_MAP2 register bits (Local bus -> PCI IO)
+ */
+#define V3_LB_MAP2_MAP_ADR		0xff00
+
+#define v3_addr_to_lb_map2(a)	(((a) >> 16) & V3_LB_MAP2_MAP_ADR)
+
+#endif
Index: build_tree/linux/include/asm/hardware/sa1111.h
diff -u /dev/null build_tree/linux/include/asm/hardware/sa1111.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/sa1111.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,581 @@
+/*
+ * linux/include/asm-arm/hardware/sa1111.h
+ *
+ * Copyright (C) 2000 John G Dorsey <john+@cs.cmu.edu>
+ *
+ * This file contains definitions for the SA-1111 Companion Chip.
+ * (Structure and naming borrowed from SA-1101.h, by Peter Danielsson.)
+ *
+ * Macro that calculates real address for registers in the SA-1111
+ */
+
+#ifndef _ASM_ARCH_SA1111
+#define _ASM_ARCH_SA1111
+
+#include <asm/arch/bitfield.h>
+
+/*
+ * The SA1111 is always located at virtual 0xf4000000, and is always
+ * "native" endian.
+ */
+
+#define SA1111_VBASE		0xf4000000
+
+/* Don't use these! */
+#define SA1111_p2v( x )         ((x) - SA1111_BASE + SA1111_VBASE)
+#define SA1111_v2p( x )         ((x) - SA1111_VBASE + SA1111_BASE)
+
+#ifndef __ASSEMBLY__
+#define _SA1111(x)	((x) + sa1111->resource.start)
+#endif
+
+#define sa1111_writel(val,addr)	__raw_writel(val, addr)
+#define sa1111_readl(addr)	__raw_readl(addr)
+
+/*
+ * 26 bits of the SA-1110 address bus are available to the SA-1111.
+ * Use these when feeding target addresses to the DMA engines.
+ */
+
+#define SA1111_ADDR_WIDTH	(26)
+#define SA1111_ADDR_MASK	((1<<SA1111_ADDR_WIDTH)-1)
+#define SA1111_DMA_ADDR(x)	((x)&SA1111_ADDR_MASK)
+
+/*
+ * Don't ask the (SAC) DMA engines to move less than this amount.
+ */
+
+#define SA1111_SAC_DMA_MIN_XFER	(0x800)
+
+/*
+ * System Bus Interface (SBI)
+ *
+ * Registers
+ *    SKCR	Control Register
+ *    SMCR	Shared Memory Controller Register
+ *    SKID	ID Register
+ */
+#define SA1111_SKCR	0x0000
+#define SA1111_SMCR	0x0004
+#define SA1111_SKID	0x0008
+
+#define SKCR_PLL_BYPASS	(1<<0)
+#define SKCR_RCLKEN	(1<<1)
+#define SKCR_SLEEP	(1<<2)
+#define SKCR_DOZE	(1<<3)
+#define SKCR_VCO_OFF	(1<<4)
+#define SKCR_SCANTSTEN	(1<<5)
+#define SKCR_CLKTSTEN	(1<<6)
+#define SKCR_RDYEN	(1<<7)
+#define SKCR_SELAC	(1<<8)
+#define SKCR_OPPC	(1<<9)
+#define SKCR_PLLTSTEN	(1<<10)
+#define SKCR_USBIOTSTEN	(1<<11)
+/*
+ * Don't believe the specs!  Take them, throw them outside.  Leave them
+ * there for a week.  Spit on them.  Walk on them.  Stamp on them.
+ * Pour gasoline over them and finally burn them.  Now think about coding.
+ *  - The October 1999 errata (278260-007) says its bit 13, 1 to enable.
+ *  - The Feb 2001 errata (278260-010) says that the previous errata
+ *    (278260-009) is wrong, and its bit actually 12, fixed in spec
+ *    278242-003.
+ *  - The SA1111 manual (278242) says bit 12, but 0 to enable.
+ *  - Reality is bit 13, 1 to enable.
+ *      -- rmk
+ */
+#define SKCR_OE_EN	(1<<13)
+
+#define SMCR_DTIM	(1<<0)
+#define SMCR_MBGE	(1<<1)
+#define SMCR_DRAC_0	(1<<2)
+#define SMCR_DRAC_1	(1<<3)
+#define SMCR_DRAC_2	(1<<4)
+#define SMCR_DRAC	Fld(3, 2)
+#define SMCR_CLAT	(1<<5)
+
+#define SKID_SIREV_MASK	(0x000000f0)
+#define SKID_MTREV_MASK (0x0000000f)
+#define SKID_ID_MASK	(0xffffff00)
+#define SKID_SA1111_ID	(0x690cc200)
+
+/*
+ * System Controller
+ *
+ * Registers
+ *    SKPCR	Power Control Register
+ *    SKCDR	Clock Divider Register
+ *    SKAUD	Audio Clock Divider Register
+ *    SKPMC	PS/2 Mouse Clock Divider Register
+ *    SKPTC	PS/2 Track Pad Clock Divider Register
+ *    SKPEN0	PWM0 Enable Register
+ *    SKPWM0	PWM0 Clock Register
+ *    SKPEN1	PWM1 Enable Register
+ *    SKPWM1	PWM1 Clock Register
+ */
+#define SA1111_SKPCR	0x0200
+#define SA1111_SKCDR	0x0204
+#define SA1111_SKAUD	0x0208
+#define SA1111_SKPMC	0x020c
+#define SA1111_SKPTC	0x0210
+#define SA1111_SKPEN0	0x0214
+#define SA1111_SKPWM0	0x0218
+#define SA1111_SKPEN1	0x021c
+#define SA1111_SKPWM1	0x0220
+
+#define SKPCR_UCLKEN	(1<<0)
+#define SKPCR_ACCLKEN	(1<<1)
+#define SKPCR_I2SCLKEN	(1<<2)
+#define SKPCR_L3CLKEN	(1<<3)
+#define SKPCR_SCLKEN	(1<<4)
+#define SKPCR_PMCLKEN	(1<<5)
+#define SKPCR_PTCLKEN	(1<<6)
+#define SKPCR_DCLKEN	(1<<7)
+#define SKPCR_PWMCLKEN	(1<<8)
+
+/*
+ * USB Host controller
+ */
+#define SA1111_USB		0x0400
+
+/*
+ * Offsets from SA1111_USB_BASE
+ */
+#define SA1111_USB_STATUS	0x0118
+#define SA1111_USB_RESET	0x011c
+#define SA1111_USB_IRQTEST	0x0120
+
+#define USB_RESET_FORCEIFRESET	(1 << 0)
+#define USB_RESET_FORCEHCRESET	(1 << 1)
+#define USB_RESET_CLKGENRESET	(1 << 2)
+#define USB_RESET_SIMSCALEDOWN	(1 << 3)
+#define USB_RESET_USBINTTEST	(1 << 4)
+#define USB_RESET_SLEEPSTBYEN	(1 << 5)
+#define USB_RESET_PWRSENSELOW	(1 << 6)
+#define USB_RESET_PWRCTRLLOW	(1 << 7)
+
+#define USB_STATUS_IRQHCIRMTWKUP  (1 <<  7)
+#define USB_STATUS_IRQHCIBUFFACC  (1 <<  8)
+#define USB_STATUS_NIRQHCIM       (1 <<  9)
+#define USB_STATUS_NHCIMFCLR      (1 << 10)
+#define USB_STATUS_USBPWRSENSE    (1 << 11)
+
+/*
+ * Serial Audio Controller
+ *
+ * Registers
+ *    SACR0             Serial Audio Common Control Register
+ *    SACR1             Serial Audio Alternate Mode (I2C/MSB) Control Register
+ *    SACR2             Serial Audio AC-link Control Register
+ *    SASR0             Serial Audio I2S/MSB Interface & FIFO Status Register
+ *    SASR1             Serial Audio AC-link Interface & FIFO Status Register
+ *    SASCR             Serial Audio Status Clear Register
+ *    L3_CAR            L3 Control Bus Address Register
+ *    L3_CDR            L3 Control Bus Data Register
+ *    ACCAR             AC-link Command Address Register
+ *    ACCDR             AC-link Command Data Register
+ *    ACSAR             AC-link Status Address Register
+ *    ACSDR             AC-link Status Data Register
+ *    SADTCS            Serial Audio DMA Transmit Control/Status Register
+ *    SADTSA            Serial Audio DMA Transmit Buffer Start Address A
+ *    SADTCA            Serial Audio DMA Transmit Buffer Count Register A
+ *    SADTSB            Serial Audio DMA Transmit Buffer Start Address B
+ *    SADTCB            Serial Audio DMA Transmit Buffer Count Register B
+ *    SADRCS            Serial Audio DMA Receive Control/Status Register
+ *    SADRSA            Serial Audio DMA Receive Buffer Start Address A
+ *    SADRCA            Serial Audio DMA Receive Buffer Count Register A
+ *    SADRSB            Serial Audio DMA Receive Buffer Start Address B
+ *    SADRCB            Serial Audio DMA Receive Buffer Count Register B
+ *    SAITR             Serial Audio Interrupt Test Register
+ *    SADR              Serial Audio Data Register (16 x 32-bit)
+ */
+
+#define SA1111_SERAUDIO		0x0600
+
+/*
+ * These are offsets from the above base.
+ */
+#define SA1111_SACR0		0x00
+#define SA1111_SACR1		0x04
+#define SA1111_SACR2		0x08
+#define SA1111_SASR0		0x0c
+#define SA1111_SASR1		0x10
+#define SA1111_SASCR		0x18
+#define SA1111_L3_CAR		0x1c
+#define SA1111_L3_CDR		0x20
+#define SA1111_ACCAR		0x24
+#define SA1111_ACCDR		0x28
+#define SA1111_ACSAR		0x2c
+#define SA1111_ACSDR		0x30
+#define SA1111_SADTCS		0x34
+#define SA1111_SADTSA		0x38
+#define SA1111_SADTCA		0x3c
+#define SA1111_SADTSB		0x40
+#define SA1111_SADTCB		0x44
+#define SA1111_SADRCS		0x48
+#define SA1111_SADRSA		0x4c
+#define SA1111_SADRCA		0x50
+#define SA1111_SADRSB		0x54
+#define SA1111_SADRCB		0x58
+#define SA1111_SAITR		0x5c
+#define SA1111_SADR		0x80
+
+#ifndef CONFIG_ARCH_PXA
+
+#define SACR0_ENB	(1<<0)
+#define SACR0_BCKD	(1<<2)
+#define SACR0_RST	(1<<3)
+
+#define SACR1_AMSL	(1<<0)
+#define SACR1_L3EN	(1<<1)
+#define SACR1_L3MB	(1<<2)
+#define SACR1_DREC	(1<<3)
+#define SACR1_DRPL	(1<<4)
+#define SACR1_ENLBF	(1<<5)
+
+#define SACR2_TS3V	(1<<0)
+#define SACR2_TS4V	(1<<1)
+#define SACR2_WKUP	(1<<2)
+#define SACR2_DREC	(1<<3)
+#define SACR2_DRPL	(1<<4)
+#define SACR2_ENLBF	(1<<5)
+#define SACR2_RESET	(1<<6)
+
+#define SASR0_TNF	(1<<0)
+#define SASR0_RNE	(1<<1)
+#define SASR0_BSY	(1<<2)
+#define SASR0_TFS	(1<<3)
+#define SASR0_RFS	(1<<4)
+#define SASR0_TUR	(1<<5)
+#define SASR0_ROR	(1<<6)
+#define SASR0_L3WD	(1<<16)
+#define SASR0_L3RD	(1<<17)
+
+#define SASR1_TNF	(1<<0)
+#define SASR1_RNE	(1<<1)
+#define SASR1_BSY	(1<<2)
+#define SASR1_TFS	(1<<3)
+#define SASR1_RFS	(1<<4)
+#define SASR1_TUR	(1<<5)
+#define SASR1_ROR	(1<<6)
+#define SASR1_CADT	(1<<16)
+#define SASR1_SADR	(1<<17)
+#define SASR1_RSTO	(1<<18)
+#define SASR1_CLPM	(1<<19)
+#define SASR1_CRDY	(1<<20)
+#define SASR1_RS3V	(1<<21)
+#define SASR1_RS4V	(1<<22)
+
+#define SASCR_TUR	(1<<5)
+#define SASCR_ROR	(1<<6)
+#define SASCR_DTS	(1<<16)
+#define SASCR_RDD	(1<<17)
+#define SASCR_STO	(1<<18)
+
+#define SADTCS_TDEN	(1<<0)
+#define SADTCS_TDIE	(1<<1)
+#define SADTCS_TDBDA	(1<<3)
+#define SADTCS_TDSTA	(1<<4)
+#define SADTCS_TDBDB	(1<<5)
+#define SADTCS_TDSTB	(1<<6)
+#define SADTCS_TBIU	(1<<7)
+
+#define SADRCS_RDEN	(1<<0)
+#define SADRCS_RDIE	(1<<1)
+#define SADRCS_RDBDA	(1<<3)
+#define SADRCS_RDSTA	(1<<4)
+#define SADRCS_RDBDB	(1<<5)
+#define SADRCS_RDSTB	(1<<6)
+#define SADRCS_RBIU	(1<<7)
+
+#define SAD_CS_DEN	(1<<0)
+#define SAD_CS_DIE	(1<<1)	/* Not functional on metal 1 */
+#define SAD_CS_DBDA	(1<<3)	/* Not functional on metal 1 */
+#define SAD_CS_DSTA	(1<<4)
+#define SAD_CS_DBDB	(1<<5)	/* Not functional on metal 1 */
+#define SAD_CS_DSTB	(1<<6)
+#define SAD_CS_BIU	(1<<7)	/* Not functional on metal 1 */
+
+#define SAITR_TFS	(1<<0)
+#define SAITR_RFS	(1<<1)
+#define SAITR_TUR	(1<<2)
+#define SAITR_ROR	(1<<3)
+#define SAITR_CADT	(1<<4)
+#define SAITR_SADR	(1<<5)
+#define SAITR_RSTO	(1<<6)
+#define SAITR_TDBDA	(1<<8)
+#define SAITR_TDBDB	(1<<9)
+#define SAITR_RDBDA	(1<<10)
+#define SAITR_RDBDB	(1<<11)
+
+#endif  /* !CONFIG_ARCH_PXA */
+
+/*
+ * General-Purpose I/O Interface
+ *
+ * Registers
+ *    PA_DDR		GPIO Block A Data Direction
+ *    PA_DRR/PA_DWR	GPIO Block A Data Value Register (read/write)
+ *    PA_SDR		GPIO Block A Sleep Direction
+ *    PA_SSR		GPIO Block A Sleep State
+ *    PB_DDR		GPIO Block B Data Direction
+ *    PB_DRR/PB_DWR	GPIO Block B Data Value Register (read/write)
+ *    PB_SDR		GPIO Block B Sleep Direction
+ *    PB_SSR		GPIO Block B Sleep State
+ *    PC_DDR		GPIO Block C Data Direction
+ *    PC_DRR/PC_DWR	GPIO Block C Data Value Register (read/write)
+ *    PC_SDR		GPIO Block C Sleep Direction
+ *    PC_SSR		GPIO Block C Sleep State
+ */
+
+#define _PA_DDR		_SA1111( 0x1000 )
+#define _PA_DRR		_SA1111( 0x1004 )
+#define _PA_DWR		_SA1111( 0x1004 )
+#define _PA_SDR		_SA1111( 0x1008 )
+#define _PA_SSR		_SA1111( 0x100c )
+#define _PB_DDR		_SA1111( 0x1010 )
+#define _PB_DRR		_SA1111( 0x1014 )
+#define _PB_DWR		_SA1111( 0x1014 )
+#define _PB_SDR		_SA1111( 0x1018 )
+#define _PB_SSR		_SA1111( 0x101c )
+#define _PC_DDR		_SA1111( 0x1020 )
+#define _PC_DRR		_SA1111( 0x1024 )
+#define _PC_DWR		_SA1111( 0x1024 )
+#define _PC_SDR		_SA1111( 0x1028 )
+#define _PC_SSR		_SA1111( 0x102c )
+
+#define SA1111_GPIO	0x1000
+
+#define SA1111_GPIO_PADDR	(0x000)
+#define SA1111_GPIO_PADRR	(0x004)
+#define SA1111_GPIO_PADWR	(0x004)
+#define SA1111_GPIO_PASDR	(0x008)
+#define SA1111_GPIO_PASSR	(0x00c)
+#define SA1111_GPIO_PBDDR	(0x010)
+#define SA1111_GPIO_PBDRR	(0x014)
+#define SA1111_GPIO_PBDWR	(0x014)
+#define SA1111_GPIO_PBSDR	(0x018)
+#define SA1111_GPIO_PBSSR	(0x01c)
+#define SA1111_GPIO_PCDDR	(0x020)
+#define SA1111_GPIO_PCDRR	(0x024)
+#define SA1111_GPIO_PCDWR	(0x024)
+#define SA1111_GPIO_PCSDR	(0x028)
+#define SA1111_GPIO_PCSSR	(0x02c)
+
+#define GPIO_A0		(1 << 0)
+#define GPIO_A1		(1 << 1)
+#define GPIO_A2		(1 << 2)
+#define GPIO_A3		(1 << 3)
+
+#define GPIO_B0		(1 << 8)
+#define GPIO_B1		(1 << 9)
+#define GPIO_B2		(1 << 10)
+#define GPIO_B3		(1 << 11)
+#define GPIO_B4		(1 << 12)
+#define GPIO_B5		(1 << 13)
+#define GPIO_B6		(1 << 14)
+#define GPIO_B7		(1 << 15)
+
+#define GPIO_C0		(1 << 16)
+#define GPIO_C1		(1 << 17)
+#define GPIO_C2		(1 << 18)
+#define GPIO_C3		(1 << 19)
+#define GPIO_C4		(1 << 20)
+#define GPIO_C5		(1 << 21)
+#define GPIO_C6		(1 << 22)
+#define GPIO_C7		(1 << 23)
+
+/*
+ * Interrupt Controller
+ *
+ * Registers
+ *    INTTEST0		Test register 0
+ *    INTTEST1		Test register 1
+ *    INTEN0		Interrupt Enable register 0
+ *    INTEN1		Interrupt Enable register 1
+ *    INTPOL0		Interrupt Polarity selection 0
+ *    INTPOL1		Interrupt Polarity selection 1
+ *    INTTSTSEL		Interrupt source selection
+ *    INTSTATCLR0	Interrupt Status/Clear 0
+ *    INTSTATCLR1	Interrupt Status/Clear 1
+ *    INTSET0		Interrupt source set 0
+ *    INTSET1		Interrupt source set 1
+ *    WAKE_EN0		Wake-up source enable 0
+ *    WAKE_EN1		Wake-up source enable 1
+ *    WAKE_POL0		Wake-up polarity selection 0
+ *    WAKE_POL1		Wake-up polarity selection 1
+ */
+#define SA1111_INTC		0x1600
+
+/*
+ * These are offsets from the above base.
+ */
+#define SA1111_INTTEST0		0x0000
+#define SA1111_INTTEST1		0x0004
+#define SA1111_INTEN0		0x0008
+#define SA1111_INTEN1		0x000c
+#define SA1111_INTPOL0		0x0010
+#define SA1111_INTPOL1		0x0014
+#define SA1111_INTTSTSEL	0x0018
+#define SA1111_INTSTATCLR0	0x001c
+#define SA1111_INTSTATCLR1	0x0020
+#define SA1111_INTSET0		0x0024
+#define SA1111_INTSET1		0x0028
+#define SA1111_WAKEEN0		0x002c
+#define SA1111_WAKEEN1		0x0030
+#define SA1111_WAKEPOL0		0x0034
+#define SA1111_WAKEPOL1		0x0038
+
+/*
+ * PS/2 Trackpad and Mouse Interfaces
+ *
+ * Registers
+ *    PS2CR		Control Register
+ *    PS2STAT		Status Register
+ *    PS2DATA		Transmit/Receive Data register
+ *    PS2CLKDIV		Clock Division Register
+ *    PS2PRECNT		Clock Precount Register
+ *    PS2TEST1		Test register 1
+ *    PS2TEST2		Test register 2
+ *    PS2TEST3		Test register 3
+ *    PS2TEST4		Test register 4
+ */
+
+#define SA1111_KBD		0x0a00
+#define SA1111_MSE		0x0c00
+
+/*
+ * These are offsets from the above bases.
+ */
+#define SA1111_PS2CR		0x0000
+#define SA1111_PS2STAT		0x0004
+#define SA1111_PS2DATA		0x0008
+#define SA1111_PS2CLKDIV	0x000c
+#define SA1111_PS2PRECNT	0x0010
+
+#define PS2CR_ENA		0x08
+#define PS2CR_FKD		0x02
+#define PS2CR_FKC		0x01
+
+#define PS2STAT_STP		0x0100
+#define PS2STAT_TXE		0x0080
+#define PS2STAT_TXB		0x0040
+#define PS2STAT_RXF		0x0020
+#define PS2STAT_RXB		0x0010
+#define PS2STAT_ENA		0x0008
+#define PS2STAT_RXP		0x0004
+#define PS2STAT_KBD		0x0002
+#define PS2STAT_KBC		0x0001
+
+/*
+ * PCMCIA Interface
+ *
+ * Registers
+ *    PCSR	Status Register
+ *    PCCR	Control Register
+ *    PCSSR	Sleep State Register
+ */
+
+#define SA1111_PCMCIA	0x1600
+
+/*
+ * These are offsets from the above base.
+ */
+#define SA1111_PCCR	0x0000
+#define SA1111_PCSSR	0x0004
+#define SA1111_PCSR	0x0008
+
+#define PCSR_S0_READY	(1<<0)
+#define PCSR_S1_READY	(1<<1)
+#define PCSR_S0_DETECT	(1<<2)
+#define PCSR_S1_DETECT	(1<<3)
+#define PCSR_S0_VS1	(1<<4)
+#define PCSR_S0_VS2	(1<<5)
+#define PCSR_S1_VS1	(1<<6)
+#define PCSR_S1_VS2	(1<<7)
+#define PCSR_S0_WP	(1<<8)
+#define PCSR_S1_WP	(1<<9)
+#define PCSR_S0_BVD1	(1<<10)
+#define PCSR_S0_BVD2	(1<<11)
+#define PCSR_S1_BVD1	(1<<12)
+#define PCSR_S1_BVD2	(1<<13)
+
+#define PCCR_S0_RST	(1<<0)
+#define PCCR_S1_RST	(1<<1)
+#define PCCR_S0_FLT	(1<<2)
+#define PCCR_S1_FLT	(1<<3)
+#define PCCR_S0_PWAITEN	(1<<4)
+#define PCCR_S1_PWAITEN	(1<<5)
+#define PCCR_S0_PSE	(1<<6)
+#define PCCR_S1_PSE	(1<<7)
+
+#define PCSSR_S0_SLEEP	(1<<0)
+#define PCSSR_S1_SLEEP	(1<<1)
+
+
+
+
+extern struct bus_type sa1111_bus_type;
+
+#define SA1111_DEVID_SBI	0
+#define SA1111_DEVID_SK		1
+#define SA1111_DEVID_USB	2
+#define SA1111_DEVID_SAC	3
+#define SA1111_DEVID_SSP	4
+#define SA1111_DEVID_PS2	5
+#define SA1111_DEVID_GPIO	6
+#define SA1111_DEVID_INT	7
+#define SA1111_DEVID_PCMCIA	8
+
+struct sa1111_dev {
+	struct device	dev;
+	unsigned int	devid;
+	struct resource	res;
+	void __iomem	*mapbase;
+	unsigned int	skpcr_mask;
+	unsigned int	irq[6];
+	u64		dma_mask;
+};
+
+#define SA1111_DEV(_d)	container_of((_d), struct sa1111_dev, dev)
+
+#define sa1111_get_drvdata(d)	dev_get_drvdata(&(d)->dev)
+#define sa1111_set_drvdata(d,p)	dev_set_drvdata(&(d)->dev, p)
+
+struct sa1111_driver {
+	struct device_driver	drv;
+	unsigned int		devid;
+	int (*probe)(struct sa1111_dev *);
+	int (*remove)(struct sa1111_dev *);
+	int (*suspend)(struct sa1111_dev *, pm_message_t);
+	int (*resume)(struct sa1111_dev *);
+};
+
+#define SA1111_DRV(_d)	container_of((_d), struct sa1111_driver, drv)
+
+#define SA1111_DRIVER_NAME(_sadev) ((_sadev)->dev.driver->name)
+
+/*
+ * These frob the SKPCR register.
+ */
+void sa1111_enable_device(struct sa1111_dev *);
+void sa1111_disable_device(struct sa1111_dev *);
+
+unsigned int sa1111_pll_clock(struct sa1111_dev *);
+
+#define SA1111_AUDIO_ACLINK	0
+#define SA1111_AUDIO_I2S	1
+
+void sa1111_select_audio_mode(struct sa1111_dev *sadev, int mode);
+int sa1111_set_audio_rate(struct sa1111_dev *sadev, int rate);
+int sa1111_get_audio_rate(struct sa1111_dev *sadev);
+
+int sa1111_check_dma_bug(dma_addr_t addr);
+
+int sa1111_driver_register(struct sa1111_driver *);
+void sa1111_driver_unregister(struct sa1111_driver *);
+
+void sa1111_set_io_dir(struct sa1111_dev *sadev, unsigned int bits, unsigned int dir, unsigned int sleep_dir);
+void sa1111_set_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v);
+void sa1111_set_sleep_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v);
+
+#endif  /* _ASM_ARCH_SA1111 */
Index: build_tree/linux/include/asm/hardware/scoop.h
diff -u /dev/null build_tree/linux/include/asm/hardware/scoop.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/scoop.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,68 @@
+/*
+ *  Definitions for the SCOOP interface found on various Sharp PDAs
+ *
+ *  Copyright (c) 2004 Richard Purdie
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#define SCOOP_MCR  0x00
+#define SCOOP_CDR  0x04
+#define SCOOP_CSR  0x08
+#define SCOOP_CPR  0x0C
+#define SCOOP_CCR  0x10
+#define SCOOP_IRR  0x14
+#define SCOOP_IRM  0x14
+#define SCOOP_IMR  0x18
+#define SCOOP_ISR  0x1C
+#define SCOOP_GPCR 0x20
+#define SCOOP_GPWR 0x24
+#define SCOOP_GPRR 0x28
+
+#define SCOOP_GPCR_PA22	( 1 << 12 )
+#define SCOOP_GPCR_PA21	( 1 << 11 )
+#define SCOOP_GPCR_PA20	( 1 << 10 )
+#define SCOOP_GPCR_PA19	( 1 << 9 )
+#define SCOOP_GPCR_PA18	( 1 << 8 )
+#define SCOOP_GPCR_PA17	( 1 << 7 )
+#define SCOOP_GPCR_PA16	( 1 << 6 )
+#define SCOOP_GPCR_PA15	( 1 << 5 )
+#define SCOOP_GPCR_PA14	( 1 << 4 )
+#define SCOOP_GPCR_PA13	( 1 << 3 )
+#define SCOOP_GPCR_PA12	( 1 << 2 )
+#define SCOOP_GPCR_PA11	( 1 << 1 )
+
+struct scoop_config {
+	unsigned short io_out;
+	unsigned short io_dir;
+	unsigned short suspend_clr;
+	unsigned short suspend_set;
+};
+
+/* Structure for linking scoop devices to PCMCIA sockets */
+struct scoop_pcmcia_dev {
+	struct device *dev;     /* Pointer to this socket's scoop device */
+	int	irq;                /* irq for socket */
+	int cd_irq;
+	const char *cd_irq_str;
+	unsigned char keep_vs;
+	unsigned char keep_rd;
+};
+
+struct scoop_pcmcia_config {
+	struct scoop_pcmcia_dev *devs;
+	int num_devs;
+	void (*pcmcia_init)(void);
+	void (*power_ctrl)(struct device *scoop, unsigned short cpr, int nr);
+};
+
+extern struct scoop_pcmcia_config *platform_scoop_config;
+
+void reset_scoop(struct device *dev);
+unsigned short set_scoop_gpio(struct device *dev, unsigned short bit);
+unsigned short reset_scoop_gpio(struct device *dev, unsigned short bit);
+unsigned short read_scoop_reg(struct device *dev, unsigned short reg);
+void write_scoop_reg(struct device *dev, unsigned short reg, unsigned short data);
Index: build_tree/linux/include/asm/hardware/sharpsl_pm.h
diff -u /dev/null build_tree/linux/include/asm/hardware/sharpsl_pm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/sharpsl_pm.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,106 @@
+/*
+ * SharpSL Battery/PM Driver
+ *
+ * Copyright (c) 2004-2005 Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/interrupt.h>
+
+struct sharpsl_charger_machinfo {
+	void (*init)(void);
+	void (*exit)(void);
+	int gpio_acin;
+	int gpio_batfull;
+	int batfull_irq;
+	int gpio_batlock;
+	int gpio_fatal;
+	void (*discharge)(int);
+	void (*discharge1)(int);
+	void (*charge)(int);
+	void (*measure_temp)(int);
+	void (*presuspend)(void);
+	void (*postsuspend)(void);
+	void (*earlyresume)(void);
+	unsigned long (*read_devdata)(int);
+#define SHARPSL_BATT_VOLT       1
+#define SHARPSL_BATT_TEMP       2
+#define SHARPSL_ACIN_VOLT       3
+#define SHARPSL_STATUS_ACIN     4
+#define SHARPSL_STATUS_LOCK     5
+#define SHARPSL_STATUS_CHRGFULL 6
+#define SHARPSL_STATUS_FATAL    7
+	unsigned long (*charger_wakeup)(void);
+	int (*should_wakeup)(unsigned int resume_on_alarm);
+	void (*backlight_limit)(int);
+	int (*backlight_get_status) (void);
+	int charge_on_volt;
+	int charge_on_temp;
+	int charge_acin_high;
+	int charge_acin_low;
+	int fatal_acin_volt;
+	int fatal_noacin_volt;
+	int bat_levels;
+	struct battery_thresh *bat_levels_noac;
+	struct battery_thresh *bat_levels_acin;
+	struct battery_thresh *bat_levels_noac_bl;
+	struct battery_thresh *bat_levels_acin_bl;
+	int status_high_acin;
+	int status_low_acin;
+	int status_high_noac;
+	int status_low_noac;
+};
+
+struct battery_thresh {
+	int voltage;
+	int percentage;
+};
+
+struct battery_stat {
+	int ac_status;         /* APM AC Present/Not Present */
+	int mainbat_status;    /* APM Main Battery Status */
+	int mainbat_percent;   /* Main Battery Percentage Charge */
+	int mainbat_voltage;   /* Main Battery Voltage */
+};
+
+struct sharpsl_pm_status {
+	struct device *dev;
+	struct timer_list ac_timer;
+	struct timer_list chrg_full_timer;
+
+	int charge_mode;
+#define CHRG_ERROR    (-1)
+#define CHRG_OFF      (0)
+#define CHRG_ON       (1)
+#define CHRG_DONE     (2)
+
+	unsigned int flags;
+#define SHARPSL_SUSPENDED       (1 << 0)  /* Device is Suspended */
+#define SHARPSL_ALARM_ACTIVE    (1 << 1)  /* Alarm is for charging event (not user) */
+#define SHARPSL_BL_LIMIT        (1 << 2)  /* Backlight Intensity Limited */
+#define SHARPSL_APM_QUEUED      (1 << 3)  /* APM Event Queued */
+#define SHARPSL_DO_OFFLINE_CHRG (1 << 4)  /* Trigger the offline charger */
+
+	int full_count;
+	unsigned long charge_start_time;
+	struct sharpsl_charger_machinfo *machinfo;
+	struct battery_stat battstat;
+};
+
+extern struct sharpsl_pm_status sharpsl_pm;
+
+
+#define SHARPSL_LED_ERROR  2
+#define SHARPSL_LED_ON     1
+#define SHARPSL_LED_OFF    0
+
+void sharpsl_battery_kick(void);
+void sharpsl_pm_led(int val);
+irqreturn_t sharpsl_ac_isr(int irq, void *dev_id);
+irqreturn_t sharpsl_chrg_full_isr(int irq, void *dev_id);
+irqreturn_t sharpsl_fatal_isr(int irq, void *dev_id);
+
Index: build_tree/linux/include/asm/hardware/ssp.h
diff -u /dev/null build_tree/linux/include/asm/hardware/ssp.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/ssp.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,28 @@
+/*
+ *  ssp.h
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef SSP_H
+#define SSP_H
+
+struct ssp_state {
+	unsigned int	cr0;
+	unsigned int	cr1;
+};
+
+int ssp_write_word(u16 data);
+int ssp_read_word(u16 *data);
+int ssp_flush(void);
+void ssp_enable(void);
+void ssp_disable(void);
+void ssp_save_state(struct ssp_state *ssp);
+void ssp_restore_state(struct ssp_state *ssp);
+int ssp_init(void);
+void ssp_exit(void);
+
+#endif
Index: build_tree/linux/include/asm/hardware/uengine.h
diff -u /dev/null build_tree/linux/include/asm/hardware/uengine.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/uengine.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,62 @@
+/*
+ * Generic library functions for the microengines found on the Intel
+ * IXP2000 series of network processors.
+ *
+ * Copyright (C) 2004, 2005 Lennert Buytenhek <buytenh@wantstofly.org>
+ * Dedicated to Marija Kulikova.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of the
+ * License, or (at your option) any later version.
+ */
+
+#ifndef __IXP2000_UENGINE_H
+#define __IXP2000_UENGINE_H
+
+extern u32 ixp2000_uengine_mask;
+
+struct ixp2000_uengine_code
+{
+	u32	cpu_model_bitmask;
+	u8	cpu_min_revision;
+	u8	cpu_max_revision;
+
+	u32	uengine_parameters;
+
+	struct ixp2000_reg_value {
+		int	reg;
+		u32	value;
+	} *initial_reg_values;
+
+	int	num_insns;
+	u8	*insns;
+};
+
+u32 ixp2000_uengine_csr_read(int uengine, int offset);
+void ixp2000_uengine_csr_write(int uengine, int offset, u32 value);
+void ixp2000_uengine_reset(u32 uengine_mask);
+void ixp2000_uengine_set_mode(int uengine, u32 mode);
+void ixp2000_uengine_load_microcode(int uengine, u8 *ucode, int insns);
+void ixp2000_uengine_init_context(int uengine, int context, int pc);
+void ixp2000_uengine_start_contexts(int uengine, u8 ctx_mask);
+void ixp2000_uengine_stop_contexts(int uengine, u8 ctx_mask);
+int ixp2000_uengine_load(int uengine, struct ixp2000_uengine_code *c);
+
+#define IXP2000_UENGINE_8_CONTEXTS		0x00000000
+#define IXP2000_UENGINE_4_CONTEXTS		0x80000000
+#define IXP2000_UENGINE_PRN_UPDATE_EVERY	0x40000000
+#define IXP2000_UENGINE_PRN_UPDATE_ON_ACCESS	0x00000000
+#define IXP2000_UENGINE_NN_FROM_SELF		0x00100000
+#define IXP2000_UENGINE_NN_FROM_PREVIOUS	0x00000000
+#define IXP2000_UENGINE_ASSERT_EMPTY_AT_3	0x000c0000
+#define IXP2000_UENGINE_ASSERT_EMPTY_AT_2	0x00080000
+#define IXP2000_UENGINE_ASSERT_EMPTY_AT_1	0x00040000
+#define IXP2000_UENGINE_ASSERT_EMPTY_AT_0	0x00000000
+#define IXP2000_UENGINE_LM_ADDR1_GLOBAL		0x00020000
+#define IXP2000_UENGINE_LM_ADDR1_PER_CONTEXT	0x00000000
+#define IXP2000_UENGINE_LM_ADDR0_GLOBAL		0x00010000
+#define IXP2000_UENGINE_LM_ADDR0_PER_CONTEXT	0x00000000
+
+
+#endif
Index: build_tree/linux/include/asm/hardware/vic.h
diff -u /dev/null build_tree/linux/include/asm/hardware/vic.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/hardware/vic.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,45 @@
+/*
+ *  linux/include/asm-arm/hardware/vic.h
+ *
+ *  Copyright (c) ARM Limited 2003.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_HARDWARE_VIC_H
+#define __ASM_ARM_HARDWARE_VIC_H
+
+#define VIC_IRQ_STATUS			0x00
+#define VIC_FIQ_STATUS			0x04
+#define VIC_RAW_STATUS			0x08
+#define VIC_INT_SELECT			0x0c	/* 1 = FIQ, 0 = IRQ */
+#define VIC_INT_ENABLE			0x10	/* 1 = enable, 0 = disable */
+#define VIC_INT_ENABLE_CLEAR		0x14
+#define VIC_INT_SOFT			0x18
+#define VIC_INT_SOFT_CLEAR		0x1c
+#define VIC_PROTECT			0x20
+#define VIC_VECT_ADDR			0x30
+#define VIC_DEF_VECT_ADDR		0x34
+
+#define VIC_VECT_ADDR0			0x100	/* 0 to 15 */
+#define VIC_VECT_CNTL0			0x200	/* 0 to 15 */
+#define VIC_ITCR			0x300	/* VIC test control register */
+
+#define VIC_VECT_CNTL_ENABLE		(1 << 5)
+
+#ifndef __ASSEMBLY__
+void vic_init(void __iomem *base, unsigned int irq_start, u32 vic_sources);
+#endif
+
+#endif
Index: build_tree/linux/include/asm/mach/arch.h
diff -u /dev/null build_tree/linux/include/asm/mach/arch.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/arch.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,60 @@
+/*
+ *  linux/include/asm-arm/mach/arch.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASSEMBLY__
+
+struct tag;
+struct meminfo;
+struct sys_timer;
+
+struct machine_desc {
+	/*
+	 * Note! The first four elements are used
+	 * by assembler code in head-armv.S
+	 */
+	unsigned int		nr;		/* architecture number	*/
+	unsigned int		phys_io;	/* start of physical io	*/
+	unsigned int		io_pg_offst;	/* byte offset for io 
+						 * page tabe entry	*/
+
+	const char		*name;		/* architecture name	*/
+	unsigned long		boot_params;	/* tagged list		*/
+
+	unsigned int		video_start;	/* start of video RAM	*/
+	unsigned int		video_end;	/* end of video RAM	*/
+
+	unsigned int		reserve_lp0 :1;	/* never has lp0	*/
+	unsigned int		reserve_lp1 :1;	/* never has lp1	*/
+	unsigned int		reserve_lp2 :1;	/* never has lp2	*/
+	unsigned int		soft_reboot :1;	/* soft reboot		*/
+	void			(*fixup)(struct machine_desc *,
+					 struct tag *, char **,
+					 struct meminfo *);
+	void			(*map_io)(void);/* IO mapping function	*/
+	void			(*init_irq)(void);
+	struct sys_timer	*timer;		/* system tick timer	*/
+	void			(*init_machine)(void);
+};
+
+/*
+ * Set of macros to define architecture features.  This is built into
+ * a table by the linker.
+ */
+#define MACHINE_START(_type,_name)			\
+static const struct machine_desc __mach_desc_##_type	\
+ __attribute_used__					\
+ __attribute__((__section__(".arch.info.init"))) = {	\
+	.nr		= MACH_TYPE_##_type,		\
+	.name		= _name,
+
+#define MACHINE_END				\
+};
+
+#endif
Index: build_tree/linux/include/asm/mach/dma.h
diff -u /dev/null build_tree/linux/include/asm/mach/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/dma.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,57 @@
+/*
+ *  linux/include/asm-arm/mach/dma.h
+ *
+ *  Copyright (C) 1998-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  This header file describes the interface between the generic DMA handler
+ *  (dma.c) and the architecture-specific DMA backends (dma-*.c)
+ */
+
+struct dma_struct;
+typedef struct dma_struct dma_t;
+
+struct dma_ops {
+	int	(*request)(dmach_t, dma_t *);		/* optional */
+	void	(*free)(dmach_t, dma_t *);		/* optional */
+	void	(*enable)(dmach_t, dma_t *);		/* mandatory */
+	void 	(*disable)(dmach_t, dma_t *);		/* mandatory */
+	int	(*residue)(dmach_t, dma_t *);		/* optional */
+	int	(*setspeed)(dmach_t, dma_t *, int);	/* optional */
+	char	*type;
+};
+
+struct dma_struct {
+	void		*addr;		/* single DMA address		*/
+	unsigned long	count;		/* single DMA size		*/
+	struct scatterlist buf;		/* single DMA			*/
+	int		sgcount;	/* number of DMA SG		*/
+	struct scatterlist *sg;		/* DMA Scatter-Gather List	*/
+
+	unsigned int	active:1;	/* Transfer active		*/
+	unsigned int	invalid:1;	/* Address/Count changed	*/
+
+	dmamode_t	dma_mode;	/* DMA mode			*/
+	int		speed;		/* DMA speed			*/
+
+	unsigned int	lock;		/* Device is allocated		*/
+	const char	*device_id;	/* Device name			*/
+
+	unsigned int	dma_base;	/* Controller base address	*/
+	int		dma_irq;	/* Controller IRQ		*/
+	struct scatterlist cur_sg;	/* Current controller buffer	*/
+	unsigned int	state;
+
+	struct dma_ops	*d_ops;
+};
+
+/* Prototype: void arch_dma_init(dma)
+ * Purpose  : Initialise architecture specific DMA
+ * Params   : dma - pointer to array of DMA structures
+ */
+extern void arch_dma_init(dma_t *dma);
+
+extern void isa_init_dma(dma_t *dma);
Index: build_tree/linux/include/asm/mach/flash.h
diff -u /dev/null build_tree/linux/include/asm/mach/flash.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/flash.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,39 @@
+/*
+ *  linux/include/asm-arm/mach/flash.h
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ASMARM_MACH_FLASH_H
+#define ASMARM_MACH_FLASH_H
+
+struct mtd_partition;
+struct mtd_info;
+
+/*
+ * map_name:	the map probe function name
+ * name:	flash device name (eg, as used with mtdparts=)
+ * width:	width of mapped device
+ * init:	method called at driver/device initialisation
+ * exit:	method called at driver/device removal
+ * set_vpp:	method called to enable or disable VPP
+ * mmcontrol:	method called to enable or disable Sync. Burst Read in OneNAND
+ * parts:	optional array of mtd_partitions for static partitioning
+ * nr_parts:	number of mtd_partitions for static partitoning
+ */
+struct flash_platform_data {
+	const char	*map_name;
+	const char	*name;
+	unsigned int	width;
+	int		(*init)(void);
+	void		(*exit)(void);
+	void		(*set_vpp)(int on);
+	void		(*mmcontrol)(struct mtd_info *mtd, int sync_read);
+	struct mtd_partition *parts;
+	unsigned int	nr_parts;
+};
+
+#endif
Index: build_tree/linux/include/asm/mach/irda.h
diff -u /dev/null build_tree/linux/include/asm/mach/irda.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/irda.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/mach/irda.h
+ *
+ *  Copyright (C) 2004 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_MACH_IRDA_H
+#define __ASM_ARM_MACH_IRDA_H
+
+struct irda_platform_data {
+	int (*startup)(struct device *);
+	void (*shutdown)(struct device *);
+	int (*set_power)(struct device *, unsigned int state);
+	void (*set_speed)(struct device *, unsigned int speed);
+};
+
+#endif
Index: build_tree/linux/include/asm/mach/irq.h
diff -u /dev/null build_tree/linux/include/asm/mach/irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/irq.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,54 @@
+/*
+ *  linux/include/asm-arm/mach/irq.h
+ *
+ *  Copyright (C) 1995-2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_MACH_IRQ_H
+#define __ASM_ARM_MACH_IRQ_H
+
+#include <linux/irq.h>
+
+struct seq_file;
+
+/*
+ * This is internal.  Do not use it.
+ */
+extern void (*init_arch_irq)(void);
+extern void init_FIQ(void);
+extern int show_fiq_list(struct seq_file *, void *);
+
+/*
+ * Obsolete inline function for calling irq descriptor handlers.
+ */
+static inline void desc_handle_irq(unsigned int irq, struct irq_desc *desc)
+{
+	desc->handle_irq(irq, desc);
+}
+
+void set_irq_flags(unsigned int irq, unsigned int flags);
+
+#define IRQF_VALID	(1 << 0)
+#define IRQF_PROBE	(1 << 1)
+#define IRQF_NOAUTOEN	(1 << 2)
+
+/*
+ * This is for easy migration, but should be changed in the source
+ */
+#define do_bad_IRQ(irq,desc)				\
+do {							\
+	spin_lock(&desc->lock);				\
+	handle_bad_irq(irq, desc);			\
+	spin_unlock(&desc->lock);			\
+} while(0)
+
+extern unsigned long irq_err_count;
+static inline void ack_bad_irq(int irq)
+{
+	irq_err_count++;
+}
+
+#endif
Index: build_tree/linux/include/asm/mach/map.h
diff -u /dev/null build_tree/linux/include/asm/mach/map.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/map.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ *  linux/include/asm-arm/map.h
+ *
+ *  Copyright (C) 1999-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Page table mapping constructs and function prototypes
+ */
+struct map_desc {
+	unsigned long virtual;
+	unsigned long pfn;
+	unsigned long length;
+	unsigned int type;
+};
+
+#define MT_DEVICE		0
+#define MT_CACHECLEAN		1
+#define MT_MINICLEAN		2
+#define MT_LOW_VECTORS		3
+#define MT_HIGH_VECTORS		4
+#define MT_MEMORY		5
+#define MT_ROM			6
+#define MT_IXP2000_DEVICE	7
+#define MT_NONSHARED_DEVICE	8
+
+#ifdef CONFIG_MMU
+extern void iotable_init(struct map_desc *, int);
+#else
+#define iotable_init(map,num)	do { } while (0)
+#endif
Index: build_tree/linux/include/asm/mach/mmc.h
diff -u /dev/null build_tree/linux/include/asm/mach/mmc.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/mmc.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,15 @@
+/*
+ *  linux/include/asm-arm/mach/mmc.h
+ */
+#ifndef ASMARM_MACH_MMC_H
+#define ASMARM_MACH_MMC_H
+
+#include <linux/mmc/protocol.h>
+
+struct mmc_platform_data {
+	unsigned int ocr_mask;			/* available voltages */
+	u32 (*translate_vdd)(struct device *, unsigned int);
+	unsigned int (*status)(struct device *);
+};
+
+#endif
Index: build_tree/linux/include/asm/mach/pci.h
diff -u /dev/null build_tree/linux/include/asm/mach/pci.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/pci.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,71 @@
+/*
+ *  linux/include/asm-arm/mach/pci.h
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+struct pci_sys_data;
+struct pci_bus;
+
+struct hw_pci {
+	struct list_head buses;
+	int		nr_controllers;
+	int		(*setup)(int nr, struct pci_sys_data *);
+	struct pci_bus *(*scan)(int nr, struct pci_sys_data *);
+	void		(*preinit)(void);
+	void		(*postinit)(void);
+	u8		(*swizzle)(struct pci_dev *dev, u8 *pin);
+	int		(*map_irq)(struct pci_dev *dev, u8 slot, u8 pin);
+};
+
+/*
+ * Per-controller structure
+ */
+struct pci_sys_data {
+	struct list_head node;
+	int		busnr;		/* primary bus number			*/
+	u64		mem_offset;	/* bus->cpu memory mapping offset	*/
+	unsigned long	io_offset;	/* bus->cpu IO mapping offset		*/
+	struct pci_bus	*bus;		/* PCI bus				*/
+	struct resource *resource[3];	/* Primary PCI bus resources		*/
+					/* Bridge swizzling			*/
+	u8		(*swizzle)(struct pci_dev *, u8 *);
+					/* IRQ mapping				*/
+	int		(*map_irq)(struct pci_dev *, u8, u8);
+	struct hw_pci	*hw;
+};
+
+/*
+ * This is the standard PCI-PCI bridge swizzling algorithm.
+ */
+u8 pci_std_swizzle(struct pci_dev *dev, u8 *pinp);
+
+/*
+ * Call this with your hw_pci struct to initialise the PCI system.
+ */
+void pci_common_init(struct hw_pci *);
+
+/*
+ * PCI controllers
+ */
+extern int iop3xx_pci_setup(int nr, struct pci_sys_data *);
+extern struct pci_bus *iop3xx_pci_scan_bus(int nr, struct pci_sys_data *);
+extern void iop3xx_pci_preinit(void);
+
+extern int dc21285_setup(int nr, struct pci_sys_data *);
+extern struct pci_bus *dc21285_scan_bus(int nr, struct pci_sys_data *);
+extern void dc21285_preinit(void);
+extern void dc21285_postinit(void);
+
+extern int via82c505_setup(int nr, struct pci_sys_data *);
+extern struct pci_bus *via82c505_scan_bus(int nr, struct pci_sys_data *);
+extern void via82c505_init(void *sysdata);
+
+extern int pci_v3_setup(int nr, struct pci_sys_data *);
+extern struct pci_bus *pci_v3_scan_bus(int nr, struct pci_sys_data *);
+extern void pci_v3_preinit(void);
+extern void pci_v3_postinit(void);
Index: build_tree/linux/include/asm/mach/serial_at91.h
diff -u /dev/null build_tree/linux/include/asm/mach/serial_at91.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/serial_at91.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,33 @@
+/*
+ *  linux/include/asm-arm/mach/serial_at91.h
+ *
+ *  Based on serial_sa1100.h  by Nicolas Pitre
+ *
+ *  Copyright (C) 2002 ATMEL Rousset
+ *
+ *  Low level machine dependent UART functions.
+ */
+
+struct uart_port;
+
+/*
+ * This is a temporary structure for registering these
+ * functions; it is intended to be discarded after boot.
+ */
+struct atmel_port_fns {
+	void	(*set_mctrl)(struct uart_port *, u_int);
+	u_int	(*get_mctrl)(struct uart_port *);
+	void	(*enable_ms)(struct uart_port *);
+	void	(*pm)(struct uart_port *, u_int, u_int);
+	int	(*set_wake)(struct uart_port *, u_int);
+	int	(*open)(struct uart_port *);
+	void	(*close)(struct uart_port *);
+};
+
+#if defined(CONFIG_SERIAL_ATMEL)
+void atmel_register_uart_fns(struct atmel_port_fns *fns);
+#else
+#define atmel_register_uart_fns(fns) do { } while (0)
+#endif
+
+
Index: build_tree/linux/include/asm/mach/serial_sa1100.h
diff -u /dev/null build_tree/linux/include/asm/mach/serial_sa1100.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/serial_sa1100.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,31 @@
+/*
+ *  linux/include/asm-arm/mach/serial_sa1100.h
+ *
+ *  Author: Nicolas Pitre
+ *
+ * Moved to include/asm-arm/mach and changed lots, Russell King
+ *
+ * Low level machine dependent UART functions.
+ */
+
+struct uart_port;
+struct uart_info;
+
+/*
+ * This is a temporary structure for registering these
+ * functions; it is intended to be discarded after boot.
+ */
+struct sa1100_port_fns {
+	void	(*set_mctrl)(struct uart_port *, u_int);
+	u_int	(*get_mctrl)(struct uart_port *);
+	void	(*pm)(struct uart_port *, u_int, u_int);
+	int	(*set_wake)(struct uart_port *, u_int);
+};
+
+#ifdef CONFIG_SERIAL_SA1100
+void sa1100_register_uart_fns(struct sa1100_port_fns *fns);
+void sa1100_register_uart(int idx, int port);
+#else
+#define sa1100_register_uart_fns(fns) do { } while (0)
+#define sa1100_register_uart(idx,port) do { } while (0)
+#endif
Index: build_tree/linux/include/asm/mach/sharpsl_param.h
diff -u /dev/null build_tree/linux/include/asm/mach/sharpsl_param.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/sharpsl_param.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,37 @@
+/*
+ * Hardware parameter area specific to Sharp SL series devices
+ *
+ * Copyright (c) 2005 Richard Purdie
+ *
+ * Based on Sharp's 2.4 kernel patches
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+struct sharpsl_param_info {
+  unsigned int comadj_keyword;
+  unsigned int comadj;
+
+  unsigned int uuid_keyword;
+  unsigned char uuid[16];
+
+  unsigned int touch_keyword;
+  unsigned int touch_xp;
+  unsigned int touch_yp;
+  unsigned int touch_xd;
+  unsigned int touch_yd;
+
+  unsigned int adadj_keyword;
+  unsigned int adadj;
+
+  unsigned int phad_keyword;
+  unsigned int phadadj;
+} __attribute__((packed));
+
+
+extern struct sharpsl_param_info sharpsl_param;
+extern void sharpsl_save_param(void);
+
Index: build_tree/linux/include/asm/mach/time.h
diff -u /dev/null build_tree/linux/include/asm/mach/time.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/time.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,79 @@
+/*
+ * linux/include/asm-arm/mach/time.h
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_ARM_MACH_TIME_H
+#define __ASM_ARM_MACH_TIME_H
+
+#include <linux/sysdev.h>
+
+/*
+ * This is our kernel timer structure.
+ *
+ * - init
+ *   Initialise the kernels jiffy timer source, claim interrupt
+ *   using setup_irq.  This is called early on during initialisation
+ *   while interrupts are still disabled on the local CPU.
+ * - suspend
+ *   Suspend the kernel jiffy timer source, if necessary.  This
+ *   is called with interrupts disabled, after all normal devices
+ *   have been suspended.  If no action is required, set this to
+ *   NULL.
+ * - resume
+ *   Resume the kernel jiffy timer source, if necessary.  This
+ *   is called with interrupts disabled before any normal devices
+ *   are resumed.  If no action is required, set this to NULL.
+ * - offset
+ *   Return the timer offset in microseconds since the last timer
+ *   interrupt.  Note: this must take account of any unprocessed
+ *   timer interrupt which may be pending.
+ */
+struct sys_timer {
+	struct sys_device	dev;
+	void			(*init)(void);
+	void			(*suspend)(void);
+	void			(*resume)(void);
+#ifndef CONFIG_GENERIC_TIME
+	unsigned long		(*offset)(void);
+#endif
+
+#ifdef CONFIG_NO_IDLE_HZ
+	struct dyn_tick_timer	*dyn_tick;
+#endif
+};
+
+#ifdef CONFIG_NO_IDLE_HZ
+
+#define DYN_TICK_ENABLED	(1 << 1)
+
+struct dyn_tick_timer {
+	spinlock_t	lock;
+	unsigned int	state;			/* Current state */
+	int		(*enable)(void);	/* Enables dynamic tick */
+	int		(*disable)(void);	/* Disables dynamic tick */
+	void		(*reprogram)(unsigned long); /* Reprograms the timer */
+	int		(*handler)(int, void *);
+};
+
+void timer_dyn_reprogram(void);
+#else
+#define timer_dyn_reprogram()	do { } while (0)
+#endif
+
+extern struct sys_timer *system_timer;
+extern void timer_tick(void);
+
+/*
+ * Kernel time keeping support.
+ */
+struct timespec;
+extern int (*set_rtc)(void);
+extern void save_time_delta(struct timespec *delta, struct timespec *rtc);
+extern void restore_time_delta(struct timespec *delta, struct timespec *rtc);
+
+#endif
Index: build_tree/linux/include/asm/mach/udc_pxa2xx.h
diff -u /dev/null build_tree/linux/include/asm/mach/udc_pxa2xx.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/mach/udc_pxa2xx.h	Fri Nov  9 13:48:56 2007
@@ -0,0 +1,26 @@
+/*
+ * linux/include/asm-arm/mach/udc_pxa2xx.h
+ *
+ * This supports machine-specific differences in how the PXA2xx
+ * USB Device Controller (UDC) is wired.
+ *
+ * It is set in linux/arch/arm/mach-pxa/<machine>.c or in
+ * linux/arch/mach-ixp4xx/<machine>.c and used in
+ * the probe routine of linux/drivers/usb/gadget/pxa2xx_udc.c
+ */
+
+struct pxa2xx_udc_mach_info {
+        int  (*udc_is_connected)(void);		/* do we see host? */
+        void (*udc_command)(int cmd);
+#define	PXA2XX_UDC_CMD_CONNECT		0	/* let host see us */
+#define	PXA2XX_UDC_CMD_DISCONNECT	1	/* so host won't see us */
+
+	/* Boards following the design guidelines in the developer's manual,
+	 * with on-chip GPIOs not Lubbock's wierd hardware, can have a sane
+	 * VBUS IRQ and omit the methods above.  Store the GPIO number
+	 * here; for GPIO 0, also mask in one of the pxa_gpio_mode() bits.
+	 */
+	u16	gpio_vbus;			/* high == vbus present */
+	u16	gpio_pullup;			/* high == pullup activated */
+};
+
Index: build_tree/linux/include/asm/plat-s3c24xx/clock.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/clock.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/clock.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,63 @@
+/* linux/include/asm-arm/plat-s3c24xx/clock.h
+ * linux/arch/arm/mach-s3c2410/clock.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *	Written by Ben Dooks, <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+struct clk {
+	struct list_head      list;
+	struct module        *owner;
+	struct clk           *parent;
+	const char           *name;
+	int		      id;
+	int		      usage;
+	unsigned long         rate;
+	unsigned long         ctrlbit;
+
+	int		    (*enable)(struct clk *, int enable);
+	int		    (*set_rate)(struct clk *c, unsigned long rate);
+	unsigned long	    (*get_rate)(struct clk *c);
+	unsigned long	    (*round_rate)(struct clk *c, unsigned long rate);
+	int		    (*set_parent)(struct clk *c, struct clk *parent);
+};
+
+/* other clocks which may be registered by board support */
+
+extern struct clk s3c24xx_dclk0;
+extern struct clk s3c24xx_dclk1;
+extern struct clk s3c24xx_clkout0;
+extern struct clk s3c24xx_clkout1;
+extern struct clk s3c24xx_uclk;
+
+extern struct clk clk_usb_bus;
+
+/* core clock support */
+
+extern struct clk clk_f;
+extern struct clk clk_h;
+extern struct clk clk_p;
+extern struct clk clk_mpll;
+extern struct clk clk_upll;
+extern struct clk clk_xtal;
+
+/* exports for arch/arm/mach-s3c2410
+ *
+ * Please DO NOT use these outside of arch/arm/mach-s3c2410
+*/
+
+extern struct mutex clocks_mutex;
+
+extern int s3c2410_clkcon_enable(struct clk *clk, int enable);
+
+extern int s3c24xx_register_clock(struct clk *clk);
+
+extern int s3c24xx_setup_clocks(unsigned long xtal,
+				unsigned long fclk,
+				unsigned long hclk,
+				unsigned long pclk);
Index: build_tree/linux/include/asm/plat-s3c24xx/common-smdk.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/common-smdk.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/common-smdk.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,15 @@
+/* linux/include/asm-arm/plat-s3c24xx/common-smdk.h
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Common code for SMDK2410 and SMDK2440 boards
+ *
+ * http://www.fluff.org/ben/smdk2440/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+extern void smdk_machine_init(void);
Index: build_tree/linux/include/asm/plat-s3c24xx/cpu.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/cpu.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/cpu.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,70 @@
+/* linux/include/asm-arm/plat-s3c24xx/cpu.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for S3C24XX CPU support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* todo - fix when rmk changes iodescs to use `void __iomem *` */
+
+#define IODESC_ENT(x) { (unsigned long)S3C24XX_VA_##x, __phys_to_pfn(S3C24XX_PA_##x), S3C24XX_SZ_##x, MT_DEVICE }
+
+#ifndef MHZ
+#define MHZ (1000*1000)
+#endif
+
+#define print_mhz(m) ((m) / MHZ), ((m / 1000) % 1000)
+
+/* forward declaration */
+struct s3c24xx_uart_resources;
+struct platform_device;
+struct s3c2410_uartcfg;
+struct map_desc;
+
+/* core initialisation functions */
+
+extern void s3c24xx_init_irq(void);
+
+extern void s3c24xx_init_io(struct map_desc *mach_desc, int size);
+
+extern void s3c24xx_init_uarts(struct s3c2410_uartcfg *cfg, int no);
+
+extern void s3c24xx_init_clocks(int xtal);
+
+extern void s3c24xx_init_uartdevs(char *name,
+				  struct s3c24xx_uart_resources *res,
+				  struct s3c2410_uartcfg *cfg, int no);
+
+/* the board structure is used at first initialsation time
+ * to get info such as the devices to register for this
+ * board. This is done because platfrom_add_devices() cannot
+ * be called from the map_io entry.
+*/
+
+struct s3c24xx_board {
+	struct platform_device  **devices;
+	unsigned int              devices_count;
+
+	struct clk		**clocks;
+	unsigned int		  clocks_count;
+};
+
+extern void s3c24xx_set_board(struct s3c24xx_board *board);
+
+/* timer for 2410/2440 */
+
+struct sys_timer;
+extern struct sys_timer s3c24xx_timer;
+
+/* system device classes */
+
+extern struct sysdev_class s3c2410_sysclass;
+extern struct sysdev_class s3c2412_sysclass;
+extern struct sysdev_class s3c2440_sysclass;
+extern struct sysdev_class s3c2442_sysclass;
+extern struct sysdev_class s3c2443_sysclass;
Index: build_tree/linux/include/asm/plat-s3c24xx/devs.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/devs.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/devs.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,51 @@
+/* linux/include/asm-arm/plat-s3c24xx/devs.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ * Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for s3c2410 standard platform devices
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+#include <linux/platform_device.h>
+
+struct s3c24xx_uart_resources {
+	struct resource		*resources;
+	unsigned long		 nr_resources;
+};
+
+extern struct s3c24xx_uart_resources s3c2410_uart_resources[];
+
+extern struct platform_device *s3c24xx_uart_devs[];
+extern struct platform_device *s3c24xx_uart_src[];
+
+extern struct platform_device s3c_device_usb;
+extern struct platform_device s3c_device_lcd;
+extern struct platform_device s3c_device_wdt;
+extern struct platform_device s3c_device_i2c;
+extern struct platform_device s3c_device_iis;
+extern struct platform_device s3c_device_rtc;
+extern struct platform_device s3c_device_adc;
+extern struct platform_device s3c_device_sdi;
+
+extern struct platform_device s3c_device_spi0;
+extern struct platform_device s3c_device_spi1;
+
+extern struct platform_device s3c_device_nand;
+
+extern struct platform_device s3c_device_timer0;
+extern struct platform_device s3c_device_timer1;
+extern struct platform_device s3c_device_timer2;
+extern struct platform_device s3c_device_timer3;
+
+extern struct platform_device s3c_device_usbgadget;
+
+/* s3c2440 specific devices */
+
+#ifdef CONFIG_CPU_S3C2440
+
+extern struct platform_device s3c_device_camif;
+
+#endif
Index: build_tree/linux/include/asm/plat-s3c24xx/dma.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/dma.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/dma.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,77 @@
+/* linux/include/asm-arm/plat-s3c24xx/dma.h
+ *
+ * Copyright (C) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C24XX DMA support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+extern struct sysdev_class dma_sysclass;
+extern struct s3c2410_dma_chan s3c2410_chans[S3C2410_DMA_CHANNELS];
+
+#define DMA_CH_VALID		(1<<31)
+#define DMA_CH_NEVER		(1<<30)
+
+struct s3c24xx_dma_addr {
+	unsigned long		from;
+	unsigned long		to;
+};
+
+/* struct s3c24xx_dma_map
+ *
+ * this holds the mapping information for the channel selected
+ * to be connected to the specified device
+*/
+
+struct s3c24xx_dma_map {
+	const char		*name;
+	struct s3c24xx_dma_addr  hw_addr;
+
+	unsigned long		 channels[S3C2410_DMA_CHANNELS];
+};
+
+struct s3c24xx_dma_selection {
+	struct s3c24xx_dma_map	*map;
+	unsigned long		 map_size;
+	unsigned long		 dcon_mask;
+
+	void	(*select)(struct s3c2410_dma_chan *chan,
+			  struct s3c24xx_dma_map *map);
+};
+
+extern int s3c24xx_dma_init_map(struct s3c24xx_dma_selection *sel);
+
+/* struct s3c24xx_dma_order_ch
+ *
+ * channel map for one of the `enum dma_ch` dma channels. the list
+ * entry contains a set of low-level channel numbers, orred with
+ * DMA_CH_VALID, which are checked in the order in the array.
+*/
+
+struct s3c24xx_dma_order_ch {
+	unsigned int	list[S3C2410_DMA_CHANNELS];	/* list of channels */
+	unsigned int	flags;				/* flags */
+};
+
+/* struct s3c24xx_dma_order
+ *
+ * information provided by either the core or the board to give the
+ * dma system a hint on how to allocate channels
+*/
+
+struct s3c24xx_dma_order {
+	struct s3c24xx_dma_order_ch	channels[DMACH_MAX];
+};
+
+extern int s3c24xx_dma_order_set(struct s3c24xx_dma_order *map);
+
+/* DMA init code, called from the cpu support code */
+
+extern int s3c2410_dma_init(void);
+
+extern int s3c24xx_dma_init(unsigned int channels, unsigned int irq,
+			    unsigned int stride);
Index: build_tree/linux/include/asm/plat-s3c24xx/irq.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/irq.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/irq.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,107 @@
+/* linux/include/asm-arm/plat-s3c24xx/irq.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for S3C24XX CPU IRQ support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#define irqdbf(x...)
+#define irqdbf2(x...)
+
+#define EXTINT_OFF (IRQ_EINT4 - 4)
+
+extern struct irq_chip s3c_irq_level_chip;
+
+static inline void
+s3c_irqsub_mask(unsigned int irqno, unsigned int parentbit,
+		int subcheck)
+{
+	unsigned long mask;
+	unsigned long submask;
+
+	submask = __raw_readl(S3C2410_INTSUBMSK);
+	mask = __raw_readl(S3C2410_INTMSK);
+
+	submask |= (1UL << (irqno - IRQ_S3CUART_RX0));
+
+	/* check to see if we need to mask the parent IRQ */
+
+	if ((submask  & subcheck) == subcheck) {
+		__raw_writel(mask | parentbit, S3C2410_INTMSK);
+	}
+
+	/* write back masks */
+	__raw_writel(submask, S3C2410_INTSUBMSK);
+
+}
+
+static inline void
+s3c_irqsub_unmask(unsigned int irqno, unsigned int parentbit)
+{
+	unsigned long mask;
+	unsigned long submask;
+
+	submask = __raw_readl(S3C2410_INTSUBMSK);
+	mask = __raw_readl(S3C2410_INTMSK);
+
+	submask &= ~(1UL << (irqno - IRQ_S3CUART_RX0));
+	mask &= ~parentbit;
+
+	/* write back masks */
+	__raw_writel(submask, S3C2410_INTSUBMSK);
+	__raw_writel(mask, S3C2410_INTMSK);
+}
+
+
+static inline void
+s3c_irqsub_maskack(unsigned int irqno, unsigned int parentmask, unsigned int group)
+{
+	unsigned int bit = 1UL << (irqno - IRQ_S3CUART_RX0);
+
+	s3c_irqsub_mask(irqno, parentmask, group);
+
+	__raw_writel(bit, S3C2410_SUBSRCPND);
+
+	/* only ack parent if we've got all the irqs (seems we must
+	 * ack, all and hope that the irq system retriggers ok when
+	 * the interrupt goes off again)
+	 */
+
+	if (1) {
+		__raw_writel(parentmask, S3C2410_SRCPND);
+		__raw_writel(parentmask, S3C2410_INTPND);
+	}
+}
+
+static inline void
+s3c_irqsub_ack(unsigned int irqno, unsigned int parentmask, unsigned int group)
+{
+	unsigned int bit = 1UL << (irqno - IRQ_S3CUART_RX0);
+
+	__raw_writel(bit, S3C2410_SUBSRCPND);
+
+	/* only ack parent if we've got all the irqs (seems we must
+	 * ack, all and hope that the irq system retriggers ok when
+	 * the interrupt goes off again)
+	 */
+
+	if (1) {
+		__raw_writel(parentmask, S3C2410_SRCPND);
+		__raw_writel(parentmask, S3C2410_INTPND);
+	}
+}
+
+/* exported for use in arch/arm/mach-s3c2410 */
+
+#ifdef CONFIG_PM
+extern int s3c_irq_wake(unsigned int irqno, unsigned int state);
+#else
+#define s3c_irq_wake NULL
+#endif
+
+extern int s3c_irqext_type(unsigned int irq, unsigned int type);
Index: build_tree/linux/include/asm/plat-s3c24xx/pm.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/pm.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/pm.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,73 @@
+/* linux/include/asm-arm/plat-s3c24xx/pm.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Written by Ben Dooks, <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* s3c2410_pm_init
+ *
+ * called from board at initialisation time to setup the power
+ * management
+*/
+
+#ifdef CONFIG_PM
+
+extern __init int s3c2410_pm_init(void);
+
+#else
+
+static inline int s3c2410_pm_init(void)
+{
+	return 0;
+}
+#endif
+
+/* configuration for the IRQ mask over sleep */
+extern unsigned long s3c_irqwake_intmask;
+extern unsigned long s3c_irqwake_eintmask;
+
+/* IRQ masks for IRQs allowed to go to sleep (see irq.c) */
+extern unsigned long s3c_irqwake_intallow;
+extern unsigned long s3c_irqwake_eintallow;
+
+/* per-cpu sleep functions */
+
+extern void (*pm_cpu_prep)(void);
+extern void (*pm_cpu_sleep)(void);
+
+/* Flags for PM Control */
+
+extern unsigned long s3c_pm_flags;
+
+/* from sleep.S */
+
+extern int  s3c2410_cpu_save(unsigned long *saveblk);
+extern void s3c2410_cpu_suspend(void);
+extern void s3c2410_cpu_resume(void);
+
+extern unsigned long s3c2410_sleep_save_phys;
+
+/* sleep save info */
+
+struct sleep_save {
+	void __iomem	*reg;
+	unsigned long	val;
+};
+
+#define SAVE_ITEM(x) \
+	{ .reg = (x) }
+
+extern void s3c2410_pm_do_save(struct sleep_save *ptr, int count);
+extern void s3c2410_pm_do_restore(struct sleep_save *ptr, int count);
+
+#ifdef CONFIG_PM
+extern int s3c24xx_irq_suspend(struct sys_device *dev, pm_message_t state);
+extern int s3c24xx_irq_resume(struct sys_device *dev);
+#else
+#define s3c24xx_irq_suspend NULL
+#define s3c24xx_irq_resume  NULL
+#endif
Index: build_tree/linux/include/asm/plat-s3c24xx/s3c2400.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/s3c2400.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/s3c2400.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,31 @@
+/* linux/include/asm-arm/plat-s3c24xx/s3c2400.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for S3C2400 cpu support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Modifications:
+ *     09-Fev-2006 LCVR  First version, based on s3c2410.h
+*/
+
+#ifdef CONFIG_CPU_S3C2400
+
+extern  int s3c2400_init(void);
+
+extern void s3c2400_map_io(struct map_desc *mach_desc, int size);
+
+extern void s3c2400_init_uarts(struct s3c2410_uartcfg *cfg, int no);
+
+extern void s3c2400_init_clocks(int xtal);
+
+#else
+#define s3c2400_init_clocks NULL
+#define s3c2400_init_uarts NULL
+#define s3c2400_map_io NULL
+#define s3c2400_init NULL
+#endif
Index: build_tree/linux/include/asm/plat-s3c24xx/s3c2410.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/s3c2410.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/s3c2410.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,31 @@
+/* linux/include/asm-arm/plat-s3c24xx/s3c2410.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for s3c2410 machine directory
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#ifdef CONFIG_CPU_S3C2410
+
+extern  int s3c2410_init(void);
+
+extern void s3c2410_map_io(struct map_desc *mach_desc, int size);
+
+extern void s3c2410_init_uarts(struct s3c2410_uartcfg *cfg, int no);
+
+extern void s3c2410_init_clocks(int xtal);
+
+extern  int s3c2410_baseclk_add(void);
+
+#else
+#define s3c2410_init_clocks NULL
+#define s3c2410_init_uarts NULL
+#define s3c2410_map_io NULL
+#define s3c2410_init NULL
+#endif
Index: build_tree/linux/include/asm/plat-s3c24xx/s3c2412.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/s3c2412.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/s3c2412.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,29 @@
+/* linux/include/asm-arm/plat-s3c24xx/s3c2412.h
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for s3c2412 cpu support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifdef CONFIG_CPU_S3C2412
+
+extern  int s3c2412_init(void);
+
+extern void s3c2412_map_io(struct map_desc *mach_desc, int size);
+
+extern void s3c2412_init_uarts(struct s3c2410_uartcfg *cfg, int no);
+
+extern void s3c2412_init_clocks(int xtal);
+
+extern  int s3c2412_baseclk_add(void);
+#else
+#define s3c2412_init_clocks NULL
+#define s3c2412_init_uarts NULL
+#define s3c2412_map_io NULL
+#define s3c2412_init NULL
+#endif
Index: build_tree/linux/include/asm/plat-s3c24xx/s3c2440.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/s3c2440.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/s3c2440.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,17 @@
+/* linux/include/asm-arm/plat-s3c24xx/s3c2440.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for s3c2440 cpu support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifdef CONFIG_CPU_S3C2440
+extern  int s3c2440_init(void);
+#else
+#define s3c2440_init NULL
+#endif
Index: build_tree/linux/include/asm/plat-s3c24xx/s3c2442.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/s3c2442.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/s3c2442.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,17 @@
+/* linux/include/asm-arm/plat-s3c24xx/s3c2442.h
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for s3c2442 cpu support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifdef CONFIG_CPU_S3C2442
+extern  int s3c2442_init(void);
+#else
+#define s3c2442_init NULL
+#endif
Index: build_tree/linux/include/asm/plat-s3c24xx/s3c2443.h
diff -u /dev/null build_tree/linux/include/asm/plat-s3c24xx/s3c2443.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm/plat-s3c24xx/s3c2443.h	Fri Nov  9 13:48:55 2007
@@ -0,0 +1,32 @@
+/* linux/include/asm-arm/plat-s3c24xx/s3c2443.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Header file for s3c2443 cpu support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifdef CONFIG_CPU_S3C2443
+
+struct s3c2410_uartcfg;
+
+extern  int s3c2443_init(void);
+
+extern void s3c2443_map_io(struct map_desc *mach_desc, int size);
+
+extern void s3c2443_init_uarts(struct s3c2410_uartcfg *cfg, int no);
+
+extern void s3c2443_init_clocks(int xtal);
+
+extern  int s3c2443_baseclk_add(void);
+
+#else
+#define s3c2443_init_clocks NULL
+#define s3c2443_init_uarts NULL
+#define s3c2443_map_io NULL
+#define s3c2443_init NULL
+#endif
Index: build_tree/linux/include/asm-arm/asm-offsets.h
diff -u /dev/null build_tree/linux/include/asm-arm/asm-offsets.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm-arm/asm-offsets.h	Fri Nov  9 13:49:00 2007
@@ -0,0 +1,66 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define TSK_ACTIVE_MM 132 /* offsetof(struct task_struct, active_mm)	@ */
+
+#define TI_FLAGS 0 /* offsetof(struct thread_info, flags)	@ */
+#define TI_PREEMPT 4 /* offsetof(struct thread_info, preempt_count)	@ */
+#define TI_ADDR_LIMIT 8 /* offsetof(struct thread_info, addr_limit)	@ */
+#define TI_TASK 12 /* offsetof(struct thread_info, task)	@ */
+#define TI_EXEC_DOMAIN 16 /* offsetof(struct thread_info, exec_domain)	@ */
+#define TI_CPU 20 /* offsetof(struct thread_info, cpu)	@ */
+#define TI_CPU_DOMAIN 24 /* offsetof(struct thread_info, cpu_domain)	@ */
+#define TI_CPU_SAVE 28 /* offsetof(struct thread_info, cpu_context)	@ */
+#define TI_USED_CP 76 /* offsetof(struct thread_info, used_cp)	@ */
+#define TI_TP_VALUE 92 /* offsetof(struct thread_info, tp_value)	@ */
+#define TI_FPSTATE 280 /* offsetof(struct thread_info, fpstate)	@ */
+#define TI_VFPSTATE 432 /* offsetof(struct thread_info, vfpstate)	@ */
+#define TI_IWMMXT_STATE 280 /* offsetof(struct thread_info, fpstate.iwmmxt)	@ */
+
+#define S_R0 0 /* offsetof(struct pt_regs, ARM_r0)	@ */
+#define S_R1 4 /* offsetof(struct pt_regs, ARM_r1)	@ */
+#define S_R2 8 /* offsetof(struct pt_regs, ARM_r2)	@ */
+#define S_R3 12 /* offsetof(struct pt_regs, ARM_r3)	@ */
+#define S_R4 16 /* offsetof(struct pt_regs, ARM_r4)	@ */
+#define S_R5 20 /* offsetof(struct pt_regs, ARM_r5)	@ */
+#define S_R6 24 /* offsetof(struct pt_regs, ARM_r6)	@ */
+#define S_R7 28 /* offsetof(struct pt_regs, ARM_r7)	@ */
+#define S_R8 32 /* offsetof(struct pt_regs, ARM_r8)	@ */
+#define S_R9 36 /* offsetof(struct pt_regs, ARM_r9)	@ */
+#define S_R10 40 /* offsetof(struct pt_regs, ARM_r10)	@ */
+#define S_FP 44 /* offsetof(struct pt_regs, ARM_fp)	@ */
+#define S_IP 48 /* offsetof(struct pt_regs, ARM_ip)	@ */
+#define S_SP 52 /* offsetof(struct pt_regs, ARM_sp)	@ */
+#define S_LR 56 /* offsetof(struct pt_regs, ARM_lr)	@ */
+#define S_PC 60 /* offsetof(struct pt_regs, ARM_pc)	@ */
+#define S_PSR 64 /* offsetof(struct pt_regs, ARM_cpsr)	@ */
+#define S_OLD_R0 68 /* offsetof(struct pt_regs, ARM_ORIG_r0)	@ */
+#define S_FRAME_SIZE 72 /* sizeof(struct pt_regs)	@ */
+
+#define VMA_VM_MM 0 /* offsetof(struct vm_area_struct, vm_mm)	@ */
+#define VMA_VM_FLAGS 20 /* offsetof(struct vm_area_struct, vm_flags)	@ */
+
+#define VM_EXEC 4 /* VM_EXEC	@ */
+
+#define PAGE_SZ 4096 /* PAGE_SIZE	@ */
+
+#define SYS_ERROR0 10420224 /* 0x9f0000	@ */
+
+#define SIZEOF_MACHINE_DESC 52 /* sizeof(struct machine_desc)	@ */
+#define MACHINFO_TYPE 0 /* offsetof(struct machine_desc, nr)	@ */
+#define MACHINFO_NAME 12 /* offsetof(struct machine_desc, name)	@ */
+#define MACHINFO_PHYSIO 4 /* offsetof(struct machine_desc, phys_io)	@ */
+#define MACHINFO_PGOFFIO 8 /* offsetof(struct machine_desc, io_pg_offst)	@ */
+
+#define PROC_INFO_SZ 52 /* sizeof(struct proc_info_list)	@ */
+#define PROCINFO_INITFUNC 16 /* offsetof(struct proc_info_list, __cpu_flush)	@ */
+#define PROCINFO_MM_MMUFLAGS 8 /* offsetof(struct proc_info_list, __cpu_mm_mmu_flags)	@ */
+#define PROCINFO_IO_MMUFLAGS 12 /* offsetof(struct proc_info_list, __cpu_io_mmu_flags)	@ */
+
+#endif
Index: build_tree/linux/include/asm-arm/mach-types.h
diff -u /dev/null build_tree/linux/include/asm-arm/mach-types.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:43 2008
+++ build_tree/linux/include/asm-arm/mach-types.h	Fri Nov  9 13:49:00 2007
@@ -0,0 +1,17160 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_NEXUSPCI             3
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_TBOX                 7
+#define MACH_TYPE_CO285                8
+#define MACH_TYPE_CLPS7110             9
+#define MACH_TYPE_ARCHIMEDES           10
+#define MACH_TYPE_A5K                  11
+#define MACH_TYPE_ETOILE               12
+#define MACH_TYPE_LACIE_NAS            13
+#define MACH_TYPE_CLPS7500             14
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_ITSY                 18
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_IXP1200              23
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_VICTOR               26
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_RANGER               28
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_FPIC                 33
+#define MACH_TYPE_EXTENEX1             34
+#define MACH_TYPE_SHERMAN              35
+#define MACH_TYPE_ACCELENT_SA          36
+#define MACH_TYPE_ACCELENT_L7200       37
+#define MACH_TYPE_NETPORT              38
+#define MACH_TYPE_PANGOLIN             39
+#define MACH_TYPE_YOPY                 40
+#define MACH_TYPE_COOLIDGE             41
+#define MACH_TYPE_HUW_WEBPANEL         42
+#define MACH_TYPE_SPOTME               43
+#define MACH_TYPE_FREEBIRD             44
+#define MACH_TYPE_TI925                45
+#define MACH_TYPE_RISCSTATION          46
+#define MACH_TYPE_CAVY                 47
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_OMNIMETER            49
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_CITYGO               51
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_SPOT                 53
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_WEBPAL               55
+#define MACH_TYPE_LINPDA               56
+#define MACH_TYPE_ANAKIN               57
+#define MACH_TYPE_MVI                  58
+#define MACH_TYPE_JUPITER              59
+#define MACH_TYPE_PSIONW               60
+#define MACH_TYPE_ALN                  61
+#define MACH_TYPE_CAMELOT              62
+#define MACH_TYPE_GDS2200              63
+#define MACH_TYPE_PSION_SERIES7        64
+#define MACH_TYPE_XFILE                65
+#define MACH_TYPE_ACCELENT_EP9312      66
+#define MACH_TYPE_IC200                67
+#define MACH_TYPE_CREDITLART           68
+#define MACH_TYPE_HTM                  69
+#define MACH_TYPE_IQ80310              70
+#define MACH_TYPE_FREEBOT              71
+#define MACH_TYPE_ENTEL                72
+#define MACH_TYPE_ENP3510              73
+#define MACH_TYPE_TRIZEPS              74
+#define MACH_TYPE_NESA                 75
+#define MACH_TYPE_VENUS                76
+#define MACH_TYPE_TARDIS               77
+#define MACH_TYPE_MERCURY              78
+#define MACH_TYPE_EMPEG                79
+#define MACH_TYPE_I80200FCC            80
+#define MACH_TYPE_ITT_CPB              81
+#define MACH_TYPE_SVC                  82
+#define MACH_TYPE_ALPHA2               84
+#define MACH_TYPE_ALPHA1               85
+#define MACH_TYPE_NETARM               86
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_PDA1                 88
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_ANIKO                90
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_CS89712              92
+#define MACH_TYPE_WEARARM              93
+#define MACH_TYPE_POSSIO_PX            94
+#define MACH_TYPE_SIDEARM              95
+#define MACH_TYPE_STORK                96
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_ACE                  98
+#define MACH_TYPE_BALLYARM             99
+#define MACH_TYPE_SIMPUTER             100
+#define MACH_TYPE_NEXTERM              101
+#define MACH_TYPE_SA1100_ELF           102
+#define MACH_TYPE_GATOR                103
+#define MACH_TYPE_GRANITE              104
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PLCE                 111
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_MEDALB               113
+#define MACH_TYPE_EAGLE                114
+#define MACH_TYPE_DSC21                115
+#define MACH_TYPE_DSC24                116
+#define MACH_TYPE_TI5472               117
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_UENGINE              119
+#define MACH_TYPE_BLUESTEM             120
+#define MACH_TYPE_XINGU8               121
+#define MACH_TYPE_BUSHSTB              122
+#define MACH_TYPE_EPSILON1             123
+#define MACH_TYPE_BALLOON              124
+#define MACH_TYPE_PUPPY                125
+#define MACH_TYPE_ELROY                126
+#define MACH_TYPE_GMS720               127
+#define MACH_TYPE_S24X                 128
+#define MACH_TYPE_JTEL_CLEP7312        129
+#define MACH_TYPE_CX821XX              130
+#define MACH_TYPE_EDB7312              131
+#define MACH_TYPE_BSA1110              132
+#define MACH_TYPE_POWERPIN             133
+#define MACH_TYPE_OPENARM              134
+#define MACH_TYPE_WHITECHAPEL          135
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_H3800                137
+#define MACH_TYPE_BLUE_V1              138
+#define MACH_TYPE_PXA_CERF             139
+#define MACH_TYPE_ARM7TEVB             140
+#define MACH_TYPE_D7400                141
+#define MACH_TYPE_PIRANHA              142
+#define MACH_TYPE_SBCAMELOT            143
+#define MACH_TYPE_KINGS                144
+#define MACH_TYPE_SMDK2400             145
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_IDR                  147
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_WEBNET               149
+#define MACH_TYPE_D7300                150
+#define MACH_TYPE_CEP                  151
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_VC547X               153
+#define MACH_TYPE_FILEWALKER           154
+#define MACH_TYPE_NETGATEWAY           155
+#define MACH_TYPE_SYMBOL2800           156
+#define MACH_TYPE_SUNS                 157
+#define MACH_TYPE_FRODO                158
+#define MACH_TYPE_MACH_TYTE_MS301      159
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_AMICO                163
+#define MACH_TYPE_IAM                  164
+#define MACH_TYPE_TT530                165
+#define MACH_TYPE_SAM2400              166
+#define MACH_TYPE_JORNADA56X           167
+#define MACH_TYPE_ACTIVE               168
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_WID                  170
+#define MACH_TYPE_SABINAL              171
+#define MACH_TYPE_IXP425_MATACUMBE     172
+#define MACH_TYPE_MINIPRINT            173
+#define MACH_TYPE_ADM510X              174
+#define MACH_TYPE_SVS200               175
+#define MACH_TYPE_ATG_TCU              176
+#define MACH_TYPE_JORNADA820           177
+#define MACH_TYPE_S3C44B0              178
+#define MACH_TYPE_MARGIS2              179
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_BRH                  181
+#define MACH_TYPE_S3C2410              182
+#define MACH_TYPE_POSSIO_PX30          183
+#define MACH_TYPE_S3C2800              184
+#define MACH_TYPE_FLEETWOOD            185
+#define MACH_TYPE_OMAHA                186
+#define MACH_TYPE_TA7                  187
+#define MACH_TYPE_NOVA                 188
+#define MACH_TYPE_HMK                  189
+#define MACH_TYPE_KARO                 190
+#define MACH_TYPE_FESTER               191
+#define MACH_TYPE_GPI                  192
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_I519                 194
+#define MACH_TYPE_NEXIO                195
+#define MACH_TYPE_BITBOX               196
+#define MACH_TYPE_G200                 197
+#define MACH_TYPE_GILL                 198
+#define MACH_TYPE_PXA_MERCURY          199
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_FRET                 201
+#define MACH_TYPE_EMAILPHONE           202
+#define MACH_TYPE_H3900                203
+#define MACH_TYPE_PXA1                 204
+#define MACH_TYPE_KOAN369              205
+#define MACH_TYPE_COGENT               206
+#define MACH_TYPE_ESL_SIMPUTER         207
+#define MACH_TYPE_ESL_SIMPUTER_CLR     208
+#define MACH_TYPE_ESL_SIMPUTER_BW      209
+#define MACH_TYPE_HHP_CRADLE           210
+#define MACH_TYPE_HE500                211
+#define MACH_TYPE_INHANDELF2           212
+#define MACH_TYPE_INHANDFTIP           213
+#define MACH_TYPE_DNP1110              214
+#define MACH_TYPE_PNP1110              215
+#define MACH_TYPE_CSB226               216
+#define MACH_TYPE_ARNOLD               217
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_JZ8028               219
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_FORTE                221
+#define MACH_TYPE_ACAM                 222
+#define MACH_TYPE_ABOX                 223
+#define MACH_TYPE_ATMEL                224
+#define MACH_TYPE_SITSANG              225
+#define MACH_TYPE_CPU1110LCDNET        226
+#define MACH_TYPE_MPL_VCMA9            227
+#define MACH_TYPE_OPUS_A1              228
+#define MACH_TYPE_DAYTONA              229
+#define MACH_TYPE_KILLBEAR             230
+#define MACH_TYPE_YOHO                 231
+#define MACH_TYPE_JASPER               232
+#define MACH_TYPE_DSC25                233
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_RAMSES               235
+#define MACH_TYPE_S28X                 236
+#define MACH_TYPE_MPORT3               237
+#define MACH_TYPE_PXA_EAGLE250         238
+#define MACH_TYPE_PDB                  239
+#define MACH_TYPE_BLUE_2G              240
+#define MACH_TYPE_BLUEARCH             241
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_EXPLORER             244
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_CHIMP                246
+#define MACH_TYPE_STORK_NEST           247
+#define MACH_TYPE_STORK_EGG            248
+#define MACH_TYPE_WISMO                249
+#define MACH_TYPE_EZLINX               250
+#define MACH_TYPE_AT91RM9200           251
+#define MACH_TYPE_ORION                252
+#define MACH_TYPE_NEPTUNE              253
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_PXA_WINS30           255
+#define MACH_TYPE_LAVINNA              256
+#define MACH_TYPE_PXA_UENGINE          257
+#define MACH_TYPE_INNOKOM              258
+#define MACH_TYPE_BMS                  259
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_PRPMC1100            261
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_ARMSTICK             263
+#define MACH_TYPE_ARMONIE              264
+#define MACH_TYPE_MPORT1               265
+#define MACH_TYPE_S3C5410              266
+#define MACH_TYPE_ZCP320A              267
+#define MACH_TYPE_I_BOX                268
+#define MACH_TYPE_STLC1502             269
+#define MACH_TYPE_SIREN                270
+#define MACH_TYPE_GREENLAKE            271
+#define MACH_TYPE_ARGUS                272
+#define MACH_TYPE_COMBADGE             273
+#define MACH_TYPE_ROKEPXA              274
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_GUIDEA07             276
+#define MACH_TYPE_TAT257               277
+#define MACH_TYPE_IGP2425              278
+#define MACH_TYPE_BLUEGRAMMA           279
+#define MACH_TYPE_IPOD                 280
+#define MACH_TYPE_ADSBITSYX            281
+#define MACH_TYPE_TRIZEPS2             282
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADSBITSYPLUS         284
+#define MACH_TYPE_ADSAGC               285
+#define MACH_TYPE_STP7312              286
+#define MACH_TYPE_NX_PHNX              287
+#define MACH_TYPE_WEP_EP250            288
+#define MACH_TYPE_INHANDELF3           289
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IYONIX               291
+#define MACH_TYPE_DAMICAM_SA1110       292
+#define MACH_TYPE_MEG03                293
+#define MACH_TYPE_PXA_WHITECHAPEL      294
+#define MACH_TYPE_NWSC                 295
+#define MACH_TYPE_NWLARM               296
+#define MACH_TYPE_IXP425_MGUARD        297
+#define MACH_TYPE_PXA_NETDCU4          298
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_ZODIAC               301
+#define MACH_TYPE_ARMMODUL             302
+#define MACH_TYPE_KETOP                303
+#define MACH_TYPE_AV7200               304
+#define MACH_TYPE_ARCH_TI925           305
+#define MACH_TYPE_ACQ200               306
+#define MACH_TYPE_PT_DAFIT             307
+#define MACH_TYPE_IHBA                 308
+#define MACH_TYPE_QUINQUE              309
+#define MACH_TYPE_NIMBRAONE            310
+#define MACH_TYPE_NIMBRA29X            311
+#define MACH_TYPE_NIMBRA210            312
+#define MACH_TYPE_HHP_D95XX            313
+#define MACH_TYPE_LABARM               314
+#define MACH_TYPE_M825XX               315
+#define MACH_TYPE_M7100                316
+#define MACH_TYPE_NIPC2                317
+#define MACH_TYPE_FU7202               318
+#define MACH_TYPE_ADSAGX               319
+#define MACH_TYPE_PXA_POOH             320
+#define MACH_TYPE_BANDON               321
+#define MACH_TYPE_PCM7210              322
+#define MACH_TYPE_NMS9200              323
+#define MACH_TYPE_LOGODL               324
+#define MACH_TYPE_M7140                325
+#define MACH_TYPE_KOREBOT              326
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_KOAN393              328
+#define MACH_TYPE_INHANDFTIP3          329
+#define MACH_TYPE_GONZO                330
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_SCANPASS             332
+#define MACH_TYPE_EP7312_POOH          333
+#define MACH_TYPE_TA7S                 334
+#define MACH_TYPE_TA7V                 335
+#define MACH_TYPE_ICARUS               336
+#define MACH_TYPE_H1900                337
+#define MACH_TYPE_GEMINI               338
+#define MACH_TYPE_AXIM                 339
+#define MACH_TYPE_AUDIOTRON            340
+#define MACH_TYPE_H2200                341
+#define MACH_TYPE_LOOX600              342
+#define MACH_TYPE_NIOP                 343
+#define MACH_TYPE_DM310                344
+#define MACH_TYPE_SEEDPXA_C2           345
+#define MACH_TYPE_IXP4XX_MGUARD_PCI    346
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_SCORPIO              348
+#define MACH_TYPE_VIVA                 349
+#define MACH_TYPE_PXA_XCARD            350
+#define MACH_TYPE_CSB335               351
+#define MACH_TYPE_IXRD425              352
+#define MACH_TYPE_IQ80315              353
+#define MACH_TYPE_NMP7312              354
+#define MACH_TYPE_CX861XX              355
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_XDA                  357
+#define MACH_TYPE_CSIR_IMS             358
+#define MACH_TYPE_IXP421_DNAEETH       359
+#define MACH_TYPE_POCKETSERV9200       360
+#define MACH_TYPE_TOTO                 361
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_KS8695P              363
+#define MACH_TYPE_SE4000               364
+#define MACH_TYPE_QUADRICEPS           365
+#define MACH_TYPE_BRONCO               366
+#define MACH_TYPE_ESL_SOFCOMP          368
+#define MACH_TYPE_S5C7375              369
+#define MACH_TYPE_SPEARHEAD            370
+#define MACH_TYPE_PANTERA              371
+#define MACH_TYPE_PRAYOGLITE           372
+#define MACH_TYPE_GUMSTIK              373
+#define MACH_TYPE_RCUBE                374
+#define MACH_TYPE_REA_OLV              375
+#define MACH_TYPE_PXA_IPHONE           376
+#define MACH_TYPE_S3C3410              377
+#define MACH_TYPE_ESPD_4510B           378
+#define MACH_TYPE_MP1X                 379
+#define MACH_TYPE_AT91RM9200TB         380
+#define MACH_TYPE_ADSVGX               381
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_PELEE                383
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_FUJITSU_CAMELOT      391
+#define MACH_TYPE_JANUS2M              392
+#define MACH_TYPE_EMBTF                393
+#define MACH_TYPE_HPM                  394
+#define MACH_TYPE_SMDK2410TK           395
+#define MACH_TYPE_SMDK2410AJ           396
+#define MACH_TYPE_STREETRACER          397
+#define MACH_TYPE_EFRAME               398
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_PXA_LARK             400
+#define MACH_TYPE_PNP2110              401
+#define MACH_TYPE_TCC72X               402
+#define MACH_TYPE_ALTAIR               403
+#define MACH_TYPE_KC3                  404
+#define MACH_TYPE_SINTEFTD             405
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_ADAY4X               407
+#define MACH_TYPE_LITE300              408
+#define MACH_TYPE_S5C7376              409
+#define MACH_TYPE_MT02                 410
+#define MACH_TYPE_MPORT3S              411
+#define MACH_TYPE_RA_ALPHA             412
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_VULCAN         414
+#define MACH_TYPE_STARGATE             415
+#define MACH_TYPE_ARMADILLOJ           416
+#define MACH_TYPE_ELROY_JACK           417
+#define MACH_TYPE_BACKEND              418
+#define MACH_TYPE_S5LINBOX             419
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_IA_CPU_9200          421
+#define MACH_TYPE_AT91_BJA1            422
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_TEN                  425
+#define MACH_TYPE_ROVERP5P             426
+#define MACH_TYPE_SC2700               427
+#define MACH_TYPE_EX_EAGLE             428
+#define MACH_TYPE_NX_PXA12             429
+#define MACH_TYPE_NX_PXA5              430
+#define MACH_TYPE_BLACKBOARD2          431
+#define MACH_TYPE_I819                 432
+#define MACH_TYPE_IXMB995E             433
+#define MACH_TYPE_SKYRIDER             434
+#define MACH_TYPE_SKYHAWK              435
+#define MACH_TYPE_ENTERPRISE           436
+#define MACH_TYPE_DEP2410              437
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_HOBBIT               439
+#define MACH_TYPE_H7210                440
+#define MACH_TYPE_PXA_NETDCU5          441
+#define MACH_TYPE_ACC                  442
+#define MACH_TYPE_ESL_SARVA            443
+#define MACH_TYPE_XM250                444
+#define MACH_TYPE_T6TC1XB              445
+#define MACH_TYPE_ESS710               446
+#define MACH_TYPE_MX31ADS              447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_BOLFENK              449
+#define MACH_TYPE_AT91RM9200KR         450
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_AXIMX3               453
+#define MACH_TYPE_EB67XDIP             454
+#define MACH_TYPE_WEBTXS               455
+#define MACH_TYPE_HAWK                 456
+#define MACH_TYPE_CCAT91SBC001         457
+#define MACH_TYPE_EXPRESSO             458
+#define MACH_TYPE_H4000                459
+#define MACH_TYPE_DINO                 460
+#define MACH_TYPE_ML675K               461
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_RECIVA_TT            464
+#define MACH_TYPE_CSTCB01              465
+#define MACH_TYPE_CSTCB1               466
+#define MACH_TYPE_SHADWELL             467
+#define MACH_TYPE_GOEPEL263            468
+#define MACH_TYPE_ACQ100               469
+#define MACH_TYPE_MX1FS2               470
+#define MACH_TYPE_HIPTOP_G1            471
+#define MACH_TYPE_SPARKY               472
+#define MACH_TYPE_NS9750               473
+#define MACH_TYPE_PHOENIX              474
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_DEISTERPXA           476
+#define MACH_TYPE_BCM1160              477
+#define MACH_TYPE_PCM022               478
+#define MACH_TYPE_ADSGCX               479
+#define MACH_TYPE_DREADNAUGHT          480
+#define MACH_TYPE_DM320                481
+#define MACH_TYPE_MARKOV               482
+#define MACH_TYPE_COS7A400             483
+#define MACH_TYPE_MILANO               484
+#define MACH_TYPE_UE9328               485
+#define MACH_TYPE_UEX255               486
+#define MACH_TYPE_UE2410               487
+#define MACH_TYPE_A620                 488
+#define MACH_TYPE_OCELOT               489
+#define MACH_TYPE_CHEETAH              490
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_ZVUE                 492
+#define MACH_TYPE_ROVERP1              493
+#define MACH_TYPE_ASIDIAL2             494
+#define MACH_TYPE_S3C24A0              495
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_S3C5500              498
+#define MACH_TYPE_SMDK5500             499
+#define MACH_TYPE_SIGNALSYNC           500
+#define MACH_TYPE_NBC                  501
+#define MACH_TYPE_KODIAK               502
+#define MACH_TYPE_NETBOOKPRO           503
+#define MACH_TYPE_HW90200              504
+#define MACH_TYPE_CONDOR               505
+#define MACH_TYPE_CUP                  506
+#define MACH_TYPE_KITE                 507
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_N10                  511
+#define MACH_TYPE_MONTAJADE            512
+#define MACH_TYPE_SG560                513
+#define MACH_TYPE_DP1000               514
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_RG100V3              516
+#define MACH_TYPE_MX2ADS               517
+#define MACH_TYPE_PXA_KILO             518
+#define MACH_TYPE_IXP4XX_EAGLE         519
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_MB2520F              521
+#define MACH_TYPE_EMC1000              522
+#define MACH_TYPE_TIDSC25              523
+#define MACH_TYPE_AKCPMXL              524
+#define MACH_TYPE_AV3XX                525
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_PXA_MPM10            527
+#define MACH_TYPE_PXA_KYANITE          528
+#define MACH_TYPE_SGOLD                529
+#define MACH_TYPE_OSCAR                530
+#define MACH_TYPE_EPXA4USB2            531
+#define MACH_TYPE_XSENGINE             532
+#define MACH_TYPE_IP600                533
+#define MACH_TYPE_MCAN2                534
+#define MACH_TYPE_DDI_BLUERIDGE        535
+#define MACH_TYPE_SKYMINDER            536
+#define MACH_TYPE_LPD79520             537
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HW90340              539
+#define MACH_TYPE_CIP_BOX              540
+#define MACH_TYPE_IVPN                 541
+#define MACH_TYPE_RSOC2                542
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_BOXER                544
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_AML42800AA           546
+#define MACH_TYPE_MACH_TYPE_ML674001   547
+#define MACH_TYPE_LPC2294              548
+#define MACH_TYPE_SWITCHGRASS          549
+#define MACH_TYPE_ENS_CMU              550
+#define MACH_TYPE_MM6_SDB              551
+#define MACH_TYPE_SATURN               552
+#define MACH_TYPE_I30030EVB            553
+#define MACH_TYPE_MXC27530EVB          554
+#define MACH_TYPE_SMDK2800             555
+#define MACH_TYPE_MTWILSON             556
+#define MACH_TYPE_ZITI                 557
+#define MACH_TYPE_GRANDFATHER          558
+#define MACH_TYPE_TENGINE              559
+#define MACH_TYPE_S3C2460              560
+#define MACH_TYPE_PDM                  561
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_H6300                563
+#define MACH_TYPE_RZ1700               564
+#define MACH_TYPE_A716                 565
+#define MACH_TYPE_ESTK2440A            566
+#define MACH_TYPE_ATWIXP425            567
+#define MACH_TYPE_CSB336               568
+#define MACH_TYPE_RIRM2                569
+#define MACH_TYPE_CX23518              570
+#define MACH_TYPE_CX2351X              571
+#define MACH_TYPE_COMPUTIME            572
+#define MACH_TYPE_IZARUS               573
+#define MACH_TYPE_RTS                  574
+#define MACH_TYPE_SE5100               575
+#define MACH_TYPE_S3C2510              576
+#define MACH_TYPE_CSB437TL             577
+#define MACH_TYPE_SLAUSON              578
+#define MACH_TYPE_PEARLRIVER           579
+#define MACH_TYPE_TDC_P210             580
+#define MACH_TYPE_SG580                581
+#define MACH_TYPE_WRSBCARM7            582
+#define MACH_TYPE_IPD                  583
+#define MACH_TYPE_PXA_DNP2110          584
+#define MACH_TYPE_XAENIAX              585
+#define MACH_TYPE_SOMN4250             586
+#define MACH_TYPE_PLEB2                587
+#define MACH_TYPE_CORNWALLIS           588
+#define MACH_TYPE_GURNEY_DRV           589
+#define MACH_TYPE_CHAFFEE              590
+#define MACH_TYPE_RMS101               591
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_SWIFT                593
+#define MACH_TYPE_ROVERP7              594
+#define MACH_TYPE_PR818S               595
+#define MACH_TYPE_TRXPRO               596
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_TRAB                 599
+#define MACH_TYPE_CMC_PU2              600
+#define MACH_TYPE_FULCRUM              601
+#define MACH_TYPE_NETGATE42X           602
+#define MACH_TYPE_STR710               603
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_TOMTOMGO             605
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_SG565                608
+#define MACH_TYPE_LPD79524             609
+#define MACH_TYPE_LPD79525             610
+#define MACH_TYPE_RMS100               611
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_HMS39C7092           614
+#define MACH_TYPE_ARMADILLO            615
+#define MACH_TYPE_IPCU                 616
+#define MACH_TYPE_LOOX720              617
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_ADSVIX               620
+#define MACH_TYPE_DM270                621
+#define MACH_TYPE_SOCLTPLUS            622
+#define MACH_TYPE_ECIA                 623
+#define MACH_TYPE_CM4008               624
+#define MACH_TYPE_P2001                625
+#define MACH_TYPE_TWISTER              626
+#define MACH_TYPE_MUDSHARK             627
+#define MACH_TYPE_HB2                  628
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_SENDT                630
+#define MACH_TYPE_MX2JAZZ              631
+#define MACH_TYPE_MULTIIO              632
+#define MACH_TYPE_HRDISPLAY            633
+#define MACH_TYPE_MXC27530ADS          634
+#define MACH_TYPE_TRIZEPS3             635
+#define MACH_TYPE_ZEFEERDZA            636
+#define MACH_TYPE_ZEFEERDZB            637
+#define MACH_TYPE_ZEFEERDZG            638
+#define MACH_TYPE_ZEFEERDZN            639
+#define MACH_TYPE_ZEFEERDZQ            640
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_ASTRO_JACK           643
+#define MACH_TYPE_TIP03                644
+#define MACH_TYPE_A9200EC              645
+#define MACH_TYPE_PNX0105              646
+#define MACH_TYPE_ADCPOECPU            647
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_ML69Q6203            649
+#define MACH_TYPE_MB9200               650
+#define MACH_TYPE_KULUN                651
+#define MACH_TYPE_SNAPPER              652
+#define MACH_TYPE_OPTIMA               653
+#define MACH_TYPE_DLHSBC               654
+#define MACH_TYPE_X30                  655
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_MANGA_KS8695         657
+#define MACH_TYPE_AJAX                 658
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_VVTK1000             661
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_VVTK3000             663
+#define MACH_TYPE_PIMX1                664
+#define MACH_TYPE_OLLIE                665
+#define MACH_TYPE_SKYMAX               666
+#define MACH_TYPE_JAZZ                 667
+#define MACH_TYPE_TEL_T3               668
+#define MACH_TYPE_AISINO_FCR255        669
+#define MACH_TYPE_BTWEB                670
+#define MACH_TYPE_DBG_LH79520          671
+#define MACH_TYPE_CM41XX               672
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_NGGPXA               674
+#define MACH_TYPE_CSB535               675
+#define MACH_TYPE_CSB536               676
+#define MACH_TYPE_PXA_TRAKPOD          677
+#define MACH_TYPE_PRAXIS               678
+#define MACH_TYPE_LH75411              679
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_LOOX410              682
+#define MACH_TYPE_WESTLAKE             683
+#define MACH_TYPE_NSB                  684
+#define MACH_TYPE_ESL_SARVA_STN        685
+#define MACH_TYPE_ESL_SARVA_TFT        686
+#define MACH_TYPE_ESL_SARVA_IAD        687
+#define MACH_TYPE_ESL_SARVA_ACC        688
+#define MACH_TYPE_TYPHOON              689
+#define MACH_TYPE_CNAV                 690
+#define MACH_TYPE_A730                 691
+#define MACH_TYPE_NETSTAR              692
+#define MACH_TYPE_PHASEFALE_SUPERCON   693
+#define MACH_TYPE_SHIVA1100            694
+#define MACH_TYPE_ETEXSC               695
+#define MACH_TYPE_IXDPG465             696
+#define MACH_TYPE_A9M2410              697
+#define MACH_TYPE_A9M2440              698
+#define MACH_TYPE_A9M9750              699
+#define MACH_TYPE_A9M9360              700
+#define MACH_TYPE_UNC90                701
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_SATVIEW              703
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_GP32                 706
+#define MACH_TYPE_GEM                  707
+#define MACH_TYPE_I858                 708
+#define MACH_TYPE_HX2750               709
+#define MACH_TYPE_MXC91131EVB          710
+#define MACH_TYPE_P700                 711
+#define MACH_TYPE_CPE                  712
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_NIMBRA340            714
+#define MACH_TYPE_LPC22XX              715
+#define MACH_TYPE_COMET3               716
+#define MACH_TYPE_COMET4               717
+#define MACH_TYPE_CSB625               718
+#define MACH_TYPE_FORTUNET2            719
+#define MACH_TYPE_S5H2200              720
+#define MACH_TYPE_OPTORM920            721
+#define MACH_TYPE_ADSBITSYXB           722
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_ADSPORTAL            724
+#define MACH_TYPE_LN2410SBC            725
+#define MACH_TYPE_CB3RUFC              726
+#define MACH_TYPE_MP2USB               727
+#define MACH_TYPE_NTNP425C             728
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_PCM7220              730
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_CMPXA                733
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_ITE8152              735
+#define MACH_TYPE_LPC3XXX              736
+#define MACH_TYPE_PUPPETEER            737
+#define MACH_TYPE_MACH_VADATECH        738
+#define MACH_TYPE_E570                 739
+#define MACH_TYPE_X50                  740
+#define MACH_TYPE_RECON                741
+#define MACH_TYPE_XBOARDGP8            742
+#define MACH_TYPE_FPIC2                743
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_A81                  745
+#define MACH_TYPE_SVM_SC25X            746
+#define MACH_TYPE_VADATECH020          747
+#define MACH_TYPE_TLI                  748
+#define MACH_TYPE_EDB9315LC            749
+#define MACH_TYPE_PASSEC               750
+#define MACH_TYPE_DS_TIGER             751
+#define MACH_TYPE_E310                 752
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_RT3000               754
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_PNX0106              756
+#define MACH_TYPE_HX21XX               757
+#define MACH_TYPE_FARADAY              758
+#define MACH_TYPE_SBC9312              759
+#define MACH_TYPE_BATMAN               760
+#define MACH_TYPE_JPD201               761
+#define MACH_TYPE_MIPSA                762
+#define MACH_TYPE_KACOM                763
+#define MACH_TYPE_SWARCOCPU            764
+#define MACH_TYPE_SWARCODSL            765
+#define MACH_TYPE_BLUEANGEL            766
+#define MACH_TYPE_HAIRYGRAMA           767
+#define MACH_TYPE_BANFF                768
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_SAM255               770
+#define MACH_TYPE_PPM10                771
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_SUNSET               773
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_MAINSTONE2           777
+#define MACH_TYPE_EZ_IXP42X            778
+#define MACH_TYPE_TAPWAVE_ZODIAC       779
+#define MACH_TYPE_UNIVERSALMETER       780
+#define MACH_TYPE_HICOARM9             781
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_KWS6000              783
+#define MACH_TYPE_PORTUX920T           784
+#define MACH_TYPE_EZ_X5                785
+#define MACH_TYPE_OMAP_RUDOLPH         786
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_REA9200              788
+#define MACH_TYPE_ACTS_PUNE_SA1110     789
+#define MACH_TYPE_IXP425               790
+#define MACH_TYPE_I30030ADS            791
+#define MACH_TYPE_PERCH                792
+#define MACH_TYPE_EIS05R1              793
+#define MACH_TYPE_PEPPERPAD            794
+#define MACH_TYPE_SB3010               795
+#define MACH_TYPE_RM9200               796
+#define MACH_TYPE_DMA03                797
+#define MACH_TYPE_ROAD_S101            798
+#define MACH_TYPE_IQ81340SC            799
+#define MACH_TYPE_IQ_NEXTGEN_B         800
+#define MACH_TYPE_IQ81340MC            801
+#define MACH_TYPE_IQ_NEXTGEN_D         802
+#define MACH_TYPE_IQ_NEXTGEN_E         803
+#define MACH_TYPE_MALLOW_AT91          804
+#define MACH_TYPE_CYBERTRACKER_I       805
+#define MACH_TYPE_GESBC931X            806
+#define MACH_TYPE_CENTIPAD             807
+#define MACH_TYPE_ARMSOC               808
+#define MACH_TYPE_SE4200               809
+#define MACH_TYPE_EMS197A              810
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_UC5471DSP            813
+#define MACH_TYPE_SJ5471ENG            814
+#define MACH_TYPE_CMPXA26X             815
+#define MACH_TYPE_NC                   816
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_AJAX52X              818
+#define MACH_TYPE_SIRIUSTAR            819
+#define MACH_TYPE_IODATA_HDLG          820
+#define MACH_TYPE_AT91RM9200UTL        821
+#define MACH_TYPE_BIOSAFE              822
+#define MACH_TYPE_MP1000               823
+#define MACH_TYPE_PARSY                824
+#define MACH_TYPE_CCXP                 825
+#define MACH_TYPE_OMAP_GSAMPLE         826
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_SAMOA                828
+#define MACH_TYPE_T3XSCALE             829
+#define MACH_TYPE_I878                 830
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_GECKO                832
+#define MACH_TYPE_DS101                833
+#define MACH_TYPE_OMAP_PALMTT2         834
+#define MACH_TYPE_XSCALE_PALMLD        835
+#define MACH_TYPE_CC9C                 836
+#define MACH_TYPE_SBC1670              837
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ML696K               840
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_MAESTRO              843
+#define MACH_TYPE_TUNGE2               844
+#define MACH_TYPE_IXBBM                845
+#define MACH_TYPE_MX27ADS              846
+#define MACH_TYPE_AX8004               847
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MAGPIE               850
+#define MACH_TYPE_MX21ADS              851
+#define MACH_TYPE_MB87M3400            852
+#define MACH_TYPE_MGUARD_DELTA         853
+#define MACH_TYPE_DAVINCI_DVDP         854
+#define MACH_TYPE_HTCUNIVERSAL         855
+#define MACH_TYPE_TPAD                 856
+#define MACH_TYPE_ROVERP3              857
+#define MACH_TYPE_JORNADA928           858
+#define MACH_TYPE_MV88FXX81            859
+#define MACH_TYPE_STMP36XX             860
+#define MACH_TYPE_SXNI79524            861
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_URANIUM              863
+#define MACH_TYPE_UCON                 864
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_L083_1000            866
+#define MACH_TYPE_EZX                  867
+#define MACH_TYPE_PNX5220              868
+#define MACH_TYPE_BUTTE                869
+#define MACH_TYPE_SRM2                 870
+#define MACH_TYPE_DSBR                 871
+#define MACH_TYPE_CRYSTALBALL          872
+#define MACH_TYPE_TINYPXA27X           873
+#define MACH_TYPE_HERBIE               874
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_CM4002               876
+#define MACH_TYPE_B4                   877
+#define MACH_TYPE_MAUI                 878
+#define MACH_TYPE_CYBERTRACKER_G       879
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_MIO8390              881
+#define MACH_TYPE_OMI_BOARD            882
+#define MACH_TYPE_MX21CIV              883
+#define MACH_TYPE_MAHI_CDAC            884
+#define MACH_TYPE_XSCALE_PALMTX        885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_SAMSYS_EP0           888
+#define MACH_TYPE_WG302V1              889
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_EB42X                891
+#define MACH_TYPE_IQ331ES              892
+#define MACH_TYPE_COSYDSP              893
+#define MACH_TYPE_UPLAT7D              894
+#define MACH_TYPE_PTDAVINCI            895
+#define MACH_TYPE_MBUS                 896
+#define MACH_TYPE_NADIA2VB             897
+#define MACH_TYPE_R1000                898
+#define MACH_TYPE_HW90250              899
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_OMAP_TORNADO         902
+#define MACH_TYPE_OLOCREEK             903
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_APF9328              906
+#define MACH_TYPE_OMAP_WIPOQ           907
+#define MACH_TYPE_OMAP_TWIP            908
+#define MACH_TYPE_XSCALE_PALMTREO650   909
+#define MACH_TYPE_ACUMEN               910
+#define MACH_TYPE_XP100                911
+#define MACH_TYPE_FS2410               912
+#define MACH_TYPE_PXA270_CERF          913
+#define MACH_TYPE_SQ2FTLPALM           914
+#define MACH_TYPE_BSEMSERVER           915
+#define MACH_TYPE_NETCLIENT            916
+#define MACH_TYPE_XSCALE_PALMTT5       917
+#define MACH_TYPE_OMAP_PALMTC          918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_MXC30030EVB          920
+#define MACH_TYPE_REA_2D               921
+#define MACH_TYPE_TI3E524              922
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_AUCKLAND             924
+#define MACH_TYPE_AK3320M              925
+#define MACH_TYPE_DURAMAX              926
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_PRONGHORN            928
+#define MACH_TYPE_FUNDY                929
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_CPU777               931
+#define MACH_TYPE_SIMICON9201          932
+#define MACH_TYPE_LEAP2_HPM            933
+#define MACH_TYPE_CM922TXA10           934
+#define MACH_TYPE_PXA                  935
+#define MACH_TYPE_SANDGATE2            936
+#define MACH_TYPE_SANDGATE2G           937
+#define MACH_TYPE_SANDGATE2P           938
+#define MACH_TYPE_FRED_JACK            939
+#define MACH_TYPE_TTG_COLOR1           940
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_NETDCU8              942
+#define MACH_TYPE_ML675050_CPU_BOA     943
+#define MACH_TYPE_NG_FVX538            944
+#define MACH_TYPE_NG_FVS338            945
+#define MACH_TYPE_PNX4103              946
+#define MACH_TYPE_HESDB                947
+#define MACH_TYPE_XSILO                948
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_EMLC                 950
+#define MACH_TYPE_SISTERON             951
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_TSC_VENUS            953
+#define MACH_TYPE_DS101J               954
+#define MACH_TYPE_MXC30030ADS          955
+#define MACH_TYPE_FUJITSU_WIMAXSOC     956
+#define MACH_TYPE_DUALPCMODEM          957
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_HTCAPACHE            959
+#define MACH_TYPE_IXDP435              960
+#define MACH_TYPE_CATPROVT100          961
+#define MACH_TYPE_PICOTUX1XX           962
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_EMPC2                965
+#define MACH_TYPE_VENTURA              966
+#define MACH_TYPE_PHIDGET_SBC          967
+#define MACH_TYPE_IJ3K                 968
+#define MACH_TYPE_PISGAH               969
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SG720                971
+#define MACH_TYPE_REDFOX               972
+#define MACH_TYPE_MYSH_EP9315_1        973
+#define MACH_TYPE_TPF106               974
+#define MACH_TYPE_AT91RM9200KG         975
+#define MACH_TYPE_SLEDB                976
+#define MACH_TYPE_ONTRACK              977
+#define MACH_TYPE_PM1200               978
+#define MACH_TYPE_ESS24XXX             979
+#define MACH_TYPE_COREMP7              980
+#define MACH_TYPE_NEXCODER_6446        981
+#define MACH_TYPE_STVC8380             982
+#define MACH_TYPE_TEKLYNX              983
+#define MACH_TYPE_CARBONADO            984
+#define MACH_TYPE_SYSMOS_MP730         985
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_PGIGIM               987
+#define MACH_TYPE_PTX9160P2            988
+#define MACH_TYPE_DCORE1               989
+#define MACH_TYPE_VICTORPXA            990
+#define MACH_TYPE_MX2DTB               991
+#define MACH_TYPE_PXA_IREX_ER0100      992
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_BARTEC_DEG           994
+#define MACH_TYPE_HW50251              995
+#define MACH_TYPE_IBOX                 996
+#define MACH_TYPE_ATLASLH7A404         997
+#define MACH_TYPE_PT2026               998
+#define MACH_TYPE_HTCALPINE            999
+#define MACH_TYPE_BARTEC_VTU           1000
+#define MACH_TYPE_VCOREII              1001
+#define MACH_TYPE_PDNB3                1002
+#define MACH_TYPE_HTCBEETLES           1003
+#define MACH_TYPE_S3C6400              1004
+#define MACH_TYPE_S3C2443              1005
+#define MACH_TYPE_OMAP_LDK             1006
+#define MACH_TYPE_SMDK2460             1007
+#define MACH_TYPE_SMDK2440             1008
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_WEBBOX               1010
+#define MACH_TYPE_CWWNDP               1011
+#define MACH_TYPE_DRAGON               1012
+#define MACH_TYPE_OPENDO_CPU_BOARD     1013
+#define MACH_TYPE_CCM2200              1014
+#define MACH_TYPE_ETWARM               1015
+#define MACH_TYPE_M93030               1016
+#define MACH_TYPE_CC7U                 1017
+#define MACH_TYPE_MTT_RANGER           1018
+#define MACH_TYPE_NEXUS                1019
+#define MACH_TYPE_DESMAN               1020
+#define MACH_TYPE_BKDE303              1021
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M7200            1023
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_SG640                1025
+#define MACH_TYPE_EDG79524             1026
+#define MACH_TYPE_AI2410               1027
+#define MACH_TYPE_IXP465               1028
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_HEINS                1030
+#define MACH_TYPE_MPLUSEVA             1031
+#define MACH_TYPE_RT042                1032
+#define MACH_TYPE_CWIEM                1033
+#define MACH_TYPE_CM_X270              1034
+#define MACH_TYPE_CM_X255              1035
+#define MACH_TYPE_ESH_AT91             1036
+#define MACH_TYPE_SANDGATE3            1037
+#define MACH_TYPE_PRIMO                1038
+#define MACH_TYPE_GEMSTONE             1039
+#define MACH_TYPE_PRONGHORNMETRO       1040
+#define MACH_TYPE_SIDEWINDER           1041
+#define MACH_TYPE_PICOMOD1             1042
+#define MACH_TYPE_SG590                1043
+#define MACH_TYPE_AKAI9307             1044
+#define MACH_TYPE_FONTAINE             1045
+#define MACH_TYPE_WOMBAT               1046
+#define MACH_TYPE_ACQ300               1047
+#define MACH_TYPE_MOD_270              1048
+#define MACH_TYPE_VC0820               1049
+#define MACH_TYPE_ANI_AIM              1050
+#define MACH_TYPE_JELLYFISH            1051
+#define MACH_TYPE_AMANITA              1052
+#define MACH_TYPE_VLINK                1053
+#define MACH_TYPE_DEXFLEX              1054
+#define MACH_TYPE_EIGEN_TTQ            1055
+#define MACH_TYPE_ARCOM_TITAN          1056
+#define MACH_TYPE_TABLA                1057
+#define MACH_TYPE_MDIRAC3              1058
+#define MACH_TYPE_MRHFBP2              1059
+#define MACH_TYPE_AT91RM9200RB         1060
+#define MACH_TYPE_ANI_APM              1061
+#define MACH_TYPE_ELLA1                1062
+#define MACH_TYPE_INHAND_PXA27X        1063
+#define MACH_TYPE_INHAND_PXA25X        1064
+#define MACH_TYPE_EMPOS_XM             1065
+#define MACH_TYPE_EMPOS                1066
+#define MACH_TYPE_EMPOS_TINY           1067
+#define MACH_TYPE_EMPOS_SM             1068
+#define MACH_TYPE_EGRET                1069
+#define MACH_TYPE_OSTRICH              1070
+#define MACH_TYPE_N50                  1071
+#define MACH_TYPE_ECBAT91              1072
+#define MACH_TYPE_STAREAST             1073
+#define MACH_TYPE_DSPG_DW              1074
+#define MACH_TYPE_ONEARM               1075
+#define MACH_TYPE_MRG110_6             1076
+#define MACH_TYPE_WRT300NV2            1077
+#define MACH_TYPE_XM_BULVERDE          1078
+#define MACH_TYPE_MSM6100              1079
+#define MACH_TYPE_ETI_B1               1080
+#define MACH_TYPE_ZILOG_ZA9L           1081
+#define MACH_TYPE_BIT2440              1082
+#define MACH_TYPE_NBI                  1083
+#define MACH_TYPE_SMDK2443             1084
+#define MACH_TYPE_VDAVINCI             1085
+#define MACH_TYPE_ATC6                 1086
+#define MACH_TYPE_MULTMDW              1087
+#define MACH_TYPE_MBA2440              1088
+#define MACH_TYPE_ECSD                 1089
+#define MACH_TYPE_ZIRE31               1090
+#define MACH_TYPE_FSG                  1091
+#define MACH_TYPE_RAZOR101             1092
+#define MACH_TYPE_OPERA_TDM            1093
+#define MACH_TYPE_COMCERTO             1094
+#define MACH_TYPE_TB0319               1095
+#define MACH_TYPE_KWS8000              1096
+#define MACH_TYPE_B2                   1097
+#define MACH_TYPE_LCL54                1098
+#define MACH_TYPE_AT91SAM9260EK        1099
+#define MACH_TYPE_GLANTANK             1100
+#define MACH_TYPE_N2100                1101
+#define MACH_TYPE_N4100                1102
+#define MACH_TYPE_VERTICAL_RSC4        1103
+#define MACH_TYPE_SG8100               1104
+#define MACH_TYPE_IM42XX               1105
+#define MACH_TYPE_FTXX                 1106
+#define MACH_TYPE_LWFUSION             1107
+#define MACH_TYPE_QT2410               1108
+#define MACH_TYPE_KIXRP435             1109
+#define MACH_TYPE_CCW9C                1110
+#define MACH_TYPE_DABHS                1111
+#define MACH_TYPE_GZMX                 1112
+#define MACH_TYPE_IPNW100AP            1113
+#define MACH_TYPE_CC9P9360DEV          1114
+#define MACH_TYPE_CC9P9750DEV          1115
+#define MACH_TYPE_CC9P9360VAL          1116
+#define MACH_TYPE_CC9P9750VAL          1117
+#define MACH_TYPE_NX70V                1118
+#define MACH_TYPE_AT91RM9200DF         1119
+#define MACH_TYPE_SE_PILOT2            1120
+#define MACH_TYPE_MTCN_T800            1121
+#define MACH_TYPE_VCMX212              1122
+#define MACH_TYPE_LYNX                 1123
+#define MACH_TYPE_AT91SAM9260ID        1124
+#define MACH_TYPE_HW86052              1125
+#define MACH_TYPE_PILZ_PMI3            1126
+#define MACH_TYPE_EDB9302A             1127
+#define MACH_TYPE_EDB9307A             1128
+#define MACH_TYPE_CT_DFS               1129
+#define MACH_TYPE_PILZ_PMI4            1130
+#define MACH_TYPE_XCEEDNP_IXP          1131
+#define MACH_TYPE_SMDK2442B            1132
+#define MACH_TYPE_XNODE                1133
+#define MACH_TYPE_AIDX270              1134
+#define MACH_TYPE_REMA                 1135
+#define MACH_TYPE_BPS1000              1136
+#define MACH_TYPE_HW90350              1137
+#define MACH_TYPE_OMAP_SDP3430         1138
+#define MACH_TYPE_BLUETOUCH            1139
+#define MACH_TYPE_VSTMS                1140
+#define MACH_TYPE_XSBASE270            1141
+#define MACH_TYPE_AT91SAM9260EK_CN     1142
+#define MACH_TYPE_ADSTURBOXB           1143
+#define MACH_TYPE_OTI4110              1144
+#define MACH_TYPE_HME_PXA              1145
+#define MACH_TYPE_DEISTERDCA           1146
+#define MACH_TYPE_CES_SSEM2            1147
+#define MACH_TYPE_CES_MTR              1148
+#define MACH_TYPE_TDS_AVNG_SBC         1149
+#define MACH_TYPE_EVEREST              1150
+#define MACH_TYPE_PNX4010              1151
+#define MACH_TYPE_OXNAS                1152
+#define MACH_TYPE_FIORI                1153
+#define MACH_TYPE_ML1200               1154
+#define MACH_TYPE_PECOS                1155
+#define MACH_TYPE_NB2XXX               1156
+#define MACH_TYPE_HW6900               1157
+#define MACH_TYPE_CDCS_QUOLL           1158
+#define MACH_TYPE_QUICKSILVER          1159
+#define MACH_TYPE_UPLAT926             1160
+#define MACH_TYPE_DEP2410_THOMAS       1161
+#define MACH_TYPE_DTK2410              1162
+#define MACH_TYPE_CHILI                1163
+#define MACH_TYPE_DEMETER              1164
+#define MACH_TYPE_DIONYSUS             1165
+#define MACH_TYPE_AS352X               1166
+#define MACH_TYPE_SERVICE              1167
+#define MACH_TYPE_CS_E9301             1168
+#define MACH_TYPE_MICRO9M              1169
+#define MACH_TYPE_IA_MOSPCK            1170
+#define MACH_TYPE_QL201B               1171
+#define MACH_TYPE_BBM                  1174
+#define MACH_TYPE_EXXX                 1175
+#define MACH_TYPE_WMA11B               1176
+#define MACH_TYPE_PELCO_ATLAS          1177
+#define MACH_TYPE_G500                 1178
+#define MACH_TYPE_BUG                  1179
+#define MACH_TYPE_MX33ADS              1180
+#define MACH_TYPE_CHUB                 1181
+#define MACH_TYPE_NEO1973_GTA01        1182
+#define MACH_TYPE_W90N740              1183
+#define MACH_TYPE_MEDALLION_SA2410     1184
+#define MACH_TYPE_IA_CPU_9200_2        1185
+#define MACH_TYPE_DIMMRM9200           1186
+#define MACH_TYPE_PM9261               1187
+#define MACH_TYPE_ML7304               1189
+#define MACH_TYPE_UCP250               1190
+#define MACH_TYPE_INTBOARD             1191
+#define MACH_TYPE_GULFSTREAM           1192
+#define MACH_TYPE_LABQUEST             1193
+#define MACH_TYPE_VCMX313              1194
+#define MACH_TYPE_URG200               1195
+#define MACH_TYPE_CPUX255LCDNET        1196
+#define MACH_TYPE_NETDCU9              1197
+#define MACH_TYPE_NETDCU10             1198
+#define MACH_TYPE_DSPG_DGA             1199
+#define MACH_TYPE_DSPG_DVW             1200
+#define MACH_TYPE_SOLOS                1201
+#define MACH_TYPE_AT91SAM9263EK        1202
+#define MACH_TYPE_OSSTBOX              1203
+#define MACH_TYPE_KBAT9261             1204
+#define MACH_TYPE_CT1100               1205
+#define MACH_TYPE_AKCPPXA              1206
+#define MACH_TYPE_ZEVIO_1020           1207
+#define MACH_TYPE_HITRACK              1208
+#define MACH_TYPE_SYME1                1209
+#define MACH_TYPE_SYHL1                1210
+#define MACH_TYPE_EMPCA400             1211
+#define MACH_TYPE_EM7210               1212
+#define MACH_TYPE_HTCHERMES            1213
+#define MACH_TYPE_ETI_C1               1214
+#define MACH_TYPE_MACH_DEP2410         1215
+#define MACH_TYPE_AC100                1216
+#define MACH_TYPE_SNEETCH              1217
+#define MACH_TYPE_STUDENTMATE          1218
+#define MACH_TYPE_ZIR2410              1219
+#define MACH_TYPE_ZIR2413              1220
+#define MACH_TYPE_DLONIP3              1221
+#define MACH_TYPE_INSTREAM             1222
+#define MACH_TYPE_AMBARELLA            1223
+#define MACH_TYPE_NEVIS                1224
+#define MACH_TYPE_HTC_TRINITY          1225
+#define MACH_TYPE_QL202B               1226
+#define MACH_TYPE_VPAC270              1227
+#define MACH_TYPE_RD129                1228
+#define MACH_TYPE_HTCWIZARD            1229
+#define MACH_TYPE_XSCALE_TREO680       1230
+#define MACH_TYPE_TECON_TMEZON         1231
+#define MACH_TYPE_ZYLONITE             1233
+#define MACH_TYPE_GENE1270             1234
+#define MACH_TYPE_ZIR2412              1235
+#define MACH_TYPE_MX31LITE             1236
+#define MACH_TYPE_T700WX               1237
+#define MACH_TYPE_VF100                1238
+#define MACH_TYPE_NSB2                 1239
+#define MACH_TYPE_NXHMI_BB             1240
+#define MACH_TYPE_NXHMI_RE             1241
+#define MACH_TYPE_N4100PRO             1242
+#define MACH_TYPE_SAM9260              1243
+#define MACH_TYPE_OMAP_TREO600         1244
+#define MACH_TYPE_INDY2410             1245
+#define MACH_TYPE_NELT_A               1246
+#define MACH_TYPE_N311                 1248
+#define MACH_TYPE_AT91SAM9260VGK       1249
+#define MACH_TYPE_AT91LEPPE            1250
+#define MACH_TYPE_AT91LEPCCN           1251
+#define MACH_TYPE_APC7100              1252
+#define MACH_TYPE_STARGAZER            1253
+#define MACH_TYPE_SONATA               1254
+#define MACH_TYPE_SCHMOOGIE            1255
+#define MACH_TYPE_AZTOOL               1256
+#define MACH_TYPE_MIOA701              1257
+#define MACH_TYPE_SXNI9260             1258
+#define MACH_TYPE_MXC27520EVB          1259
+#define MACH_TYPE_ARMADILLO5X0         1260
+#define MACH_TYPE_MB9260               1261
+#define MACH_TYPE_MB9263               1262
+#define MACH_TYPE_IPAC9302             1263
+#define MACH_TYPE_CC9P9360JS           1264
+#define MACH_TYPE_GALLIUM              1265
+#define MACH_TYPE_MSC2410              1266
+#define MACH_TYPE_GHI270               1267
+#define MACH_TYPE_DAVINCI_LEONARDO     1268
+#define MACH_TYPE_OIAB                 1269
+#define MACH_TYPE_SMDK6400             1270
+#define MACH_TYPE_NOKIA_N800           1271
+#define MACH_TYPE_GREENPHONE           1272
+#define MACH_TYPE_COMPEXWP18           1273
+#define MACH_TYPE_XMATE                1274
+#define MACH_TYPE_ENERGIZER            1275
+#define MACH_TYPE_IME1                 1276
+#define MACH_TYPE_SWEDATMS             1277
+#define MACH_TYPE_NTNP435C             1278
+#define MACH_TYPE_SPECTRO2             1279
+#define MACH_TYPE_H6039                1280
+#define MACH_TYPE_EP80219              1281
+#define MACH_TYPE_SAMOA_II             1282
+#define MACH_TYPE_CWMXL                1283
+#define MACH_TYPE_AS9200               1284
+#define MACH_TYPE_SFX1149              1285
+#define MACH_TYPE_NAVI010              1286
+#define MACH_TYPE_MULTMDP              1287
+#define MACH_TYPE_SCB9520              1288
+#define MACH_TYPE_HTCATHENA            1289
+#define MACH_TYPE_XP179                1290
+#define MACH_TYPE_H4300                1291
+#define MACH_TYPE_GORAMO_MLR           1292
+#define MACH_TYPE_MXC30020EVB          1293
+#define MACH_TYPE_ADSBITSIMX           1294
+#define MACH_TYPE_ADSPORTALPLUS        1295
+#define MACH_TYPE_MMSP2PLUS            1296
+#define MACH_TYPE_EM_X270              1297
+#define MACH_TYPE_TPP302               1298
+#define MACH_TYPE_TPM104               1299
+#define MACH_TYPE_TPM102               1300
+#define MACH_TYPE_TPM109               1301
+#define MACH_TYPE_FBXO1                1302
+#define MACH_TYPE_HXD8                 1303
+#define MACH_TYPE_NEO1973_GTA02        1304
+#define MACH_TYPE_EMTEST               1305
+#define MACH_TYPE_AD6900               1306
+#define MACH_TYPE_EUROPA               1307
+#define MACH_TYPE_METROCONNECT         1308
+#define MACH_TYPE_EZ_S2410             1309
+#define MACH_TYPE_EZ_S2440             1310
+#define MACH_TYPE_EZ_EP9312            1311
+#define MACH_TYPE_EZ_EP9315            1312
+#define MACH_TYPE_EZ_X7                1313
+#define MACH_TYPE_GODOTDB              1314
+#define MACH_TYPE_MISTRAL              1315
+#define MACH_TYPE_MSM                  1316
+#define MACH_TYPE_CT5910               1317
+#define MACH_TYPE_CT5912               1318
+#define MACH_TYPE_HYNET_INE            1319
+#define MACH_TYPE_HYNET_APP            1320
+#define MACH_TYPE_MSM7200              1321
+#define MACH_TYPE_MSM7600              1322
+#define MACH_TYPE_CEB255               1323
+#define MACH_TYPE_CIEL                 1324
+#define MACH_TYPE_SLM5650              1325
+#define MACH_TYPE_AT91SAM9RLEK         1326
+#define MACH_TYPE_COMTECH_ROUTER       1327
+#define MACH_TYPE_SBC2410X             1328
+#define MACH_TYPE_AT4X0BD              1329
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEXUSPCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUSPCI
+# endif
+# define machine_is_nexuspci()	(machine_arch_type == MACH_TYPE_NEXUSPCI)
+#else
+# define machine_is_nexuspci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBOX
+# endif
+# define machine_is_tbox()	(machine_arch_type == MACH_TYPE_TBOX)
+#else
+# define machine_is_tbox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CO285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CO285
+# endif
+# define machine_is_co285()	(machine_arch_type == MACH_TYPE_CO285)
+#else
+# define machine_is_co285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7110
+# endif
+# define machine_is_clps7110()	(machine_arch_type == MACH_TYPE_CLPS7110)
+#else
+# define machine_is_clps7110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCHIMEDES
+# endif
+# define machine_is_archimedes()	(machine_arch_type == MACH_TYPE_ARCHIMEDES)
+#else
+# define machine_is_archimedes()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_A5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A5K
+# endif
+# define machine_is_a5k()	(machine_arch_type == MACH_TYPE_A5K)
+#else
+# define machine_is_a5k()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ETOILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETOILE
+# endif
+# define machine_is_etoile()	(machine_arch_type == MACH_TYPE_ETOILE)
+#else
+# define machine_is_etoile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LACIE_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LACIE_NAS
+# endif
+# define machine_is_lacie_nas()	(machine_arch_type == MACH_TYPE_LACIE_NAS)
+#else
+# define machine_is_lacie_nas()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7500
+# endif
+# define machine_is_clps7500()	(machine_arch_type == MACH_TYPE_CLPS7500)
+#else
+# define machine_is_clps7500()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITSY
+# endif
+# define machine_is_itsy()	(machine_arch_type == MACH_TYPE_ITSY)
+#else
+# define machine_is_itsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP1200
+# endif
+# define machine_is_ixp1200()	(machine_arch_type == MACH_TYPE_IXP1200)
+#else
+# define machine_is_ixp1200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_VICTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTOR
+# endif
+# define machine_is_victor()	(machine_arch_type == MACH_TYPE_VICTOR)
+#else
+# define machine_is_victor()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RANGER
+# endif
+# define machine_is_ranger()	(machine_arch_type == MACH_TYPE_RANGER)
+#else
+# define machine_is_ranger()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FPIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC
+# endif
+# define machine_is_fpic()	(machine_arch_type == MACH_TYPE_FPIC)
+#else
+# define machine_is_fpic()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXTENEX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXTENEX1
+# endif
+# define machine_is_extenex1()	(machine_arch_type == MACH_TYPE_EXTENEX1)
+#else
+# define machine_is_extenex1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHERMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHERMAN
+# endif
+# define machine_is_sherman()	(machine_arch_type == MACH_TYPE_SHERMAN)
+#else
+# define machine_is_sherman()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_SA
+# endif
+# define machine_is_accelent_sa()	(machine_arch_type == MACH_TYPE_ACCELENT_SA)
+#else
+# define machine_is_accelent_sa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_L7200
+# endif
+# define machine_is_accelent_l7200()	(machine_arch_type == MACH_TYPE_ACCELENT_L7200)
+#else
+# define machine_is_accelent_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETPORT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETPORT
+# endif
+# define machine_is_netport()	(machine_arch_type == MACH_TYPE_NETPORT)
+#else
+# define machine_is_netport()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PANGOLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANGOLIN
+# endif
+# define machine_is_pangolin()	(machine_arch_type == MACH_TYPE_PANGOLIN)
+#else
+# define machine_is_pangolin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_YOPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOPY
+# endif
+# define machine_is_yopy()	(machine_arch_type == MACH_TYPE_YOPY)
+#else
+# define machine_is_yopy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COOLIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COOLIDGE
+# endif
+# define machine_is_coolidge()	(machine_arch_type == MACH_TYPE_COOLIDGE)
+#else
+# define machine_is_coolidge()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUW_WEBPANEL
+# endif
+# define machine_is_huw_webpanel()	(machine_arch_type == MACH_TYPE_HUW_WEBPANEL)
+#else
+# define machine_is_huw_webpanel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPOTME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOTME
+# endif
+# define machine_is_spotme()	(machine_arch_type == MACH_TYPE_SPOTME)
+#else
+# define machine_is_spotme()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FREEBIRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBIRD
+# endif
+# define machine_is_freebird()	(machine_arch_type == MACH_TYPE_FREEBIRD)
+#else
+# define machine_is_freebird()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI925
+# endif
+# define machine_is_ti925()	(machine_arch_type == MACH_TYPE_TI925)
+#else
+# define machine_is_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RISCSTATION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCSTATION
+# endif
+# define machine_is_riscstation()	(machine_arch_type == MACH_TYPE_RISCSTATION)
+#else
+# define machine_is_riscstation()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CAVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAVY
+# endif
+# define machine_is_cavy()	(machine_arch_type == MACH_TYPE_CAVY)
+#else
+# define machine_is_cavy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_OMNIMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMNIMETER
+# endif
+# define machine_is_omnimeter()	(machine_arch_type == MACH_TYPE_OMNIMETER)
+#else
+# define machine_is_omnimeter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CITYGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CITYGO
+# endif
+# define machine_is_citygo()	(machine_arch_type == MACH_TYPE_CITYGO)
+#else
+# define machine_is_citygo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SPOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOT
+# endif
+# define machine_is_spot()	(machine_arch_type == MACH_TYPE_SPOT)
+#else
+# define machine_is_spot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBPAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBPAL
+# endif
+# define machine_is_webpal()	(machine_arch_type == MACH_TYPE_WEBPAL)
+#else
+# define machine_is_webpal()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LINPDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINPDA
+# endif
+# define machine_is_linpda()	(machine_arch_type == MACH_TYPE_LINPDA)
+#else
+# define machine_is_linpda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANAKIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANAKIN
+# endif
+# define machine_is_anakin()	(machine_arch_type == MACH_TYPE_ANAKIN)
+#else
+# define machine_is_anakin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MVI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVI
+# endif
+# define machine_is_mvi()	(machine_arch_type == MACH_TYPE_MVI)
+#else
+# define machine_is_mvi()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JUPITER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JUPITER
+# endif
+# define machine_is_jupiter()	(machine_arch_type == MACH_TYPE_JUPITER)
+#else
+# define machine_is_jupiter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PSIONW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSIONW
+# endif
+# define machine_is_psionw()	(machine_arch_type == MACH_TYPE_PSIONW)
+#else
+# define machine_is_psionw()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALN
+# endif
+# define machine_is_aln()	(machine_arch_type == MACH_TYPE_ALN)
+#else
+# define machine_is_aln()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMELOT
+# endif
+# define machine_is_epxa()	(machine_arch_type == MACH_TYPE_CAMELOT)
+#else
+# define machine_is_epxa()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GDS2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GDS2200
+# endif
+# define machine_is_gds2200()	(machine_arch_type == MACH_TYPE_GDS2200)
+#else
+# define machine_is_gds2200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PSION_SERIES7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSION_SERIES7
+# endif
+# define machine_is_netbook()	(machine_arch_type == MACH_TYPE_PSION_SERIES7)
+#else
+# define machine_is_netbook()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XFILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XFILE
+# endif
+# define machine_is_xfile()	(machine_arch_type == MACH_TYPE_XFILE)
+#else
+# define machine_is_xfile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACCELENT_EP9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_EP9312
+# endif
+# define machine_is_accelent_ep9312()	(machine_arch_type == MACH_TYPE_ACCELENT_EP9312)
+#else
+# define machine_is_accelent_ep9312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IC200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IC200
+# endif
+# define machine_is_ic200()	(machine_arch_type == MACH_TYPE_IC200)
+#else
+# define machine_is_ic200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CREDITLART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CREDITLART
+# endif
+# define machine_is_creditlart()	(machine_arch_type == MACH_TYPE_CREDITLART)
+#else
+# define machine_is_creditlart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HTM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTM
+# endif
+# define machine_is_htm()	(machine_arch_type == MACH_TYPE_HTM)
+#else
+# define machine_is_htm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80310
+# endif
+# define machine_is_iq80310()	(machine_arch_type == MACH_TYPE_IQ80310)
+#else
+# define machine_is_iq80310()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FREEBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBOT
+# endif
+# define machine_is_freebot()	(machine_arch_type == MACH_TYPE_FREEBOT)
+#else
+# define machine_is_freebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENTEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTEL
+# endif
+# define machine_is_entel()	(machine_arch_type == MACH_TYPE_ENTEL)
+#else
+# define machine_is_entel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP3510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP3510
+# endif
+# define machine_is_enp3510()	(machine_arch_type == MACH_TYPE_ENP3510)
+#else
+# define machine_is_enp3510()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TRIZEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS
+# endif
+# define machine_is_trizeps()	(machine_arch_type == MACH_TYPE_TRIZEPS)
+#else
+# define machine_is_trizeps()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NESA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NESA
+# endif
+# define machine_is_nesa()	(machine_arch_type == MACH_TYPE_NESA)
+#else
+# define machine_is_nesa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENUS
+# endif
+# define machine_is_venus()	(machine_arch_type == MACH_TYPE_VENUS)
+#else
+# define machine_is_venus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TARDIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TARDIS
+# endif
+# define machine_is_tardis()	(machine_arch_type == MACH_TYPE_TARDIS)
+#else
+# define machine_is_tardis()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERCURY
+# endif
+# define machine_is_mercury()	(machine_arch_type == MACH_TYPE_MERCURY)
+#else
+# define machine_is_mercury()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMPEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPEG
+# endif
+# define machine_is_empeg()	(machine_arch_type == MACH_TYPE_EMPEG)
+#else
+# define machine_is_empeg()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I80200FCC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I80200FCC
+# endif
+# define machine_is_adi_evb()	(machine_arch_type == MACH_TYPE_I80200FCC)
+#else
+# define machine_is_adi_evb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITT_CPB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITT_CPB
+# endif
+# define machine_is_itt_cpb()	(machine_arch_type == MACH_TYPE_ITT_CPB)
+#else
+# define machine_is_itt_cpb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVC
+# endif
+# define machine_is_svc()	(machine_arch_type == MACH_TYPE_SVC)
+#else
+# define machine_is_svc()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA2
+# endif
+# define machine_is_alpha2()	(machine_arch_type == MACH_TYPE_ALPHA2)
+#else
+# define machine_is_alpha2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA1
+# endif
+# define machine_is_alpha1()	(machine_arch_type == MACH_TYPE_ALPHA1)
+#else
+# define machine_is_alpha1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETARM
+# endif
+# define machine_is_netarm()	(machine_arch_type == MACH_TYPE_NETARM)
+#else
+# define machine_is_netarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDA1
+# endif
+# define machine_is_pda1()	(machine_arch_type == MACH_TYPE_PDA1)
+#else
+# define machine_is_pda1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANIKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANIKO
+# endif
+# define machine_is_aniko()	(machine_arch_type == MACH_TYPE_ANIKO)
+#else
+# define machine_is_aniko()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CS89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS89712
+# endif
+# define machine_is_cs89712()	(machine_arch_type == MACH_TYPE_CS89712)
+#else
+# define machine_is_cs89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WEARARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEARARM
+# endif
+# define machine_is_weararm()	(machine_arch_type == MACH_TYPE_WEARARM)
+#else
+# define machine_is_weararm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_POSSIO_PX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX
+# endif
+# define machine_is_possio_px()	(machine_arch_type == MACH_TYPE_POSSIO_PX)
+#else
+# define machine_is_possio_px()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIDEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEARM
+# endif
+# define machine_is_sidearm()	(machine_arch_type == MACH_TYPE_SIDEARM)
+#else
+# define machine_is_sidearm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_STORK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK
+# endif
+# define machine_is_stork()	(machine_arch_type == MACH_TYPE_STORK)
+#else
+# define machine_is_stork()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACE
+# endif
+# define machine_is_ace()	(machine_arch_type == MACH_TYPE_ACE)
+#else
+# define machine_is_ace()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLYARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLYARM
+# endif
+# define machine_is_ballyarm()	(machine_arch_type == MACH_TYPE_BALLYARM)
+#else
+# define machine_is_ballyarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPUTER
+# endif
+# define machine_is_simputer()	(machine_arch_type == MACH_TYPE_SIMPUTER)
+#else
+# define machine_is_simputer()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXTERM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXTERM
+# endif
+# define machine_is_nexterm()	(machine_arch_type == MACH_TYPE_NEXTERM)
+#else
+# define machine_is_nexterm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SA1100_ELF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SA1100_ELF
+# endif
+# define machine_is_sa1100_elf()	(machine_arch_type == MACH_TYPE_SA1100_ELF)
+#else
+# define machine_is_sa1100_elf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATOR
+# endif
+# define machine_is_gator()	(machine_arch_type == MACH_TYPE_GATOR)
+#else
+# define machine_is_gator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GRANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANITE
+# endif
+# define machine_is_granite()	(machine_arch_type == MACH_TYPE_GRANITE)
+#else
+# define machine_is_granite()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PLCE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLCE
+# endif
+# define machine_is_plce()	(machine_arch_type == MACH_TYPE_PLCE)
+#else
+# define machine_is_plce()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEDALB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEDALB
+# endif
+# define machine_is_murphy()	(machine_arch_type == MACH_TYPE_MEDALB)
+#else
+# define machine_is_murphy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAGLE
+# endif
+# define machine_is_eagle()	(machine_arch_type == MACH_TYPE_EAGLE)
+#else
+# define machine_is_eagle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC21
+# endif
+# define machine_is_dsc21()	(machine_arch_type == MACH_TYPE_DSC21)
+#else
+# define machine_is_dsc21()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC24
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC24
+# endif
+# define machine_is_dsc24()	(machine_arch_type == MACH_TYPE_DSC24)
+#else
+# define machine_is_dsc24()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI5472
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI5472
+# endif
+# define machine_is_ti5472()	(machine_arch_type == MACH_TYPE_TI5472)
+#else
+# define machine_is_ti5472()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UENGINE
+# endif
+# define machine_is_uengine()	(machine_arch_type == MACH_TYPE_UENGINE)
+#else
+# define machine_is_uengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUESTEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUESTEM
+# endif
+# define machine_is_bluestem()	(machine_arch_type == MACH_TYPE_BLUESTEM)
+#else
+# define machine_is_bluestem()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_XINGU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XINGU8
+# endif
+# define machine_is_xingu8()	(machine_arch_type == MACH_TYPE_XINGU8)
+#else
+# define machine_is_xingu8()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BUSHSTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUSHSTB
+# endif
+# define machine_is_bushstb()	(machine_arch_type == MACH_TYPE_BUSHSTB)
+#else
+# define machine_is_bushstb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EPSILON1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPSILON1
+# endif
+# define machine_is_epsilon1()	(machine_arch_type == MACH_TYPE_EPSILON1)
+#else
+# define machine_is_epsilon1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON
+# endif
+# define machine_is_balloon()	(machine_arch_type == MACH_TYPE_BALLOON)
+#else
+# define machine_is_balloon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPY
+# endif
+# define machine_is_puppy()	(machine_arch_type == MACH_TYPE_PUPPY)
+#else
+# define machine_is_puppy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ELROY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY
+# endif
+# define machine_is_elroy()	(machine_arch_type == MACH_TYPE_ELROY)
+#else
+# define machine_is_elroy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GMS720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GMS720
+# endif
+# define machine_is_gms720()	(machine_arch_type == MACH_TYPE_GMS720)
+#else
+# define machine_is_gms720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S24X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S24X
+# endif
+# define machine_is_s24x()	(machine_arch_type == MACH_TYPE_S24X)
+#else
+# define machine_is_s24x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JTEL_CLEP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JTEL_CLEP7312
+# endif
+# define machine_is_jtel_clep7312()	(machine_arch_type == MACH_TYPE_JTEL_CLEP7312)
+#else
+# define machine_is_jtel_clep7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX821XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX821XX
+# endif
+# define machine_is_cx821xx()	(machine_arch_type == MACH_TYPE_CX821XX)
+#else
+# define machine_is_cx821xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7312
+# endif
+# define machine_is_edb7312()	(machine_arch_type == MACH_TYPE_EDB7312)
+#else
+# define machine_is_edb7312()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BSA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSA1110
+# endif
+# define machine_is_bsa1110()	(machine_arch_type == MACH_TYPE_BSA1110)
+#else
+# define machine_is_bsa1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POWERPIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POWERPIN
+# endif
+# define machine_is_powerpin()	(machine_arch_type == MACH_TYPE_POWERPIN)
+#else
+# define machine_is_powerpin()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPENARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENARM
+# endif
+# define machine_is_openarm()	(machine_arch_type == MACH_TYPE_OPENARM)
+#else
+# define machine_is_openarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITECHAPEL
+# endif
+# define machine_is_whitechapel()	(machine_arch_type == MACH_TYPE_WHITECHAPEL)
+#else
+# define machine_is_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3800
+# endif
+# define machine_is_h3800()	(machine_arch_type == MACH_TYPE_H3800)
+#else
+# define machine_is_h3800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUE_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_V1
+# endif
+# define machine_is_blue_v1()	(machine_arch_type == MACH_TYPE_BLUE_V1)
+#else
+# define machine_is_blue_v1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_CERF
+# endif
+# define machine_is_pxa_cerf()	(machine_arch_type == MACH_TYPE_PXA_CERF)
+#else
+# define machine_is_pxa_cerf()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARM7TEVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM7TEVB
+# endif
+# define machine_is_arm7tevb()	(machine_arch_type == MACH_TYPE_ARM7TEVB)
+#else
+# define machine_is_arm7tevb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7400
+# endif
+# define machine_is_d7400()	(machine_arch_type == MACH_TYPE_D7400)
+#else
+# define machine_is_d7400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PIRANHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIRANHA
+# endif
+# define machine_is_piranha()	(machine_arch_type == MACH_TYPE_PIRANHA)
+#else
+# define machine_is_piranha()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SBCAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBCAMELOT
+# endif
+# define machine_is_sbcamelot()	(machine_arch_type == MACH_TYPE_SBCAMELOT)
+#else
+# define machine_is_sbcamelot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KINGS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGS
+# endif
+# define machine_is_kings()	(machine_arch_type == MACH_TYPE_KINGS)
+#else
+# define machine_is_kings()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2400
+# endif
+# define machine_is_smdk2400()	(machine_arch_type == MACH_TYPE_SMDK2400)
+#else
+# define machine_is_smdk2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDR
+# endif
+# define machine_is_idr()	(machine_arch_type == MACH_TYPE_IDR)
+#else
+# define machine_is_idr()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBNET
+# endif
+# define machine_is_webnet()	(machine_arch_type == MACH_TYPE_WEBNET)
+#else
+# define machine_is_webnet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7300
+# endif
+# define machine_is_d7300()	(machine_arch_type == MACH_TYPE_D7300)
+#else
+# define machine_is_d7300()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEP
+# endif
+# define machine_is_cep()	(machine_arch_type == MACH_TYPE_CEP)
+#else
+# define machine_is_cep()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VC547X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC547X
+# endif
+# define machine_is_vc547x()	(machine_arch_type == MACH_TYPE_VC547X)
+#else
+# define machine_is_vc547x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FILEWALKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FILEWALKER
+# endif
+# define machine_is_filewalker()	(machine_arch_type == MACH_TYPE_FILEWALKER)
+#else
+# define machine_is_filewalker()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETGATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATEWAY
+# endif
+# define machine_is_netgateway()	(machine_arch_type == MACH_TYPE_NETGATEWAY)
+#else
+# define machine_is_netgateway()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SYMBOL2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYMBOL2800
+# endif
+# define machine_is_symbol2800()	(machine_arch_type == MACH_TYPE_SYMBOL2800)
+#else
+# define machine_is_symbol2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SUNS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNS
+# endif
+# define machine_is_suns()	(machine_arch_type == MACH_TYPE_SUNS)
+#else
+# define machine_is_suns()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRODO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRODO
+# endif
+# define machine_is_frodo()	(machine_arch_type == MACH_TYPE_FRODO)
+#else
+# define machine_is_frodo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MACH_TYTE_MS301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_TYTE_MS301
+# endif
+# define machine_is_ms301()	(machine_arch_type == MACH_TYPE_MACH_TYTE_MS301)
+#else
+# define machine_is_ms301()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AMICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMICO
+# endif
+# define machine_is_amico()	(machine_arch_type == MACH_TYPE_AMICO)
+#else
+# define machine_is_amico()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_IAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM
+# endif
+# define machine_is_iam()	(machine_arch_type == MACH_TYPE_IAM)
+#else
+# define machine_is_iam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TT530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT530
+# endif
+# define machine_is_tt530()	(machine_arch_type == MACH_TYPE_TT530)
+#else
+# define machine_is_tt530()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SAM2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM2400
+# endif
+# define machine_is_sam2400()	(machine_arch_type == MACH_TYPE_SAM2400)
+#else
+# define machine_is_sam2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA56X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA56X
+# endif
+# define machine_is_jornada56x()	(machine_arch_type == MACH_TYPE_JORNADA56X)
+#else
+# define machine_is_jornada56x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACTIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTIVE
+# endif
+# define machine_is_active()	(machine_arch_type == MACH_TYPE_ACTIVE)
+#else
+# define machine_is_active()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WID
+# endif
+# define machine_is_wid()	(machine_arch_type == MACH_TYPE_WID)
+#else
+# define machine_is_wid()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SABINAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SABINAL
+# endif
+# define machine_is_sabinal()	(machine_arch_type == MACH_TYPE_SABINAL)
+#else
+# define machine_is_sabinal()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MATACUMBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MATACUMBE
+# endif
+# define machine_is_ixp425_matacumbe()	(machine_arch_type == MACH_TYPE_IXP425_MATACUMBE)
+#else
+# define machine_is_ixp425_matacumbe()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MINIPRINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIPRINT
+# endif
+# define machine_is_miniprint()	(machine_arch_type == MACH_TYPE_MINIPRINT)
+#else
+# define machine_is_miniprint()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADM510X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADM510X
+# endif
+# define machine_is_adm510x()	(machine_arch_type == MACH_TYPE_ADM510X)
+#else
+# define machine_is_adm510x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVS200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVS200
+# endif
+# define machine_is_svs200()	(machine_arch_type == MACH_TYPE_SVS200)
+#else
+# define machine_is_svs200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATG_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATG_TCU
+# endif
+# define machine_is_atg_tcu()	(machine_arch_type == MACH_TYPE_ATG_TCU)
+#else
+# define machine_is_atg_tcu()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA820
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA820
+# endif
+# define machine_is_jornada820()	(machine_arch_type == MACH_TYPE_JORNADA820)
+#else
+# define machine_is_jornada820()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C44B0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C44B0
+# endif
+# define machine_is_s3c44b0()	(machine_arch_type == MACH_TYPE_S3C44B0)
+#else
+# define machine_is_s3c44b0()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MARGIS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARGIS2
+# endif
+# define machine_is_margis2()	(machine_arch_type == MACH_TYPE_MARGIS2)
+#else
+# define machine_is_margis2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRH
+# endif
+# define machine_is_brh()	(machine_arch_type == MACH_TYPE_BRH)
+#else
+# define machine_is_brh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2410
+# endif
+# define machine_is_s3c2410()	(machine_arch_type == MACH_TYPE_S3C2410)
+#else
+# define machine_is_s3c2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POSSIO_PX30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX30
+# endif
+# define machine_is_possio_px30()	(machine_arch_type == MACH_TYPE_POSSIO_PX30)
+#else
+# define machine_is_possio_px30()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2800
+# endif
+# define machine_is_s3c2800()	(machine_arch_type == MACH_TYPE_S3C2800)
+#else
+# define machine_is_s3c2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEETWOOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEETWOOD
+# endif
+# define machine_is_fleetwood()	(machine_arch_type == MACH_TYPE_FLEETWOOD)
+#else
+# define machine_is_fleetwood()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OMAHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAHA
+# endif
+# define machine_is_omaha()	(machine_arch_type == MACH_TYPE_OMAHA)
+#else
+# define machine_is_omaha()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7
+# endif
+# define machine_is_ta7()	(machine_arch_type == MACH_TYPE_TA7)
+#else
+# define machine_is_ta7()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOVA
+# endif
+# define machine_is_nova()	(machine_arch_type == MACH_TYPE_NOVA)
+#else
+# define machine_is_nova()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HMK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMK
+# endif
+# define machine_is_hmk()	(machine_arch_type == MACH_TYPE_HMK)
+#else
+# define machine_is_hmk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KARO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KARO
+# endif
+# define machine_is_karo()	(machine_arch_type == MACH_TYPE_KARO)
+#else
+# define machine_is_karo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FESTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FESTER
+# endif
+# define machine_is_fester()	(machine_arch_type == MACH_TYPE_FESTER)
+#else
+# define machine_is_fester()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GPI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPI
+# endif
+# define machine_is_gpi()	(machine_arch_type == MACH_TYPE_GPI)
+#else
+# define machine_is_gpi()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I519
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I519
+# endif
+# define machine_is_i519()	(machine_arch_type == MACH_TYPE_I519)
+#else
+# define machine_is_i519()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXIO
+# endif
+# define machine_is_nexio()	(machine_arch_type == MACH_TYPE_NEXIO)
+#else
+# define machine_is_nexio()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BITBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BITBOX
+# endif
+# define machine_is_bitbox()	(machine_arch_type == MACH_TYPE_BITBOX)
+#else
+# define machine_is_bitbox()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_G200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G200
+# endif
+# define machine_is_g200()	(machine_arch_type == MACH_TYPE_G200)
+#else
+# define machine_is_g200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GILL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GILL
+# endif
+# define machine_is_gill()	(machine_arch_type == MACH_TYPE_GILL)
+#else
+# define machine_is_gill()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MERCURY
+# endif
+# define machine_is_pxa_mercury()	(machine_arch_type == MACH_TYPE_PXA_MERCURY)
+#else
+# define machine_is_pxa_mercury()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRET
+# endif
+# define machine_is_fret()	(machine_arch_type == MACH_TYPE_FRET)
+#else
+# define machine_is_fret()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMAILPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMAILPHONE
+# endif
+# define machine_is_emailphone()	(machine_arch_type == MACH_TYPE_EMAILPHONE)
+#else
+# define machine_is_emailphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H3900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3900
+# endif
+# define machine_is_h3900()	(machine_arch_type == MACH_TYPE_H3900)
+#else
+# define machine_is_h3900()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA1
+# endif
+# define machine_is_pxa1()	(machine_arch_type == MACH_TYPE_PXA1)
+#else
+# define machine_is_pxa1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN369
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN369
+# endif
+# define machine_is_koan369()	(machine_arch_type == MACH_TYPE_KOAN369)
+#else
+# define machine_is_koan369()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_COGENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COGENT
+# endif
+# define machine_is_cogent()	(machine_arch_type == MACH_TYPE_COGENT)
+#else
+# define machine_is_cogent()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER
+# endif
+# define machine_is_esl_simputer()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER)
+#else
+# define machine_is_esl_simputer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_CLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_CLR
+# endif
+# define machine_is_esl_simputer_clr()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_CLR)
+#else
+# define machine_is_esl_simputer_clr()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_BW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_BW
+# endif
+# define machine_is_esl_simputer_bw()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_BW)
+#else
+# define machine_is_esl_simputer_bw()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_CRADLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_CRADLE
+# endif
+# define machine_is_hhp_cradle()	(machine_arch_type == MACH_TYPE_HHP_CRADLE)
+#else
+# define machine_is_hhp_cradle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HE500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HE500
+# endif
+# define machine_is_he500()	(machine_arch_type == MACH_TYPE_HE500)
+#else
+# define machine_is_he500()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDELF2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF2
+# endif
+# define machine_is_inhandelf2()	(machine_arch_type == MACH_TYPE_INHANDELF2)
+#else
+# define machine_is_inhandelf2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDFTIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP
+# endif
+# define machine_is_inhandftip()	(machine_arch_type == MACH_TYPE_INHANDFTIP)
+#else
+# define machine_is_inhandftip()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_DNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNP1110
+# endif
+# define machine_is_dnp1110()	(machine_arch_type == MACH_TYPE_DNP1110)
+#else
+# define machine_is_dnp1110()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP1110
+# endif
+# define machine_is_pnp1110()	(machine_arch_type == MACH_TYPE_PNP1110)
+#else
+# define machine_is_pnp1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB226
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB226
+# endif
+# define machine_is_csb226()	(machine_arch_type == MACH_TYPE_CSB226)
+#else
+# define machine_is_csb226()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ARNOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARNOLD
+# endif
+# define machine_is_arnold()	(machine_arch_type == MACH_TYPE_ARNOLD)
+#else
+# define machine_is_arnold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JZ8028
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JZ8028
+# endif
+# define machine_is_jz8028()	(machine_arch_type == MACH_TYPE_JZ8028)
+#else
+# define machine_is_jz8028()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FORTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTE
+# endif
+# define machine_is_forte()	(machine_arch_type == MACH_TYPE_FORTE)
+#else
+# define machine_is_forte()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACAM
+# endif
+# define machine_is_acam()	(machine_arch_type == MACH_TYPE_ACAM)
+#else
+# define machine_is_acam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ABOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABOX
+# endif
+# define machine_is_abox()	(machine_arch_type == MACH_TYPE_ABOX)
+#else
+# define machine_is_abox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATMEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATMEL
+# endif
+# define machine_is_atmel()	(machine_arch_type == MACH_TYPE_ATMEL)
+#else
+# define machine_is_atmel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SITSANG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SITSANG
+# endif
+# define machine_is_sitsang()	(machine_arch_type == MACH_TYPE_SITSANG)
+#else
+# define machine_is_sitsang()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CPU1110LCDNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU1110LCDNET
+# endif
+# define machine_is_cpu1110lcdnet()	(machine_arch_type == MACH_TYPE_CPU1110LCDNET)
+#else
+# define machine_is_cpu1110lcdnet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPL_VCMA9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPL_VCMA9
+# endif
+# define machine_is_mpl_vcma9()	(machine_arch_type == MACH_TYPE_MPL_VCMA9)
+#else
+# define machine_is_mpl_vcma9()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPUS_A1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPUS_A1
+# endif
+# define machine_is_opus_a1()	(machine_arch_type == MACH_TYPE_OPUS_A1)
+#else
+# define machine_is_opus_a1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAYTONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAYTONA
+# endif
+# define machine_is_daytona()	(machine_arch_type == MACH_TYPE_DAYTONA)
+#else
+# define machine_is_daytona()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KILLBEAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KILLBEAR
+# endif
+# define machine_is_killbear()	(machine_arch_type == MACH_TYPE_KILLBEAR)
+#else
+# define machine_is_killbear()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_YOHO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOHO
+# endif
+# define machine_is_yoho()	(machine_arch_type == MACH_TYPE_YOHO)
+#else
+# define machine_is_yoho()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASPER
+# endif
+# define machine_is_jasper()	(machine_arch_type == MACH_TYPE_JASPER)
+#else
+# define machine_is_jasper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC25
+# endif
+# define machine_is_dsc25()	(machine_arch_type == MACH_TYPE_DSC25)
+#else
+# define machine_is_dsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RAMSES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAMSES
+# endif
+# define machine_is_mnci()	(machine_arch_type == MACH_TYPE_RAMSES)
+#else
+# define machine_is_mnci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S28X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S28X
+# endif
+# define machine_is_s28x()	(machine_arch_type == MACH_TYPE_S28X)
+#else
+# define machine_is_s28x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3
+# endif
+# define machine_is_mport3()	(machine_arch_type == MACH_TYPE_MPORT3)
+#else
+# define machine_is_mport3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_EAGLE250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_EAGLE250
+# endif
+# define machine_is_pxa_eagle250()	(machine_arch_type == MACH_TYPE_PXA_EAGLE250)
+#else
+# define machine_is_pxa_eagle250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDB
+# endif
+# define machine_is_pdb()	(machine_arch_type == MACH_TYPE_PDB)
+#else
+# define machine_is_pdb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUE_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_2G
+# endif
+# define machine_is_blue_2g()	(machine_arch_type == MACH_TYPE_BLUE_2G)
+#else
+# define machine_is_blue_2g()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUEARCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEARCH
+# endif
+# define machine_is_bluearch()	(machine_arch_type == MACH_TYPE_BLUEARCH)
+#else
+# define machine_is_bluearch()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXPLORER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPLORER
+# endif
+# define machine_is_explorer()	(machine_arch_type == MACH_TYPE_EXPLORER)
+#else
+# define machine_is_explorer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CHIMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHIMP
+# endif
+# define machine_is_chimp()	(machine_arch_type == MACH_TYPE_CHIMP)
+#else
+# define machine_is_chimp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_NEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_NEST
+# endif
+# define machine_is_stork_nest()	(machine_arch_type == MACH_TYPE_STORK_NEST)
+#else
+# define machine_is_stork_nest()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_EGG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_EGG
+# endif
+# define machine_is_stork_egg()	(machine_arch_type == MACH_TYPE_STORK_EGG)
+#else
+# define machine_is_stork_egg()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WISMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WISMO
+# endif
+# define machine_is_wismo()	(machine_arch_type == MACH_TYPE_WISMO)
+#else
+# define machine_is_wismo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EZLINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZLINX
+# endif
+# define machine_is_ezlinx()	(machine_arch_type == MACH_TYPE_EZLINX)
+#else
+# define machine_is_ezlinx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200
+# endif
+# define machine_is_at91rm9200()	(machine_arch_type == MACH_TYPE_AT91RM9200)
+#else
+# define machine_is_at91rm9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ORION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORION
+# endif
+# define machine_is_orion()	(machine_arch_type == MACH_TYPE_ORION)
+#else
+# define machine_is_orion()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEPTUNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEPTUNE
+# endif
+# define machine_is_neptune()	(machine_arch_type == MACH_TYPE_NEPTUNE)
+#else
+# define machine_is_neptune()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WINS30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WINS30
+# endif
+# define machine_is_pxa_wins30()	(machine_arch_type == MACH_TYPE_PXA_WINS30)
+#else
+# define machine_is_pxa_wins30()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LAVINNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAVINNA
+# endif
+# define machine_is_lavinna()	(machine_arch_type == MACH_TYPE_LAVINNA)
+#else
+# define machine_is_lavinna()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_UENGINE
+# endif
+# define machine_is_pxa_uengine()	(machine_arch_type == MACH_TYPE_PXA_UENGINE)
+#else
+# define machine_is_pxa_uengine()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INNOKOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INNOKOM
+# endif
+# define machine_is_innokom()	(machine_arch_type == MACH_TYPE_INNOKOM)
+#else
+# define machine_is_innokom()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BMS
+# endif
+# define machine_is_bms()	(machine_arch_type == MACH_TYPE_BMS)
+#else
+# define machine_is_bms()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRPMC1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRPMC1100
+# endif
+# define machine_is_prpmc1100()	(machine_arch_type == MACH_TYPE_PRPMC1100)
+#else
+# define machine_is_prpmc1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMSTICK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSTICK
+# endif
+# define machine_is_armstick()	(machine_arch_type == MACH_TYPE_ARMSTICK)
+#else
+# define machine_is_armstick()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMONIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMONIE
+# endif
+# define machine_is_armonie()	(machine_arch_type == MACH_TYPE_ARMONIE)
+#else
+# define machine_is_armonie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT1
+# endif
+# define machine_is_mport1()	(machine_arch_type == MACH_TYPE_MPORT1)
+#else
+# define machine_is_mport1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C5410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5410
+# endif
+# define machine_is_s3c5410()	(machine_arch_type == MACH_TYPE_S3C5410)
+#else
+# define machine_is_s3c5410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZCP320A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZCP320A
+# endif
+# define machine_is_zcp320a()	(machine_arch_type == MACH_TYPE_ZCP320A)
+#else
+# define machine_is_zcp320a()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I_BOX
+# endif
+# define machine_is_i_box()	(machine_arch_type == MACH_TYPE_I_BOX)
+#else
+# define machine_is_i_box()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STLC1502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STLC1502
+# endif
+# define machine_is_stlc1502()	(machine_arch_type == MACH_TYPE_STLC1502)
+#else
+# define machine_is_stlc1502()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SIREN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIREN
+# endif
+# define machine_is_siren()	(machine_arch_type == MACH_TYPE_SIREN)
+#else
+# define machine_is_siren()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GREENLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREENLAKE
+# endif
+# define machine_is_greenlake()	(machine_arch_type == MACH_TYPE_GREENLAKE)
+#else
+# define machine_is_greenlake()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARGUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARGUS
+# endif
+# define machine_is_argus()	(machine_arch_type == MACH_TYPE_ARGUS)
+#else
+# define machine_is_argus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COMBADGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMBADGE
+# endif
+# define machine_is_combadge()	(machine_arch_type == MACH_TYPE_COMBADGE)
+#else
+# define machine_is_combadge()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ROKEPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROKEPXA
+# endif
+# define machine_is_rokepxa()	(machine_arch_type == MACH_TYPE_ROKEPXA)
+#else
+# define machine_is_rokepxa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUIDEA07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUIDEA07
+# endif
+# define machine_is_guidea07()	(machine_arch_type == MACH_TYPE_GUIDEA07)
+#else
+# define machine_is_guidea07()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TAT257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAT257
+# endif
+# define machine_is_tat257()	(machine_arch_type == MACH_TYPE_TAT257)
+#else
+# define machine_is_tat257()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IGP2425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGP2425
+# endif
+# define machine_is_igp2425()	(machine_arch_type == MACH_TYPE_IGP2425)
+#else
+# define machine_is_igp2425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUEGRAMMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEGRAMMA
+# endif
+# define machine_is_bluegrama()	(machine_arch_type == MACH_TYPE_BLUEGRAMMA)
+#else
+# define machine_is_bluegrama()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD
+# endif
+# define machine_is_ipod()	(machine_arch_type == MACH_TYPE_IPOD)
+#else
+# define machine_is_ipod()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSBITSYX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYX
+# endif
+# define machine_is_adsbitsyx()	(machine_arch_type == MACH_TYPE_ADSBITSYX)
+#else
+# define machine_is_adsbitsyx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TRIZEPS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS2
+# endif
+# define machine_is_trizeps2()	(machine_arch_type == MACH_TYPE_TRIZEPS2)
+#else
+# define machine_is_trizeps2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSYPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYPLUS
+# endif
+# define machine_is_adsbitsyplus()	(machine_arch_type == MACH_TYPE_ADSBITSYPLUS)
+#else
+# define machine_is_adsbitsyplus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSAGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGC
+# endif
+# define machine_is_adsagc()	(machine_arch_type == MACH_TYPE_ADSAGC)
+#else
+# define machine_is_adsagc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STP7312
+# endif
+# define machine_is_stp7312()	(machine_arch_type == MACH_TYPE_STP7312)
+#else
+# define machine_is_stp7312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PHNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PHNX
+# endif
+# define machine_is_nx_phnx()	(machine_arch_type == MACH_TYPE_NX_PHNX)
+#else
+# define machine_is_nx_phnx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEP_EP250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEP_EP250
+# endif
+# define machine_is_wep_ep250()	(machine_arch_type == MACH_TYPE_WEP_EP250)
+#else
+# define machine_is_wep_ep250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDELF3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF3
+# endif
+# define machine_is_inhandelf3()	(machine_arch_type == MACH_TYPE_INHANDELF3)
+#else
+# define machine_is_inhandelf3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IYONIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IYONIX
+# endif
+# define machine_is_iyonix()	(machine_arch_type == MACH_TYPE_IYONIX)
+#else
+# define machine_is_iyonix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAMICAM_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAMICAM_SA1110
+# endif
+# define machine_is_damicam1()	(machine_arch_type == MACH_TYPE_DAMICAM_SA1110)
+#else
+# define machine_is_damicam1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEG03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEG03
+# endif
+# define machine_is_meg03()	(machine_arch_type == MACH_TYPE_MEG03)
+#else
+# define machine_is_meg03()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WHITECHAPEL
+# endif
+# define machine_is_pxa_whitechapel()	(machine_arch_type == MACH_TYPE_PXA_WHITECHAPEL)
+#else
+# define machine_is_pxa_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWSC
+# endif
+# define machine_is_nwsc()	(machine_arch_type == MACH_TYPE_NWSC)
+#else
+# define machine_is_nwsc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWLARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWLARM
+# endif
+# define machine_is_nwlarm()	(machine_arch_type == MACH_TYPE_NWLARM)
+#else
+# define machine_is_nwlarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MGUARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MGUARD
+# endif
+# define machine_is_ixp425_mguard()	(machine_arch_type == MACH_TYPE_IXP425_MGUARD)
+#else
+# define machine_is_ixp425_mguard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_NETDCU4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU4
+# endif
+# define machine_is_pxa_netdcu4()	(machine_arch_type == MACH_TYPE_PXA_NETDCU4)
+#else
+# define machine_is_pxa_netdcu4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZODIAC
+# endif
+# define machine_is_zodiac()	(machine_arch_type == MACH_TYPE_ZODIAC)
+#else
+# define machine_is_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMMODUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMMODUL
+# endif
+# define machine_is_armmodul()	(machine_arch_type == MACH_TYPE_ARMMODUL)
+#else
+# define machine_is_armmodul()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KETOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KETOP
+# endif
+# define machine_is_ketop()	(machine_arch_type == MACH_TYPE_KETOP)
+#else
+# define machine_is_ketop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AV7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV7200
+# endif
+# define machine_is_av7200()	(machine_arch_type == MACH_TYPE_AV7200)
+#else
+# define machine_is_av7200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCH_TI925
+# endif
+# define machine_is_arch_ti925()	(machine_arch_type == MACH_TYPE_ARCH_TI925)
+#else
+# define machine_is_arch_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACQ200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ200
+# endif
+# define machine_is_acq200()	(machine_arch_type == MACH_TYPE_ACQ200)
+#else
+# define machine_is_acq200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_DAFIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_DAFIT
+# endif
+# define machine_is_pt_dafit()	(machine_arch_type == MACH_TYPE_PT_DAFIT)
+#else
+# define machine_is_pt_dafit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IHBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IHBA
+# endif
+# define machine_is_ihba()	(machine_arch_type == MACH_TYPE_IHBA)
+#else
+# define machine_is_ihba()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUINQUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUINQUE
+# endif
+# define machine_is_quinque()	(machine_arch_type == MACH_TYPE_QUINQUE)
+#else
+# define machine_is_quinque()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRAONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRAONE
+# endif
+# define machine_is_nimbraone()	(machine_arch_type == MACH_TYPE_NIMBRAONE)
+#else
+# define machine_is_nimbraone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA29X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA29X
+# endif
+# define machine_is_nimbra29x()	(machine_arch_type == MACH_TYPE_NIMBRA29X)
+#else
+# define machine_is_nimbra29x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA210
+# endif
+# define machine_is_nimbra210()	(machine_arch_type == MACH_TYPE_NIMBRA210)
+#else
+# define machine_is_nimbra210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_D95XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_D95XX
+# endif
+# define machine_is_hhp_d95xx()	(machine_arch_type == MACH_TYPE_HHP_D95XX)
+#else
+# define machine_is_hhp_d95xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LABARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LABARM
+# endif
+# define machine_is_labarm()	(machine_arch_type == MACH_TYPE_LABARM)
+#else
+# define machine_is_labarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_M825XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M825XX
+# endif
+# define machine_is_m825xx()	(machine_arch_type == MACH_TYPE_M825XX)
+#else
+# define machine_is_m825xx()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7100
+# endif
+# define machine_is_m7100()	(machine_arch_type == MACH_TYPE_M7100)
+#else
+# define machine_is_m7100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIPC2
+# endif
+# define machine_is_nipc2()	(machine_arch_type == MACH_TYPE_NIPC2)
+#else
+# define machine_is_nipc2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FU7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FU7202
+# endif
+# define machine_is_fu7202()	(machine_arch_type == MACH_TYPE_FU7202)
+#else
+# define machine_is_fu7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSAGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGX
+# endif
+# define machine_is_adsagx()	(machine_arch_type == MACH_TYPE_ADSAGX)
+#else
+# define machine_is_adsagx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_POOH
+# endif
+# define machine_is_pxa_pooh()	(machine_arch_type == MACH_TYPE_PXA_POOH)
+#else
+# define machine_is_pxa_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BANDON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANDON
+# endif
+# define machine_is_bandon()	(machine_arch_type == MACH_TYPE_BANDON)
+#else
+# define machine_is_bandon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PCM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7210
+# endif
+# define machine_is_pcm7210()	(machine_arch_type == MACH_TYPE_PCM7210)
+#else
+# define machine_is_pcm7210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMS9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMS9200
+# endif
+# define machine_is_nms9200()	(machine_arch_type == MACH_TYPE_NMS9200)
+#else
+# define machine_is_nms9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOGODL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGODL
+# endif
+# define machine_is_logodl()	(machine_arch_type == MACH_TYPE_LOGODL)
+#else
+# define machine_is_logodl()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7140
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7140
+# endif
+# define machine_is_m7140()	(machine_arch_type == MACH_TYPE_M7140)
+#else
+# define machine_is_m7140()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KOREBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOREBOT
+# endif
+# define machine_is_korebot()	(machine_arch_type == MACH_TYPE_KOREBOT)
+#else
+# define machine_is_korebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN393
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN393
+# endif
+# define machine_is_koan393()	(machine_arch_type == MACH_TYPE_KOAN393)
+#else
+# define machine_is_koan393()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDFTIP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP3
+# endif
+# define machine_is_inhandftip3()	(machine_arch_type == MACH_TYPE_INHANDFTIP3)
+#else
+# define machine_is_inhandftip3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GONZO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONZO
+# endif
+# define machine_is_gonzo()	(machine_arch_type == MACH_TYPE_GONZO)
+#else
+# define machine_is_gonzo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCANPASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCANPASS
+# endif
+# define machine_is_scanpass()	(machine_arch_type == MACH_TYPE_SCANPASS)
+#else
+# define machine_is_scanpass()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EP7312_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP7312_POOH
+# endif
+# define machine_is_ep7312_pooh()	(machine_arch_type == MACH_TYPE_EP7312_POOH)
+#else
+# define machine_is_ep7312_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7S
+# endif
+# define machine_is_ta7s()	(machine_arch_type == MACH_TYPE_TA7S)
+#else
+# define machine_is_ta7s()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7V
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7V
+# endif
+# define machine_is_ta7v()	(machine_arch_type == MACH_TYPE_TA7V)
+#else
+# define machine_is_ta7v()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ICARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICARUS
+# endif
+# define machine_is_icarus()	(machine_arch_type == MACH_TYPE_ICARUS)
+#else
+# define machine_is_icarus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1900
+# endif
+# define machine_is_h1900()	(machine_arch_type == MACH_TYPE_H1900)
+#else
+# define machine_is_h1900()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GEMINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMINI
+# endif
+# define machine_is_gemini()	(machine_arch_type == MACH_TYPE_GEMINI)
+#else
+# define machine_is_gemini()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AXIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIM
+# endif
+# define machine_is_axim()	(machine_arch_type == MACH_TYPE_AXIM)
+#else
+# define machine_is_axim()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUDIOTRON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUDIOTRON
+# endif
+# define machine_is_audiotron()	(machine_arch_type == MACH_TYPE_AUDIOTRON)
+#else
+# define machine_is_audiotron()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H2200
+# endif
+# define machine_is_h2200()	(machine_arch_type == MACH_TYPE_H2200)
+#else
+# define machine_is_h2200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOOX600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX600
+# endif
+# define machine_is_loox600()	(machine_arch_type == MACH_TYPE_LOOX600)
+#else
+# define machine_is_loox600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIOP
+# endif
+# define machine_is_niop()	(machine_arch_type == MACH_TYPE_NIOP)
+#else
+# define machine_is_niop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DM310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM310
+# endif
+# define machine_is_dm310()	(machine_arch_type == MACH_TYPE_DM310)
+#else
+# define machine_is_dm310()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SEEDPXA_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEEDPXA_C2
+# endif
+# define machine_is_seedpxa_c2()	(machine_arch_type == MACH_TYPE_SEEDPXA_C2)
+#else
+# define machine_is_seedpxa_c2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP4XX_MGUARD_PCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_MGUARD_PCI
+# endif
+# define machine_is_ixp4xx_mguardpci()	(machine_arch_type == MACH_TYPE_IXP4XX_MGUARD_PCI)
+#else
+# define machine_is_ixp4xx_mguardpci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCORPIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCORPIO
+# endif
+# define machine_is_scorpio()	(machine_arch_type == MACH_TYPE_SCORPIO)
+#else
+# define machine_is_scorpio()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVA
+# endif
+# define machine_is_viva()	(machine_arch_type == MACH_TYPE_VIVA)
+#else
+# define machine_is_viva()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_XCARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_XCARD
+# endif
+# define machine_is_pxa_xcard()	(machine_arch_type == MACH_TYPE_PXA_XCARD)
+#else
+# define machine_is_pxa_xcard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB335
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB335
+# endif
+# define machine_is_csb335()	(machine_arch_type == MACH_TYPE_CSB335)
+#else
+# define machine_is_csb335()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXRD425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXRD425
+# endif
+# define machine_is_ixrd425()	(machine_arch_type == MACH_TYPE_IXRD425)
+#else
+# define machine_is_ixrd425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80315
+# endif
+# define machine_is_iq80315()	(machine_arch_type == MACH_TYPE_IQ80315)
+#else
+# define machine_is_iq80315()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMP7312
+# endif
+# define machine_is_nmp7312()	(machine_arch_type == MACH_TYPE_NMP7312)
+#else
+# define machine_is_nmp7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX861XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX861XX
+# endif
+# define machine_is_cx861xx()	(machine_arch_type == MACH_TYPE_CX861XX)
+#else
+# define machine_is_cx861xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDA
+# endif
+# define machine_is_xda()	(machine_arch_type == MACH_TYPE_XDA)
+#else
+# define machine_is_xda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSIR_IMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSIR_IMS
+# endif
+# define machine_is_csir_ims()	(machine_arch_type == MACH_TYPE_CSIR_IMS)
+#else
+# define machine_is_csir_ims()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP421_DNAEETH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP421_DNAEETH
+# endif
+# define machine_is_ixp421_dnaeeth()	(machine_arch_type == MACH_TYPE_IXP421_DNAEETH)
+#else
+# define machine_is_ixp421_dnaeeth()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POCKETSERV9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POCKETSERV9200
+# endif
+# define machine_is_pocketserv9200()	(machine_arch_type == MACH_TYPE_POCKETSERV9200)
+#else
+# define machine_is_pocketserv9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TOTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOTO
+# endif
+# define machine_is_toto()	(machine_arch_type == MACH_TYPE_TOTO)
+#else
+# define machine_is_toto()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695P
+# endif
+# define machine_is_ks8695p()	(machine_arch_type == MACH_TYPE_KS8695P)
+#else
+# define machine_is_ks8695p()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SE4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4000
+# endif
+# define machine_is_se4000()	(machine_arch_type == MACH_TYPE_SE4000)
+#else
+# define machine_is_se4000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUADRICEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUADRICEPS
+# endif
+# define machine_is_quadriceps()	(machine_arch_type == MACH_TYPE_QUADRICEPS)
+#else
+# define machine_is_quadriceps()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRONCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRONCO
+# endif
+# define machine_is_bronco()	(machine_arch_type == MACH_TYPE_BRONCO)
+#else
+# define machine_is_bronco()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SOFCOMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SOFCOMP
+# endif
+# define machine_is_esl_sofcomp()	(machine_arch_type == MACH_TYPE_ESL_SOFCOMP)
+#else
+# define machine_is_esl_sofcomp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S5C7375
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7375
+# endif
+# define machine_is_s5c7375()	(machine_arch_type == MACH_TYPE_S5C7375)
+#else
+# define machine_is_s5c7375()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPEARHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEARHEAD
+# endif
+# define machine_is_spearhead()	(machine_arch_type == MACH_TYPE_SPEARHEAD)
+#else
+# define machine_is_spearhead()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PANTERA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANTERA
+# endif
+# define machine_is_pantera()	(machine_arch_type == MACH_TYPE_PANTERA)
+#else
+# define machine_is_pantera()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRAYOGLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAYOGLITE
+# endif
+# define machine_is_prayoglite()	(machine_arch_type == MACH_TYPE_PRAYOGLITE)
+#else
+# define machine_is_prayoglite()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIK
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIK)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RCUBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RCUBE
+# endif
+# define machine_is_rcube()	(machine_arch_type == MACH_TYPE_RCUBE)
+#else
+# define machine_is_rcube()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_REA_OLV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_OLV
+# endif
+# define machine_is_rea_olv()	(machine_arch_type == MACH_TYPE_REA_OLV)
+#else
+# define machine_is_rea_olv()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IPHONE
+# endif
+# define machine_is_pxa_iphone()	(machine_arch_type == MACH_TYPE_PXA_IPHONE)
+#else
+# define machine_is_pxa_iphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C3410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C3410
+# endif
+# define machine_is_s3c3410()	(machine_arch_type == MACH_TYPE_S3C3410)
+#else
+# define machine_is_s3c3410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESPD_4510B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPD_4510B
+# endif
+# define machine_is_espd_4510b()	(machine_arch_type == MACH_TYPE_ESPD_4510B)
+#else
+# define machine_is_espd_4510b()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MP1X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1X
+# endif
+# define machine_is_mp1x()	(machine_arch_type == MACH_TYPE_MP1X)
+#else
+# define machine_is_mp1x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200TB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200TB
+# endif
+# define machine_is_at91rm9200tb()	(machine_arch_type == MACH_TYPE_AT91RM9200TB)
+#else
+# define machine_is_at91rm9200tb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSVGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVGX
+# endif
+# define machine_is_adsvgx()	(machine_arch_type == MACH_TYPE_ADSVGX)
+#else
+# define machine_is_adsvgx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PELEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELEE
+# endif
+# define machine_is_pelee()	(machine_arch_type == MACH_TYPE_PELEE)
+#else
+# define machine_is_pelee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FUJITSU_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_CAMELOT
+# endif
+# define machine_is_fujitsu_camelot()	(machine_arch_type == MACH_TYPE_FUJITSU_CAMELOT)
+#else
+# define machine_is_fujitsu_camelot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JANUS2M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS2M
+# endif
+# define machine_is_janus2m()	(machine_arch_type == MACH_TYPE_JANUS2M)
+#else
+# define machine_is_janus2m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMBTF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMBTF
+# endif
+# define machine_is_embtf()	(machine_arch_type == MACH_TYPE_EMBTF)
+#else
+# define machine_is_embtf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPM
+# endif
+# define machine_is_hpm()	(machine_arch_type == MACH_TYPE_HPM)
+#else
+# define machine_is_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410TK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410TK
+# endif
+# define machine_is_smdk2410tk()	(machine_arch_type == MACH_TYPE_SMDK2410TK)
+#else
+# define machine_is_smdk2410tk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410AJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410AJ
+# endif
+# define machine_is_smdk2410aj()	(machine_arch_type == MACH_TYPE_SMDK2410AJ)
+#else
+# define machine_is_smdk2410aj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STREETRACER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STREETRACER
+# endif
+# define machine_is_streetracer()	(machine_arch_type == MACH_TYPE_STREETRACER)
+#else
+# define machine_is_streetracer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EFRAME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EFRAME
+# endif
+# define machine_is_eframe()	(machine_arch_type == MACH_TYPE_EFRAME)
+#else
+# define machine_is_eframe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_LARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_LARK
+# endif
+# define machine_is_pxa_lark()	(machine_arch_type == MACH_TYPE_PXA_LARK)
+#else
+# define machine_is_pxa_lark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP2110
+# endif
+# define machine_is_pxa_pnp2110()	(machine_arch_type == MACH_TYPE_PNP2110)
+#else
+# define machine_is_pxa_pnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC72X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC72X
+# endif
+# define machine_is_tcc72x()	(machine_arch_type == MACH_TYPE_TCC72X)
+#else
+# define machine_is_tcc72x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALTAIR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALTAIR
+# endif
+# define machine_is_altair()	(machine_arch_type == MACH_TYPE_ALTAIR)
+#else
+# define machine_is_altair()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KC3
+# endif
+# define machine_is_kc3()	(machine_arch_type == MACH_TYPE_KC3)
+#else
+# define machine_is_kc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SINTEFTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SINTEFTD
+# endif
+# define machine_is_sinteftd()	(machine_arch_type == MACH_TYPE_SINTEFTD)
+#else
+# define machine_is_sinteftd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADAY4X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADAY4X
+# endif
+# define machine_is_aday4x()	(machine_arch_type == MACH_TYPE_ADAY4X)
+#else
+# define machine_is_aday4x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITE300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITE300
+# endif
+# define machine_is_lite300()	(machine_arch_type == MACH_TYPE_LITE300)
+#else
+# define machine_is_lite300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5C7376
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7376
+# endif
+# define machine_is_s5c7376()	(machine_arch_type == MACH_TYPE_S5C7376)
+#else
+# define machine_is_s5c7376()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT02
+# endif
+# define machine_is_mt02()	(machine_arch_type == MACH_TYPE_MT02)
+#else
+# define machine_is_mt02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPORT3S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3S
+# endif
+# define machine_is_mport3s()	(machine_arch_type == MACH_TYPE_MPORT3S)
+#else
+# define machine_is_mport3s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RA_ALPHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RA_ALPHA
+# endif
+# define machine_is_ra_alpha()	(machine_arch_type == MACH_TYPE_RA_ALPHA)
+#else
+# define machine_is_ra_alpha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_VULCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
+# endif
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
+#else
+# define machine_is_arcom_vulcan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE
+# endif
+# define machine_is_stargate()	(machine_arch_type == MACH_TYPE_STARGATE)
+#else
+# define machine_is_stargate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLOJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLOJ
+# endif
+# define machine_is_armadilloj()	(machine_arch_type == MACH_TYPE_ARMADILLOJ)
+#else
+# define machine_is_armadilloj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELROY_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY_JACK
+# endif
+# define machine_is_elroy_jack()	(machine_arch_type == MACH_TYPE_ELROY_JACK)
+#else
+# define machine_is_elroy_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BACKEND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BACKEND
+# endif
+# define machine_is_backend()	(machine_arch_type == MACH_TYPE_BACKEND)
+#else
+# define machine_is_backend()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5LINBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5LINBOX
+# endif
+# define machine_is_s5linbox()	(machine_arch_type == MACH_TYPE_S5LINBOX)
+#else
+# define machine_is_s5linbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_CPU_9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_CPU_9200
+# endif
+# define machine_is_ia_cpu_9200()	(machine_arch_type == MACH_TYPE_IA_CPU_9200)
+#else
+# define machine_is_ia_cpu_9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91_BJA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91_BJA1
+# endif
+# define machine_is_at91_bja1()	(machine_arch_type == MACH_TYPE_AT91_BJA1)
+#else
+# define machine_is_at91_bja1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEN
+# endif
+# define machine_is_ten()	(machine_arch_type == MACH_TYPE_TEN)
+#else
+# define machine_is_ten()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP5P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP5P
+# endif
+# define machine_is_roverp5p()	(machine_arch_type == MACH_TYPE_ROVERP5P)
+#else
+# define machine_is_roverp5p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC2700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC2700
+# endif
+# define machine_is_sc2700()	(machine_arch_type == MACH_TYPE_SC2700)
+#else
+# define machine_is_sc2700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EX_EAGLE
+# endif
+# define machine_is_ex_eagle()	(machine_arch_type == MACH_TYPE_EX_EAGLE)
+#else
+# define machine_is_ex_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA12
+# endif
+# define machine_is_nx_pxa12()	(machine_arch_type == MACH_TYPE_NX_PXA12)
+#else
+# define machine_is_nx_pxa12()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA5
+# endif
+# define machine_is_nx_pxa5()	(machine_arch_type == MACH_TYPE_NX_PXA5)
+#else
+# define machine_is_nx_pxa5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKBOARD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKBOARD2
+# endif
+# define machine_is_blackboard2()	(machine_arch_type == MACH_TYPE_BLACKBOARD2)
+#else
+# define machine_is_blackboard2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I819
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I819
+# endif
+# define machine_is_i819()	(machine_arch_type == MACH_TYPE_I819)
+#else
+# define machine_is_i819()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXMB995E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXMB995E
+# endif
+# define machine_is_ixmb995e()	(machine_arch_type == MACH_TYPE_IXMB995E)
+#else
+# define machine_is_ixmb995e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYRIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYRIDER
+# endif
+# define machine_is_skyrider()	(machine_arch_type == MACH_TYPE_SKYRIDER)
+#else
+# define machine_is_skyrider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYHAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYHAWK
+# endif
+# define machine_is_skyhawk()	(machine_arch_type == MACH_TYPE_SKYHAWK)
+#else
+# define machine_is_skyhawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENTERPRISE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTERPRISE
+# endif
+# define machine_is_enterprise()	(machine_arch_type == MACH_TYPE_ENTERPRISE)
+#else
+# define machine_is_enterprise()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410
+# endif
+# define machine_is_dep2410()	(machine_arch_type == MACH_TYPE_DEP2410)
+#else
+# define machine_is_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOBBIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOBBIT
+# endif
+# define machine_is_hobbit()	(machine_arch_type == MACH_TYPE_HOBBIT)
+#else
+# define machine_is_hobbit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7210
+# endif
+# define machine_is_h7210()	(machine_arch_type == MACH_TYPE_H7210)
+#else
+# define machine_is_h7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_NETDCU5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU5
+# endif
+# define machine_is_pxa_netdcu5()	(machine_arch_type == MACH_TYPE_PXA_NETDCU5)
+#else
+# define machine_is_pxa_netdcu5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACC
+# endif
+# define machine_is_acc()	(machine_arch_type == MACH_TYPE_ACC)
+#else
+# define machine_is_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA
+# endif
+# define machine_is_esl_sarva()	(machine_arch_type == MACH_TYPE_ESL_SARVA)
+#else
+# define machine_is_esl_sarva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XM250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XM250
+# endif
+# define machine_is_xm250()	(machine_arch_type == MACH_TYPE_XM250)
+#else
+# define machine_is_xm250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T6TC1XB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T6TC1XB
+# endif
+# define machine_is_t6tc1xb()	(machine_arch_type == MACH_TYPE_T6TC1XB)
+#else
+# define machine_is_t6tc1xb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS710
+# endif
+# define machine_is_ess710()	(machine_arch_type == MACH_TYPE_ESS710)
+#else
+# define machine_is_ess710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31ADS
+# endif
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
+#else
+# define machine_is_mx31ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOLFENK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOLFENK
+# endif
+# define machine_is_bolfenk()	(machine_arch_type == MACH_TYPE_BOLFENK)
+#else
+# define machine_is_bolfenk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KR
+# endif
+# define machine_is_at91rm9200kr()	(machine_arch_type == MACH_TYPE_AT91RM9200KR)
+#else
+# define machine_is_at91rm9200kr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXIMX3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIMX3
+# endif
+# define machine_is_aximx3()	(machine_arch_type == MACH_TYPE_AXIMX3)
+#else
+# define machine_is_aximx3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB67XDIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB67XDIP
+# endif
+# define machine_is_eb67xdip()	(machine_arch_type == MACH_TYPE_EB67XDIP)
+#else
+# define machine_is_eb67xdip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBTXS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBTXS
+# endif
+# define machine_is_webtxs()	(machine_arch_type == MACH_TYPE_WEBTXS)
+#else
+# define machine_is_webtxs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAWK
+# endif
+# define machine_is_hawk()	(machine_arch_type == MACH_TYPE_HAWK)
+#else
+# define machine_is_hawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCAT91SBC001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCAT91SBC001
+# endif
+# define machine_is_ccat91sbc001()	(machine_arch_type == MACH_TYPE_CCAT91SBC001)
+#else
+# define machine_is_ccat91sbc001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSO
+# endif
+# define machine_is_expresso()	(machine_arch_type == MACH_TYPE_EXPRESSO)
+#else
+# define machine_is_expresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4000
+# endif
+# define machine_is_h4000()	(machine_arch_type == MACH_TYPE_H4000)
+#else
+# define machine_is_h4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINO
+# endif
+# define machine_is_dino()	(machine_arch_type == MACH_TYPE_DINO)
+#else
+# define machine_is_dino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML675K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML675K
+# endif
+# define machine_is_ml675k()	(machine_arch_type == MACH_TYPE_ML675K)
+#else
+# define machine_is_ml675k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECIVA_TT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECIVA_TT
+# endif
+# define machine_is_reciva_tt()	(machine_arch_type == MACH_TYPE_RECIVA_TT)
+#else
+# define machine_is_reciva_tt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB01
+# endif
+# define machine_is_cstcb01()	(machine_arch_type == MACH_TYPE_CSTCB01)
+#else
+# define machine_is_cstcb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB1
+# endif
+# define machine_is_cstcb1()	(machine_arch_type == MACH_TYPE_CSTCB1)
+#else
+# define machine_is_cstcb1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHADWELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHADWELL
+# endif
+# define machine_is_shadwell()	(machine_arch_type == MACH_TYPE_SHADWELL)
+#else
+# define machine_is_shadwell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOEPEL263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOEPEL263
+# endif
+# define machine_is_goepel263()	(machine_arch_type == MACH_TYPE_GOEPEL263)
+#else
+# define machine_is_goepel263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ100
+# endif
+# define machine_is_acq100()	(machine_arch_type == MACH_TYPE_ACQ100)
+#else
+# define machine_is_acq100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX1FS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1FS2
+# endif
+# define machine_is_mx1fs2()	(machine_arch_type == MACH_TYPE_MX1FS2)
+#else
+# define machine_is_mx1fs2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPTOP_G1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPTOP_G1
+# endif
+# define machine_is_hiptop_g1()	(machine_arch_type == MACH_TYPE_HIPTOP_G1)
+#else
+# define machine_is_hiptop_g1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARKY
+# endif
+# define machine_is_sparky()	(machine_arch_type == MACH_TYPE_SPARKY)
+#else
+# define machine_is_sparky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS9750
+# endif
+# define machine_is_ns9750()	(machine_arch_type == MACH_TYPE_NS9750)
+#else
+# define machine_is_ns9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHOENIX
+# endif
+# define machine_is_phoenix()	(machine_arch_type == MACH_TYPE_PHOENIX)
+#else
+# define machine_is_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTERPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTERPXA
+# endif
+# define machine_is_deisterpxa()	(machine_arch_type == MACH_TYPE_DEISTERPXA)
+#else
+# define machine_is_deisterpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM1160
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM1160
+# endif
+# define machine_is_bcm1160()	(machine_arch_type == MACH_TYPE_BCM1160)
+#else
+# define machine_is_bcm1160()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM022
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM022
+# endif
+# define machine_is_pcm022()	(machine_arch_type == MACH_TYPE_PCM022)
+#else
+# define machine_is_pcm022()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSGCX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSGCX
+# endif
+# define machine_is_adsgcx()	(machine_arch_type == MACH_TYPE_ADSGCX)
+#else
+# define machine_is_adsgcx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DREADNAUGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DREADNAUGHT
+# endif
+# define machine_is_dreadnaught()	(machine_arch_type == MACH_TYPE_DREADNAUGHT)
+#else
+# define machine_is_dreadnaught()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM320
+# endif
+# define machine_is_dm320()	(machine_arch_type == MACH_TYPE_DM320)
+#else
+# define machine_is_dm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARKOV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARKOV
+# endif
+# define machine_is_markov()	(machine_arch_type == MACH_TYPE_MARKOV)
+#else
+# define machine_is_markov()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COS7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COS7A400
+# endif
+# define machine_is_cos7a400()	(machine_arch_type == MACH_TYPE_COS7A400)
+#else
+# define machine_is_cos7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILANO
+# endif
+# define machine_is_milano()	(machine_arch_type == MACH_TYPE_MILANO)
+#else
+# define machine_is_milano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE9328
+# endif
+# define machine_is_ue9328()	(machine_arch_type == MACH_TYPE_UE9328)
+#else
+# define machine_is_ue9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEX255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEX255
+# endif
+# define machine_is_uex255()	(machine_arch_type == MACH_TYPE_UEX255)
+#else
+# define machine_is_uex255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE2410
+# endif
+# define machine_is_ue2410()	(machine_arch_type == MACH_TYPE_UE2410)
+#else
+# define machine_is_ue2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A620
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A620
+# endif
+# define machine_is_a620()	(machine_arch_type == MACH_TYPE_A620)
+#else
+# define machine_is_a620()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCELOT
+# endif
+# define machine_is_ocelot()	(machine_arch_type == MACH_TYPE_OCELOT)
+#else
+# define machine_is_ocelot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHEETAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHEETAH
+# endif
+# define machine_is_cheetah()	(machine_arch_type == MACH_TYPE_CHEETAH)
+#else
+# define machine_is_cheetah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZVUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZVUE
+# endif
+# define machine_is_zvue()	(machine_arch_type == MACH_TYPE_ZVUE)
+#else
+# define machine_is_zvue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP1
+# endif
+# define machine_is_roverp1()	(machine_arch_type == MACH_TYPE_ROVERP1)
+#else
+# define machine_is_roverp1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASIDIAL2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASIDIAL2
+# endif
+# define machine_is_asidial2()	(machine_arch_type == MACH_TYPE_ASIDIAL2)
+#else
+# define machine_is_asidial2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C24A0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C24A0
+# endif
+# define machine_is_s3c24a0()	(machine_arch_type == MACH_TYPE_S3C24A0)
+#else
+# define machine_is_s3c24a0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5500
+# endif
+# define machine_is_s3c5500()	(machine_arch_type == MACH_TYPE_S3C5500)
+#else
+# define machine_is_s3c5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5500
+# endif
+# define machine_is_smdk5500()	(machine_arch_type == MACH_TYPE_SMDK5500)
+#else
+# define machine_is_smdk5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIGNALSYNC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIGNALSYNC
+# endif
+# define machine_is_signalsync()	(machine_arch_type == MACH_TYPE_SIGNALSYNC)
+#else
+# define machine_is_signalsync()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NBC
+# endif
+# define machine_is_nbc()	(machine_arch_type == MACH_TYPE_NBC)
+#else
+# define machine_is_nbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KODIAK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KODIAK
+# endif
+# define machine_is_kodiak()	(machine_arch_type == MACH_TYPE_KODIAK)
+#else
+# define machine_is_kodiak()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETBOOKPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETBOOKPRO
+# endif
+# define machine_is_netbookpro()	(machine_arch_type == MACH_TYPE_NETBOOKPRO)
+#else
+# define machine_is_netbookpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90200
+# endif
+# define machine_is_hw90200()	(machine_arch_type == MACH_TYPE_HW90200)
+#else
+# define machine_is_hw90200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONDOR
+# endif
+# define machine_is_condor()	(machine_arch_type == MACH_TYPE_CONDOR)
+#else
+# define machine_is_condor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CUP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CUP
+# endif
+# define machine_is_cup()	(machine_arch_type == MACH_TYPE_CUP)
+#else
+# define machine_is_cup()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KITE
+# endif
+# define machine_is_kite()	(machine_arch_type == MACH_TYPE_KITE)
+#else
+# define machine_is_kite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N10
+# endif
+# define machine_is_n10()	(machine_arch_type == MACH_TYPE_N10)
+#else
+# define machine_is_n10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONTAJADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONTAJADE
+# endif
+# define machine_is_montejade()	(machine_arch_type == MACH_TYPE_MONTAJADE)
+#else
+# define machine_is_montejade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560
+# endif
+# define machine_is_sg560()	(machine_arch_type == MACH_TYPE_SG560)
+#else
+# define machine_is_sg560()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP1000
+# endif
+# define machine_is_dp1000()	(machine_arch_type == MACH_TYPE_DP1000)
+#else
+# define machine_is_dp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RG100V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RG100V3
+# endif
+# define machine_is_rg100v3()	(machine_arch_type == MACH_TYPE_RG100V3)
+#else
+# define machine_is_rg100v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2ADS
+# endif
+# define machine_is_mx2ads()	(machine_arch_type == MACH_TYPE_MX2ADS)
+#else
+# define machine_is_mx2ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KILO
+# endif
+# define machine_is_pxa_kilo()	(machine_arch_type == MACH_TYPE_PXA_KILO)
+#else
+# define machine_is_pxa_kilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP4XX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_EAGLE
+# endif
+# define machine_is_ixp4xx_eagle()	(machine_arch_type == MACH_TYPE_IXP4XX_EAGLE)
+#else
+# define machine_is_ixp4xx_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB2520F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB2520F
+# endif
+# define machine_is_mb2520f()	(machine_arch_type == MACH_TYPE_MB2520F)
+#else
+# define machine_is_mb2520f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMC1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMC1000
+# endif
+# define machine_is_emc1000()	(machine_arch_type == MACH_TYPE_EMC1000)
+#else
+# define machine_is_emc1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIDSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIDSC25
+# endif
+# define machine_is_tidsc25()	(machine_arch_type == MACH_TYPE_TIDSC25)
+#else
+# define machine_is_tidsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKCPMXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKCPMXL
+# endif
+# define machine_is_akcpmxl()	(machine_arch_type == MACH_TYPE_AKCPMXL)
+#else
+# define machine_is_akcpmxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AV3XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV3XX
+# endif
+# define machine_is_av3xx()	(machine_arch_type == MACH_TYPE_AV3XX)
+#else
+# define machine_is_av3xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_MPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MPM10
+# endif
+# define machine_is_pxa_mpm10()	(machine_arch_type == MACH_TYPE_PXA_MPM10)
+#else
+# define machine_is_pxa_mpm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KYANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KYANITE
+# endif
+# define machine_is_pxa_kyanite()	(machine_arch_type == MACH_TYPE_PXA_KYANITE)
+#else
+# define machine_is_pxa_kyanite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGOLD
+# endif
+# define machine_is_sgold()	(machine_arch_type == MACH_TYPE_SGOLD)
+#else
+# define machine_is_sgold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSCAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSCAR
+# endif
+# define machine_is_oscar()	(machine_arch_type == MACH_TYPE_OSCAR)
+#else
+# define machine_is_oscar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPXA4USB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPXA4USB2
+# endif
+# define machine_is_epxa4usb2()	(machine_arch_type == MACH_TYPE_EPXA4USB2)
+#else
+# define machine_is_epxa4usb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSENGINE
+# endif
+# define machine_is_xsengine()	(machine_arch_type == MACH_TYPE_XSENGINE)
+#else
+# define machine_is_xsengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP600
+# endif
+# define machine_is_ip600()	(machine_arch_type == MACH_TYPE_IP600)
+#else
+# define machine_is_ip600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCAN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCAN2
+# endif
+# define machine_is_mcan2()	(machine_arch_type == MACH_TYPE_MCAN2)
+#else
+# define machine_is_mcan2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDI_BLUERIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDI_BLUERIDGE
+# endif
+# define machine_is_ddi_blueridge()	(machine_arch_type == MACH_TYPE_DDI_BLUERIDGE)
+#else
+# define machine_is_ddi_blueridge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMINDER
+# endif
+# define machine_is_skyminder()	(machine_arch_type == MACH_TYPE_SKYMINDER)
+#else
+# define machine_is_skyminder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79520
+# endif
+# define machine_is_lpd79520()	(machine_arch_type == MACH_TYPE_LPD79520)
+#else
+# define machine_is_lpd79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90340
+# endif
+# define machine_is_hw90340()	(machine_arch_type == MACH_TYPE_HW90340)
+#else
+# define machine_is_hw90340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CIP_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CIP_BOX
+# endif
+# define machine_is_cip_box()	(machine_arch_type == MACH_TYPE_CIP_BOX)
+#else
+# define machine_is_cip_box()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IVPN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IVPN
+# endif
+# define machine_is_ivpn()	(machine_arch_type == MACH_TYPE_IVPN)
+#else
+# define machine_is_ivpn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSOC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSOC2
+# endif
+# define machine_is_rsoc2()	(machine_arch_type == MACH_TYPE_RSOC2)
+#else
+# define machine_is_rsoc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOXER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOXER
+# endif
+# define machine_is_boxer()	(machine_arch_type == MACH_TYPE_BOXER)
+#else
+# define machine_is_boxer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML42800AA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML42800AA
+# endif
+# define machine_is_aml42800aa()	(machine_arch_type == MACH_TYPE_AML42800AA)
+#else
+# define machine_is_aml42800aa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_TYPE_ML674001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_TYPE_ML674001
+# endif
+# define machine_is_ml674001()	(machine_arch_type == MACH_TYPE_MACH_TYPE_ML674001)
+#else
+# define machine_is_ml674001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC2294
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC2294
+# endif
+# define machine_is_lpc2294()	(machine_arch_type == MACH_TYPE_LPC2294)
+#else
+# define machine_is_lpc2294()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWITCHGRASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWITCHGRASS
+# endif
+# define machine_is_switchgrass()	(machine_arch_type == MACH_TYPE_SWITCHGRASS)
+#else
+# define machine_is_switchgrass()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENS_CMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENS_CMU
+# endif
+# define machine_is_ens_cmu()	(machine_arch_type == MACH_TYPE_ENS_CMU)
+#else
+# define machine_is_ens_cmu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MM6_SDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MM6_SDB
+# endif
+# define machine_is_mm6_sdb()	(machine_arch_type == MACH_TYPE_MM6_SDB)
+#else
+# define machine_is_mm6_sdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATURN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATURN
+# endif
+# define machine_is_saturn()	(machine_arch_type == MACH_TYPE_SATURN)
+#else
+# define machine_is_saturn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I30030EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I30030EVB
+# endif
+# define machine_is_i30030evb()	(machine_arch_type == MACH_TYPE_I30030EVB)
+#else
+# define machine_is_i30030evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27530EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27530EVB
+# endif
+# define machine_is_mxc27530evb()	(machine_arch_type == MACH_TYPE_MXC27530EVB)
+#else
+# define machine_is_mxc27530evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2800
+# endif
+# define machine_is_smdk2800()	(machine_arch_type == MACH_TYPE_SMDK2800)
+#else
+# define machine_is_smdk2800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTWILSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTWILSON
+# endif
+# define machine_is_mtwilson()	(machine_arch_type == MACH_TYPE_MTWILSON)
+#else
+# define machine_is_mtwilson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZITI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZITI
+# endif
+# define machine_is_ziti()	(machine_arch_type == MACH_TYPE_ZITI)
+#else
+# define machine_is_ziti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GRANDFATHER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANDFATHER
+# endif
+# define machine_is_grandfather()	(machine_arch_type == MACH_TYPE_GRANDFATHER)
+#else
+# define machine_is_grandfather()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TENGINE
+# endif
+# define machine_is_tengine()	(machine_arch_type == MACH_TYPE_TENGINE)
+#else
+# define machine_is_tengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2460
+# endif
+# define machine_is_s3c2460()	(machine_arch_type == MACH_TYPE_S3C2460)
+#else
+# define machine_is_s3c2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDM
+# endif
+# define machine_is_pdm()	(machine_arch_type == MACH_TYPE_PDM)
+#else
+# define machine_is_pdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6300
+# endif
+# define machine_is_h6300()	(machine_arch_type == MACH_TYPE_H6300)
+#else
+# define machine_is_h6300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RZ1700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RZ1700
+# endif
+# define machine_is_rz1700()	(machine_arch_type == MACH_TYPE_RZ1700)
+#else
+# define machine_is_rz1700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A716
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A716
+# endif
+# define machine_is_a716()	(machine_arch_type == MACH_TYPE_A716)
+#else
+# define machine_is_a716()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESTK2440A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESTK2440A
+# endif
+# define machine_is_estk2440a()	(machine_arch_type == MACH_TYPE_ESTK2440A)
+#else
+# define machine_is_estk2440a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATWIXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATWIXP425
+# endif
+# define machine_is_atwixp425()	(machine_arch_type == MACH_TYPE_ATWIXP425)
+#else
+# define machine_is_atwixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB336
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB336
+# endif
+# define machine_is_csb336()	(machine_arch_type == MACH_TYPE_CSB336)
+#else
+# define machine_is_csb336()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIRM2
+# endif
+# define machine_is_rirm2()	(machine_arch_type == MACH_TYPE_RIRM2)
+#else
+# define machine_is_rirm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX23518
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX23518
+# endif
+# define machine_is_cx23518()	(machine_arch_type == MACH_TYPE_CX23518)
+#else
+# define machine_is_cx23518()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX2351X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX2351X
+# endif
+# define machine_is_cx2351x()	(machine_arch_type == MACH_TYPE_CX2351X)
+#else
+# define machine_is_cx2351x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPUTIME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPUTIME
+# endif
+# define machine_is_computime()	(machine_arch_type == MACH_TYPE_COMPUTIME)
+#else
+# define machine_is_computime()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IZARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IZARUS
+# endif
+# define machine_is_izarus()	(machine_arch_type == MACH_TYPE_IZARUS)
+#else
+# define machine_is_izarus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RTS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RTS
+# endif
+# define machine_is_pxa_rts()	(machine_arch_type == MACH_TYPE_RTS)
+#else
+# define machine_is_pxa_rts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE5100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE5100
+# endif
+# define machine_is_se5100()	(machine_arch_type == MACH_TYPE_SE5100)
+#else
+# define machine_is_se5100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2510
+# endif
+# define machine_is_s3c2510()	(machine_arch_type == MACH_TYPE_S3C2510)
+#else
+# define machine_is_s3c2510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB437TL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB437TL
+# endif
+# define machine_is_csb437tl()	(machine_arch_type == MACH_TYPE_CSB437TL)
+#else
+# define machine_is_csb437tl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLAUSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLAUSON
+# endif
+# define machine_is_slauson()	(machine_arch_type == MACH_TYPE_SLAUSON)
+#else
+# define machine_is_slauson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEARLRIVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEARLRIVER
+# endif
+# define machine_is_pearlriver()	(machine_arch_type == MACH_TYPE_PEARLRIVER)
+#else
+# define machine_is_pearlriver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TDC_P210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TDC_P210
+# endif
+# define machine_is_tdc_p210()	(machine_arch_type == MACH_TYPE_TDC_P210)
+#else
+# define machine_is_tdc_p210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG580
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG580
+# endif
+# define machine_is_sg580()	(machine_arch_type == MACH_TYPE_SG580)
+#else
+# define machine_is_sg580()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRSBCARM7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRSBCARM7
+# endif
+# define machine_is_wrsbcarm7()	(machine_arch_type == MACH_TYPE_WRSBCARM7)
+#else
+# define machine_is_wrsbcarm7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPD
+# endif
+# define machine_is_ipd()	(machine_arch_type == MACH_TYPE_IPD)
+#else
+# define machine_is_ipd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_DNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_DNP2110
+# endif
+# define machine_is_pxa_dnp2110()	(machine_arch_type == MACH_TYPE_PXA_DNP2110)
+#else
+# define machine_is_pxa_dnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XAENIAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XAENIAX
+# endif
+# define machine_is_xaeniax()	(machine_arch_type == MACH_TYPE_XAENIAX)
+#else
+# define machine_is_xaeniax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOMN4250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOMN4250
+# endif
+# define machine_is_somn4250()	(machine_arch_type == MACH_TYPE_SOMN4250)
+#else
+# define machine_is_somn4250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLEB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB2
+# endif
+# define machine_is_pleb2()	(machine_arch_type == MACH_TYPE_PLEB2)
+#else
+# define machine_is_pleb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORNWALLIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORNWALLIS
+# endif
+# define machine_is_cornwallis()	(machine_arch_type == MACH_TYPE_CORNWALLIS)
+#else
+# define machine_is_cornwallis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURNEY_DRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURNEY_DRV
+# endif
+# define machine_is_gurney_drv()	(machine_arch_type == MACH_TYPE_GURNEY_DRV)
+#else
+# define machine_is_gurney_drv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHAFFEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHAFFEE
+# endif
+# define machine_is_chaffee()	(machine_arch_type == MACH_TYPE_CHAFFEE)
+#else
+# define machine_is_chaffee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS101
+# endif
+# define machine_is_rms101()	(machine_arch_type == MACH_TYPE_RMS101)
+#else
+# define machine_is_rms101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWIFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWIFT
+# endif
+# define machine_is_swift()	(machine_arch_type == MACH_TYPE_SWIFT)
+#else
+# define machine_is_swift()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP7
+# endif
+# define machine_is_roverp7()	(machine_arch_type == MACH_TYPE_ROVERP7)
+#else
+# define machine_is_roverp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PR818S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PR818S
+# endif
+# define machine_is_pr818s()	(machine_arch_type == MACH_TYPE_PR818S)
+#else
+# define machine_is_pr818s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRXPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRXPRO
+# endif
+# define machine_is_trxpro()	(machine_arch_type == MACH_TYPE_TRXPRO)
+#else
+# define machine_is_trxpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRAB
+# endif
+# define machine_is_trab()	(machine_arch_type == MACH_TYPE_TRAB)
+#else
+# define machine_is_trab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMC_PU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMC_PU2
+# endif
+# define machine_is_cmc_pu2()	(machine_arch_type == MACH_TYPE_CMC_PU2)
+#else
+# define machine_is_cmc_pu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FULCRUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FULCRUM
+# endif
+# define machine_is_fulcrum()	(machine_arch_type == MACH_TYPE_FULCRUM)
+#else
+# define machine_is_fulcrum()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETGATE42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATE42X
+# endif
+# define machine_is_netgate42x()	(machine_arch_type == MACH_TYPE_NETGATE42X)
+#else
+# define machine_is_netgate42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR710
+# endif
+# define machine_is_str710()	(machine_arch_type == MACH_TYPE_STR710)
+#else
+# define machine_is_str710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOMTOMGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOMTOMGO
+# endif
+# define machine_is_tomtomgo()	(machine_arch_type == MACH_TYPE_TOMTOMGO)
+#else
+# define machine_is_tomtomgo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG565
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG565
+# endif
+# define machine_is_sg565()	(machine_arch_type == MACH_TYPE_SG565)
+#else
+# define machine_is_sg565()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79524
+# endif
+# define machine_is_lpd79524()	(machine_arch_type == MACH_TYPE_LPD79524)
+#else
+# define machine_is_lpd79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79525
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79525
+# endif
+# define machine_is_lpd79525()	(machine_arch_type == MACH_TYPE_LPD79525)
+#else
+# define machine_is_lpd79525()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS100
+# endif
+# define machine_is_rms100()	(machine_arch_type == MACH_TYPE_RMS100)
+#else
+# define machine_is_rms100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMS39C7092
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMS39C7092
+# endif
+# define machine_is_hms39c7092()	(machine_arch_type == MACH_TYPE_HMS39C7092)
+#else
+# define machine_is_hms39c7092()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO
+# endif
+# define machine_is_armadillo()	(machine_arch_type == MACH_TYPE_ARMADILLO)
+#else
+# define machine_is_armadillo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPCU
+# endif
+# define machine_is_ipcu()	(machine_arch_type == MACH_TYPE_IPCU)
+#else
+# define machine_is_ipcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX720
+# endif
+# define machine_is_loox720()	(machine_arch_type == MACH_TYPE_LOOX720)
+#else
+# define machine_is_loox720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSVIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVIX
+# endif
+# define machine_is_adsvix()	(machine_arch_type == MACH_TYPE_ADSVIX)
+#else
+# define machine_is_adsvix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM270
+# endif
+# define machine_is_dm270()	(machine_arch_type == MACH_TYPE_DM270)
+#else
+# define machine_is_dm270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOCLTPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOCLTPLUS
+# endif
+# define machine_is_socltplus()	(machine_arch_type == MACH_TYPE_SOCLTPLUS)
+#else
+# define machine_is_socltplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECIA
+# endif
+# define machine_is_ecia()	(machine_arch_type == MACH_TYPE_ECIA)
+#else
+# define machine_is_ecia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4008
+# endif
+# define machine_is_cm4008()	(machine_arch_type == MACH_TYPE_CM4008)
+#else
+# define machine_is_cm4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P2001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P2001
+# endif
+# define machine_is_p2001()	(machine_arch_type == MACH_TYPE_P2001)
+#else
+# define machine_is_p2001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TWISTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TWISTER
+# endif
+# define machine_is_twister()	(machine_arch_type == MACH_TYPE_TWISTER)
+#else
+# define machine_is_twister()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MUDSHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MUDSHARK
+# endif
+# define machine_is_mudshark()	(machine_arch_type == MACH_TYPE_MUDSHARK)
+#else
+# define machine_is_mudshark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HB2
+# endif
+# define machine_is_hb2()	(machine_arch_type == MACH_TYPE_HB2)
+#else
+# define machine_is_hb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SENDT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SENDT
+# endif
+# define machine_is_sendt()	(machine_arch_type == MACH_TYPE_SENDT)
+#else
+# define machine_is_sendt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2JAZZ
+# endif
+# define machine_is_mx2jazz()	(machine_arch_type == MACH_TYPE_MX2JAZZ)
+#else
+# define machine_is_mx2jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIIO
+# endif
+# define machine_is_multiio()	(machine_arch_type == MACH_TYPE_MULTIIO)
+#else
+# define machine_is_multiio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HRDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HRDISPLAY
+# endif
+# define machine_is_hrdisplay()	(machine_arch_type == MACH_TYPE_HRDISPLAY)
+#else
+# define machine_is_hrdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27530ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27530ADS
+# endif
+# define machine_is_mxc27530ads()	(machine_arch_type == MACH_TYPE_MXC27530ADS)
+#else
+# define machine_is_mxc27530ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS3
+# endif
+# define machine_is_trizeps3()	(machine_arch_type == MACH_TYPE_TRIZEPS3)
+#else
+# define machine_is_trizeps3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZA
+# endif
+# define machine_is_zefeerdza()	(machine_arch_type == MACH_TYPE_ZEFEERDZA)
+#else
+# define machine_is_zefeerdza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZB
+# endif
+# define machine_is_zefeerdzb()	(machine_arch_type == MACH_TYPE_ZEFEERDZB)
+#else
+# define machine_is_zefeerdzb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZG
+# endif
+# define machine_is_zefeerdzg()	(machine_arch_type == MACH_TYPE_ZEFEERDZG)
+#else
+# define machine_is_zefeerdzg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZN
+# endif
+# define machine_is_zefeerdzn()	(machine_arch_type == MACH_TYPE_ZEFEERDZN)
+#else
+# define machine_is_zefeerdzn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZQ
+# endif
+# define machine_is_zefeerdzq()	(machine_arch_type == MACH_TYPE_ZEFEERDZQ)
+#else
+# define machine_is_zefeerdzq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASTRO_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASTRO_JACK
+# endif
+# define machine_is_astro_jack()	(machine_arch_type == MACH_TYPE_ASTRO_JACK)
+#else
+# define machine_is_astro_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIP03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIP03
+# endif
+# define machine_is_tip03()	(machine_arch_type == MACH_TYPE_TIP03)
+#else
+# define machine_is_tip03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9200EC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9200EC
+# endif
+# define machine_is_a9200ec()	(machine_arch_type == MACH_TYPE_A9200EC)
+#else
+# define machine_is_a9200ec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0105
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0105
+# endif
+# define machine_is_pnx0105()	(machine_arch_type == MACH_TYPE_PNX0105)
+#else
+# define machine_is_pnx0105()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADCPOECPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADCPOECPU
+# endif
+# define machine_is_adcpoecpu()	(machine_arch_type == MACH_TYPE_ADCPOECPU)
+#else
+# define machine_is_adcpoecpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML69Q6203
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML69Q6203
+# endif
+# define machine_is_ml69q6203()	(machine_arch_type == MACH_TYPE_ML69Q6203)
+#else
+# define machine_is_ml69q6203()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9200
+# endif
+# define machine_is_mb9200()	(machine_arch_type == MACH_TYPE_MB9200)
+#else
+# define machine_is_mb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KULUN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KULUN
+# endif
+# define machine_is_kulun()	(machine_arch_type == MACH_TYPE_KULUN)
+#else
+# define machine_is_kulun()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER
+# endif
+# define machine_is_snapper()	(machine_arch_type == MACH_TYPE_SNAPPER)
+#else
+# define machine_is_snapper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTIMA
+# endif
+# define machine_is_optima()	(machine_arch_type == MACH_TYPE_OPTIMA)
+#else
+# define machine_is_optima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLHSBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLHSBC
+# endif
+# define machine_is_dlhsbc()	(machine_arch_type == MACH_TYPE_DLHSBC)
+#else
+# define machine_is_dlhsbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X30
+# endif
+# define machine_is_x30()	(machine_arch_type == MACH_TYPE_X30)
+#else
+# define machine_is_x30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANGA_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANGA_KS8695
+# endif
+# define machine_is_manga_ks8695()	(machine_arch_type == MACH_TYPE_MANGA_KS8695)
+#else
+# define machine_is_manga_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX
+# endif
+# define machine_is_ajax()	(machine_arch_type == MACH_TYPE_AJAX)
+#else
+# define machine_is_ajax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK1000
+# endif
+# define machine_is_vvtk1000()	(machine_arch_type == MACH_TYPE_VVTK1000)
+#else
+# define machine_is_vvtk1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK3000
+# endif
+# define machine_is_vvtk3000()	(machine_arch_type == MACH_TYPE_VVTK3000)
+#else
+# define machine_is_vvtk3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIMX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIMX1
+# endif
+# define machine_is_pimx1()	(machine_arch_type == MACH_TYPE_PIMX1)
+#else
+# define machine_is_pimx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLLIE
+# endif
+# define machine_is_ollie()	(machine_arch_type == MACH_TYPE_OLLIE)
+#else
+# define machine_is_ollie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMAX
+# endif
+# define machine_is_skymax()	(machine_arch_type == MACH_TYPE_SKYMAX)
+#else
+# define machine_is_skymax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JAZZ
+# endif
+# define machine_is_jazz()	(machine_arch_type == MACH_TYPE_JAZZ)
+#else
+# define machine_is_jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEL_T3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEL_T3
+# endif
+# define machine_is_tel_t3()	(machine_arch_type == MACH_TYPE_TEL_T3)
+#else
+# define machine_is_tel_t3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AISINO_FCR255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AISINO_FCR255
+# endif
+# define machine_is_aisino_fcr255()	(machine_arch_type == MACH_TYPE_AISINO_FCR255)
+#else
+# define machine_is_aisino_fcr255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTWEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTWEB
+# endif
+# define machine_is_btweb()	(machine_arch_type == MACH_TYPE_BTWEB)
+#else
+# define machine_is_btweb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DBG_LH79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DBG_LH79520
+# endif
+# define machine_is_dbg_lh79520()	(machine_arch_type == MACH_TYPE_DBG_LH79520)
+#else
+# define machine_is_dbg_lh79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM41XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM41XX
+# endif
+# define machine_is_cm41xx()	(machine_arch_type == MACH_TYPE_CM41XX)
+#else
+# define machine_is_cm41xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NGGPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NGGPXA
+# endif
+# define machine_is_nggpxa()	(machine_arch_type == MACH_TYPE_NGGPXA)
+#else
+# define machine_is_nggpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB535
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB535
+# endif
+# define machine_is_csb535()	(machine_arch_type == MACH_TYPE_CSB535)
+#else
+# define machine_is_csb535()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB536
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB536
+# endif
+# define machine_is_csb536()	(machine_arch_type == MACH_TYPE_CSB536)
+#else
+# define machine_is_csb536()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_TRAKPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_TRAKPOD
+# endif
+# define machine_is_pxa_trakpod()	(machine_arch_type == MACH_TYPE_PXA_TRAKPOD)
+#else
+# define machine_is_pxa_trakpod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRAXIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAXIS
+# endif
+# define machine_is_praxis()	(machine_arch_type == MACH_TYPE_PRAXIS)
+#else
+# define machine_is_praxis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LH75411
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LH75411
+# endif
+# define machine_is_lh75411()	(machine_arch_type == MACH_TYPE_LH75411)
+#else
+# define machine_is_lh75411()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX410
+# endif
+# define machine_is_loox410()	(machine_arch_type == MACH_TYPE_LOOX410)
+#else
+# define machine_is_loox410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WESTLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WESTLAKE
+# endif
+# define machine_is_westlake()	(machine_arch_type == MACH_TYPE_WESTLAKE)
+#else
+# define machine_is_westlake()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB
+# endif
+# define machine_is_nsb()	(machine_arch_type == MACH_TYPE_NSB)
+#else
+# define machine_is_nsb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_STN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_STN
+# endif
+# define machine_is_esl_sarva_stn()	(machine_arch_type == MACH_TYPE_ESL_SARVA_STN)
+#else
+# define machine_is_esl_sarva_stn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_TFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_TFT
+# endif
+# define machine_is_esl_sarva_tft()	(machine_arch_type == MACH_TYPE_ESL_SARVA_TFT)
+#else
+# define machine_is_esl_sarva_tft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_IAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_IAD
+# endif
+# define machine_is_esl_sarva_iad()	(machine_arch_type == MACH_TYPE_ESL_SARVA_IAD)
+#else
+# define machine_is_esl_sarva_iad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_ACC
+# endif
+# define machine_is_esl_sarva_acc()	(machine_arch_type == MACH_TYPE_ESL_SARVA_ACC)
+#else
+# define machine_is_esl_sarva_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TYPHOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TYPHOON
+# endif
+# define machine_is_typhoon()	(machine_arch_type == MACH_TYPE_TYPHOON)
+#else
+# define machine_is_typhoon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNAV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNAV
+# endif
+# define machine_is_cnav()	(machine_arch_type == MACH_TYPE_CNAV)
+#else
+# define machine_is_cnav()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A730
+# endif
+# define machine_is_a730()	(machine_arch_type == MACH_TYPE_A730)
+#else
+# define machine_is_a730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSTAR
+# endif
+# define machine_is_netstar()	(machine_arch_type == MACH_TYPE_NETSTAR)
+#else
+# define machine_is_netstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHASEFALE_SUPERCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHASEFALE_SUPERCON
+# endif
+# define machine_is_supercon()	(machine_arch_type == MACH_TYPE_PHASEFALE_SUPERCON)
+#else
+# define machine_is_supercon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHIVA1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHIVA1100
+# endif
+# define machine_is_shiva1100()	(machine_arch_type == MACH_TYPE_SHIVA1100)
+#else
+# define machine_is_shiva1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETEXSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETEXSC
+# endif
+# define machine_is_etexsc()	(machine_arch_type == MACH_TYPE_ETEXSC)
+#else
+# define machine_is_etexsc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG465
+# endif
+# define machine_is_ixdpg465()	(machine_arch_type == MACH_TYPE_IXDPG465)
+#else
+# define machine_is_ixdpg465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2410
+# endif
+# define machine_is_a9m2410()	(machine_arch_type == MACH_TYPE_A9M2410)
+#else
+# define machine_is_a9m2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2440
+# endif
+# define machine_is_a9m2440()	(machine_arch_type == MACH_TYPE_A9M2440)
+#else
+# define machine_is_a9m2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9750
+# endif
+# define machine_is_a9m9750()	(machine_arch_type == MACH_TYPE_A9M9750)
+#else
+# define machine_is_a9m9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9360
+# endif
+# define machine_is_a9m9360()	(machine_arch_type == MACH_TYPE_A9M9360)
+#else
+# define machine_is_a9m9360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNC90
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNC90
+# endif
+# define machine_is_unc90()	(machine_arch_type == MACH_TYPE_UNC90)
+#else
+# define machine_is_unc90()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATVIEW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATVIEW
+# endif
+# define machine_is_satview()	(machine_arch_type == MACH_TYPE_SATVIEW)
+#else
+# define machine_is_satview()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GP32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GP32
+# endif
+# define machine_is_gp32()	(machine_arch_type == MACH_TYPE_GP32)
+#else
+# define machine_is_gp32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEM
+# endif
+# define machine_is_gem()	(machine_arch_type == MACH_TYPE_GEM)
+#else
+# define machine_is_gem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I858
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I858
+# endif
+# define machine_is_i858()	(machine_arch_type == MACH_TYPE_I858)
+#else
+# define machine_is_i858()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX2750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX2750
+# endif
+# define machine_is_hx2750()	(machine_arch_type == MACH_TYPE_HX2750)
+#else
+# define machine_is_hx2750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC91131EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC91131EVB
+# endif
+# define machine_is_mxc91131evb()	(machine_arch_type == MACH_TYPE_MXC91131EVB)
+#else
+# define machine_is_mxc91131evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P700
+# endif
+# define machine_is_p700()	(machine_arch_type == MACH_TYPE_P700)
+#else
+# define machine_is_p700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPE
+# endif
+# define machine_is_cpe()	(machine_arch_type == MACH_TYPE_CPE)
+#else
+# define machine_is_cpe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NIMBRA340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA340
+# endif
+# define machine_is_nimbra340()	(machine_arch_type == MACH_TYPE_NIMBRA340)
+#else
+# define machine_is_nimbra340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC22XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC22XX
+# endif
+# define machine_is_lpc22xx()	(machine_arch_type == MACH_TYPE_LPC22XX)
+#else
+# define machine_is_lpc22xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET3
+# endif
+# define machine_is_omap_comet3()	(machine_arch_type == MACH_TYPE_COMET3)
+#else
+# define machine_is_omap_comet3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET4
+# endif
+# define machine_is_omap_comet4()	(machine_arch_type == MACH_TYPE_COMET4)
+#else
+# define machine_is_omap_comet4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB625
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB625
+# endif
+# define machine_is_csb625()	(machine_arch_type == MACH_TYPE_CSB625)
+#else
+# define machine_is_csb625()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FORTUNET2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET2
+# endif
+# define machine_is_fortunet2()	(machine_arch_type == MACH_TYPE_FORTUNET2)
+#else
+# define machine_is_fortunet2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5H2200
+# endif
+# define machine_is_s5h2200()	(machine_arch_type == MACH_TYPE_S5H2200)
+#else
+# define machine_is_s5h2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTORM920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTORM920
+# endif
+# define machine_is_optorm920()	(machine_arch_type == MACH_TYPE_OPTORM920)
+#else
+# define machine_is_optorm920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSBITSYXB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYXB
+# endif
+# define machine_is_adsbitsyxb()	(machine_arch_type == MACH_TYPE_ADSBITSYXB)
+#else
+# define machine_is_adsbitsyxb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSPORTAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSPORTAL
+# endif
+# define machine_is_adsportal()	(machine_arch_type == MACH_TYPE_ADSPORTAL)
+#else
+# define machine_is_adsportal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LN2410SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LN2410SBC
+# endif
+# define machine_is_ln2410sbc()	(machine_arch_type == MACH_TYPE_LN2410SBC)
+#else
+# define machine_is_ln2410sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CB3RUFC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CB3RUFC
+# endif
+# define machine_is_cb3rufc()	(machine_arch_type == MACH_TYPE_CB3RUFC)
+#else
+# define machine_is_cb3rufc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP2USB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP2USB
+# endif
+# define machine_is_mp2usb()	(machine_arch_type == MACH_TYPE_MP2USB)
+#else
+# define machine_is_mp2usb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NTNP425C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTNP425C
+# endif
+# define machine_is_ntnp425c()	(machine_arch_type == MACH_TYPE_NTNP425C)
+#else
+# define machine_is_ntnp425c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM7220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7220
+# endif
+# define machine_is_pcm7220()	(machine_arch_type == MACH_TYPE_PCM7220)
+#else
+# define machine_is_pcm7220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA
+# endif
+# define machine_is_cmpxa()	(machine_arch_type == MACH_TYPE_CMPXA)
+#else
+# define machine_is_cmpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ITE8152
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITE8152
+# endif
+# define machine_is_ite8152()	(machine_arch_type == MACH_TYPE_ITE8152)
+#else
+# define machine_is_ite8152()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC3XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC3XXX
+# endif
+# define machine_is_lpc3xxx()	(machine_arch_type == MACH_TYPE_LPC3XXX)
+#else
+# define machine_is_lpc3xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUPPETEER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPETEER
+# endif
+# define machine_is_puppeteer()	(machine_arch_type == MACH_TYPE_PUPPETEER)
+#else
+# define machine_is_puppeteer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_VADATECH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_VADATECH
+# endif
+# define machine_is_vt001()	(machine_arch_type == MACH_TYPE_MACH_VADATECH)
+#else
+# define machine_is_vt001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E570
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E570
+# endif
+# define machine_is_e570()	(machine_arch_type == MACH_TYPE_E570)
+#else
+# define machine_is_e570()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X50
+# endif
+# define machine_is_x50()	(machine_arch_type == MACH_TYPE_X50)
+#else
+# define machine_is_x50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECON
+# endif
+# define machine_is_recon()	(machine_arch_type == MACH_TYPE_RECON)
+#else
+# define machine_is_recon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XBOARDGP8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XBOARDGP8
+# endif
+# define machine_is_xboardgp8()	(machine_arch_type == MACH_TYPE_XBOARDGP8)
+#else
+# define machine_is_xboardgp8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FPIC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC2
+# endif
+# define machine_is_fpic2()	(machine_arch_type == MACH_TYPE_FPIC2)
+#else
+# define machine_is_fpic2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A81
+# endif
+# define machine_is_a81()	(machine_arch_type == MACH_TYPE_A81)
+#else
+# define machine_is_a81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVM_SC25X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVM_SC25X
+# endif
+# define machine_is_svm_sc25x()	(machine_arch_type == MACH_TYPE_SVM_SC25X)
+#else
+# define machine_is_svm_sc25x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VADATECH020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VADATECH020
+# endif
+# define machine_is_vt020()	(machine_arch_type == MACH_TYPE_VADATECH020)
+#else
+# define machine_is_vt020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TLI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TLI
+# endif
+# define machine_is_tli()	(machine_arch_type == MACH_TYPE_TLI)
+#else
+# define machine_is_tli()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315LC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315LC
+# endif
+# define machine_is_edb9315lc()	(machine_arch_type == MACH_TYPE_EDB9315LC)
+#else
+# define machine_is_edb9315lc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSEC
+# endif
+# define machine_is_passec()	(machine_arch_type == MACH_TYPE_PASSEC)
+#else
+# define machine_is_passec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS_TIGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS_TIGER
+# endif
+# define machine_is_ds_tiger()	(machine_arch_type == MACH_TYPE_DS_TIGER)
+#else
+# define machine_is_ds_tiger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E310
+# endif
+# define machine_is_e310()	(machine_arch_type == MACH_TYPE_E310)
+#else
+# define machine_is_e310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RT3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RT3000
+# endif
+# define machine_is_rt3000()	(machine_arch_type == MACH_TYPE_RT3000)
+#else
+# define machine_is_rt3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0106
+# endif
+# define machine_is_pnx0106()	(machine_arch_type == MACH_TYPE_PNX0106)
+#else
+# define machine_is_pnx0106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX21XX
+# endif
+# define machine_is_hx21xx()	(machine_arch_type == MACH_TYPE_HX21XX)
+#else
+# define machine_is_hx21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARADAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARADAY
+# endif
+# define machine_is_faraday()	(machine_arch_type == MACH_TYPE_FARADAY)
+#else
+# define machine_is_faraday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC9312
+# endif
+# define machine_is_sbc9312()	(machine_arch_type == MACH_TYPE_SBC9312)
+#else
+# define machine_is_sbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BATMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BATMAN
+# endif
+# define machine_is_batman()	(machine_arch_type == MACH_TYPE_BATMAN)
+#else
+# define machine_is_batman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JPD201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JPD201
+# endif
+# define machine_is_jpd201()	(machine_arch_type == MACH_TYPE_JPD201)
+#else
+# define machine_is_jpd201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIPSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIPSA
+# endif
+# define machine_is_mipsa()	(machine_arch_type == MACH_TYPE_MIPSA)
+#else
+# define machine_is_mipsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KACOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KACOM
+# endif
+# define machine_is_kacom()	(machine_arch_type == MACH_TYPE_KACOM)
+#else
+# define machine_is_kacom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOCPU
+# endif
+# define machine_is_swarcocpu()	(machine_arch_type == MACH_TYPE_SWARCOCPU)
+#else
+# define machine_is_swarcocpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCODSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCODSL
+# endif
+# define machine_is_swarcodsl()	(machine_arch_type == MACH_TYPE_SWARCODSL)
+#else
+# define machine_is_swarcodsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEANGEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEANGEL
+# endif
+# define machine_is_blueangel()	(machine_arch_type == MACH_TYPE_BLUEANGEL)
+#else
+# define machine_is_blueangel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAIRYGRAMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAIRYGRAMA
+# endif
+# define machine_is_hairygrama()	(machine_arch_type == MACH_TYPE_HAIRYGRAMA)
+#else
+# define machine_is_hairygrama()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BANFF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANFF
+# endif
+# define machine_is_banff()	(machine_arch_type == MACH_TYPE_BANFF)
+#else
+# define machine_is_banff()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM255
+# endif
+# define machine_is_sam255()	(machine_arch_type == MACH_TYPE_SAM255)
+#else
+# define machine_is_sam255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PPM10
+# endif
+# define machine_is_ppm10()	(machine_arch_type == MACH_TYPE_PPM10)
+#else
+# define machine_is_ppm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNSET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNSET
+# endif
+# define machine_is_sunset()	(machine_arch_type == MACH_TYPE_SUNSET)
+#else
+# define machine_is_sunset()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE2
+# endif
+# define machine_is_mainstone2()	(machine_arch_type == MACH_TYPE_MAINSTONE2)
+#else
+# define machine_is_mainstone2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_IXP42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_IXP42X
+# endif
+# define machine_is_ez_ixp42x()	(machine_arch_type == MACH_TYPE_EZ_IXP42X)
+#else
+# define machine_is_ez_ixp42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAPWAVE_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAPWAVE_ZODIAC
+# endif
+# define machine_is_tapwave_zodiac()	(machine_arch_type == MACH_TYPE_TAPWAVE_ZODIAC)
+#else
+# define machine_is_tapwave_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSALMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSALMETER
+# endif
+# define machine_is_universalmeter()	(machine_arch_type == MACH_TYPE_UNIVERSALMETER)
+#else
+# define machine_is_universalmeter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HICOARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HICOARM9
+# endif
+# define machine_is_hicoarm9()	(machine_arch_type == MACH_TYPE_HICOARM9)
+#else
+# define machine_is_hicoarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KWS6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KWS6000
+# endif
+# define machine_is_kws6000()	(machine_arch_type == MACH_TYPE_KWS6000)
+#else
+# define machine_is_kws6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUX920T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUX920T
+# endif
+# define machine_is_portux920t()	(machine_arch_type == MACH_TYPE_PORTUX920T)
+#else
+# define machine_is_portux920t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_X5
+# endif
+# define machine_is_ez_x5()	(machine_arch_type == MACH_TYPE_EZ_X5)
+#else
+# define machine_is_ez_x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_RUDOLPH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_RUDOLPH
+# endif
+# define machine_is_omap_rudolph()	(machine_arch_type == MACH_TYPE_OMAP_RUDOLPH)
+#else
+# define machine_is_omap_rudolph()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA9200
+# endif
+# define machine_is_rea9200()	(machine_arch_type == MACH_TYPE_REA9200)
+#else
+# define machine_is_rea9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTS_PUNE_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTS_PUNE_SA1110
+# endif
+# define machine_is_acts_pune_sa1110()	(machine_arch_type == MACH_TYPE_ACTS_PUNE_SA1110)
+#else
+# define machine_is_acts_pune_sa1110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425
+# endif
+# define machine_is_ixp425()	(machine_arch_type == MACH_TYPE_IXP425)
+#else
+# define machine_is_ixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I30030ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I30030ADS
+# endif
+# define machine_is_i30030ads()	(machine_arch_type == MACH_TYPE_I30030ADS)
+#else
+# define machine_is_i30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PERCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERCH
+# endif
+# define machine_is_perch()	(machine_arch_type == MACH_TYPE_PERCH)
+#else
+# define machine_is_perch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIS05R1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIS05R1
+# endif
+# define machine_is_eis05r1()	(machine_arch_type == MACH_TYPE_EIS05R1)
+#else
+# define machine_is_eis05r1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEPPERPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEPPERPAD
+# endif
+# define machine_is_pepperpad()	(machine_arch_type == MACH_TYPE_PEPPERPAD)
+#else
+# define machine_is_pepperpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SB3010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SB3010
+# endif
+# define machine_is_sb3010()	(machine_arch_type == MACH_TYPE_SB3010)
+#else
+# define machine_is_sb3010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RM9200
+# endif
+# define machine_is_rm9200()	(machine_arch_type == MACH_TYPE_RM9200)
+#else
+# define machine_is_rm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA03
+# endif
+# define machine_is_dma03()	(machine_arch_type == MACH_TYPE_DMA03)
+#else
+# define machine_is_dma03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROAD_S101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROAD_S101
+# endif
+# define machine_is_road_s101()	(machine_arch_type == MACH_TYPE_ROAD_S101)
+#else
+# define machine_is_road_s101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340SC
+# endif
+# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
+#else
+# define machine_is_iq81340sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_B
+# endif
+# define machine_is_iq_nextgen_b()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_B)
+#else
+# define machine_is_iq_nextgen_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340MC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340MC
+# endif
+# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
+#else
+# define machine_is_iq81340mc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_D
+# endif
+# define machine_is_iq_nextgen_d()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_D)
+#else
+# define machine_is_iq_nextgen_d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_E
+# endif
+# define machine_is_iq_nextgen_e()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_E)
+#else
+# define machine_is_iq_nextgen_e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MALLOW_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MALLOW_AT91
+# endif
+# define machine_is_mallow_at91()	(machine_arch_type == MACH_TYPE_MALLOW_AT91)
+#else
+# define machine_is_mallow_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_I
+# endif
+# define machine_is_cybertracker_i()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_I)
+#else
+# define machine_is_cybertracker_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC931X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC931X
+# endif
+# define machine_is_gesbc931x()	(machine_arch_type == MACH_TYPE_GESBC931X)
+#else
+# define machine_is_gesbc931x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTIPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTIPAD
+# endif
+# define machine_is_centipad()	(machine_arch_type == MACH_TYPE_CENTIPAD)
+#else
+# define machine_is_centipad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSOC
+# endif
+# define machine_is_armsoc()	(machine_arch_type == MACH_TYPE_ARMSOC)
+#else
+# define machine_is_armsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE4200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4200
+# endif
+# define machine_is_se4200()	(machine_arch_type == MACH_TYPE_SE4200)
+#else
+# define machine_is_se4200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMS197A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMS197A
+# endif
+# define machine_is_ems197a()	(machine_arch_type == MACH_TYPE_EMS197A)
+#else
+# define machine_is_ems197a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UC5471DSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UC5471DSP
+# endif
+# define machine_is_uc5471dsp()	(machine_arch_type == MACH_TYPE_UC5471DSP)
+#else
+# define machine_is_uc5471dsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SJ5471ENG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SJ5471ENG
+# endif
+# define machine_is_sj5471eng()	(machine_arch_type == MACH_TYPE_SJ5471ENG)
+#else
+# define machine_is_sj5471eng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA26X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA26X
+# endif
+# define machine_is_none()	(machine_arch_type == MACH_TYPE_CMPXA26X)
+#else
+# define machine_is_none()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NC
+# endif
+# define machine_is_nc1()	(machine_arch_type == MACH_TYPE_NC)
+#else
+# define machine_is_nc1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX52X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX52X
+# endif
+# define machine_is_ajax52x()	(machine_arch_type == MACH_TYPE_AJAX52X)
+#else
+# define machine_is_ajax52x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIRIUSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIRIUSTAR
+# endif
+# define machine_is_siriustar()	(machine_arch_type == MACH_TYPE_SIRIUSTAR)
+#else
+# define machine_is_siriustar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IODATA_HDLG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IODATA_HDLG
+# endif
+# define machine_is_iodata_hdlg()	(machine_arch_type == MACH_TYPE_IODATA_HDLG)
+#else
+# define machine_is_iodata_hdlg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200UTL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200UTL
+# endif
+# define machine_is_at91rm9200utl()	(machine_arch_type == MACH_TYPE_AT91RM9200UTL)
+#else
+# define machine_is_at91rm9200utl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIOSAFE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIOSAFE
+# endif
+# define machine_is_biosafe()	(machine_arch_type == MACH_TYPE_BIOSAFE)
+#else
+# define machine_is_biosafe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1000
+# endif
+# define machine_is_mp1000()	(machine_arch_type == MACH_TYPE_MP1000)
+#else
+# define machine_is_mp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PARSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PARSY
+# endif
+# define machine_is_parsy()	(machine_arch_type == MACH_TYPE_PARSY)
+#else
+# define machine_is_parsy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCXP
+# endif
+# define machine_is_ccxp270()	(machine_arch_type == MACH_TYPE_CCXP)
+#else
+# define machine_is_ccxp270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GSAMPLE
+# endif
+# define machine_is_omap_gsample()	(machine_arch_type == MACH_TYPE_OMAP_GSAMPLE)
+#else
+# define machine_is_omap_gsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMOA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMOA
+# endif
+# define machine_is_samoa()	(machine_arch_type == MACH_TYPE_SAMOA)
+#else
+# define machine_is_samoa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T3XSCALE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T3XSCALE
+# endif
+# define machine_is_t3xscale()	(machine_arch_type == MACH_TYPE_T3XSCALE)
+#else
+# define machine_is_t3xscale()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I878
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I878
+# endif
+# define machine_is_i878()	(machine_arch_type == MACH_TYPE_I878)
+#else
+# define machine_is_i878()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GECKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GECKO
+# endif
+# define machine_is_gecko()	(machine_arch_type == MACH_TYPE_GECKO)
+#else
+# define machine_is_gecko()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101
+# endif
+# define machine_is_ds101()	(machine_arch_type == MACH_TYPE_DS101)
+#else
+# define machine_is_ds101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT2
+# endif
+# define machine_is_omap_palmtt2()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT2)
+#else
+# define machine_is_omap_palmtt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMLD
+# endif
+# define machine_is_xscale_palmld()	(machine_arch_type == MACH_TYPE_XSCALE_PALMLD)
+#else
+# define machine_is_xscale_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9C
+# endif
+# define machine_is_cc9c()	(machine_arch_type == MACH_TYPE_CC9C)
+#else
+# define machine_is_cc9c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC1670
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC1670
+# endif
+# define machine_is_sbc1670()	(machine_arch_type == MACH_TYPE_SBC1670)
+#else
+# define machine_is_sbc1670()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML696K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML696K
+# endif
+# define machine_is_ml696k()	(machine_arch_type == MACH_TYPE_ML696K)
+#else
+# define machine_is_ml696k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAESTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAESTRO
+# endif
+# define machine_is_maestro()	(machine_arch_type == MACH_TYPE_MAESTRO)
+#else
+# define machine_is_maestro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUNGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUNGE2
+# endif
+# define machine_is_tunge2()	(machine_arch_type == MACH_TYPE_TUNGE2)
+#else
+# define machine_is_tunge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXBBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXBBM
+# endif
+# define machine_is_ixbbm()	(machine_arch_type == MACH_TYPE_IXBBM)
+#else
+# define machine_is_ixbbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27ADS
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX8004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX8004
+# endif
+# define machine_is_ax8004()	(machine_arch_type == MACH_TYPE_AX8004)
+#else
+# define machine_is_ax8004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGPIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGPIE
+# endif
+# define machine_is_magpie()	(machine_arch_type == MACH_TYPE_MAGPIE)
+#else
+# define machine_is_magpie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21ADS
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB87M3400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB87M3400
+# endif
+# define machine_is_mb87m3400()	(machine_arch_type == MACH_TYPE_MB87M3400)
+#else
+# define machine_is_mb87m3400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MGUARD_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MGUARD_DELTA
+# endif
+# define machine_is_mguard_delta()	(machine_arch_type == MACH_TYPE_MGUARD_DELTA)
+#else
+# define machine_is_mguard_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DVDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DVDP
+# endif
+# define machine_is_davinci_dvdp()	(machine_arch_type == MACH_TYPE_DAVINCI_DVDP)
+#else
+# define machine_is_davinci_dvdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCUNIVERSAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCUNIVERSAL
+# endif
+# define machine_is_htcuniversal()	(machine_arch_type == MACH_TYPE_HTCUNIVERSAL)
+#else
+# define machine_is_htcuniversal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPAD
+# endif
+# define machine_is_tpad()	(machine_arch_type == MACH_TYPE_TPAD)
+#else
+# define machine_is_tpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP3
+# endif
+# define machine_is_roverp3()	(machine_arch_type == MACH_TYPE_ROVERP3)
+#else
+# define machine_is_roverp3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JORNADA928
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA928
+# endif
+# define machine_is_jornada928()	(machine_arch_type == MACH_TYPE_JORNADA928)
+#else
+# define machine_is_jornada928()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88FXX81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88FXX81
+# endif
+# define machine_is_mv88fxx81()	(machine_arch_type == MACH_TYPE_MV88FXX81)
+#else
+# define machine_is_mv88fxx81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP36XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP36XX
+# endif
+# define machine_is_stmp36xx()	(machine_arch_type == MACH_TYPE_STMP36XX)
+#else
+# define machine_is_stmp36xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SXNI79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SXNI79524
+# endif
+# define machine_is_sxni79524()	(machine_arch_type == MACH_TYPE_SXNI79524)
+#else
+# define machine_is_sxni79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_URANIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_URANIUM
+# endif
+# define machine_is_uranium()	(machine_arch_type == MACH_TYPE_URANIUM)
+#else
+# define machine_is_uranium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCON
+# endif
+# define machine_is_ucon()	(machine_arch_type == MACH_TYPE_UCON)
+#else
+# define machine_is_ucon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_L083_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L083_1000
+# endif
+# define machine_is_l083()	(machine_arch_type == MACH_TYPE_L083_1000)
+#else
+# define machine_is_l083()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX
+# endif
+# define machine_is_ezx()	(machine_arch_type == MACH_TYPE_EZX)
+#else
+# define machine_is_ezx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX5220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX5220
+# endif
+# define machine_is_pnx5220()	(machine_arch_type == MACH_TYPE_PNX5220)
+#else
+# define machine_is_pnx5220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUTTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUTTE
+# endif
+# define machine_is_butte()	(machine_arch_type == MACH_TYPE_BUTTE)
+#else
+# define machine_is_butte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SRM2
+# endif
+# define machine_is_srm2()	(machine_arch_type == MACH_TYPE_SRM2)
+#else
+# define machine_is_srm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSBR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSBR
+# endif
+# define machine_is_dsbr()	(machine_arch_type == MACH_TYPE_DSBR)
+#else
+# define machine_is_dsbr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRYSTALBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRYSTALBALL
+# endif
+# define machine_is_crystalball()	(machine_arch_type == MACH_TYPE_CRYSTALBALL)
+#else
+# define machine_is_crystalball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINYPXA27X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINYPXA27X
+# endif
+# define machine_is_tinypxa27x()	(machine_arch_type == MACH_TYPE_TINYPXA27X)
+#else
+# define machine_is_tinypxa27x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERBIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERBIE
+# endif
+# define machine_is_herbie()	(machine_arch_type == MACH_TYPE_HERBIE)
+#else
+# define machine_is_herbie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4002
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4002
+# endif
+# define machine_is_cm4002()	(machine_arch_type == MACH_TYPE_CM4002)
+#else
+# define machine_is_cm4002()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B4
+# endif
+# define machine_is_b4()	(machine_arch_type == MACH_TYPE_B4)
+#else
+# define machine_is_b4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAUI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAUI
+# endif
+# define machine_is_maui()	(machine_arch_type == MACH_TYPE_MAUI)
+#else
+# define machine_is_maui()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_G
+# endif
+# define machine_is_cybertracker_g()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_G)
+#else
+# define machine_is_cybertracker_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIO8390
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIO8390
+# endif
+# define machine_is_mio8390()	(machine_arch_type == MACH_TYPE_MIO8390)
+#else
+# define machine_is_mio8390()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMI_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMI_BOARD
+# endif
+# define machine_is_omi_board()	(machine_arch_type == MACH_TYPE_OMI_BOARD)
+#else
+# define machine_is_omi_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21CIV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21CIV
+# endif
+# define machine_is_mx21civ()	(machine_arch_type == MACH_TYPE_MX21CIV)
+#else
+# define machine_is_mx21civ()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHI_CDAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHI_CDAC
+# endif
+# define machine_is_mahi_cdac()	(machine_arch_type == MACH_TYPE_MAHI_CDAC)
+#else
+# define machine_is_mahi_cdac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTX
+# endif
+# define machine_is_xscale_palmtx()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTX)
+#else
+# define machine_is_xscale_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMSYS_EP0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMSYS_EP0
+# endif
+# define machine_is_samsys_ep0()	(machine_arch_type == MACH_TYPE_SAMSYS_EP0)
+#else
+# define machine_is_samsys_ep0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V1
+# endif
+# define machine_is_wg302v1()	(machine_arch_type == MACH_TYPE_WG302V1)
+#else
+# define machine_is_wg302v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB42X
+# endif
+# define machine_is_eb42x()	(machine_arch_type == MACH_TYPE_EB42X)
+#else
+# define machine_is_eb42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ331ES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ331ES
+# endif
+# define machine_is_iq331es()	(machine_arch_type == MACH_TYPE_IQ331ES)
+#else
+# define machine_is_iq331es()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COSYDSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COSYDSP
+# endif
+# define machine_is_cosydsp()	(machine_arch_type == MACH_TYPE_COSYDSP)
+#else
+# define machine_is_cosydsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UPLAT7D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UPLAT7D
+# endif
+# define machine_is_uplat7d_proto()	(machine_arch_type == MACH_TYPE_UPLAT7D)
+#else
+# define machine_is_uplat7d_proto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTDAVINCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTDAVINCI
+# endif
+# define machine_is_ptdavinci()	(machine_arch_type == MACH_TYPE_PTDAVINCI)
+#else
+# define machine_is_ptdavinci()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBUS
+# endif
+# define machine_is_mbus()	(machine_arch_type == MACH_TYPE_MBUS)
+#else
+# define machine_is_mbus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NADIA2VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NADIA2VB
+# endif
+# define machine_is_nadia2vb()	(machine_arch_type == MACH_TYPE_NADIA2VB)
+#else
+# define machine_is_nadia2vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1000
+# endif
+# define machine_is_r1000()	(machine_arch_type == MACH_TYPE_R1000)
+#else
+# define machine_is_r1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90250
+# endif
+# define machine_is_hw90250()	(machine_arch_type == MACH_TYPE_HW90250)
+#else
+# define machine_is_hw90250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TORNADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TORNADO
+# endif
+# define machine_is_omap_tornado()	(machine_arch_type == MACH_TYPE_OMAP_TORNADO)
+#else
+# define machine_is_omap_tornado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLOCREEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLOCREEK
+# endif
+# define machine_is_olocreek()	(machine_arch_type == MACH_TYPE_OLOCREEK)
+#else
+# define machine_is_olocreek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF9328
+# endif
+# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
+#else
+# define machine_is_apf9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_WIPOQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_WIPOQ
+# endif
+# define machine_is_omap_wipoq()	(machine_arch_type == MACH_TYPE_OMAP_WIPOQ)
+#else
+# define machine_is_omap_wipoq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TWIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TWIP
+# endif
+# define machine_is_omap_twip()	(machine_arch_type == MACH_TYPE_OMAP_TWIP)
+#else
+# define machine_is_omap_twip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTREO650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTREO650
+# endif
+# define machine_is_xscale_treo650()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTREO650)
+#else
+# define machine_is_xscale_treo650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACUMEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACUMEN
+# endif
+# define machine_is_acumen()	(machine_arch_type == MACH_TYPE_ACUMEN)
+#else
+# define machine_is_acumen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XP100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP100
+# endif
+# define machine_is_xp100()	(machine_arch_type == MACH_TYPE_XP100)
+#else
+# define machine_is_xp100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FS2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FS2410
+# endif
+# define machine_is_fs2410()	(machine_arch_type == MACH_TYPE_FS2410)
+#else
+# define machine_is_fs2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA270_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA270_CERF
+# endif
+# define machine_is_pxa270_cerf()	(machine_arch_type == MACH_TYPE_PXA270_CERF)
+#else
+# define machine_is_pxa270_cerf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SQ2FTLPALM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SQ2FTLPALM
+# endif
+# define machine_is_sq2ftlpalm()	(machine_arch_type == MACH_TYPE_SQ2FTLPALM)
+#else
+# define machine_is_sq2ftlpalm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSEMSERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSEMSERVER
+# endif
+# define machine_is_bsemserver()	(machine_arch_type == MACH_TYPE_BSEMSERVER)
+#else
+# define machine_is_bsemserver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETCLIENT
+# endif
+# define machine_is_netclient()	(machine_arch_type == MACH_TYPE_NETCLIENT)
+#else
+# define machine_is_netclient()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTT5
+# endif
+# define machine_is_xscale_palmtt5()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTT5)
+#else
+# define machine_is_xscale_palmtt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTC
+# endif
+# define machine_is_xscale_palmtc()	(machine_arch_type == MACH_TYPE_OMAP_PALMTC)
+#else
+# define machine_is_xscale_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030EVB
+# endif
+# define machine_is_mxc30030evb()	(machine_arch_type == MACH_TYPE_MXC30030EVB)
+#else
+# define machine_is_mxc30030evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA_2D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_2D
+# endif
+# define machine_is_rea_2d()	(machine_arch_type == MACH_TYPE_REA_2D)
+#else
+# define machine_is_rea_2d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI3E524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI3E524
+# endif
+# define machine_is_eti3e524()	(machine_arch_type == MACH_TYPE_TI3E524)
+#else
+# define machine_is_eti3e524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AUCKLAND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUCKLAND
+# endif
+# define machine_is_auckland()	(machine_arch_type == MACH_TYPE_AUCKLAND)
+#else
+# define machine_is_auckland()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AK3320M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AK3320M
+# endif
+# define machine_is_ak3220m()	(machine_arch_type == MACH_TYPE_AK3320M)
+#else
+# define machine_is_ak3220m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DURAMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DURAMAX
+# endif
+# define machine_is_duramax()	(machine_arch_type == MACH_TYPE_DURAMAX)
+#else
+# define machine_is_duramax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRONGHORN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRONGHORN
+# endif
+# define machine_is_pronghorn()	(machine_arch_type == MACH_TYPE_PRONGHORN)
+#else
+# define machine_is_pronghorn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUNDY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUNDY
+# endif
+# define machine_is_fundy()	(machine_arch_type == MACH_TYPE_FUNDY)
+#else
+# define machine_is_fundy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPU777
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU777
+# endif
+# define machine_is_cpu777()	(machine_arch_type == MACH_TYPE_CPU777)
+#else
+# define machine_is_cpu777()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMICON9201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMICON9201
+# endif
+# define machine_is_simicon9201()	(machine_arch_type == MACH_TYPE_SIMICON9201)
+#else
+# define machine_is_simicon9201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEAP2_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEAP2_HPM
+# endif
+# define machine_is_leap2_hpm()	(machine_arch_type == MACH_TYPE_LEAP2_HPM)
+#else
+# define machine_is_leap2_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM922TXA10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM922TXA10
+# endif
+# define machine_is_cm922txa10()	(machine_arch_type == MACH_TYPE_CM922TXA10)
+#else
+# define machine_is_cm922txa10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA
+# endif
+# define machine_is_sandgate()	(machine_arch_type == MACH_TYPE_PXA)
+#else
+# define machine_is_sandgate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2
+# endif
+# define machine_is_sandgate2()	(machine_arch_type == MACH_TYPE_SANDGATE2)
+#else
+# define machine_is_sandgate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2G
+# endif
+# define machine_is_sandgate2g()	(machine_arch_type == MACH_TYPE_SANDGATE2G)
+#else
+# define machine_is_sandgate2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2P
+# endif
+# define machine_is_sandgate2p()	(machine_arch_type == MACH_TYPE_SANDGATE2P)
+#else
+# define machine_is_sandgate2p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRED_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRED_JACK
+# endif
+# define machine_is_fred_jack()	(machine_arch_type == MACH_TYPE_FRED_JACK)
+#else
+# define machine_is_fred_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTG_COLOR1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTG_COLOR1
+# endif
+# define machine_is_ttg_color1()	(machine_arch_type == MACH_TYPE_TTG_COLOR1)
+#else
+# define machine_is_ttg_color1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU8
+# endif
+# define machine_is_netdcu8()	(machine_arch_type == MACH_TYPE_NETDCU8)
+#else
+# define machine_is_netdcu8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML675050_CPU_BOA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML675050_CPU_BOA
+# endif
+# define machine_is_ml675050_cpu_boa()	(machine_arch_type == MACH_TYPE_ML675050_CPU_BOA)
+#else
+# define machine_is_ml675050_cpu_boa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVX538
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVX538
+# endif
+# define machine_is_ng_fvx538()	(machine_arch_type == MACH_TYPE_NG_FVX538)
+#else
+# define machine_is_ng_fvx538()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVS338
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVS338
+# endif
+# define machine_is_ng_fvs338()	(machine_arch_type == MACH_TYPE_NG_FVS338)
+#else
+# define machine_is_ng_fvs338()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4103
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4103
+# endif
+# define machine_is_pnx4103()	(machine_arch_type == MACH_TYPE_PNX4103)
+#else
+# define machine_is_pnx4103()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HESDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HESDB
+# endif
+# define machine_is_hesdb()	(machine_arch_type == MACH_TYPE_HESDB)
+#else
+# define machine_is_hesdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSILO
+# endif
+# define machine_is_xsilo()	(machine_arch_type == MACH_TYPE_XSILO)
+#else
+# define machine_is_xsilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMLC
+# endif
+# define machine_is_emlc()	(machine_arch_type == MACH_TYPE_EMLC)
+#else
+# define machine_is_emlc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SISTERON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SISTERON
+# endif
+# define machine_is_sisteron()	(machine_arch_type == MACH_TYPE_SISTERON)
+#else
+# define machine_is_sisteron()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSC_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSC_VENUS
+# endif
+# define machine_is_tsc_venus()	(machine_arch_type == MACH_TYPE_TSC_VENUS)
+#else
+# define machine_is_tsc_venus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101J
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101J
+# endif
+# define machine_is_ds101j()	(machine_arch_type == MACH_TYPE_DS101J)
+#else
+# define machine_is_ds101j()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030ADS
+# endif
+# define machine_is_mxc30030ads()	(machine_arch_type == MACH_TYPE_MXC30030ADS)
+#else
+# define machine_is_mxc30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJITSU_WIMAXSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_WIMAXSOC
+# endif
+# define machine_is_fujitsu_wimaxsoc()	(machine_arch_type == MACH_TYPE_FUJITSU_WIMAXSOC)
+#else
+# define machine_is_fujitsu_wimaxsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DUALPCMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DUALPCMODEM
+# endif
+# define machine_is_dualpcmodem()	(machine_arch_type == MACH_TYPE_DUALPCMODEM)
+#else
+# define machine_is_dualpcmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCAPACHE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCAPACHE
+# endif
+# define machine_is_htcapache()	(machine_arch_type == MACH_TYPE_HTCAPACHE)
+#else
+# define machine_is_htcapache()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP435
+# endif
+# define machine_is_ixdp435()	(machine_arch_type == MACH_TYPE_IXDP435)
+#else
+# define machine_is_ixdp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CATPROVT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATPROVT100
+# endif
+# define machine_is_catprovt100()	(machine_arch_type == MACH_TYPE_CATPROVT100)
+#else
+# define machine_is_catprovt100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX1XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX1XX
+# endif
+# define machine_is_picotux1xx()	(machine_arch_type == MACH_TYPE_PICOTUX1XX)
+#else
+# define machine_is_picotux1xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPC2
+# endif
+# define machine_is_empc2()	(machine_arch_type == MACH_TYPE_EMPC2)
+#else
+# define machine_is_empc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VENTURA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENTURA
+# endif
+# define machine_is_ventura()	(machine_arch_type == MACH_TYPE_VENTURA)
+#else
+# define machine_is_ventura()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC
+# endif
+# define machine_is_phidget_sbc()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC)
+#else
+# define machine_is_phidget_sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IJ3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IJ3K
+# endif
+# define machine_is_ij3k()	(machine_arch_type == MACH_TYPE_IJ3K)
+#else
+# define machine_is_ij3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PISGAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PISGAH
+# endif
+# define machine_is_pisgah()	(machine_arch_type == MACH_TYPE_PISGAH)
+#else
+# define machine_is_pisgah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG720
+# endif
+# define machine_is_sg720()	(machine_arch_type == MACH_TYPE_SG720)
+#else
+# define machine_is_sg720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REDFOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REDFOX
+# endif
+# define machine_is_redfox()	(machine_arch_type == MACH_TYPE_REDFOX)
+#else
+# define machine_is_redfox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MYSH_EP9315_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MYSH_EP9315_1
+# endif
+# define machine_is_mysh_ep9315_1()	(machine_arch_type == MACH_TYPE_MYSH_EP9315_1)
+#else
+# define machine_is_mysh_ep9315_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPF106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPF106
+# endif
+# define machine_is_tpf106()	(machine_arch_type == MACH_TYPE_TPF106)
+#else
+# define machine_is_tpf106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KG
+# endif
+# define machine_is_at91rm9200kg()	(machine_arch_type == MACH_TYPE_AT91RM9200KG)
+#else
+# define machine_is_at91rm9200kg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLEDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLEDB
+# endif
+# define machine_is_rcmt2()	(machine_arch_type == MACH_TYPE_SLEDB)
+#else
+# define machine_is_rcmt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONTRACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONTRACK
+# endif
+# define machine_is_ontrack()	(machine_arch_type == MACH_TYPE_ONTRACK)
+#else
+# define machine_is_ontrack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM1200
+# endif
+# define machine_is_pm1200()	(machine_arch_type == MACH_TYPE_PM1200)
+#else
+# define machine_is_pm1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS24XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS24XXX
+# endif
+# define machine_is_ess24562()	(machine_arch_type == MACH_TYPE_ESS24XXX)
+#else
+# define machine_is_ess24562()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COREMP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COREMP7
+# endif
+# define machine_is_coremp7()	(machine_arch_type == MACH_TYPE_COREMP7)
+#else
+# define machine_is_coremp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_6446
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_6446
+# endif
+# define machine_is_nexcoder_6446()	(machine_arch_type == MACH_TYPE_NEXCODER_6446)
+#else
+# define machine_is_nexcoder_6446()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STVC8380
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STVC8380
+# endif
+# define machine_is_stvc8380()	(machine_arch_type == MACH_TYPE_STVC8380)
+#else
+# define machine_is_stvc8380()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEKLYNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEKLYNX
+# endif
+# define machine_is_teklynx()	(machine_arch_type == MACH_TYPE_TEKLYNX)
+#else
+# define machine_is_teklynx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARBONADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARBONADO
+# endif
+# define machine_is_carbonado()	(machine_arch_type == MACH_TYPE_CARBONADO)
+#else
+# define machine_is_carbonado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYSMOS_MP730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYSMOS_MP730
+# endif
+# define machine_is_sysmos_mp730()	(machine_arch_type == MACH_TYPE_SYSMOS_MP730)
+#else
+# define machine_is_sysmos_mp730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PGIGIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PGIGIM
+# endif
+# define machine_is_pgigim()	(machine_arch_type == MACH_TYPE_PGIGIM)
+#else
+# define machine_is_pgigim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX9160P2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX9160P2
+# endif
+# define machine_is_ptx9160p2()	(machine_arch_type == MACH_TYPE_PTX9160P2)
+#else
+# define machine_is_ptx9160p2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DCORE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DCORE1
+# endif
+# define machine_is_dcore1()	(machine_arch_type == MACH_TYPE_DCORE1)
+#else
+# define machine_is_dcore1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VICTORPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTORPXA
+# endif
+# define machine_is_victorpxa()	(machine_arch_type == MACH_TYPE_VICTORPXA)
+#else
+# define machine_is_victorpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2DTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2DTB
+# endif
+# define machine_is_mx2dtb()	(machine_arch_type == MACH_TYPE_MX2DTB)
+#else
+# define machine_is_mx2dtb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_IREX_ER0100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IREX_ER0100
+# endif
+# define machine_is_pxa_irex_er0100()	(machine_arch_type == MACH_TYPE_PXA_IREX_ER0100)
+#else
+# define machine_is_pxa_irex_er0100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_DEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_DEG
+# endif
+# define machine_is_bartec_deg()	(machine_arch_type == MACH_TYPE_BARTEC_DEG)
+#else
+# define machine_is_bartec_deg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW50251
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW50251
+# endif
+# define machine_is_hw50251()	(machine_arch_type == MACH_TYPE_HW50251)
+#else
+# define machine_is_hw50251()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IBOX
+# endif
+# define machine_is_ibox()	(machine_arch_type == MACH_TYPE_IBOX)
+#else
+# define machine_is_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLASLH7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLASLH7A404
+# endif
+# define machine_is_atlaslh7a404()	(machine_arch_type == MACH_TYPE_ATLASLH7A404)
+#else
+# define machine_is_atlaslh7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PT2026
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT2026
+# endif
+# define machine_is_pt2026()	(machine_arch_type == MACH_TYPE_PT2026)
+#else
+# define machine_is_pt2026()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCALPINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCALPINE
+# endif
+# define machine_is_htcalpine()	(machine_arch_type == MACH_TYPE_HTCALPINE)
+#else
+# define machine_is_htcalpine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_VTU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_VTU
+# endif
+# define machine_is_bartec_vtu()	(machine_arch_type == MACH_TYPE_BARTEC_VTU)
+#else
+# define machine_is_bartec_vtu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCOREII
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCOREII
+# endif
+# define machine_is_vcoreii()	(machine_arch_type == MACH_TYPE_VCOREII)
+#else
+# define machine_is_vcoreii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDNB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDNB3
+# endif
+# define machine_is_pdnb3()	(machine_arch_type == MACH_TYPE_PDNB3)
+#else
+# define machine_is_pdnb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCBEETLES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCBEETLES
+# endif
+# define machine_is_htcbeetles()	(machine_arch_type == MACH_TYPE_HTCBEETLES)
+#else
+# define machine_is_htcbeetles()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C6400
+# endif
+# define machine_is_s3c6400()	(machine_arch_type == MACH_TYPE_S3C6400)
+#else
+# define machine_is_s3c6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2443
+# endif
+# define machine_is_s3c2443()	(machine_arch_type == MACH_TYPE_S3C2443)
+#else
+# define machine_is_s3c2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDK
+# endif
+# define machine_is_omap_ldk()	(machine_arch_type == MACH_TYPE_OMAP_LDK)
+#else
+# define machine_is_omap_ldk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2460
+# endif
+# define machine_is_smdk2460()	(machine_arch_type == MACH_TYPE_SMDK2460)
+#else
+# define machine_is_smdk2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2440
+# endif
+# define machine_is_smdk2440()	(machine_arch_type == MACH_TYPE_SMDK2440)
+#else
+# define machine_is_smdk2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBBOX
+# endif
+# define machine_is_webbox()	(machine_arch_type == MACH_TYPE_WEBBOX)
+#else
+# define machine_is_webbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWWNDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWWNDP
+# endif
+# define machine_is_cwwndp()	(machine_arch_type == MACH_TYPE_CWWNDP)
+#else
+# define machine_is_cwwndp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON
+# endif
+# define machine_is_i839()	(machine_arch_type == MACH_TYPE_DRAGON)
+#else
+# define machine_is_i839()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENDO_CPU_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENDO_CPU_BOARD
+# endif
+# define machine_is_opendo_cpu_board()	(machine_arch_type == MACH_TYPE_OPENDO_CPU_BOARD)
+#else
+# define machine_is_opendo_cpu_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCM2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCM2200
+# endif
+# define machine_is_ccm2200()	(machine_arch_type == MACH_TYPE_CCM2200)
+#else
+# define machine_is_ccm2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETWARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETWARM
+# endif
+# define machine_is_etwarm()	(machine_arch_type == MACH_TYPE_ETWARM)
+#else
+# define machine_is_etwarm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M93030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M93030
+# endif
+# define machine_is_m93030()	(machine_arch_type == MACH_TYPE_M93030)
+#else
+# define machine_is_m93030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC7U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC7U
+# endif
+# define machine_is_cc7u()	(machine_arch_type == MACH_TYPE_CC7U)
+#else
+# define machine_is_cc7u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT_RANGER
+# endif
+# define machine_is_mtt_ranger()	(machine_arch_type == MACH_TYPE_MTT_RANGER)
+#else
+# define machine_is_mtt_ranger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUS
+# endif
+# define machine_is_nexus()	(machine_arch_type == MACH_TYPE_NEXUS)
+#else
+# define machine_is_nexus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DESMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DESMAN
+# endif
+# define machine_is_desman()	(machine_arch_type == MACH_TYPE_DESMAN)
+#else
+# define machine_is_desman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BKDE303
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BKDE303
+# endif
+# define machine_is_bkde303()	(machine_arch_type == MACH_TYPE_BKDE303)
+#else
+# define machine_is_bkde303()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M7200
+# endif
+# define machine_is_aml_m7200()	(machine_arch_type == MACH_TYPE_AML_M7200)
+#else
+# define machine_is_aml_m7200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG640
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG640
+# endif
+# define machine_is_sg640()	(machine_arch_type == MACH_TYPE_SG640)
+#else
+# define machine_is_sg640()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDG79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDG79524
+# endif
+# define machine_is_edg79524()	(machine_arch_type == MACH_TYPE_EDG79524)
+#else
+# define machine_is_edg79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AI2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AI2410
+# endif
+# define machine_is_ai2410()	(machine_arch_type == MACH_TYPE_AI2410)
+#else
+# define machine_is_ai2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP465
+# endif
+# define machine_is_ixp465()	(machine_arch_type == MACH_TYPE_IXP465)
+#else
+# define machine_is_ixp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HEINS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HEINS
+# endif
+# define machine_is_heins()	(machine_arch_type == MACH_TYPE_HEINS)
+#else
+# define machine_is_heins()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPLUSEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPLUSEVA
+# endif
+# define machine_is_mpluseva()	(machine_arch_type == MACH_TYPE_MPLUSEVA)
+#else
+# define machine_is_mpluseva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RT042
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RT042
+# endif
+# define machine_is_rt042()	(machine_arch_type == MACH_TYPE_RT042)
+#else
+# define machine_is_rt042()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWIEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWIEM
+# endif
+# define machine_is_cwiem()	(machine_arch_type == MACH_TYPE_CWIEM)
+#else
+# define machine_is_cwiem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X270
+# endif
+# define machine_is_cm_x270()	(machine_arch_type == MACH_TYPE_CM_X270)
+#else
+# define machine_is_cm_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X255
+# endif
+# define machine_is_cm_x255()	(machine_arch_type == MACH_TYPE_CM_X255)
+#else
+# define machine_is_cm_x255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESH_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESH_AT91
+# endif
+# define machine_is_esh_at91()	(machine_arch_type == MACH_TYPE_ESH_AT91)
+#else
+# define machine_is_esh_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE3
+# endif
+# define machine_is_sandgate3()	(machine_arch_type == MACH_TYPE_SANDGATE3)
+#else
+# define machine_is_sandgate3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMO
+# endif
+# define machine_is_primo()	(machine_arch_type == MACH_TYPE_PRIMO)
+#else
+# define machine_is_primo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMSTONE
+# endif
+# define machine_is_gemstone()	(machine_arch_type == MACH_TYPE_GEMSTONE)
+#else
+# define machine_is_gemstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRONGHORNMETRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRONGHORNMETRO
+# endif
+# define machine_is_pronghorn_metro()	(machine_arch_type == MACH_TYPE_PRONGHORNMETRO)
+#else
+# define machine_is_pronghorn_metro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIDEWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEWINDER
+# endif
+# define machine_is_sidewinder()	(machine_arch_type == MACH_TYPE_SIDEWINDER)
+#else
+# define machine_is_sidewinder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOMOD1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOMOD1
+# endif
+# define machine_is_picomod1()	(machine_arch_type == MACH_TYPE_PICOMOD1)
+#else
+# define machine_is_picomod1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG590
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG590
+# endif
+# define machine_is_sg590()	(machine_arch_type == MACH_TYPE_SG590)
+#else
+# define machine_is_sg590()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKAI9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKAI9307
+# endif
+# define machine_is_akai9307()	(machine_arch_type == MACH_TYPE_AKAI9307)
+#else
+# define machine_is_akai9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FONTAINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FONTAINE
+# endif
+# define machine_is_fontaine()	(machine_arch_type == MACH_TYPE_FONTAINE)
+#else
+# define machine_is_fontaine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WOMBAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WOMBAT
+# endif
+# define machine_is_wombat()	(machine_arch_type == MACH_TYPE_WOMBAT)
+#else
+# define machine_is_wombat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ300
+# endif
+# define machine_is_acq300()	(machine_arch_type == MACH_TYPE_ACQ300)
+#else
+# define machine_is_acq300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOD_270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOD_270
+# endif
+# define machine_is_mod272()	(machine_arch_type == MACH_TYPE_MOD_270)
+#else
+# define machine_is_mod272()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC0820
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC0820
+# endif
+# define machine_is_vmc_vc0820()	(machine_arch_type == MACH_TYPE_VC0820)
+#else
+# define machine_is_vmc_vc0820()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANI_AIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANI_AIM
+# endif
+# define machine_is_ani_aim()	(machine_arch_type == MACH_TYPE_ANI_AIM)
+#else
+# define machine_is_ani_aim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JELLYFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JELLYFISH
+# endif
+# define machine_is_jellyfish()	(machine_arch_type == MACH_TYPE_JELLYFISH)
+#else
+# define machine_is_jellyfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMANITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMANITA
+# endif
+# define machine_is_amanita()	(machine_arch_type == MACH_TYPE_AMANITA)
+#else
+# define machine_is_amanita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VLINK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VLINK
+# endif
+# define machine_is_vlink()	(machine_arch_type == MACH_TYPE_VLINK)
+#else
+# define machine_is_vlink()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEXFLEX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEXFLEX
+# endif
+# define machine_is_dexflex()	(machine_arch_type == MACH_TYPE_DEXFLEX)
+#else
+# define machine_is_dexflex()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIGEN_TTQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIGEN_TTQ
+# endif
+# define machine_is_eigen_ttq()	(machine_arch_type == MACH_TYPE_EIGEN_TTQ)
+#else
+# define machine_is_eigen_ttq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_TITAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_TITAN
+# endif
+# define machine_is_arcom_titan()	(machine_arch_type == MACH_TYPE_ARCOM_TITAN)
+#else
+# define machine_is_arcom_titan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TABLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TABLA
+# endif
+# define machine_is_tabla()	(machine_arch_type == MACH_TYPE_TABLA)
+#else
+# define machine_is_tabla()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MDIRAC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MDIRAC3
+# endif
+# define machine_is_mdirac3()	(machine_arch_type == MACH_TYPE_MDIRAC3)
+#else
+# define machine_is_mdirac3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRHFBP2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRHFBP2
+# endif
+# define machine_is_mrhfbp2()	(machine_arch_type == MACH_TYPE_MRHFBP2)
+#else
+# define machine_is_mrhfbp2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200RB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200RB
+# endif
+# define machine_is_at91rm9200rb()	(machine_arch_type == MACH_TYPE_AT91RM9200RB)
+#else
+# define machine_is_at91rm9200rb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANI_APM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANI_APM
+# endif
+# define machine_is_ani_apm()	(machine_arch_type == MACH_TYPE_ANI_APM)
+#else
+# define machine_is_ani_apm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELLA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELLA1
+# endif
+# define machine_is_ella1()	(machine_arch_type == MACH_TYPE_ELLA1)
+#else
+# define machine_is_ella1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_PXA27X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_PXA27X
+# endif
+# define machine_is_inhand_pxa27x()	(machine_arch_type == MACH_TYPE_INHAND_PXA27X)
+#else
+# define machine_is_inhand_pxa27x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_PXA25X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_PXA25X
+# endif
+# define machine_is_inhand_pxa25x()	(machine_arch_type == MACH_TYPE_INHAND_PXA25X)
+#else
+# define machine_is_inhand_pxa25x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_XM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_XM
+# endif
+# define machine_is_empos_xm()	(machine_arch_type == MACH_TYPE_EMPOS_XM)
+#else
+# define machine_is_empos_xm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS
+# endif
+# define machine_is_empos()	(machine_arch_type == MACH_TYPE_EMPOS)
+#else
+# define machine_is_empos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_TINY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_TINY
+# endif
+# define machine_is_empos_tiny()	(machine_arch_type == MACH_TYPE_EMPOS_TINY)
+#else
+# define machine_is_empos_tiny()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_SM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_SM
+# endif
+# define machine_is_empos_sm()	(machine_arch_type == MACH_TYPE_EMPOS_SM)
+#else
+# define machine_is_empos_sm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EGRET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EGRET
+# endif
+# define machine_is_egret()	(machine_arch_type == MACH_TYPE_EGRET)
+#else
+# define machine_is_egret()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSTRICH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSTRICH
+# endif
+# define machine_is_ostrich()	(machine_arch_type == MACH_TYPE_OSTRICH)
+#else
+# define machine_is_ostrich()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N50
+# endif
+# define machine_is_n50()	(machine_arch_type == MACH_TYPE_N50)
+#else
+# define machine_is_n50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECBAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECBAT91
+# endif
+# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
+#else
+# define machine_is_ecbat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAREAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAREAST
+# endif
+# define machine_is_stareast()	(machine_arch_type == MACH_TYPE_STAREAST)
+#else
+# define machine_is_stareast()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DW
+# endif
+# define machine_is_dspg_dw()	(machine_arch_type == MACH_TYPE_DSPG_DW)
+#else
+# define machine_is_dspg_dw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONEARM
+# endif
+# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
+#else
+# define machine_is_onearm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRG110_6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRG110_6
+# endif
+# define machine_is_mrg110_6()	(machine_arch_type == MACH_TYPE_MRG110_6)
+#else
+# define machine_is_mrg110_6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT300NV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT300NV2
+# endif
+# define machine_is_wrt300nv2()	(machine_arch_type == MACH_TYPE_WRT300NV2)
+#else
+# define machine_is_wrt300nv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XM_BULVERDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XM_BULVERDE
+# endif
+# define machine_is_xm_bulverde()	(machine_arch_type == MACH_TYPE_XM_BULVERDE)
+#else
+# define machine_is_xm_bulverde()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM6100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM6100
+# endif
+# define machine_is_msm6100()	(machine_arch_type == MACH_TYPE_MSM6100)
+#else
+# define machine_is_msm6100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_B1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_B1
+# endif
+# define machine_is_eti_b1()	(machine_arch_type == MACH_TYPE_ETI_B1)
+#else
+# define machine_is_eti_b1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZILOG_ZA9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZILOG_ZA9L
+# endif
+# define machine_is_za9l_series()	(machine_arch_type == MACH_TYPE_ZILOG_ZA9L)
+#else
+# define machine_is_za9l_series()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIT2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIT2440
+# endif
+# define machine_is_bit2440()	(machine_arch_type == MACH_TYPE_BIT2440)
+#else
+# define machine_is_bit2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NBI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NBI
+# endif
+# define machine_is_nbi()	(machine_arch_type == MACH_TYPE_NBI)
+#else
+# define machine_is_nbi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2443
+# endif
+# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
+#else
+# define machine_is_smdk2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VDAVINCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VDAVINCI
+# endif
+# define machine_is_vdavinci()	(machine_arch_type == MACH_TYPE_VDAVINCI)
+#else
+# define machine_is_vdavinci()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATC6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATC6
+# endif
+# define machine_is_atc6()	(machine_arch_type == MACH_TYPE_ATC6)
+#else
+# define machine_is_atc6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTMDW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTMDW
+# endif
+# define machine_is_multmdw()	(machine_arch_type == MACH_TYPE_MULTMDW)
+#else
+# define machine_is_multmdw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBA2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBA2440
+# endif
+# define machine_is_mba2440()	(machine_arch_type == MACH_TYPE_MBA2440)
+#else
+# define machine_is_mba2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECSD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECSD
+# endif
+# define machine_is_ecsd()	(machine_arch_type == MACH_TYPE_ECSD)
+#else
+# define machine_is_ecsd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIRE31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIRE31
+# endif
+# define machine_is_zire31()	(machine_arch_type == MACH_TYPE_ZIRE31)
+#else
+# define machine_is_zire31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSG
+# endif
+# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
+#else
+# define machine_is_fsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAZOR101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAZOR101
+# endif
+# define machine_is_razor101()	(machine_arch_type == MACH_TYPE_RAZOR101)
+#else
+# define machine_is_razor101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPERA_TDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPERA_TDM
+# endif
+# define machine_is_opera_tdm()	(machine_arch_type == MACH_TYPE_OPERA_TDM)
+#else
+# define machine_is_opera_tdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMCERTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMCERTO
+# endif
+# define machine_is_comcerto()	(machine_arch_type == MACH_TYPE_COMCERTO)
+#else
+# define machine_is_comcerto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TB0319
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TB0319
+# endif
+# define machine_is_tb0319()	(machine_arch_type == MACH_TYPE_TB0319)
+#else
+# define machine_is_tb0319()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KWS8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KWS8000
+# endif
+# define machine_is_kws8000()	(machine_arch_type == MACH_TYPE_KWS8000)
+#else
+# define machine_is_kws8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B2
+# endif
+# define machine_is_b2()	(machine_arch_type == MACH_TYPE_B2)
+#else
+# define machine_is_b2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LCL54
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LCL54
+# endif
+# define machine_is_lcl54()	(machine_arch_type == MACH_TYPE_LCL54)
+#else
+# define machine_is_lcl54()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
+# endif
+# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
+#else
+# define machine_is_at91sam9260ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLANTANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLANTANK
+# endif
+# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
+#else
+# define machine_is_glantank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N2100
+# endif
+# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
+#else
+# define machine_is_n2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N4100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N4100
+# endif
+# define machine_is_n4100()	(machine_arch_type == MACH_TYPE_N4100)
+#else
+# define machine_is_n4100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERTICAL_RSC4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERTICAL_RSC4
+# endif
+# define machine_is_rsc4()	(machine_arch_type == MACH_TYPE_VERTICAL_RSC4)
+#else
+# define machine_is_rsc4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG8100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG8100
+# endif
+# define machine_is_sg8100()	(machine_arch_type == MACH_TYPE_SG8100)
+#else
+# define machine_is_sg8100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IM42XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IM42XX
+# endif
+# define machine_is_im42xx()	(machine_arch_type == MACH_TYPE_IM42XX)
+#else
+# define machine_is_im42xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FTXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FTXX
+# endif
+# define machine_is_ftxx()	(machine_arch_type == MACH_TYPE_FTXX)
+#else
+# define machine_is_ftxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LWFUSION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LWFUSION
+# endif
+# define machine_is_lwfusion()	(machine_arch_type == MACH_TYPE_LWFUSION)
+#else
+# define machine_is_lwfusion()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXRP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXRP435
+# endif
+# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
+#else
+# define machine_is_kixrp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9C
+# endif
+# define machine_is_ccw9c()	(machine_arch_type == MACH_TYPE_CCW9C)
+#else
+# define machine_is_ccw9c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DABHS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DABHS
+# endif
+# define machine_is_dabhs()	(machine_arch_type == MACH_TYPE_DABHS)
+#else
+# define machine_is_dabhs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GZMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GZMX
+# endif
+# define machine_is_gzmx()	(machine_arch_type == MACH_TYPE_GZMX)
+#else
+# define machine_is_gzmx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPNW100AP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPNW100AP
+# endif
+# define machine_is_ipnw100ap()	(machine_arch_type == MACH_TYPE_IPNW100AP)
+#else
+# define machine_is_ipnw100ap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
+# endif
+# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
+#else
+# define machine_is_cc9p9360dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9750DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9750DEV
+# endif
+# define machine_is_cc9p9750dev()	(machine_arch_type == MACH_TYPE_CC9P9750DEV)
+#else
+# define machine_is_cc9p9750dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360VAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360VAL
+# endif
+# define machine_is_cc9p9360val()	(machine_arch_type == MACH_TYPE_CC9P9360VAL)
+#else
+# define machine_is_cc9p9360val()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9750VAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9750VAL
+# endif
+# define machine_is_cc9p9750val()	(machine_arch_type == MACH_TYPE_CC9P9750VAL)
+#else
+# define machine_is_cc9p9750val()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX70V
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX70V
+# endif
+# define machine_is_nx70v()	(machine_arch_type == MACH_TYPE_NX70V)
+#else
+# define machine_is_nx70v()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200DF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DF
+# endif
+# define machine_is_at91rm9200df()	(machine_arch_type == MACH_TYPE_AT91RM9200DF)
+#else
+# define machine_is_at91rm9200df()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE_PILOT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE_PILOT2
+# endif
+# define machine_is_se_pilot2()	(machine_arch_type == MACH_TYPE_SE_PILOT2)
+#else
+# define machine_is_se_pilot2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTCN_T800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTCN_T800
+# endif
+# define machine_is_mtcn_t800()	(machine_arch_type == MACH_TYPE_MTCN_T800)
+#else
+# define machine_is_mtcn_t800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCMX212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCMX212
+# endif
+# define machine_is_vcmx212()	(machine_arch_type == MACH_TYPE_VCMX212)
+#else
+# define machine_is_vcmx212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LYNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LYNX
+# endif
+# define machine_is_lynx()	(machine_arch_type == MACH_TYPE_LYNX)
+#else
+# define machine_is_lynx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260ID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260ID
+# endif
+# define machine_is_at91sam9260id()	(machine_arch_type == MACH_TYPE_AT91SAM9260ID)
+#else
+# define machine_is_at91sam9260id()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW86052
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW86052
+# endif
+# define machine_is_hw86052()	(machine_arch_type == MACH_TYPE_HW86052)
+#else
+# define machine_is_hw86052()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI3
+# endif
+# define machine_is_pilz_pmi3()	(machine_arch_type == MACH_TYPE_PILZ_PMI3)
+#else
+# define machine_is_pilz_pmi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302A
+# endif
+# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
+#else
+# define machine_is_edb9302a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307A
+# endif
+# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
+#else
+# define machine_is_edb9307a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT_DFS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT_DFS
+# endif
+# define machine_is_ct_dfs()	(machine_arch_type == MACH_TYPE_CT_DFS)
+#else
+# define machine_is_ct_dfs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI4
+# endif
+# define machine_is_pilz_pmi4()	(machine_arch_type == MACH_TYPE_PILZ_PMI4)
+#else
+# define machine_is_pilz_pmi4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEEDNP_IXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEEDNP_IXP
+# endif
+# define machine_is_xceednp_ixp()	(machine_arch_type == MACH_TYPE_XCEEDNP_IXP)
+#else
+# define machine_is_xceednp_ixp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2442B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2442B
+# endif
+# define machine_is_smdk2442b()	(machine_arch_type == MACH_TYPE_SMDK2442B)
+#else
+# define machine_is_smdk2442b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XNODE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XNODE
+# endif
+# define machine_is_xnode()	(machine_arch_type == MACH_TYPE_XNODE)
+#else
+# define machine_is_xnode()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIDX270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIDX270
+# endif
+# define machine_is_aidx270()	(machine_arch_type == MACH_TYPE_AIDX270)
+#else
+# define machine_is_aidx270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REMA
+# endif
+# define machine_is_rema()	(machine_arch_type == MACH_TYPE_REMA)
+#else
+# define machine_is_rema()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BPS1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BPS1000
+# endif
+# define machine_is_bps1000()	(machine_arch_type == MACH_TYPE_BPS1000)
+#else
+# define machine_is_bps1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90350
+# endif
+# define machine_is_hw90350()	(machine_arch_type == MACH_TYPE_HW90350)
+#else
+# define machine_is_hw90350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_SDP3430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_SDP3430
+# endif
+# define machine_is_omap_sdp3430()	(machine_arch_type == MACH_TYPE_OMAP_SDP3430)
+#else
+# define machine_is_omap_sdp3430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUETOUCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUETOUCH
+# endif
+# define machine_is_bluetouch()	(machine_arch_type == MACH_TYPE_BLUETOUCH)
+#else
+# define machine_is_bluetouch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSTMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSTMS
+# endif
+# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
+#else
+# define machine_is_vstms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSBASE270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSBASE270
+# endif
+# define machine_is_xsbase270()	(machine_arch_type == MACH_TYPE_XSBASE270)
+#else
+# define machine_is_xsbase270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK_CN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK_CN
+# endif
+# define machine_is_at91sam9260ek_cn()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK_CN)
+#else
+# define machine_is_at91sam9260ek_cn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSTURBOXB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSTURBOXB
+# endif
+# define machine_is_adsturboxb()	(machine_arch_type == MACH_TYPE_ADSTURBOXB)
+#else
+# define machine_is_adsturboxb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTI4110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTI4110
+# endif
+# define machine_is_oti4110()	(machine_arch_type == MACH_TYPE_OTI4110)
+#else
+# define machine_is_oti4110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HME_PXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HME_PXA
+# endif
+# define machine_is_hme_pxa()	(machine_arch_type == MACH_TYPE_HME_PXA)
+#else
+# define machine_is_hme_pxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTERDCA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTERDCA
+# endif
+# define machine_is_deisterdca()	(machine_arch_type == MACH_TYPE_DEISTERDCA)
+#else
+# define machine_is_deisterdca()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CES_SSEM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CES_SSEM2
+# endif
+# define machine_is_ces_ssem2()	(machine_arch_type == MACH_TYPE_CES_SSEM2)
+#else
+# define machine_is_ces_ssem2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CES_MTR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CES_MTR
+# endif
+# define machine_is_ces_mtr()	(machine_arch_type == MACH_TYPE_CES_MTR)
+#else
+# define machine_is_ces_mtr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TDS_AVNG_SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TDS_AVNG_SBC
+# endif
+# define machine_is_tds_avng_sbc()	(machine_arch_type == MACH_TYPE_TDS_AVNG_SBC)
+#else
+# define machine_is_tds_avng_sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVEREST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVEREST
+# endif
+# define machine_is_everest()	(machine_arch_type == MACH_TYPE_EVEREST)
+#else
+# define machine_is_everest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4010
+# endif
+# define machine_is_pnx4010()	(machine_arch_type == MACH_TYPE_PNX4010)
+#else
+# define machine_is_pnx4010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OXNAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OXNAS
+# endif
+# define machine_is_oxnas()	(machine_arch_type == MACH_TYPE_OXNAS)
+#else
+# define machine_is_oxnas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIORI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIORI
+# endif
+# define machine_is_fiori()	(machine_arch_type == MACH_TYPE_FIORI)
+#else
+# define machine_is_fiori()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML1200
+# endif
+# define machine_is_ml1200()	(machine_arch_type == MACH_TYPE_ML1200)
+#else
+# define machine_is_ml1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PECOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PECOS
+# endif
+# define machine_is_pecos()	(machine_arch_type == MACH_TYPE_PECOS)
+#else
+# define machine_is_pecos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NB2XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NB2XXX
+# endif
+# define machine_is_nb2xxx()	(machine_arch_type == MACH_TYPE_NB2XXX)
+#else
+# define machine_is_nb2xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW6900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW6900
+# endif
+# define machine_is_hw6900()	(machine_arch_type == MACH_TYPE_HW6900)
+#else
+# define machine_is_hw6900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CDCS_QUOLL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDCS_QUOLL
+# endif
+# define machine_is_cdcs_quoll()	(machine_arch_type == MACH_TYPE_CDCS_QUOLL)
+#else
+# define machine_is_cdcs_quoll()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUICKSILVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUICKSILVER
+# endif
+# define machine_is_quicksilver()	(machine_arch_type == MACH_TYPE_QUICKSILVER)
+#else
+# define machine_is_quicksilver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UPLAT926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UPLAT926
+# endif
+# define machine_is_uplat926()	(machine_arch_type == MACH_TYPE_UPLAT926)
+#else
+# define machine_is_uplat926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410_THOMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410_THOMAS
+# endif
+# define machine_is_dep2410_dep2410()	(machine_arch_type == MACH_TYPE_DEP2410_THOMAS)
+#else
+# define machine_is_dep2410_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DTK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DTK2410
+# endif
+# define machine_is_dtk2410()	(machine_arch_type == MACH_TYPE_DTK2410)
+#else
+# define machine_is_dtk2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHILI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHILI
+# endif
+# define machine_is_chili()	(machine_arch_type == MACH_TYPE_CHILI)
+#else
+# define machine_is_chili()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEMETER
+# endif
+# define machine_is_demeter()	(machine_arch_type == MACH_TYPE_DEMETER)
+#else
+# define machine_is_demeter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIONYSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIONYSUS
+# endif
+# define machine_is_dionysus()	(machine_arch_type == MACH_TYPE_DIONYSUS)
+#else
+# define machine_is_dionysus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS352X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS352X
+# endif
+# define machine_is_as352x()	(machine_arch_type == MACH_TYPE_AS352X)
+#else
+# define machine_is_as352x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SERVICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SERVICE
+# endif
+# define machine_is_service()	(machine_arch_type == MACH_TYPE_SERVICE)
+#else
+# define machine_is_service()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CS_E9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS_E9301
+# endif
+# define machine_is_cs_e9301()	(machine_arch_type == MACH_TYPE_CS_E9301)
+#else
+# define machine_is_cs_e9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9M
+# endif
+# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
+#else
+# define machine_is_micro9m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_MOSPCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_MOSPCK
+# endif
+# define machine_is_ia_mospck()	(machine_arch_type == MACH_TYPE_IA_MOSPCK)
+#else
+# define machine_is_ia_mospck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL201B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL201B
+# endif
+# define machine_is_ql201b()	(machine_arch_type == MACH_TYPE_QL201B)
+#else
+# define machine_is_ql201b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BBM
+# endif
+# define machine_is_bbm()	(machine_arch_type == MACH_TYPE_BBM)
+#else
+# define machine_is_bbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXXX
+# endif
+# define machine_is_exxx()	(machine_arch_type == MACH_TYPE_EXXX)
+#else
+# define machine_is_exxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WMA11B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WMA11B
+# endif
+# define machine_is_wma11b()	(machine_arch_type == MACH_TYPE_WMA11B)
+#else
+# define machine_is_wma11b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ATLAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ATLAS
+# endif
+# define machine_is_pelco_atlas()	(machine_arch_type == MACH_TYPE_PELCO_ATLAS)
+#else
+# define machine_is_pelco_atlas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G500
+# endif
+# define machine_is_g500()	(machine_arch_type == MACH_TYPE_G500)
+#else
+# define machine_is_g500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG
+# endif
+# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
+#else
+# define machine_is_bug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX33ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX33ADS
+# endif
+# define machine_is_mx33ads()	(machine_arch_type == MACH_TYPE_MX33ADS)
+#else
+# define machine_is_mx33ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHUB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHUB
+# endif
+# define machine_is_chub()	(machine_arch_type == MACH_TYPE_CHUB)
+#else
+# define machine_is_chub()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA01
+# endif
+# define machine_is_neo1973_gta01()	(machine_arch_type == MACH_TYPE_NEO1973_GTA01)
+#else
+# define machine_is_neo1973_gta01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N740
+# endif
+# define machine_is_w90n740()	(machine_arch_type == MACH_TYPE_W90N740)
+#else
+# define machine_is_w90n740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEDALLION_SA2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEDALLION_SA2410
+# endif
+# define machine_is_medallion_sa2410()	(machine_arch_type == MACH_TYPE_MEDALLION_SA2410)
+#else
+# define machine_is_medallion_sa2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_CPU_9200_2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_CPU_9200_2
+# endif
+# define machine_is_ia_cpu_9200_2()	(machine_arch_type == MACH_TYPE_IA_CPU_9200_2)
+#else
+# define machine_is_ia_cpu_9200_2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMMRM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMMRM9200
+# endif
+# define machine_is_dimmrm9200()	(machine_arch_type == MACH_TYPE_DIMMRM9200)
+#else
+# define machine_is_dimmrm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM9261
+# endif
+# define machine_is_pm9261()	(machine_arch_type == MACH_TYPE_PM9261)
+#else
+# define machine_is_pm9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML7304
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML7304
+# endif
+# define machine_is_ml7304()	(machine_arch_type == MACH_TYPE_ML7304)
+#else
+# define machine_is_ml7304()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCP250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCP250
+# endif
+# define machine_is_ucp250()	(machine_arch_type == MACH_TYPE_UCP250)
+#else
+# define machine_is_ucp250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTBOARD
+# endif
+# define machine_is_intboard()	(machine_arch_type == MACH_TYPE_INTBOARD)
+#else
+# define machine_is_intboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GULFSTREAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GULFSTREAM
+# endif
+# define machine_is_gulfstream()	(machine_arch_type == MACH_TYPE_GULFSTREAM)
+#else
+# define machine_is_gulfstream()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LABQUEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LABQUEST
+# endif
+# define machine_is_labquest()	(machine_arch_type == MACH_TYPE_LABQUEST)
+#else
+# define machine_is_labquest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCMX313
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCMX313
+# endif
+# define machine_is_vcmx313()	(machine_arch_type == MACH_TYPE_VCMX313)
+#else
+# define machine_is_vcmx313()	(0)
+#endif
+
+#ifdef CONFIG_MACH_URG200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_URG200
+# endif
+# define machine_is_urg200()	(machine_arch_type == MACH_TYPE_URG200)
+#else
+# define machine_is_urg200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUX255LCDNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUX255LCDNET
+# endif
+# define machine_is_cpux255lcdnet()	(machine_arch_type == MACH_TYPE_CPUX255LCDNET)
+#else
+# define machine_is_cpux255lcdnet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU9
+# endif
+# define machine_is_netdcu9()	(machine_arch_type == MACH_TYPE_NETDCU9)
+#else
+# define machine_is_netdcu9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU10
+# endif
+# define machine_is_netdcu10()	(machine_arch_type == MACH_TYPE_NETDCU10)
+#else
+# define machine_is_netdcu10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DGA
+# endif
+# define machine_is_dspg_dga()	(machine_arch_type == MACH_TYPE_DSPG_DGA)
+#else
+# define machine_is_dspg_dga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DVW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DVW
+# endif
+# define machine_is_dspg_dvw()	(machine_arch_type == MACH_TYPE_DSPG_DVW)
+#else
+# define machine_is_dspg_dvw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOLOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOLOS
+# endif
+# define machine_is_solos()	(machine_arch_type == MACH_TYPE_SOLOS)
+#else
+# define machine_is_solos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
+# endif
+# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
+#else
+# define machine_is_at91sam9263ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSSTBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSSTBOX
+# endif
+# define machine_is_osstbox()	(machine_arch_type == MACH_TYPE_OSSTBOX)
+#else
+# define machine_is_osstbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KBAT9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KBAT9261
+# endif
+# define machine_is_kbat9261()	(machine_arch_type == MACH_TYPE_KBAT9261)
+#else
+# define machine_is_kbat9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT1100
+# endif
+# define machine_is_ct1100()	(machine_arch_type == MACH_TYPE_CT1100)
+#else
+# define machine_is_ct1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKCPPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKCPPXA
+# endif
+# define machine_is_akcppxa()	(machine_arch_type == MACH_TYPE_AKCPPXA)
+#else
+# define machine_is_akcppxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEVIO_1020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEVIO_1020
+# endif
+# define machine_is_zevio_1020()	(machine_arch_type == MACH_TYPE_ZEVIO_1020)
+#else
+# define machine_is_zevio_1020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HITRACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HITRACK
+# endif
+# define machine_is_hitrack()	(machine_arch_type == MACH_TYPE_HITRACK)
+#else
+# define machine_is_hitrack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYME1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYME1
+# endif
+# define machine_is_syme1()	(machine_arch_type == MACH_TYPE_SYME1)
+#else
+# define machine_is_syme1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYHL1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYHL1
+# endif
+# define machine_is_syhl1()	(machine_arch_type == MACH_TYPE_SYHL1)
+#else
+# define machine_is_syhl1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPCA400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPCA400
+# endif
+# define machine_is_empca400()	(machine_arch_type == MACH_TYPE_EMPCA400)
+#else
+# define machine_is_empca400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM7210
+# endif
+# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
+#else
+# define machine_is_em7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCHERMES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCHERMES
+# endif
+# define machine_is_htchermes()	(machine_arch_type == MACH_TYPE_HTCHERMES)
+#else
+# define machine_is_htchermes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_C1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_C1
+# endif
+# define machine_is_eti_c1()	(machine_arch_type == MACH_TYPE_ETI_C1)
+#else
+# define machine_is_eti_c1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_DEP2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_DEP2410
+# endif
+# define machine_is_mach_dep2410()	(machine_arch_type == MACH_TYPE_MACH_DEP2410)
+#else
+# define machine_is_mach_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AC100
+# endif
+# define machine_is_ac100()	(machine_arch_type == MACH_TYPE_AC100)
+#else
+# define machine_is_ac100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNEETCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNEETCH
+# endif
+# define machine_is_sneetch()	(machine_arch_type == MACH_TYPE_SNEETCH)
+#else
+# define machine_is_sneetch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STUDENTMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STUDENTMATE
+# endif
+# define machine_is_studentmate()	(machine_arch_type == MACH_TYPE_STUDENTMATE)
+#else
+# define machine_is_studentmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2410
+# endif
+# define machine_is_zir2410()	(machine_arch_type == MACH_TYPE_ZIR2410)
+#else
+# define machine_is_zir2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2413
+# endif
+# define machine_is_zir2413()	(machine_arch_type == MACH_TYPE_ZIR2413)
+#else
+# define machine_is_zir2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLONIP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLONIP3
+# endif
+# define machine_is_dlonip3()	(machine_arch_type == MACH_TYPE_DLONIP3)
+#else
+# define machine_is_dlonip3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INSTREAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INSTREAM
+# endif
+# define machine_is_instream()	(machine_arch_type == MACH_TYPE_INSTREAM)
+#else
+# define machine_is_instream()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMBARELLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMBARELLA
+# endif
+# define machine_is_ambarella()	(machine_arch_type == MACH_TYPE_AMBARELLA)
+#else
+# define machine_is_ambarella()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEVIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEVIS
+# endif
+# define machine_is_nevis()	(machine_arch_type == MACH_TYPE_NEVIS)
+#else
+# define machine_is_nevis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_TRINITY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_TRINITY
+# endif
+# define machine_is_htc_trinity()	(machine_arch_type == MACH_TYPE_HTC_TRINITY)
+#else
+# define machine_is_htc_trinity()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL202B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL202B
+# endif
+# define machine_is_ql202b()	(machine_arch_type == MACH_TYPE_QL202B)
+#else
+# define machine_is_ql202b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPAC270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPAC270
+# endif
+# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
+#else
+# define machine_is_vpac270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD129
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD129
+# endif
+# define machine_is_rd129()	(machine_arch_type == MACH_TYPE_RD129)
+#else
+# define machine_is_rd129()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCWIZARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCWIZARD
+# endif
+# define machine_is_htcwizard()	(machine_arch_type == MACH_TYPE_HTCWIZARD)
+#else
+# define machine_is_htcwizard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_TREO680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_TREO680
+# endif
+# define machine_is_xscale_treo680()	(machine_arch_type == MACH_TYPE_XSCALE_TREO680)
+#else
+# define machine_is_xscale_treo680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TECON_TMEZON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TECON_TMEZON
+# endif
+# define machine_is_tecon_tmezon()	(machine_arch_type == MACH_TYPE_TECON_TMEZON)
+#else
+# define machine_is_tecon_tmezon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE
+# endif
+# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
+#else
+# define machine_is_zylonite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENE1270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENE1270
+# endif
+# define machine_is_gene1270()	(machine_arch_type == MACH_TYPE_GENE1270)
+#else
+# define machine_is_gene1270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2412
+# endif
+# define machine_is_zir2412()	(machine_arch_type == MACH_TYPE_ZIR2412)
+#else
+# define machine_is_zir2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31LITE
+# endif
+# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
+#else
+# define machine_is_mx31lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T700WX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T700WX
+# endif
+# define machine_is_t700wx()	(machine_arch_type == MACH_TYPE_T700WX)
+#else
+# define machine_is_t700wx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VF100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VF100
+# endif
+# define machine_is_vf100()	(machine_arch_type == MACH_TYPE_VF100)
+#else
+# define machine_is_vf100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB2
+# endif
+# define machine_is_nsb2()	(machine_arch_type == MACH_TYPE_NSB2)
+#else
+# define machine_is_nsb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXHMI_BB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXHMI_BB
+# endif
+# define machine_is_nxhmi_bb()	(machine_arch_type == MACH_TYPE_NXHMI_BB)
+#else
+# define machine_is_nxhmi_bb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXHMI_RE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXHMI_RE
+# endif
+# define machine_is_nxhmi_re()	(machine_arch_type == MACH_TYPE_NXHMI_RE)
+#else
+# define machine_is_nxhmi_re()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N4100PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N4100PRO
+# endif
+# define machine_is_n4100pro()	(machine_arch_type == MACH_TYPE_N4100PRO)
+#else
+# define machine_is_n4100pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9260
+# endif
+# define machine_is_sam9260()	(machine_arch_type == MACH_TYPE_SAM9260)
+#else
+# define machine_is_sam9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TREO600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TREO600
+# endif
+# define machine_is_omap_treo600()	(machine_arch_type == MACH_TYPE_OMAP_TREO600)
+#else
+# define machine_is_omap_treo600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INDY2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INDY2410
+# endif
+# define machine_is_indy2410()	(machine_arch_type == MACH_TYPE_INDY2410)
+#else
+# define machine_is_indy2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NELT_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NELT_A
+# endif
+# define machine_is_nelt_a()	(machine_arch_type == MACH_TYPE_NELT_A)
+#else
+# define machine_is_nelt_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N311
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N311
+# endif
+# define machine_is_n311()	(machine_arch_type == MACH_TYPE_N311)
+#else
+# define machine_is_n311()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260VGK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260VGK
+# endif
+# define machine_is_at91sam9260vgk()	(machine_arch_type == MACH_TYPE_AT91SAM9260VGK)
+#else
+# define machine_is_at91sam9260vgk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91LEPPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91LEPPE
+# endif
+# define machine_is_at91leppe()	(machine_arch_type == MACH_TYPE_AT91LEPPE)
+#else
+# define machine_is_at91leppe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91LEPCCN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91LEPCCN
+# endif
+# define machine_is_at91lepccn()	(machine_arch_type == MACH_TYPE_AT91LEPCCN)
+#else
+# define machine_is_at91lepccn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APC7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APC7100
+# endif
+# define machine_is_apc7100()	(machine_arch_type == MACH_TYPE_APC7100)
+#else
+# define machine_is_apc7100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGAZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGAZER
+# endif
+# define machine_is_stargazer()	(machine_arch_type == MACH_TYPE_STARGAZER)
+#else
+# define machine_is_stargazer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONATA
+# endif
+# define machine_is_sonata()	(machine_arch_type == MACH_TYPE_SONATA)
+#else
+# define machine_is_sonata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCHMOOGIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCHMOOGIE
+# endif
+# define machine_is_schmoogie()	(machine_arch_type == MACH_TYPE_SCHMOOGIE)
+#else
+# define machine_is_schmoogie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AZTOOL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AZTOOL
+# endif
+# define machine_is_aztool()	(machine_arch_type == MACH_TYPE_AZTOOL)
+#else
+# define machine_is_aztool()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA701
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA701
+# endif
+# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
+#else
+# define machine_is_mioa701()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SXNI9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SXNI9260
+# endif
+# define machine_is_sxni9260()	(machine_arch_type == MACH_TYPE_SXNI9260)
+#else
+# define machine_is_sxni9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27520EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27520EVB
+# endif
+# define machine_is_mxc27520evb()	(machine_arch_type == MACH_TYPE_MXC27520EVB)
+#else
+# define machine_is_mxc27520evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO5X0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
+# endif
+# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
+#else
+# define machine_is_armadillo5x0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9260
+# endif
+# define machine_is_mb9260()	(machine_arch_type == MACH_TYPE_MB9260)
+#else
+# define machine_is_mb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9263
+# endif
+# define machine_is_mb9263()	(machine_arch_type == MACH_TYPE_MB9263)
+#else
+# define machine_is_mb9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPAC9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPAC9302
+# endif
+# define machine_is_ipac9302()	(machine_arch_type == MACH_TYPE_IPAC9302)
+#else
+# define machine_is_ipac9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360JS
+# endif
+# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
+#else
+# define machine_is_cc9p9360js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GALLIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GALLIUM
+# endif
+# define machine_is_gallium()	(machine_arch_type == MACH_TYPE_GALLIUM)
+#else
+# define machine_is_gallium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSC2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSC2410
+# endif
+# define machine_is_msc2410()	(machine_arch_type == MACH_TYPE_MSC2410)
+#else
+# define machine_is_msc2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GHI270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GHI270
+# endif
+# define machine_is_ghi270()	(machine_arch_type == MACH_TYPE_GHI270)
+#else
+# define machine_is_ghi270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_LEONARDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_LEONARDO
+# endif
+# define machine_is_davinci_leonardo()	(machine_arch_type == MACH_TYPE_DAVINCI_LEONARDO)
+#else
+# define machine_is_davinci_leonardo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OIAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OIAB
+# endif
+# define machine_is_oiab()	(machine_arch_type == MACH_TYPE_OIAB)
+#else
+# define machine_is_oiab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6400
+# endif
+# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
+#else
+# define machine_is_smdk6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N800
+# endif
+# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
+#else
+# define machine_is_nokia_n800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GREENPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREENPHONE
+# endif
+# define machine_is_greenphone()	(machine_arch_type == MACH_TYPE_GREENPHONE)
+#else
+# define machine_is_greenphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPEXWP18
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPEXWP18
+# endif
+# define machine_is_compex42x()	(machine_arch_type == MACH_TYPE_COMPEXWP18)
+#else
+# define machine_is_compex42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XMATE
+# endif
+# define machine_is_xmate()	(machine_arch_type == MACH_TYPE_XMATE)
+#else
+# define machine_is_xmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENERGIZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENERGIZER
+# endif
+# define machine_is_energizer()	(machine_arch_type == MACH_TYPE_ENERGIZER)
+#else
+# define machine_is_energizer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IME1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IME1
+# endif
+# define machine_is_ime1()	(machine_arch_type == MACH_TYPE_IME1)
+#else
+# define machine_is_ime1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWEDATMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWEDATMS
+# endif
+# define machine_is_sweda_tms()	(machine_arch_type == MACH_TYPE_SWEDATMS)
+#else
+# define machine_is_sweda_tms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NTNP435C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTNP435C
+# endif
+# define machine_is_ntnp435c()	(machine_arch_type == MACH_TYPE_NTNP435C)
+#else
+# define machine_is_ntnp435c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPECTRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPECTRO2
+# endif
+# define machine_is_spectro2()	(machine_arch_type == MACH_TYPE_SPECTRO2)
+#else
+# define machine_is_spectro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6039
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6039
+# endif
+# define machine_is_h6039()	(machine_arch_type == MACH_TYPE_H6039)
+#else
+# define machine_is_h6039()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP80219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP80219
+# endif
+# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
+#else
+# define machine_is_ep80219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMOA_II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMOA_II
+# endif
+# define machine_is_samoa_ii()	(machine_arch_type == MACH_TYPE_SAMOA_II)
+#else
+# define machine_is_samoa_ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMXL
+# endif
+# define machine_is_cwmxl()	(machine_arch_type == MACH_TYPE_CWMXL)
+#else
+# define machine_is_cwmxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS9200
+# endif
+# define machine_is_as9200()	(machine_arch_type == MACH_TYPE_AS9200)
+#else
+# define machine_is_as9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFX1149
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFX1149
+# endif
+# define machine_is_sfx1149()	(machine_arch_type == MACH_TYPE_SFX1149)
+#else
+# define machine_is_sfx1149()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAVI010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAVI010
+# endif
+# define machine_is_navi010()	(machine_arch_type == MACH_TYPE_NAVI010)
+#else
+# define machine_is_navi010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTMDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTMDP
+# endif
+# define machine_is_multmdp()	(machine_arch_type == MACH_TYPE_MULTMDP)
+#else
+# define machine_is_multmdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9520
+# endif
+# define machine_is_scb9520()	(machine_arch_type == MACH_TYPE_SCB9520)
+#else
+# define machine_is_scb9520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCATHENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCATHENA
+# endif
+# define machine_is_htcathena()	(machine_arch_type == MACH_TYPE_HTCATHENA)
+#else
+# define machine_is_htcathena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XP179
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP179
+# endif
+# define machine_is_xp179()	(machine_arch_type == MACH_TYPE_XP179)
+#else
+# define machine_is_xp179()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4300
+# endif
+# define machine_is_h4300()	(machine_arch_type == MACH_TYPE_H4300)
+#else
+# define machine_is_h4300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GORAMO_MLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
+# endif
+# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
+#else
+# define machine_is_goramo_mlr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30020EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30020EVB
+# endif
+# define machine_is_mxc30020evb()	(machine_arch_type == MACH_TYPE_MXC30020EVB)
+#else
+# define machine_is_mxc30020evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSBITSIMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSIMX
+# endif
+# define machine_is_adsbitsymx()	(machine_arch_type == MACH_TYPE_ADSBITSIMX)
+#else
+# define machine_is_adsbitsymx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSPORTALPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSPORTALPLUS
+# endif
+# define machine_is_adsportalplus()	(machine_arch_type == MACH_TYPE_ADSPORTALPLUS)
+#else
+# define machine_is_adsportalplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMSP2PLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMSP2PLUS
+# endif
+# define machine_is_mmsp2plus()	(machine_arch_type == MACH_TYPE_MMSP2PLUS)
+#else
+# define machine_is_mmsp2plus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_X270
+# endif
+# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
+#else
+# define machine_is_em_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPP302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPP302
+# endif
+# define machine_is_tpp302()	(machine_arch_type == MACH_TYPE_TPP302)
+#else
+# define machine_is_tpp302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM104
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM104
+# endif
+# define machine_is_tpp104()	(machine_arch_type == MACH_TYPE_TPM104)
+#else
+# define machine_is_tpp104()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM102
+# endif
+# define machine_is_tpm102()	(machine_arch_type == MACH_TYPE_TPM102)
+#else
+# define machine_is_tpm102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM109
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM109
+# endif
+# define machine_is_tpm109()	(machine_arch_type == MACH_TYPE_TPM109)
+#else
+# define machine_is_tpm109()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FBXO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FBXO1
+# endif
+# define machine_is_fbxo1()	(machine_arch_type == MACH_TYPE_FBXO1)
+#else
+# define machine_is_fbxo1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HXD8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HXD8
+# endif
+# define machine_is_hxd8()	(machine_arch_type == MACH_TYPE_HXD8)
+#else
+# define machine_is_hxd8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
+# endif
+# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
+#else
+# define machine_is_neo1973_gta02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMTEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMTEST
+# endif
+# define machine_is_emtest()	(machine_arch_type == MACH_TYPE_EMTEST)
+#else
+# define machine_is_emtest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AD6900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AD6900
+# endif
+# define machine_is_ad6900()	(machine_arch_type == MACH_TYPE_AD6900)
+#else
+# define machine_is_ad6900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUROPA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUROPA
+# endif
+# define machine_is_europa()	(machine_arch_type == MACH_TYPE_EUROPA)
+#else
+# define machine_is_europa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_METROCONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_METROCONNECT
+# endif
+# define machine_is_metroconnect()	(machine_arch_type == MACH_TYPE_METROCONNECT)
+#else
+# define machine_is_metroconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_S2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_S2410
+# endif
+# define machine_is_ez_s2410()	(machine_arch_type == MACH_TYPE_EZ_S2410)
+#else
+# define machine_is_ez_s2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_S2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_S2440
+# endif
+# define machine_is_ez_s2440()	(machine_arch_type == MACH_TYPE_EZ_S2440)
+#else
+# define machine_is_ez_s2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_EP9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_EP9312
+# endif
+# define machine_is_ez_ep9312()	(machine_arch_type == MACH_TYPE_EZ_EP9312)
+#else
+# define machine_is_ez_ep9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_EP9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_EP9315
+# endif
+# define machine_is_ez_ep9315()	(machine_arch_type == MACH_TYPE_EZ_EP9315)
+#else
+# define machine_is_ez_ep9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_X7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_X7
+# endif
+# define machine_is_ez_x7()	(machine_arch_type == MACH_TYPE_EZ_X7)
+#else
+# define machine_is_ez_x7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GODOTDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GODOTDB
+# endif
+# define machine_is_godotdb()	(machine_arch_type == MACH_TYPE_GODOTDB)
+#else
+# define machine_is_godotdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MISTRAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MISTRAL
+# endif
+# define machine_is_mistral()	(machine_arch_type == MACH_TYPE_MISTRAL)
+#else
+# define machine_is_mistral()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM
+# endif
+# define machine_is_msm()	(machine_arch_type == MACH_TYPE_MSM)
+#else
+# define machine_is_msm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT5910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT5910
+# endif
+# define machine_is_ct5910()	(machine_arch_type == MACH_TYPE_CT5910)
+#else
+# define machine_is_ct5910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT5912
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT5912
+# endif
+# define machine_is_ct5912()	(machine_arch_type == MACH_TYPE_CT5912)
+#else
+# define machine_is_ct5912()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYNET_INE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYNET_INE
+# endif
+# define machine_is_hynet_ine()	(machine_arch_type == MACH_TYPE_HYNET_INE)
+#else
+# define machine_is_hynet_ine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYNET_APP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYNET_APP
+# endif
+# define machine_is_hynet_app()	(machine_arch_type == MACH_TYPE_HYNET_APP)
+#else
+# define machine_is_hynet_app()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7200
+# endif
+# define machine_is_msm7200()	(machine_arch_type == MACH_TYPE_MSM7200)
+#else
+# define machine_is_msm7200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7600
+# endif
+# define machine_is_msm7600()	(machine_arch_type == MACH_TYPE_MSM7600)
+#else
+# define machine_is_msm7600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEB255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEB255
+# endif
+# define machine_is_ceb255()	(machine_arch_type == MACH_TYPE_CEB255)
+#else
+# define machine_is_ceb255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CIEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CIEL
+# endif
+# define machine_is_ciel()	(machine_arch_type == MACH_TYPE_CIEL)
+#else
+# define machine_is_ciel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLM5650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLM5650
+# endif
+# define machine_is_slm5650()	(machine_arch_type == MACH_TYPE_SLM5650)
+#else
+# define machine_is_slm5650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9RLEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
+# endif
+# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
+#else
+# define machine_is_at91sam9rlek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMTECH_ROUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMTECH_ROUTER
+# endif
+# define machine_is_comtech_router()	(machine_arch_type == MACH_TYPE_COMTECH_ROUTER)
+#else
+# define machine_is_comtech_router()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2410X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2410X
+# endif
+# define machine_is_sbc2410x()	(machine_arch_type == MACH_TYPE_SBC2410X)
+#else
+# define machine_is_sbc2410x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT4X0BD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT4X0BD
+# endif
+# define machine_is_at4x0bd()	(machine_arch_type == MACH_TYPE_AT4X0BD)
+#else
+# define machine_is_at4x0bd()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+/* #define MACH_TYPE_367                  <<not registered>> */
+#define machine_is_esl_wireless_tab()	(0)
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
Index: build_tree/linux/include/asm-arm/arch-pxa/pxa-regs.h
diff -u build_tree/linux/include/asm-arm/arch-pxa/pxa-regs.h:1.1.1.1 build_tree/linux/include/asm-arm/arch-pxa/pxa-regs.h:1.1.1.2
--- build_tree/linux/include/asm-arm/arch-pxa/pxa-regs.h:1.1.1.1	Thu Nov  8 14:27:48 2007
+++ build_tree/linux/include/asm-arm/arch-pxa/pxa-regs.h	Fri Nov  9 13:49:01 2007
@@ -1111,6 +1111,10 @@
 #define PWM_PWDUTY1	__REG(0x40C00004)  /* PWM 1 Duty Cycle Register */
 #define PWM_PERVAL1	__REG(0x40C00008)  /* PWM 1 Period Control Register */
 
+/* AERONIX added for Zipit2*/
+#define PWM_CTRL2       __REG(0x40B00010)
+#define PWM_PWDUTY2     __REG(0x40B00014)
+#define PWM_PERVAL2     __REG(0x40B00018)
 
 /*
  * Interrupt Controller
Index: build_tree/linux/include/asm-arm/arch-pxa/pxafb.h
diff -u build_tree/linux/include/asm-arm/arch-pxa/pxafb.h:1.1.1.1 build_tree/linux/include/asm-arm/arch-pxa/pxafb.h:1.1.1.2
--- build_tree/linux/include/asm-arm/arch-pxa/pxafb.h:1.1.1.1	Thu Nov  8 14:27:48 2007
+++ build_tree/linux/include/asm-arm/arch-pxa/pxafb.h	Fri Nov  9 13:49:01 2007
@@ -78,3 +78,58 @@
 void set_pxa_fb_info(struct pxafb_mach_info *hard_pxa_fb_info);
 void set_pxa_fb_parent(struct device *parent_dev);
 unsigned long pxafb_get_hsync_time(struct device *dev);
+
+
+/* PIXCLOCK --- unit 10khz*/
+/* Modified for Z2 Optrex */
+#define ZIPIT2
+
+#if 1   /*Z2 rev 2 LCD*/
+#define LCD_PIXCLOCK	688	
+/*JWK test new Z2 LCD 041607 #define LCD_PIXCLOCK		576 */
+#define LCD_BPP				16
+#define LCD_XRES			240
+#define LCD_YRES			320
+#define LCD_HORIZONTAL_SYNC_PULSE_WIDTH	4
+#define LCD_VERTICAL_SYNC_PULSE_WIDTH	4
+#define LCD_BEGIN_OF_LINE_WAIT_COUNT	4
+#define LCD_BEGIN_FRAME_WAIT_COUNT 	4
+#define LCD_END_OF_LINE_WAIT_COUNT	8
+#define LCD_END_OF_FRAME_WAIT_COUNT	8
+#define LCD_SYNC			(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT)
+#else /*Z2 rev 1 LCD*/
+#define LCD_PIXCLOCK	 		576	
+#define LCD_BPP				16
+#define LCD_XRES			240
+#define LCD_YRES			320
+#define LCD_HORIZONTAL_SYNC_PULSE_WIDTH	2
+#define LCD_VERTICAL_SYNC_PULSE_WIDTH	2
+#define LCD_BEGIN_OF_LINE_WAIT_COUNT	1
+#define LCD_BEGIN_FRAME_WAIT_COUNT 	1
+#define LCD_END_OF_LINE_WAIT_COUNT	10
+#define LCD_END_OF_FRAME_WAIT_COUNT	1
+#define LCD_SYNC			(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT)
+#endif 
+
+
+//#define LCD_LCCR0		0x1B00A78
+//#define LCD_LCCR3		0x4008000
+
+//#define LCD_LCCR0		(LCCR0_OUC | LCCR0_CMDIM | LCCR0_RDSTM | \
+                         LCCR0_OUM | LCCR0_BM | LCCR0_QDM | LCCR0_PAS | \
+                         LCCR0_EFM | LCCR0_IUM | LCCR0_SFM | LCCR0_LDM)
+
+/* Z2 -- Removed Active setting */
+/*#define LCD_LCCR0		(LCCR0_OUC | LCCR0_CMDIM | LCCR0_RDSTM | \
+                         LCCR0_OUM | LCCR0_BM | LCCR0_QDM | \
+                         LCCR0_EFM | LCCR0_IUM | LCCR0_SFM | LCCR0_LDM)
+*/
+#define LCD_LCCR0 0x05B00AF8 // per Frank W."older than IEEE"  Tinklepaugh
+
+/*#define LCD_LCCR3 	    (LCCR3_PCP | LCCR3_HSP | LCCR3_VSP )
+*/
+#if 0 /*Z2 rev 1 LCD*/
+#define LCD_LCCR3 0x04f00009
+#else  /*Z2 rev 2 LCD*/
+#define LCD_LCCR3 0x04b00006
+#endif
Index: build_tree/linux/include/asm-powerpc/eeh.h
diff -u build_tree/linux/include/asm-powerpc/eeh.h:1.1.1.1 build_tree/linux/include/asm-powerpc/eeh.h:1.2
--- build_tree/linux/include/asm-powerpc/eeh.h:1.1.1.1	Thu Nov  8 14:27:42 2007
+++ build_tree/linux/include/asm-powerpc/eeh.h	Mon Nov 12 10:16:37 2007
@@ -209,3 +209,4 @@
 
 #endif /* __KERNEL__ */
 #endif /* _PPC64_EEH_H */
+
Index: build_tree/linux/include/config/auto.conf
diff -u /dev/null build_tree/linux/include/config/auto.conf:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/include/config/auto.conf	Fri Nov  9 13:49:03 2007
@@ -0,0 +1,272 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.21.1
+# Wed Sep 19 09:53:53 2007
+#
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+CONFIG_MTD_ABSENT=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_FLATMEM=y
+CONFIG_I2C_PXA=m
+CONFIG_CPU_XSCALE=y
+CONFIG_SERIAL_PXA=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_NFS_COMMON=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_HW_CONSOLE=y
+CONFIG_XSCALE_PMU=y
+CONFIG_SPI_PXA2XX=m
+CONFIG_MTD_CFI=y
+CONFIG_SPI_MASTER=y
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_HAS_IOPORT=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_MODULES=y
+CONFIG_EXT2_FS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_CRYPTO_DES=y
+CONFIG_DNOTIFY=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_ARCH="arm"
+CONFIG_I2C_ALGOBIT=m
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RTC_LIB=y
+CONFIG_LOGO_ZIPIT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_SLAB=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_HOTPLUG=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_SND_PCM=m
+CONFIG_MTD_RAM=m
+CONFIG_MMC_PXA=y
+CONFIG_MACH_MAINSTONE=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_VFAT_FS=y
+CONFIG_SND_SOC=m
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_IPMI_SI=m
+CONFIG_KMOD=y
+CONFIG_PROC_FS=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_GPIO=m
+CONFIG_INET=y
+CONFIG_RT_MUTEXES=y
+CONFIG_LOGO=y
+CONFIG_SYSVIPC=y
+CONFIG_MTD_ROM=m
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_IP_SCTP=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_SWAP=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_CRC32=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_DEFAULT_CFQ=y
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_CPU_CP15=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PACKET_MMAP=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_UNIX=y
+CONFIG_SERIAL_CORE=y
+CONFIG_UID16=y
+CONFIG_BINFMT_MISC=m
+CONFIG_IP_FIB_HASH=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_WATCHDOG=y
+CONFIG_MTD_PARTITIONS=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+CONFIG_JFFS2_FS=y
+CONFIG_SND_PXA2XX_SOC=m
+CONFIG_LOCKD_V4=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_CPU_32v5=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_AUDIODRV=m
+CONFIG_ELF_CORE=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MTD_CHAR=y
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CRYPTO_HASH=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_SYN_COOKIES=y
+CONFIG_ARCH_PXA=y
+CONFIG_FORCED_INLINING=y
+CONFIG_BLOCK=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_LOCKD=y
+CONFIG_ZONE_DMA=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_KALLSYMS=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_NLS_UTF8=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_AUDIT=y
+CONFIG_SND_PCM_OSS=m
+CONFIG_RAMFS=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SHMEM=y
+CONFIG_EPOLL=y
+CONFIG_MSDOS_FS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_RPCSEC_GSS_KRB5=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_FB=y
+CONFIG_SOUND=m
+CONFIG_TMPFS=y
+CONFIG_ASK_IP_FIB_HASH=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_IPMI_HANDLER=m
+CONFIG_DUMMY=m
+CONFIG_PLIST=y
+CONFIG_FUTEX=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_INPUT=y
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_LOCALVERSION=""
+CONFIG_ZLIB_INFLATE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_SYSFS=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_PM=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_HZ=100
+CONFIG_NLS_ISO8859_1=y
+CONFIG_MMC_BLOCK=y
+CONFIG_VT=y
+CONFIG_CPU_32=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_BASE_FULL=y
+CONFIG_CRC_CCITT=m
+CONFIG_IP_MULTICAST=y
+CONFIG_MTD_BLOCK=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_FW_LOADER=y
+CONFIG_NLS_ASCII=y
+CONFIG_NET_RADIO=y
+CONFIG_PACKET=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_FPE_NWFPE=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_I2C=m
+CONFIG_ARM_THUMB=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_SND_TIMER=m
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_PXA27x=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_FB_PXA=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_LBD=y
+CONFIG_AUDIT_GENERIC=y
+CONFIG_FAT_FS=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_IP_MROUTE=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_UNAME_RELEASE="2.6.17-1.2142_FC4smp"
+CONFIG_SCTP_HMAC_MD5=y
+CONFIG_PRINTK=y
+CONFIG_SUNRPC=y
+CONFIG_FS_MBCACHE=y
+CONFIG_MMC=y
+CONFIG_INITRAMFS_SOURCE="../rfs"
+CONFIG_BUG=y
+CONFIG_NFS_FS=y
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_ARM=y
+CONFIG_CRYPTO=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_SYSCTL=y
+CONFIG_SND=m
+CONFIG_MTD=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_IWMMXT=y
+CONFIG_NET=y
+CONFIG_KERNELVERSION="2.6.21.1"
+CONFIG_MODULE_UNLOAD=y
+CONFIG_STANDALONE=y
+CONFIG_NETDEVICES=y
+CONFIG_FRAME_POINTER=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_SPI=y
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_NLS=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MMU=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_MTD_CFI_I2=y
+CONFIG_DEBUG_INFO=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_MTD_MAINSTONE=y
+CONFIG_IOSCHED_AS=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_BASE_SMALL=0
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_BINFMT_ELF=y
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_BITREVERSE=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_CMDLINE="console=ttyS2,115200"
+CONFIG_DUMMY_CONSOLE=y
Index: build_tree/linux/include/config/auto.conf.cmd
diff -u /dev/null build_tree/linux/include/config/auto.conf.cmd:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/include/config/auto.conf.cmd	Fri Nov  9 13:49:03 2007
@@ -0,0 +1,279 @@
+deps_config := \
+	lib/Kconfig \
+	arch/s390/crypto/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.debug \
+	arch/arm/Kconfig.debug \
+	arch/arm/oprofile/Kconfig \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/Kconfig \
+	drivers/audiodrv/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/net/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/input/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/at91/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/usb/Kconfig \
+	sound/mips/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/cinergyT2/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/dvb-core/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/zc0301/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvideo/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/chips/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/drm/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/watchdog/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/serial/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/bcm43xx/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/fec_8xx/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/ieee1394/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/acorn/block/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/Kconfig \
+	net/ieee80211/softmac/Kconfig \
+	net/ieee80211/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/sched/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/bridge/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/ipvs/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	kernel/power/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/cpufreq/Kconfig \
+	mm/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	arch/arm/common/Kconfig \
+	arch/arm/Kconfig-nommu \
+	arch/arm/mm/Kconfig \
+	arch/arm/mach-ns9xxx/Kconfig \
+	arch/arm/mach-netx/Kconfig \
+	arch/arm/mach-at91/Kconfig \
+	arch/arm/mach-realview/Kconfig \
+	arch/arm/mach-aaec2000/Kconfig \
+	arch/arm/mach-versatile/Kconfig \
+	arch/arm/mach-h720x/Kconfig \
+	arch/arm/mach-imx/Kconfig \
+	arch/arm/mach-lh7a40x/Kconfig \
+	arch/arm/mach-s3c2443/Kconfig \
+	arch/arm/mach-s3c2442/Kconfig \
+	arch/arm/mach-s3c2440/Kconfig \
+	arch/arm/mach-s3c2412/Kconfig \
+	arch/arm/mach-s3c2410/Kconfig \
+	arch/arm/mach-s3c2400/Kconfig \
+	arch/arm/plat-s3c24xx/Kconfig \
+	arch/arm/mach-omap2/Kconfig \
+	arch/arm/mach-omap1/Kconfig \
+	arch/arm/plat-omap/Kconfig \
+	arch/arm/mach-sa1100/Kconfig \
+	arch/arm/mach-pxa/Kconfig \
+	arch/arm/mach-ixp23xx/Kconfig \
+	arch/arm/mach-ixp2000/Kconfig \
+	arch/arm/mach-ixp4xx/Kconfig \
+	arch/arm/mach-iop13xx/Kconfig \
+	arch/arm/mach-iop33x/Kconfig \
+	arch/arm/mach-iop32x/Kconfig \
+	arch/arm/mach-integrator/Kconfig \
+	arch/arm/mach-footbridge/Kconfig \
+	arch/arm/mach-ep93xx/Kconfig \
+	arch/arm/mach-clps711x/Kconfig \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	usr/Kconfig \
+	init/Kconfig \
+	arch/arm/Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+$(deps_config): ;
Index: build_tree/linux/include/config/kernel.release
diff -u /dev/null build_tree/linux/include/config/kernel.release:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/include/config/kernel.release	Fri Nov  9 13:49:03 2007
@@ -0,0 +1 @@
+2.6.21.1
Index: build_tree/linux/include/linux/autoconf.h
diff -u /dev/null build_tree/linux/include/linux/autoconf.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/include/linux/autoconf.h	Fri Nov  9 13:48:45 2007
@@ -0,0 +1,273 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.21.1
+ * Wed Sep 19 09:53:53 2007
+ */
+#define AUTOCONF_INCLUDED
+#define CONFIG_DEBUG_SPINLOCK_SLEEP 1
+#define CONFIG_MTD_ABSENT_MODULE 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_FLATMEM 1
+#define CONFIG_I2C_PXA_MODULE 1
+#define CONFIG_CPU_XSCALE 1
+#define CONFIG_SERIAL_PXA 1
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
+#define CONFIG_BROKEN_ON_SMP 1
+#define CONFIG_EXT2_FS_XATTR 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_XSCALE_PMU 1
+#define CONFIG_SPI_PXA2XX_MODULE 1
+#define CONFIG_MTD_CFI 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_MTD_JEDECPROBE_MODULE 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_JFFS2_FS_DEBUG 0
+#define CONFIG_MODULES 1
+#define CONFIG_EXT2_FS 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_SND_MIXER_OSS_MODULE 1
+#define CONFIG_ARCH "arm"
+#define CONFIG_I2C_ALGOBIT_MODULE 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_LOGO_ZIPIT 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_DETECT_SOFTLOCKUP 1
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define CONFIG_SLAB 1
+#define CONFIG_FLATMEM_MANUAL 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_SND_PCM_MODULE 1
+#define CONFIG_MTD_RAM_MODULE 1
+#define CONFIG_MMC_PXA 1
+#define CONFIG_MACH_MAINSTONE 1
+#define CONFIG_SUNRPC_GSS 1
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_SND_SOC_MODULE 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_IPMI_SI_MODULE 1
+#define CONFIG_KMOD 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_IPMI_DEVICE_INTERFACE_MODULE 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_GPIO_MODULE 1
+#define CONFIG_INET 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_LOGO 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_MTD_ROM_MODULE 1
+#define CONFIG_MTD_CFI_AMDSTD 1
+#define CONFIG_IP_SCTP_MODULE 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_CRYPTO_DEFLATE_MODULE 1
+#define CONFIG_ALIGNMENT_TRAP 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_JFFS2_RTIME 1
+#define CONFIG_SWAP 1
+#define CONFIG_EXT2_FS_POSIX_ACL 1
+#define CONFIG_CRC32 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_DEFAULT_CFQ 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_CPU_CP15 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_PACKET_MMAP 1
+#define CONFIG_CPU_CACHE_VIVT 1
+#define CONFIG_UNIX 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_UID16 1
+#define CONFIG_BINFMT_MISC_MODULE 1
+#define CONFIG_IP_FIB_HASH 1
+#define CONFIG_CRYPTO_SHA1 1
+#define CONFIG_PARTITION_ADVANCED 1
+#define CONFIG_MTD_BLKDEVS 1
+#define CONFIG_NLS_DEFAULT "utf8"
+#define CONFIG_WATCHDOG 1
+#define CONFIG_MTD_PARTITIONS 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4096
+#define CONFIG_JFFS2_FS 1
+#define CONFIG_SND_PXA2XX_SOC_MODULE 1
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_CPU_32v5 1
+#define CONFIG_CRYPTO_HMAC 1
+#define CONFIG_BLK_DEV_RAM_BLOCKSIZE 1024
+#define CONFIG_SYSCTL_SYSCALL 1
+#define CONFIG_AUDIODRV_MODULE 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_MTD_CHAR 1
+#define CONFIG_DEFAULT_IOSCHED "cfq"
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_IP_PIMSM_V1 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_IP_PIMSM_V2 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_SYN_COOKIES 1
+#define CONFIG_ARCH_PXA 1
+#define CONFIG_FORCED_INLINING 1
+#define CONFIG_BLOCK 1
+#define CONFIG_SND_OSSEMUL 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_LOCKD 1
+#define CONFIG_ZONE_DMA 1
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_AUDIT 1
+#define CONFIG_SND_PCM_OSS_MODULE 1
+#define CONFIG_RAMFS 1
+#define CONFIG_SERIAL_PXA_CONSOLE 1
+#define CONFIG_SHMEM 1
+#define CONFIG_EPOLL 1
+#define CONFIG_MSDOS_FS 1
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define CONFIG_RPCSEC_GSS_KRB5 1
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_INITRAMFS_ROOT_GID 0
+#define CONFIG_ZLIB_DEFLATE 1
+#define CONFIG_SND_VERBOSE_PROCFS 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define CONFIG_FB 1
+#define CONFIG_SOUND_MODULE 1
+#define CONFIG_TMPFS 1
+#define CONFIG_ASK_IP_FIB_HASH 1
+#define CONFIG_GENERIC_TIME 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_IPMI_HANDLER_MODULE 1
+#define CONFIG_DUMMY_MODULE 1
+#define CONFIG_PLIST 1
+#define CONFIG_FUTEX 1
+#define CONFIG_CPU_CP15_MMU 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_NETWORK_SECMARK 1
+#define CONFIG_INPUT 1
+#define CONFIG_INITRAMFS_ROOT_UID 0
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_SYSFS 1
+#define CONFIG_NFS_DIRECTIO 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_PM 1
+#define CONFIG_MTD_CFI_STAA 1
+#define CONFIG_IP_ROUTE_MULTIPATH 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define CONFIG_HZ 100
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_MMC_BLOCK 1
+#define CONFIG_VT 1
+#define CONFIG_CPU_32 1
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_CRC_CCITT_MODULE 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_MTD_BLOCK 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_BLK_DEV_LOOP_MODULE 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_ARCH_MTD_XIP 1
+#define CONFIG_MTD_CFI_UTIL 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_NLS_ASCII 1
+#define CONFIG_NET_RADIO 1
+#define CONFIG_PACKET 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_FS_POSIX_ACL 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_FPE_NWFPE 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_WIRELESS_EXT 1
+#define CONFIG_I2C_MODULE 1
+#define CONFIG_ARM_THUMB 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_POSIX_MQUEUE 1
+#define CONFIG_SND_TIMER_MODULE 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_SYSFS_DEPRECATED 1
+#define CONFIG_PXA27x 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_NFS_V4 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_FB_PXA 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_LBD 1
+#define CONFIG_AUDIT_GENERIC 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_IP_MROUTE 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_UNAME_RELEASE "2.6.17-1.2142_FC4smp"
+#define CONFIG_SCTP_HMAC_MD5 1
+#define CONFIG_PRINTK 1
+#define CONFIG_SUNRPC 1
+#define CONFIG_FS_MBCACHE 1
+#define CONFIG_MMC 1
+#define CONFIG_INITRAMFS_SOURCE "../rfs"
+#define CONFIG_BUG 1
+#define CONFIG_NFS_FS 1
+#define CONFIG_IPMI_WATCHDOG_MODULE 1
+#define CONFIG_ARM 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_MTD_CFI_INTELEXT 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_SND_MODULE 1
+#define CONFIG_MTD 1
+#define CONFIG_ZONE_DMA_FLAG 1
+#define CONFIG_IWMMXT 1
+#define CONFIG_NET 1
+#define CONFIG_KERNELVERSION "2.6.21.1"
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_FRAME_POINTER 1
+#define CONFIG_JFFS2_ZLIB 1
+#define CONFIG_SPI 1
+#define CONFIG_SOFT_WATCHDOG_MODULE 1
+#define CONFIG_NLS 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_MTD_CFI_I1 1
+#define CONFIG_MMU 1
+#define CONFIG_BLK_DEV_RAM_SIZE 16384
+#define CONFIG_MTD_CFI_I2 1
+#define CONFIG_DEBUG_INFO 1
+#define CONFIG_EXT2_FS_SECURITY 1
+#define CONFIG_MTD_MAINSTONE 1
+#define CONFIG_IOSCHED_AS 1
+#define CONFIG_CPU_ABRT_EV5T 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_CPU_TLB_V4WBI 1
+#define CONFIG_MTD_GEN_PROBE 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_JFFS2_FS_WRITEBUFFER 1
+#define CONFIG_SND_PCM_OSS_PLUGINS 1
+#define CONFIG_LOG_BUF_SHIFT 17
+#define CONFIG_BITREVERSE 1
+#define CONFIG_IP_ROUTE_VERBOSE 1
+#define CONFIG_CMDLINE "console=ttyS2,115200"
+#define CONFIG_DUMMY_CONSOLE 1
Index: build_tree/linux/include/linux/gpio-ioctl.h
diff -u /dev/null build_tree/linux/include/linux/gpio-ioctl.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/include/linux/gpio-ioctl.h	Fri Nov  9 13:48:44 2007
@@ -0,0 +1,50 @@
+
+#ifndef __GPIO_IOCTL_H_
+#define __GPIO_IOCTL_H_
+
+#include <linux/ioctl.h>
+
+#define GPIO_IOCTL_API_VERSION (1 << 16 | 0)
+
+#define GPIO_IOCTL_BASE	'O'
+
+#define GPIO_DRV_GETVERSION						_IOR(GPIO_IOCTL_BASE,  0, __u32)
+#define GPIO_DRV_SET_GPIO						_IOW(GPIO_IOCTL_BASE,  1, __u32)
+#define GPIO_DRV_GET_GPIO						_IOW(GPIO_IOCTL_BASE,  2, __u32)
+#define GPIO_DRV_SET_MODE                       _IOW(GPIO_IOCTL_BASE,  3, __u32)
+#define GPIO_DRV_SET_PWM_PRESCALE               _IOW(GPIO_IOCTL_BASE,  4, __u32)
+#define GPIO_DRV_SET_PWM_DUTYCYCLE              _IOW(GPIO_IOCTL_BASE,  5, __u32)
+#define GPIO_DRV_SET_PWM_PERIOD                 _IOW(GPIO_IOCTL_BASE,  6, __u32)
+#define GPIO_DRV_SET_PWM_CLK_ENABLE             _IOW(GPIO_IOCTL_BASE,  7, __u32)
+#define GPIO_DRV_SET_PWRMODE		            _IOW(GPIO_IOCTL_BASE,  8, __u32)
+#define GPIO_DRV_IO_READ			            _IOW(GPIO_IOCTL_BASE,  9, __u32)
+#define GPIO_DRV_SET_IO_WRITE_ADDRESS           _IOW(GPIO_IOCTL_BASE, 10, __u32)
+#define GPIO_DRV_IO_WRITE			            _IOW(GPIO_IOCTL_BASE, 11, __u32)
+#define GPIO_DRV_GET_CAMERA_FRAME	            _IOW(GPIO_IOCTL_BASE, 12, __u32)
+#define GPIO_DRV_RESET_SYSTEM		            _IOW(GPIO_IOCTL_BASE, 13, __u32)
+#define GPIO_DRV_SET_CLKCFG			            _IOW(GPIO_IOCTL_BASE, 14, __u32)
+
+
+typedef enum
+{
+   GPIO_MODE_INPUT,
+   GPIO_MODE_OUTPUT,
+   GPIO_MODE_ALT_FUNC_1_IN,
+   GPIO_MODE_ALT_FUNC_1_OUT,
+   GPIO_MODE_ALT_FUNC_2_IN,
+   GPIO_MODE_ALT_FUNC_2_OUT,
+   GPIO_MODE_ALT_FUNC_3_IN,
+   GPIO_MODE_ALT_FUNC_3_OUT
+}gpioMode;
+
+typedef enum
+{
+	PWRMODE_IDLE = 0x01,
+	PWRMODE_STANDBY,
+	PWRMODE_SLEEP,
+	PWRMODE_DEEPSLEEP = 0x7
+}pwrMode;
+
+
+#endif // __GPIO_IOCTL_H_
+
Index: build_tree/linux/include/linux/irq.h
diff -u build_tree/linux/include/linux/irq.h:1.1.1.1 build_tree/linux/include/linux/irq.h:1.1.1.2
--- build_tree/linux/include/linux/irq.h:1.1.1.1	Thu Nov  8 14:27:38 2007
+++ build_tree/linux/include/linux/irq.h	Fri Nov  9 13:48:44 2007
@@ -28,7 +28,6 @@
 typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
 					    struct irq_desc *desc);
 
-
 /*
  * IRQ line status.
  *
Index: build_tree/linux/include/linux/utsrelease.h
diff -u /dev/null build_tree/linux/include/linux/utsrelease.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/include/linux/utsrelease.h	Fri Nov  9 13:48:45 2007
@@ -0,0 +1 @@
+#define UTS_RELEASE "2.6.21.1"
Index: build_tree/linux/include/linux/version.h
diff -u /dev/null build_tree/linux/include/linux/version.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/include/linux/version.h	Fri Nov  9 13:48:42 2007
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 132629
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
Index: build_tree/linux/init/initramfs.c
diff -u build_tree/linux/init/initramfs.c:1.1.1.1 build_tree/linux/init/initramfs.c:1.1.1.2
--- build_tree/linux/init/initramfs.c:1.1.1.1	Thu Nov  8 14:27:34 2007
+++ build_tree/linux/init/initramfs.c	Fri Nov  9 13:48:39 2007
@@ -543,6 +543,7 @@
 
 static int __init populate_rootfs(void)
 {
+	printk(KERN_INFO "populate_rootfs...initramfs: start: 0x%08lX, end: 0x%08lX\n", __initramfs_start, __initramfs_end);
 	char *err = unpack_to_rootfs(__initramfs_start,
 			 __initramfs_end - __initramfs_start, 0);
 	if (err)
Index: build_tree/linux/kernel/hrtimer.c
diff -u build_tree/linux/kernel/hrtimer.c:1.1.1.1 build_tree/linux/kernel/hrtimer.c:1.1.1.2
--- build_tree/linux/kernel/hrtimer.c:1.1.1.1	Thu Nov  8 14:27:30 2007
+++ build_tree/linux/kernel/hrtimer.c	Fri Nov  9 13:48:34 2007
@@ -43,6 +43,7 @@
 #include <linux/tick.h>
 #include <linux/seq_file.h>
 #include <linux/err.h>
+#include <linux/delay.h>
 
 #include <asm/uaccess.h>
 
@@ -304,7 +305,6 @@
 
 /* High resolution timer related functions */
 #ifdef CONFIG_HIGH_RES_TIMERS
-
 /*
  * High resolution timer enabled ?
  */
@@ -1332,6 +1332,13 @@
 	if (!timespec_valid(&tu))
 		return -EINVAL;
 
+#if 1 //AERONIX added to fix bug with nano sleep(would only allow 10ms resolution)
+        if(tu.tv_sec == 0 && tu.tv_nsec <= 2000000L && current->policy != SCHED_NORMAL)
+        {
+           udelay((tu.tv_nsec + 999) / 1000);
+           return 0;
+        }
+#endif
 	return hrtimer_nanosleep(&tu, rmtp, HRTIMER_MODE_REL, CLOCK_MONOTONIC);
 }
 
Index: build_tree/linux/kernel/module.c
diff -u build_tree/linux/kernel/module.c:1.1.1.1 build_tree/linux/kernel/module.c:1.1.1.2
--- build_tree/linux/kernel/module.c:1.1.1.1	Thu Nov  8 14:27:30 2007
+++ build_tree/linux/kernel/module.c	Fri Nov  9 13:48:34 2007
@@ -941,6 +941,7 @@
 
 static inline int same_magic(const char *amagic, const char *bmagic)
 {
+	return 1;
 	return strcmp(amagic, bmagic) == 0;
 }
 #endif /* CONFIG_MODVERSIONS */
Index: build_tree/linux/scripts/genksyms/keywords.c
diff -u /dev/null build_tree/linux/scripts/genksyms/keywords.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/scripts/genksyms/keywords.c	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,212 @@
+/* ANSI-C code produced by gperf version 3.0.1 */
+/* Command-line: gperf -L ANSI-C -a -C -E -g -H is_reserved_hash -k '1,3,$' -N is_reserved_word -p -t scripts/genksyms/keywords.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 1 "scripts/genksyms/keywords.gperf"
+
+#line 3 "scripts/genksyms/keywords.gperf"
+struct resword { const char *name; int token; };
+/* maximum key range = 68, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+is_reserved_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71,  0,
+      71, 71, 71, 71, 71, 71, 35, 71, 71, 71,
+       5, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71,  0, 71,  0, 71,  5,
+       5,  0, 10, 20, 71, 25, 71, 71, 20,  0,
+      20, 30, 25, 71, 10,  5,  0, 20, 15, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
+      71, 71, 71, 71, 71, 71
+    };
+  return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[0]] + asso_values[(unsigned char)str[len - 1]];
+}
+
+#ifdef __GNUC__
+__inline
+#endif
+const struct resword *
+is_reserved_word (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 42,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 24,
+      MIN_HASH_VALUE = 3,
+      MAX_HASH_VALUE = 70
+    };
+
+  static const struct resword wordlist[] =
+    {
+      {""}, {""}, {""},
+#line 25 "scripts/genksyms/keywords.gperf"
+      {"asm", ASM_KEYW},
+      {""},
+#line 8 "scripts/genksyms/keywords.gperf"
+      {"__asm", ASM_KEYW},
+      {""},
+#line 9 "scripts/genksyms/keywords.gperf"
+      {"__asm__", ASM_KEYW},
+      {""},
+#line 22 "scripts/genksyms/keywords.gperf"
+      {"_restrict", RESTRICT_KEYW},
+#line 51 "scripts/genksyms/keywords.gperf"
+      {"__typeof__", TYPEOF_KEYW},
+#line 10 "scripts/genksyms/keywords.gperf"
+      {"__attribute", ATTRIBUTE_KEYW},
+#line 12 "scripts/genksyms/keywords.gperf"
+      {"__const", CONST_KEYW},
+#line 11 "scripts/genksyms/keywords.gperf"
+      {"__attribute__", ATTRIBUTE_KEYW},
+#line 13 "scripts/genksyms/keywords.gperf"
+      {"__const__", CONST_KEYW},
+#line 17 "scripts/genksyms/keywords.gperf"
+      {"__signed__", SIGNED_KEYW},
+#line 43 "scripts/genksyms/keywords.gperf"
+      {"static", STATIC_KEYW},
+      {""},
+#line 16 "scripts/genksyms/keywords.gperf"
+      {"__signed", SIGNED_KEYW},
+#line 31 "scripts/genksyms/keywords.gperf"
+      {"char", CHAR_KEYW},
+      {""},
+#line 44 "scripts/genksyms/keywords.gperf"
+      {"struct", STRUCT_KEYW},
+#line 23 "scripts/genksyms/keywords.gperf"
+      {"__restrict__", RESTRICT_KEYW},
+#line 24 "scripts/genksyms/keywords.gperf"
+      {"restrict", RESTRICT_KEYW},
+#line 34 "scripts/genksyms/keywords.gperf"
+      {"enum", ENUM_KEYW},
+#line 18 "scripts/genksyms/keywords.gperf"
+      {"__volatile", VOLATILE_KEYW},
+#line 35 "scripts/genksyms/keywords.gperf"
+      {"extern", EXTERN_KEYW},
+#line 19 "scripts/genksyms/keywords.gperf"
+      {"__volatile__", VOLATILE_KEYW},
+#line 38 "scripts/genksyms/keywords.gperf"
+      {"int", INT_KEYW},
+#line 7 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL_GPL_FUTURE", EXPORT_SYMBOL_KEYW},
+#line 32 "scripts/genksyms/keywords.gperf"
+      {"const", CONST_KEYW},
+#line 33 "scripts/genksyms/keywords.gperf"
+      {"double", DOUBLE_KEYW},
+      {""},
+#line 14 "scripts/genksyms/keywords.gperf"
+      {"__inline", INLINE_KEYW},
+#line 30 "scripts/genksyms/keywords.gperf"
+      {"auto", AUTO_KEYW},
+#line 15 "scripts/genksyms/keywords.gperf"
+      {"__inline__", INLINE_KEYW},
+#line 42 "scripts/genksyms/keywords.gperf"
+      {"signed", SIGNED_KEYW},
+      {""},
+#line 47 "scripts/genksyms/keywords.gperf"
+      {"unsigned", UNSIGNED_KEYW},
+      {""},
+#line 41 "scripts/genksyms/keywords.gperf"
+      {"short", SHORT_KEYW},
+#line 50 "scripts/genksyms/keywords.gperf"
+      {"typeof", TYPEOF_KEYW},
+#line 45 "scripts/genksyms/keywords.gperf"
+      {"typedef", TYPEDEF_KEYW},
+#line 49 "scripts/genksyms/keywords.gperf"
+      {"volatile", VOLATILE_KEYW},
+      {""},
+#line 36 "scripts/genksyms/keywords.gperf"
+      {"float", FLOAT_KEYW},
+      {""}, {""},
+#line 40 "scripts/genksyms/keywords.gperf"
+      {"register", REGISTER_KEYW},
+#line 48 "scripts/genksyms/keywords.gperf"
+      {"void", VOID_KEYW},
+      {""},
+#line 37 "scripts/genksyms/keywords.gperf"
+      {"inline", INLINE_KEYW},
+      {""},
+#line 5 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW},
+      {""},
+#line 21 "scripts/genksyms/keywords.gperf"
+      {"_Bool", BOOL_KEYW},
+      {""},
+#line 6 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
+      {""}, {""}, {""}, {""}, {""}, {""},
+#line 39 "scripts/genksyms/keywords.gperf"
+      {"long", LONG_KEYW},
+      {""}, {""}, {""}, {""}, {""},
+#line 46 "scripts/genksyms/keywords.gperf"
+      {"union", UNION_KEYW}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = is_reserved_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register const char *s = wordlist[key].name;
+
+          if (*str == *s && !strcmp (str + 1, s + 1))
+            return &wordlist[key];
+        }
+    }
+  return 0;
+}
Index: build_tree/linux/scripts/genksyms/lex.c
diff -u /dev/null build_tree/linux/scripts/genksyms/lex.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/scripts/genksyms/lex.c	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,2166 @@
+#line 2 "scripts/genksyms/lex.c"
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+#include <unistd.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+
+#define yywrap() 1
+#define YY_SKIP_YYWRAP
+
+#define FLEX_DEBUG
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+
+#define FLEX_DEBUG
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 13
+#define YY_END_OF_BUFFER 14
+static yyconst short int yy_accept[76] =
+    {   0,
+        0,    0,    0,    0,   14,   12,    4,    3,   12,    7,
+       12,   12,    7,   12,   12,   12,   12,   12,    9,    9,
+       12,   12,   12,    4,    0,    5,    0,    7,    0,    6,
+        0,    0,    0,    0,    0,    0,    2,    8,   10,   10,
+        9,    0,    0,    9,    9,    0,    9,    0,    0,   11,
+        0,    0,    0,   10,    0,   10,    9,    9,    0,    0,
+        0,    0,    0,    0,    0,   10,   10,    0,    0,    0,
+        0,    0,    0,    1,    0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        4,    4,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    5,    6,    7,    8,    9,   10,    1,
+        1,    8,   11,    1,   12,   13,    8,   14,   15,   15,
+       15,   15,   15,   15,   15,   16,   16,    1,    1,   17,
+       18,   19,    1,    1,   20,   20,   20,   20,   21,   22,
+        7,    7,    7,    7,    7,   23,    7,    7,    7,    7,
+        7,    7,    7,    7,   24,    7,    7,   25,    7,    7,
+        1,   26,    1,    8,    7,    1,   20,   20,   20,   20,
+
+       21,   22,    7,    7,    7,    7,    7,   27,    7,    7,
+        7,    7,    7,    7,    7,    7,   24,    7,    7,   25,
+        7,    7,    1,   28,    1,    8,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[29] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
+        4,    4,    5,    6,    6,    6,    1,    1,    1,    7,
+        8,    7,    3,    3,    3,    1,    3,    1
+    } ;
+
+static yyconst short int yy_base[88] =
+    {   0,
+        0,  147,   21,  140,  145,  284,   39,  284,   26,    0,
+       32,  126,   40,   44,  115,   35,   36,   46,   50,   53,
+       39,   61,   54,   79,   65,  284,    0,    0,   66,  284,
+        0,  119,   79,   75,  123,  104,  284,  284,  107,    0,
+       79,   73,   76,   76,   66,    0,    0,   85,   86,  284,
+      133,   83,   91,  284,   99,  147,  284,  114,  122,   70,
+      107,  141,  172,  151,  135,  181,  284,  137,  114,  157,
+      149,   48,   45,  284,  284,  208,  214,  222,  230,  238,
+      246,  250,  255,  256,  261,  267,  275
+    } ;
+
+static yyconst short int yy_def[88] =
+    {   0,
+       75,    1,    1,    3,   75,   75,   75,   75,   76,   77,
+       78,   75,   77,   79,   75,   75,   75,   75,   75,   19,
+       75,   75,   75,   75,   76,   75,   80,   77,   78,   75,
+       81,   75,   76,   78,   79,   79,   75,   75,   75,   39,
+       19,   82,   83,   75,   75,   84,   20,   76,   78,   75,
+       79,   51,   85,   75,   75,   75,   75,   84,   79,   51,
+       79,   79,   79,   51,   75,   75,   75,   86,   79,   63,
+       86,   87,   87,   75,    0,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75
+    } ;
+
+static yyconst short int yy_nxt[313] =
+    {   0,
+        6,    7,    8,    7,    9,    6,   10,    6,    6,   11,
+        6,    6,   12,    6,    6,    6,    6,    6,    6,   10,
+       10,   10,   13,   10,   10,    6,   10,    6,   15,   16,
+       26,   15,   17,   18,   19,   20,   20,   21,   15,   22,
+       24,   30,   24,   38,   33,   36,   37,   74,   23,   34,
+       74,   27,   38,   38,   38,   38,   38,   31,   32,   39,
+       39,   39,   40,   41,   41,   42,   47,   47,   47,   26,
+       43,   38,   44,   45,   46,   30,   44,   75,   38,   38,
+       24,   38,   24,   26,   30,   40,   55,   55,   57,   26,
+       27,   31,   57,   43,   35,   30,   64,   64,   64,   57,
+
+       31,   65,   65,   75,   27,   36,   37,   35,   59,   37,
+       27,   31,   56,   56,   56,   59,   37,   51,   52,   52,
+       39,   39,   39,   59,   37,   37,   68,   53,   54,   54,
+       69,   50,   38,   54,   59,   37,   44,   45,   32,   37,
+       44,   35,   59,   37,   75,   14,   60,   60,   66,   66,
+       66,   37,   14,   72,   75,   61,   62,   63,   59,   61,
+       56,   56,   56,   69,   64,   64,   64,   69,   67,   67,
+       75,   75,   75,   67,   37,   35,   75,   75,   75,   61,
+       62,   75,   75,   61,   75,   70,   70,   70,   75,   75,
+       75,   70,   70,   70,   66,   66,   66,   75,   75,   75,
+
+       75,   75,   54,   54,   75,   75,   75,   54,   25,   25,
+       25,   25,   25,   25,   25,   25,   28,   75,   75,   28,
+       28,   28,   29,   29,   29,   29,   29,   29,   29,   29,
+       35,   35,   35,   35,   35,   35,   35,   35,   48,   75,
+       48,   48,   48,   48,   48,   48,   49,   75,   49,   49,
+       49,   49,   49,   49,   42,   42,   75,   42,   56,   75,
+       56,   58,   58,   58,   66,   75,   66,   71,   71,   71,
+       71,   71,   71,   71,   71,   73,   73,   73,   73,   73,
+       73,   73,   73,    5,   75,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+       75,   75
+    } ;
+
+static yyconst short int yy_chk[313] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    3,    3,
+        9,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        7,   11,    7,   16,   13,   14,   14,   73,    3,   13,
+       72,    9,   16,   17,   17,   21,   21,   11,   18,   18,
+       18,   18,   19,   19,   19,   19,   20,   20,   20,   25,
+       19,   23,   19,   19,   19,   29,   19,   20,   22,   22,
+       24,   23,   24,   33,   34,   42,   43,   43,   45,   48,
+       25,   29,   45,   42,   60,   49,   52,   52,   52,   44,
+
+       34,   53,   53,   41,   33,   36,   36,   52,   61,   61,
+       48,   49,   55,   55,   55,   69,   69,   36,   36,   36,
+       39,   39,   39,   59,   59,   35,   59,   39,   39,   39,
+       61,   32,   15,   39,   51,   51,   58,   58,   12,   68,
+       58,   68,   62,   62,    5,    4,   51,   51,   65,   65,
+       65,   71,    2,   71,    0,   51,   51,   51,   70,   51,
+       56,   56,   56,   62,   64,   64,   64,   62,   56,   56,
+        0,    0,    0,   56,   63,   64,    0,    0,    0,   70,
+       70,    0,    0,   70,    0,   63,   63,   63,    0,    0,
+        0,   63,   63,   63,   66,   66,   66,    0,    0,    0,
+
+        0,    0,   66,   66,    0,    0,    0,   66,   76,   76,
+       76,   76,   76,   76,   76,   76,   77,    0,    0,   77,
+       77,   77,   78,   78,   78,   78,   78,   78,   78,   78,
+       79,   79,   79,   79,   79,   79,   79,   79,   80,    0,
+       80,   80,   80,   80,   80,   80,   81,    0,   81,   81,
+       81,   81,   81,   81,   82,   82,    0,   82,   83,    0,
+       83,   84,   84,   84,   85,    0,   85,   86,   86,   86,
+       86,   86,   86,   86,   86,   87,   87,   87,   87,   87,
+       87,   87,   87,   75,   75,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+       75,   75
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 1;
+
+static yyconst short int yy_rule_linenum[13] =
+    {   0,
+       69,   70,   71,   74,   77,   78,   79,   85,   86,   87,
+       89,   92
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scripts/genksyms/lex.l"
+#define INITIAL 0
+/* Lexical analysis for genksyms.
+   Copyright 1996, 1997 Linux International.
+
+   New implementation contributed by Richard Henderson <rth@tamu.edu>
+   Based on original work by Bjorn Ekwall <bj0rn@blox.se>
+
+   Taken from Linux modutils 2.4.22.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+#line 25 "scripts/genksyms/lex.l"
+
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "genksyms.h"
+#include "parse.h"
+
+/* We've got a two-level lexer here.  We let flex do basic tokenization
+   and then we categorize those basic tokens in the second stage.  */
+#define YY_DECL		static int yylex1(void)
+
+/* Version 2 checksumming does proper tokenization; version 1 wasn't
+   quite so pedantic.  */
+#define V2_TOKENS 1
+
+/* We don't do multiple input files.  */
+#line 513 "scripts/genksyms/lex.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		yy_current_buffer->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp = NULL, *yy_bp = NULL;
+	register int yy_act;
+
+#line 65 "scripts/genksyms/lex.l"
+
+
+
+ /* Keep track of our location in the original source files.  */
+#line 672 "scripts/genksyms/lex.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 76 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 284 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		if ( yy_flex_debug )
+			{
+			if ( yy_act == 0 )
+				fprintf( stderr, "--scanner backing up\n" );
+			else if ( yy_act < 13 )
+				fprintf( stderr, "--accepting rule at line %d (\"%s\")\n",
+				         yy_rule_linenum[yy_act], yytext );
+			else if ( yy_act == 13 )
+				fprintf( stderr, "--accepting default rule (\"%s\")\n",
+				         yytext );
+			else if ( yy_act == 14 )
+				fprintf( stderr, "--(end of buffer or a NUL)\n" );
+			else
+				fprintf( stderr, "--EOF (start condition %d)\n", YY_START );
+			}
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 69 "scripts/genksyms/lex.l"
+return FILENAME;
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 70 "scripts/genksyms/lex.l"
+cur_line++;
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 71 "scripts/genksyms/lex.l"
+cur_line++;
+	YY_BREAK
+/* Ignore all other whitespace.  */
+case 4:
+YY_RULE_SETUP
+#line 74 "scripts/genksyms/lex.l"
+;
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 77 "scripts/genksyms/lex.l"
+return STRING;
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 78 "scripts/genksyms/lex.l"
+return CHAR;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 79 "scripts/genksyms/lex.l"
+return IDENT;
+	YY_BREAK
+/* The Pedant requires that the other C multi-character tokens be
+    recognized as tokens.  We don't actually use them since we don't
+    parse expressions, but we do want whitespace to be arranged
+    around them properly.  */
+case 8:
+YY_RULE_SETUP
+#line 85 "scripts/genksyms/lex.l"
+return OTHER;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 86 "scripts/genksyms/lex.l"
+return INT;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 87 "scripts/genksyms/lex.l"
+return REAL;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 89 "scripts/genksyms/lex.l"
+return DOTS;
+	YY_BREAK
+/* All other tokens are single characters.  */
+case 12:
+YY_RULE_SETUP
+#line 92 "scripts/genksyms/lex.l"
+return yytext[0];
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 95 "scripts/genksyms/lex.l"
+ECHO;
+	YY_BREAK
+#line 842 "scripts/genksyms/lex.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(V2_TOKENS):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 76 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 76 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 75);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+	yy_current_buffer->yy_at_bol = (c == '\n');
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 95 "scripts/genksyms/lex.l"
+
+
+/* Bring in the keyword recognizer.  */
+
+#include "keywords.c"
+
+
+/* Macros to append to our phrase collection list.  */
+
+#define _APP(T,L)	do {						   \
+			  cur_node = next_node;				   \
+			  next_node = xmalloc(sizeof(*next_node));	   \
+			  next_node->next = cur_node;			   \
+			  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \
+			  cur_node->tag = SYM_NORMAL;			   \
+			} while (0)
+
+#define APP		_APP(yytext, yyleng)
+
+
+/* The second stage lexer.  Here we incorporate knowledge of the state
+   of the parser to tailor the tokens that are returned.  */
+
+int
+yylex(void)
+{
+  static enum {
+    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_BRACKET, ST_BRACE,
+    ST_EXPRESSION, ST_TABLE_1, ST_TABLE_2, ST_TABLE_3, ST_TABLE_4,
+    ST_TABLE_5, ST_TABLE_6
+  } lexstate = ST_NOTSTARTED;
+
+  static int suppress_type_lookup, dont_want_brace_phrase;
+  static struct string_list *next_node;
+
+  int token, count = 0;
+  struct string_list *cur_node;
+
+  if (lexstate == ST_NOTSTARTED)
+    {
+      BEGIN(V2_TOKENS);
+      next_node = xmalloc(sizeof(*next_node));
+      next_node->next = NULL;
+      lexstate = ST_NORMAL;
+    }
+
+repeat:
+  token = yylex1();
+
+  if (token == 0)
+    return 0;
+  else if (token == FILENAME)
+    {
+      char *file, *e;
+
+      /* Save the filename and line number for later error messages.  */
+
+      if (cur_filename)
+	free(cur_filename);
+
+      file = strchr(yytext, '\"')+1;
+      e = strchr(file, '\"');
+      *e = '\0';
+      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);
+      cur_line = atoi(yytext+2);
+
+      goto repeat;
+    }
+
+  switch (lexstate)
+    {
+    case ST_NORMAL:
+      switch (token)
+	{
+	case IDENT:
+	  APP;
+	  {
+	    const struct resword *r = is_reserved_word(yytext, yyleng);
+	    if (r)
+	      {
+		switch (token = r->token)
+		  {
+		  case ATTRIBUTE_KEYW:
+		    lexstate = ST_ATTRIBUTE;
+		    count = 0;
+		    goto repeat;
+		  case ASM_KEYW:
+		    lexstate = ST_ASM;
+		    count = 0;
+		    goto repeat;
+
+		  case STRUCT_KEYW:
+		  case UNION_KEYW:
+		    dont_want_brace_phrase = 3;
+		  case ENUM_KEYW:
+		    suppress_type_lookup = 2;
+		    goto fini;
+
+		  case EXPORT_SYMBOL_KEYW:
+		      goto fini;
+		  }
+	      }
+	    if (!suppress_type_lookup)
+	      {
+		struct symbol *sym = find_symbol(yytext, SYM_TYPEDEF);
+		if (sym && sym->type == SYM_TYPEDEF)
+		  token = TYPE;
+	      }
+	  }
+	  break;
+
+	case '[':
+	  APP;
+	  lexstate = ST_BRACKET;
+	  count = 1;
+	  goto repeat;
+
+	case '{':
+	  APP;
+	  if (dont_want_brace_phrase)
+	    break;
+	  lexstate = ST_BRACE;
+	  count = 1;
+	  goto repeat;
+
+	case '=': case ':':
+	  APP;
+	  lexstate = ST_EXPRESSION;
+	  break;
+
+	case DOTS:
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    case ST_ATTRIBUTE:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ATTRIBUTE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_ASM:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ASM_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACKET:
+      APP;
+      switch (token)
+	{
+	case '[':
+	  ++count;
+	  goto repeat;
+	case ']':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACKET_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACE:
+      APP;
+      switch (token)
+	{
+	case '{':
+	  ++count;
+	  goto repeat;
+	case '}':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_EXPRESSION:
+      switch (token)
+	{
+	case '(': case '[': case '{':
+	  ++count;
+	  APP;
+	  goto repeat;
+	case ')': case ']': case '}':
+	  --count;
+	  APP;
+	  goto repeat;
+	case ',': case ';':
+	  if (count == 0)
+	    {
+	      /* Put back the token we just read so's we can find it again
+		 after registering the expression.  */
+	      unput(token);
+
+	      lexstate = ST_NORMAL;
+	      token = EXPRESSION_PHRASE;
+	      break;
+	    }
+	  APP;
+	  goto repeat;
+	default:
+	  APP;
+	  goto repeat;
+	}
+      break;
+
+    case ST_TABLE_1:
+      goto repeat;
+
+    case ST_TABLE_2:
+      if (token == IDENT && yyleng == 1 && yytext[0] == 'X')
+	{
+	  token = EXPORT_SYMBOL_KEYW;
+	  lexstate = ST_TABLE_5;
+	  APP;
+	  break;
+	}
+      lexstate = ST_TABLE_6;
+      /* FALLTHRU */
+
+    case ST_TABLE_6:
+      switch (token)
+	{
+	case '{': case '[': case '(':
+	  ++count;
+	  break;
+	case '}': case ']': case ')':
+	  --count;
+	  break;
+	case ',':
+	  if (count == 0)
+	    lexstate = ST_TABLE_2;
+	  break;
+	};
+      goto repeat;
+
+    case ST_TABLE_3:
+      goto repeat;
+
+    case ST_TABLE_4:
+      if (token == ';')
+	lexstate = ST_NORMAL;
+      goto repeat;
+
+    case ST_TABLE_5:
+      switch (token)
+	{
+	case ',':
+	  token = ';';
+	  lexstate = ST_TABLE_2;
+	  APP;
+	  break;
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    default:
+      exit(1);
+    }
+fini:
+
+  if (suppress_type_lookup > 0)
+    --suppress_type_lookup;
+  if (dont_want_brace_phrase > 0)
+    --dont_want_brace_phrase;
+
+  yylval = &next_node->next;
+
+  return token;
+}
+/* A Bison parser, made by GNU Bison 2.0.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     FLOAT_KEYW = 267,
+     INLINE_KEYW = 268,
+     INT_KEYW = 269,
+     LONG_KEYW = 270,
+     REGISTER_KEYW = 271,
+     RESTRICT_KEYW = 272,
+     SHORT_KEYW = 273,
+     SIGNED_KEYW = 274,
+     STATIC_KEYW = 275,
+     STRUCT_KEYW = 276,
+     TYPEDEF_KEYW = 277,
+     UNION_KEYW = 278,
+     UNSIGNED_KEYW = 279,
+     VOID_KEYW = 280,
+     VOLATILE_KEYW = 281,
+     TYPEOF_KEYW = 282,
+     EXPORT_SYMBOL_KEYW = 283,
+     ASM_PHRASE = 284,
+     ATTRIBUTE_PHRASE = 285,
+     BRACE_PHRASE = 286,
+     BRACKET_PHRASE = 287,
+     EXPRESSION_PHRASE = 288,
+     CHAR = 289,
+     DOTS = 290,
+     IDENT = 291,
+     INT = 292,
+     REAL = 293,
+     STRING = 294,
+     TYPE = 295,
+     OTHER = 296,
+     FILENAME = 297
+   };
+#endif
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define FLOAT_KEYW 267
+#define INLINE_KEYW 268
+#define INT_KEYW 269
+#define LONG_KEYW 270
+#define REGISTER_KEYW 271
+#define RESTRICT_KEYW 272
+#define SHORT_KEYW 273
+#define SIGNED_KEYW 274
+#define STATIC_KEYW 275
+#define STRUCT_KEYW 276
+#define TYPEDEF_KEYW 277
+#define UNION_KEYW 278
+#define UNSIGNED_KEYW 279
+#define VOID_KEYW 280
+#define VOLATILE_KEYW 281
+#define TYPEOF_KEYW 282
+#define EXPORT_SYMBOL_KEYW 283
+#define ASM_PHRASE 284
+#define ATTRIBUTE_PHRASE 285
+#define BRACE_PHRASE 286
+#define BRACKET_PHRASE 287
+#define EXPRESSION_PHRASE 288
+#define CHAR 289
+#define DOTS 290
+#define IDENT 291
+#define INT 292
+#define REAL 293
+#define STRING 294
+#define TYPE 295
+#define OTHER 296
+#define FILENAME 297
+
+
+
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
+
+
Index: build_tree/linux/scripts/genksyms/parse.c
diff -u /dev/null build_tree/linux/scripts/genksyms/parse.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/scripts/genksyms/parse.c	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,2051 @@
+/* A Bison parser, made by GNU Bison 2.0.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     FLOAT_KEYW = 267,
+     INLINE_KEYW = 268,
+     INT_KEYW = 269,
+     LONG_KEYW = 270,
+     REGISTER_KEYW = 271,
+     RESTRICT_KEYW = 272,
+     SHORT_KEYW = 273,
+     SIGNED_KEYW = 274,
+     STATIC_KEYW = 275,
+     STRUCT_KEYW = 276,
+     TYPEDEF_KEYW = 277,
+     UNION_KEYW = 278,
+     UNSIGNED_KEYW = 279,
+     VOID_KEYW = 280,
+     VOLATILE_KEYW = 281,
+     TYPEOF_KEYW = 282,
+     EXPORT_SYMBOL_KEYW = 283,
+     ASM_PHRASE = 284,
+     ATTRIBUTE_PHRASE = 285,
+     BRACE_PHRASE = 286,
+     BRACKET_PHRASE = 287,
+     EXPRESSION_PHRASE = 288,
+     CHAR = 289,
+     DOTS = 290,
+     IDENT = 291,
+     INT = 292,
+     REAL = 293,
+     STRING = 294,
+     TYPE = 295,
+     OTHER = 296,
+     FILENAME = 297
+   };
+#endif
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define FLOAT_KEYW 267
+#define INLINE_KEYW 268
+#define INT_KEYW 269
+#define LONG_KEYW 270
+#define REGISTER_KEYW 271
+#define RESTRICT_KEYW 272
+#define SHORT_KEYW 273
+#define SIGNED_KEYW 274
+#define STATIC_KEYW 275
+#define STRUCT_KEYW 276
+#define TYPEDEF_KEYW 277
+#define UNION_KEYW 278
+#define UNSIGNED_KEYW 279
+#define VOID_KEYW 280
+#define VOLATILE_KEYW 281
+#define TYPEOF_KEYW 282
+#define EXPORT_SYMBOL_KEYW 283
+#define ASM_PHRASE 284
+#define ATTRIBUTE_PHRASE 285
+#define BRACE_PHRASE 286
+#define BRACKET_PHRASE 287
+#define EXPRESSION_PHRASE 288
+#define CHAR 289
+#define DOTS 290
+#define IDENT 291
+#define INT 292
+#define REAL 293
+#define STRING 294
+#define TYPE 295
+#define OTHER 296
+#define FILENAME 297
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 24 "scripts/genksyms/parse.y"
+
+
+#include <assert.h>
+#include <malloc.h>
+#include "genksyms.h"
+
+static int is_typedef;
+static int is_extern;
+static char *current_name;
+static struct string_list *decl_spec;
+
+static void yyerror(const char *);
+
+static inline void
+remove_node(struct string_list **p)
+{
+  struct string_list *node = *p;
+  *p = node->next;
+  free_node(node);
+}
+
+static inline void
+remove_list(struct string_list **pb, struct string_list **pe)
+{
+  struct string_list *b = *pb, *e = *pe;
+  *pb = e;
+  free_list(b, e);
+}
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 213 of yacc.c.  */
+#line 202 "scripts/genksyms/parse.c"
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+# ifndef YYFREE
+#  define YYFREE free
+# endif
+# ifndef YYMALLOC
+#  define YYMALLOC malloc
+# endif
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short int yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short int) + sizeof (YYSTYPE))			\
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined (__GNUC__) && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short int yysigned_char;
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  4
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   535
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  52
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  45
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  124
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  174
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   297
+
+#define YYTRANSLATE(YYX) 						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      46,    48,    47,     2,    45,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    51,    43,
+       2,    49,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    50,     2,    44,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned short int yyprhs[] =
+{
+       0,     0,     3,     5,     8,     9,    12,    13,    17,    19,
+      21,    23,    25,    28,    31,    35,    36,    38,    40,    44,
+      49,    50,    52,    54,    57,    59,    61,    63,    65,    67,
+      69,    71,    73,    75,    81,    86,    89,    92,    95,    99,
+     103,   107,   110,   113,   116,   118,   120,   122,   124,   126,
+     128,   130,   132,   134,   136,   138,   141,   142,   144,   146,
+     149,   151,   153,   155,   157,   160,   162,   164,   169,   174,
+     177,   181,   185,   188,   190,   192,   194,   199,   204,   207,
+     211,   215,   218,   220,   224,   225,   227,   229,   233,   236,
+     239,   241,   242,   244,   246,   251,   256,   259,   263,   267,
+     271,   272,   274,   277,   281,   285,   286,   288,   290,   293,
+     297,   300,   301,   303,   305,   309,   312,   315,   317,   320,
+     321,   323,   326,   327,   329
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      53,     0,    -1,    54,    -1,    53,    54,    -1,    -1,    55,
+      56,    -1,    -1,    22,    57,    58,    -1,    58,    -1,    82,
+      -1,    94,    -1,    96,    -1,     1,    43,    -1,     1,    44,
+      -1,    62,    59,    43,    -1,    -1,    60,    -1,    61,    -1,
+      60,    45,    61,    -1,    72,    95,    93,    83,    -1,    -1,
+      63,    -1,    64,    -1,    63,    64,    -1,    65,    -1,    66,
+      -1,     5,    -1,    16,    -1,    20,    -1,    11,    -1,    13,
+      -1,    67,    -1,    71,    -1,    27,    46,    63,    47,    48,
+      -1,    27,    46,    63,    48,    -1,    21,    36,    -1,    23,
+      36,    -1,    10,    36,    -1,    21,    36,    85,    -1,    23,
+      36,    85,    -1,    10,    36,    31,    -1,    10,    31,    -1,
+      21,    85,    -1,    23,    85,    -1,     7,    -1,    18,    -1,
+      14,    -1,    15,    -1,    19,    -1,    24,    -1,    12,    -1,
+       9,    -1,    25,    -1,     6,    -1,    40,    -1,    47,    69,
+      -1,    -1,    70,    -1,    71,    -1,    70,    71,    -1,     8,
+      -1,    26,    -1,    30,    -1,    17,    -1,    68,    72,    -1,
+      73,    -1,    36,    -1,    73,    46,    76,    48,    -1,    73,
+      46,     1,    48,    -1,    73,    32,    -1,    46,    72,    48,
+      -1,    46,     1,    48,    -1,    68,    74,    -1,    75,    -1,
+      36,    -1,    40,    -1,    75,    46,    76,    48,    -1,    75,
+      46,     1,    48,    -1,    75,    32,    -1,    46,    74,    48,
+      -1,    46,     1,    48,    -1,    77,    35,    -1,    77,    -1,
+      78,    45,    35,    -1,    -1,    78,    -1,    79,    -1,    78,
+      45,    79,    -1,    63,    80,    -1,    68,    80,    -1,    81,
+      -1,    -1,    36,    -1,    40,    -1,    81,    46,    76,    48,
+      -1,    81,    46,     1,    48,    -1,    81,    32,    -1,    46,
+      80,    48,    -1,    46,     1,    48,    -1,    62,    72,    31,
+      -1,    -1,    84,    -1,    49,    33,    -1,    50,    86,    44,
+      -1,    50,     1,    44,    -1,    -1,    87,    -1,    88,    -1,
+      87,    88,    -1,    62,    89,    43,    -1,     1,    43,    -1,
+      -1,    90,    -1,    91,    -1,    90,    45,    91,    -1,    74,
+      93,    -1,    36,    92,    -1,    92,    -1,    51,    33,    -1,
+      -1,    30,    -1,    29,    43,    -1,    -1,    29,    -1,    28,
+      46,    36,    48,    43,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short int yyrline[] =
+{
+       0,   102,   102,   103,   107,   107,   113,   113,   115,   116,
+     117,   118,   119,   120,   124,   138,   139,   143,   151,   164,
+     170,   171,   175,   176,   180,   186,   190,   191,   192,   193,
+     194,   198,   199,   200,   201,   205,   207,   209,   213,   220,
+     227,   236,   237,   238,   242,   243,   244,   245,   246,   247,
+     248,   249,   250,   251,   252,   256,   261,   262,   266,   267,
+     271,   271,   271,   272,   280,   281,   285,   294,   296,   298,
+     300,   302,   309,   310,   314,   315,   316,   318,   320,   322,
+     324,   329,   330,   331,   335,   336,   340,   341,   346,   351,
+     353,   357,   358,   366,   370,   372,   374,   376,   378,   383,
+     392,   393,   398,   403,   404,   408,   409,   413,   414,   418,
+     420,   425,   426,   430,   431,   435,   436,   437,   441,   445,
+     446,   450,   454,   455,   459
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "ASM_KEYW", "ATTRIBUTE_KEYW",
+  "AUTO_KEYW", "BOOL_KEYW", "CHAR_KEYW", "CONST_KEYW", "DOUBLE_KEYW",
+  "ENUM_KEYW", "EXTERN_KEYW", "FLOAT_KEYW", "INLINE_KEYW", "INT_KEYW",
+  "LONG_KEYW", "REGISTER_KEYW", "RESTRICT_KEYW", "SHORT_KEYW",
+  "SIGNED_KEYW", "STATIC_KEYW", "STRUCT_KEYW", "TYPEDEF_KEYW",
+  "UNION_KEYW", "UNSIGNED_KEYW", "VOID_KEYW", "VOLATILE_KEYW",
+  "TYPEOF_KEYW", "EXPORT_SYMBOL_KEYW", "ASM_PHRASE", "ATTRIBUTE_PHRASE",
+  "BRACE_PHRASE", "BRACKET_PHRASE", "EXPRESSION_PHRASE", "CHAR", "DOTS",
+  "IDENT", "INT", "REAL", "STRING", "TYPE", "OTHER", "FILENAME", "';'",
+  "'}'", "','", "'('", "'*'", "')'", "'='", "'{'", "':'", "$accept",
+  "declaration_seq", "declaration", "@1", "declaration1", "@2",
+  "simple_declaration", "init_declarator_list_opt", "init_declarator_list",
+  "init_declarator", "decl_specifier_seq_opt", "decl_specifier_seq",
+  "decl_specifier", "storage_class_specifier", "type_specifier",
+  "simple_type_specifier", "ptr_operator", "cvar_qualifier_seq_opt",
+  "cvar_qualifier_seq", "cvar_qualifier", "declarator",
+  "direct_declarator", "nested_declarator", "direct_nested_declarator",
+  "parameter_declaration_clause", "parameter_declaration_list_opt",
+  "parameter_declaration_list", "parameter_declaration",
+  "m_abstract_declarator", "direct_m_abstract_declarator",
+  "function_definition", "initializer_opt", "initializer", "class_body",
+  "member_specification_opt", "member_specification", "member_declaration",
+  "member_declarator_list_opt", "member_declarator_list",
+  "member_declarator", "member_bitfield_declarator", "attribute_opt",
+  "asm_definition", "asm_phrase_opt", "export_definition", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short int yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,    59,   125,    44,    40,    42,    41,    61,
+     123,    58
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    52,    53,    53,    55,    54,    57,    56,    56,    56,
+      56,    56,    56,    56,    58,    59,    59,    60,    60,    61,
+      62,    62,    63,    63,    64,    64,    65,    65,    65,    65,
+      65,    66,    66,    66,    66,    66,    66,    66,    66,    66,
+      66,    66,    66,    66,    67,    67,    67,    67,    67,    67,
+      67,    67,    67,    67,    67,    68,    69,    69,    70,    70,
+      71,    71,    71,    71,    72,    72,    73,    73,    73,    73,
+      73,    73,    74,    74,    75,    75,    75,    75,    75,    75,
+      75,    76,    76,    76,    77,    77,    78,    78,    79,    80,
+      80,    81,    81,    81,    81,    81,    81,    81,    81,    82,
+      83,    83,    84,    85,    85,    86,    86,    87,    87,    88,
+      88,    89,    89,    90,    90,    91,    91,    91,    92,    93,
+      93,    94,    95,    95,    96
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     1,     2,     0,     2,     0,     3,     1,     1,
+       1,     1,     2,     2,     3,     0,     1,     1,     3,     4,
+       0,     1,     1,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     5,     4,     2,     2,     2,     3,     3,
+       3,     2,     2,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     2,     0,     1,     1,     2,
+       1,     1,     1,     1,     2,     1,     1,     4,     4,     2,
+       3,     3,     2,     1,     1,     1,     4,     4,     2,     3,
+       3,     2,     1,     3,     0,     1,     1,     3,     2,     2,
+       1,     0,     1,     1,     4,     4,     2,     3,     3,     3,
+       0,     1,     2,     3,     3,     0,     1,     1,     2,     3,
+       2,     0,     1,     1,     3,     2,     2,     1,     2,     0,
+       1,     2,     0,     1,     5
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       4,     4,     2,     0,     1,     3,     0,    26,    53,    44,
+      60,    51,     0,    29,    50,    30,    46,    47,    27,    63,
+      45,    48,    28,     0,     6,     0,    49,    52,    61,     0,
+       0,     0,    62,    54,     5,     8,    15,    21,    22,    24,
+      25,    31,    32,     9,    10,    11,    12,    13,    41,    37,
+      35,     0,    42,    20,    36,    43,     0,     0,   121,    66,
+       0,    56,     0,    16,    17,     0,   122,    65,    23,    40,
+      38,     0,   111,     0,     0,   107,     7,    15,    39,     0,
+       0,     0,     0,    55,    57,    58,    14,     0,    64,   123,
+      99,   119,    69,     0,   110,   104,    74,    75,     0,     0,
+       0,   119,    73,     0,   112,   113,   117,   103,     0,   108,
+     122,     0,    34,     0,    71,    70,    59,    18,   120,   100,
+       0,    91,     0,    82,    85,    86,   116,     0,    74,     0,
+     118,    72,   115,    78,     0,   109,     0,    33,   124,     0,
+      19,   101,    68,    92,    54,     0,    91,    88,    90,    67,
+      81,     0,    80,    79,     0,     0,   114,   102,     0,    93,
+       0,    89,    96,     0,    83,    87,    77,    76,    98,    97,
+       0,     0,    95,    94
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const short int yydefgoto[] =
+{
+      -1,     1,     2,     3,    34,    53,    35,    62,    63,    64,
+      72,    37,    38,    39,    40,    41,    65,    83,    84,    42,
+     110,    67,   101,   102,   122,   123,   124,   125,   147,   148,
+      43,   140,   141,    52,    73,    74,    75,   103,   104,   105,
+     106,   119,    44,    91,    45
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -128
+static const short int yypact[] =
+{
+    -128,    13,  -128,   329,  -128,  -128,    36,  -128,  -128,  -128,
+    -128,  -128,   -16,  -128,  -128,  -128,  -128,  -128,  -128,  -128,
+    -128,  -128,  -128,   -25,  -128,   -24,  -128,  -128,  -128,   -29,
+      -4,   -22,  -128,  -128,  -128,  -128,   -28,   495,  -128,  -128,
+    -128,  -128,  -128,  -128,  -128,  -128,  -128,  -128,  -128,    16,
+     -23,   103,  -128,   495,   -23,  -128,   495,    35,  -128,  -128,
+       3,    15,     9,    17,  -128,   -28,   -15,    -8,  -128,  -128,
+    -128,    47,    23,    44,   150,  -128,  -128,   -28,  -128,   372,
+      33,    48,    49,  -128,    15,  -128,  -128,   -28,  -128,  -128,
+    -128,    64,  -128,   197,  -128,  -128,    50,  -128,    21,    65,
+      37,    64,    14,    56,    55,  -128,  -128,  -128,    59,  -128,
+      74,    57,  -128,    63,  -128,  -128,  -128,  -128,  -128,    76,
+      83,   416,    84,    99,    90,  -128,  -128,    88,  -128,    89,
+    -128,  -128,  -128,  -128,   241,  -128,    23,  -128,  -128,   105,
+    -128,  -128,  -128,  -128,  -128,     8,    46,  -128,    26,  -128,
+    -128,   459,  -128,  -128,    92,    93,  -128,  -128,    94,  -128,
+      96,  -128,  -128,   285,  -128,  -128,  -128,  -128,  -128,  -128,
+      97,   100,  -128,  -128
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const short int yypgoto[] =
+{
+    -128,  -128,   151,  -128,  -128,  -128,   119,  -128,  -128,    66,
+       0,   -56,   -36,  -128,  -128,  -128,   -70,  -128,  -128,   -51,
+     -31,  -128,   -11,  -128,  -127,  -128,  -128,    27,   -81,  -128,
+    -128,  -128,  -128,   -19,  -128,  -128,   107,  -128,  -128,    43,
+      86,    82,  -128,  -128,  -128
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -107
+static const short int yytable[] =
+{
+      79,    68,   100,    36,    81,    66,    55,   155,    59,   158,
+      85,    50,    54,     4,    89,    48,    90,    56,    60,    61,
+      49,    58,   127,    10,    92,    51,    51,    51,   100,    82,
+     100,    70,    19,   116,    88,    78,   171,   121,    93,    59,
+     -91,    28,    57,    68,   143,    32,   133,    69,   159,    60,
+      61,   146,    86,    77,   145,    61,   -91,   128,   162,    96,
+     134,    97,    87,    97,   160,   161,   100,    98,    61,    98,
+      61,    80,   163,   128,    99,   146,   146,    97,   121,    46,
+      47,   113,   143,    98,    61,    68,   159,   129,   107,   131,
+      94,    95,   145,    61,   118,   121,   114,   115,   130,   135,
+     136,    99,    94,    89,    71,   137,   138,   121,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,   139,    25,    26,    27,    28,
+      29,   142,   149,    32,   150,   151,   152,   153,   157,   -20,
+     166,   167,   168,    33,   169,   172,   -20,  -105,   173,   -20,
+     -20,   108,     5,   117,   -20,     7,     8,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
+      22,    23,    76,    25,    26,    27,    28,    29,   165,   156,
+      32,   109,   126,   132,     0,     0,   -20,     0,     0,     0,
+      33,     0,     0,   -20,  -106,     0,   -20,   -20,   120,     0,
+       0,   -20,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,     0,
+      25,    26,    27,    28,    29,     0,     0,    32,     0,     0,
+       0,     0,   -84,     0,     0,     0,     0,    33,     0,     0,
+       0,     0,   154,     0,     0,   -84,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     0,    25,    26,    27,    28,    29,     0,
+       0,    32,     0,     0,     0,     0,   -84,     0,     0,     0,
+       0,    33,     0,     0,     0,     0,   170,     0,     0,   -84,
+       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,     0,    25,    26,
+      27,    28,    29,     0,     0,    32,     0,     0,     0,     0,
+     -84,     0,     0,     0,     0,    33,     0,     0,     0,     0,
+       6,     0,     0,   -84,     7,     8,     9,    10,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+       0,     0,     0,     0,     0,   -20,     0,     0,     0,    33,
+       0,     0,   -20,     0,     0,   -20,   -20,     7,     8,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,     0,    25,    26,    27,    28,    29,
+       0,     0,    32,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    33,     0,     0,     0,     0,     0,     0,   111,
+     112,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,     0,    25,
+      26,    27,    28,    29,     0,     0,    32,     0,     0,     0,
+       0,     0,   143,     0,     0,     0,   144,     0,     0,     0,
+       0,     0,   145,    61,     7,     8,     9,    10,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,     0,    25,    26,    27,    28,    29,     0,     0,    32,
+       0,     0,     0,     0,   164,     0,     0,     0,     0,    33,
+       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,     0,    25,    26,
+      27,    28,    29,     0,     0,    32,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    33
+};
+
+static const short int yycheck[] =
+{
+      56,    37,    72,     3,     1,    36,    25,   134,    36,     1,
+      61,    36,    36,     0,    29,    31,    31,    46,    46,    47,
+      36,    43,     1,     8,    32,    50,    50,    50,    98,    60,
+     100,    50,    17,    84,    65,    54,   163,    93,    46,    36,
+      32,    26,    46,    79,    36,    30,    32,    31,    40,    46,
+      47,   121,    43,    53,    46,    47,    48,    36,    32,    36,
+      46,    40,    45,    40,   145,   146,   136,    46,    47,    46,
+      47,    36,    46,    36,    51,   145,   146,    40,   134,    43,
+      44,    48,    36,    46,    47,   121,    40,    98,    44,   100,
+      43,    44,    46,    47,    30,   151,    48,    48,    33,    43,
+      45,    51,    43,    29,     1,    48,    43,   163,     5,     6,
+       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    49,    23,    24,    25,    26,
+      27,    48,    48,    30,    35,    45,    48,    48,    33,    36,
+      48,    48,    48,    40,    48,    48,    43,    44,    48,    46,
+      47,     1,     1,    87,    51,     5,     6,     7,     8,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    53,    23,    24,    25,    26,    27,   151,   136,
+      30,    74,    96,   101,    -1,    -1,    36,    -1,    -1,    -1,
+      40,    -1,    -1,    43,    44,    -1,    46,    47,     1,    -1,
+      -1,    51,     5,     6,     7,     8,     9,    10,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    -1,
+      23,    24,    25,    26,    27,    -1,    -1,    30,    -1,    -1,
+      -1,    -1,    35,    -1,    -1,    -1,    -1,    40,    -1,    -1,
+      -1,    -1,     1,    -1,    -1,    48,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    -1,    23,    24,    25,    26,    27,    -1,
+      -1,    30,    -1,    -1,    -1,    -1,    35,    -1,    -1,    -1,
+      -1,    40,    -1,    -1,    -1,    -1,     1,    -1,    -1,    48,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    -1,    23,    24,
+      25,    26,    27,    -1,    -1,    30,    -1,    -1,    -1,    -1,
+      35,    -1,    -1,    -1,    -1,    40,    -1,    -1,    -1,    -1,
+       1,    -1,    -1,    48,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      -1,    -1,    -1,    -1,    -1,    36,    -1,    -1,    -1,    40,
+      -1,    -1,    43,    -1,    -1,    46,    47,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    -1,    23,    24,    25,    26,    27,
+      -1,    -1,    30,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    -1,    47,
+      48,     5,     6,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    -1,    23,
+      24,    25,    26,    27,    -1,    -1,    30,    -1,    -1,    -1,
+      -1,    -1,    36,    -1,    -1,    -1,    40,    -1,    -1,    -1,
+      -1,    -1,    46,    47,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    -1,    23,    24,    25,    26,    27,    -1,    -1,    30,
+      -1,    -1,    -1,    -1,    35,    -1,    -1,    -1,    -1,    40,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    -1,    23,    24,
+      25,    26,    27,    -1,    -1,    30,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    40
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    53,    54,    55,     0,    54,     1,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    40,    56,    58,    62,    63,    64,    65,
+      66,    67,    71,    82,    94,    96,    43,    44,    31,    36,
+      36,    50,    85,    57,    36,    85,    46,    46,    43,    36,
+      46,    47,    59,    60,    61,    68,    72,    73,    64,    31,
+      85,     1,    62,    86,    87,    88,    58,    62,    85,    63,
+      36,     1,    72,    69,    70,    71,    43,    45,    72,    29,
+      31,    95,    32,    46,    43,    44,    36,    40,    46,    51,
+      68,    74,    75,    89,    90,    91,    92,    44,     1,    88,
+      72,    47,    48,    48,    48,    48,    71,    61,    30,    93,
+       1,    63,    76,    77,    78,    79,    92,     1,    36,    74,
+      33,    74,    93,    32,    46,    43,    45,    48,    43,    49,
+      83,    84,    48,    36,    40,    46,    68,    80,    81,    48,
+      35,    45,    48,    48,     1,    76,    91,    33,     1,    40,
+      80,    80,    32,    46,    35,    79,    48,    48,    48,    48,
+       1,    76,    48,    48
+};
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { 								\
+      yyerror ("syntax error: cannot back up");\
+      YYERROR;							\
+    }								\
+while (0)
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (N)								\
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (0)
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+              (Loc).first_line, (Loc).first_column,	\
+              (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr, 					\
+                  Type, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short int *bottom, short int *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    short int *bottom;
+    short int *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
+#endif
+{
+  int yyi;
+  unsigned int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
+             yyrule - 1, yylno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+#endif /* !YYERROR_VERBOSE */
+
+
+
+#if YYDEBUG
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF (yyoutput, ")");
+}
+
+#endif /* ! YYDEBUG */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+        break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM);
+# else
+int yyparse ();
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  register int yystate;
+  register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short int yyssa[YYINITDEPTH];
+  short int *yyss = yyssa;
+  register short int *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+
+  yyvsp[0] = yylval;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short int *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyoverflowlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short int *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a look-ahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+#line 107 "scripts/genksyms/parse.y"
+    { is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; ;}
+    break;
+
+  case 5:
+#line 109 "scripts/genksyms/parse.y"
+    { free_list(*(yyvsp[0]), NULL); *(yyvsp[0]) = NULL; ;}
+    break;
+
+  case 6:
+#line 113 "scripts/genksyms/parse.y"
+    { is_typedef = 1; ;}
+    break;
+
+  case 7:
+#line 114 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 12:
+#line 119 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 13:
+#line 120 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 14:
+#line 125 "scripts/genksyms/parse.y"
+    { if (current_name) {
+		    struct string_list *decl = (*(yyvsp[0]))->next;
+		    (*(yyvsp[0]))->next = NULL;
+		    add_symbol(current_name,
+			       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,
+			       decl, is_extern);
+		    current_name = NULL;
+		  }
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 15:
+#line 138 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 17:
+#line 144 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[0]);
+		  *(yyvsp[0]) = NULL;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 18:
+#line 152 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[0]);
+		  *(yyvsp[0]) = NULL;
+		  free_list(*(yyvsp[-1]), NULL);
+		  *(yyvsp[-1]) = decl_spec;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 19:
+#line 165 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]) ? (yyvsp[0]) : (yyvsp[-1]) ? (yyvsp[-1]) : (yyvsp[-2]) ? (yyvsp[-2]) : (yyvsp[-3]); ;}
+    break;
+
+  case 20:
+#line 170 "scripts/genksyms/parse.y"
+    { decl_spec = NULL; ;}
+    break;
+
+  case 22:
+#line 175 "scripts/genksyms/parse.y"
+    { decl_spec = *(yyvsp[0]); ;}
+    break;
+
+  case 23:
+#line 176 "scripts/genksyms/parse.y"
+    { decl_spec = *(yyvsp[0]); ;}
+    break;
+
+  case 24:
+#line 181 "scripts/genksyms/parse.y"
+    { /* Version 2 checksumming ignores storage class, as that
+		     is really irrelevant to the linkage.  */
+		  remove_node((yyvsp[0]));
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 29:
+#line 193 "scripts/genksyms/parse.y"
+    { is_extern = 1; (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 30:
+#line 194 "scripts/genksyms/parse.y"
+    { is_extern = 0; (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 35:
+#line 206 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[-1])); (*(yyvsp[0]))->tag = SYM_STRUCT; (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 36:
+#line 208 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[-1])); (*(yyvsp[0]))->tag = SYM_UNION; (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 37:
+#line 210 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[-1])); (*(yyvsp[0]))->tag = SYM_ENUM; (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 38:
+#line 214 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[0]), *i = *(yyvsp[-1]), *r;
+		  r = copy_node(i); r->tag = SYM_STRUCT;
+		  r->next = (*(yyvsp[-2]))->next; *(yyvsp[0]) = r; (*(yyvsp[-2]))->next = NULL;
+		  add_symbol(i->string, SYM_STRUCT, s, is_extern);
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 39:
+#line 221 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[0]), *i = *(yyvsp[-1]), *r;
+		  r = copy_node(i); r->tag = SYM_UNION;
+		  r->next = (*(yyvsp[-2]))->next; *(yyvsp[0]) = r; (*(yyvsp[-2]))->next = NULL;
+		  add_symbol(i->string, SYM_UNION, s, is_extern);
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 40:
+#line 228 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[0]), *i = *(yyvsp[-1]), *r;
+		  r = copy_node(i); r->tag = SYM_ENUM;
+		  r->next = (*(yyvsp[-2]))->next; *(yyvsp[0]) = r; (*(yyvsp[-2]))->next = NULL;
+		  add_symbol(i->string, SYM_ENUM, s, is_extern);
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 41:
+#line 236 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 42:
+#line 237 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 43:
+#line 238 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 54:
+#line 252 "scripts/genksyms/parse.y"
+    { (*(yyvsp[0]))->tag = SYM_TYPEDEF; (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 55:
+#line 257 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]) ? (yyvsp[0]) : (yyvsp[-1]); ;}
+    break;
+
+  case 56:
+#line 261 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 59:
+#line 267 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 63:
+#line 273 "scripts/genksyms/parse.y"
+    { /* restrict has no effect in prototypes so ignore it */
+		  remove_node((yyvsp[0]));
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 64:
+#line 280 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 66:
+#line 286 "scripts/genksyms/parse.y"
+    { if (current_name != NULL) {
+		    error_with_pos("unexpected second declaration name");
+		    YYERROR;
+		  } else {
+		    current_name = (*(yyvsp[0]))->string;
+		    (yyval) = (yyvsp[0]);
+		  }
+		;}
+    break;
+
+  case 67:
+#line 295 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 68:
+#line 297 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 69:
+#line 299 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 70:
+#line 301 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 71:
+#line 303 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 72:
+#line 309 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 76:
+#line 317 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 77:
+#line 319 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 78:
+#line 321 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 79:
+#line 323 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 80:
+#line 325 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 81:
+#line 329 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 83:
+#line 331 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 84:
+#line 335 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 87:
+#line 342 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 88:
+#line 347 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]) ? (yyvsp[0]) : (yyvsp[-1]); ;}
+    break;
+
+  case 89:
+#line 352 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]) ? (yyvsp[0]) : (yyvsp[-1]); ;}
+    break;
+
+  case 91:
+#line 357 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 92:
+#line 359 "scripts/genksyms/parse.y"
+    { /* For version 2 checksums, we don't want to remember
+		     private parameter names.  */
+		  remove_node((yyvsp[0]));
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 93:
+#line 367 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[0]));
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 94:
+#line 371 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 95:
+#line 373 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 96:
+#line 375 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 97:
+#line 377 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 98:
+#line 379 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 99:
+#line 384 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[-1]);
+		  *(yyvsp[-1]) = NULL;
+		  add_symbol(current_name, SYM_NORMAL, decl, is_extern);
+		  (yyval) = (yyvsp[0]);
+		;}
+    break;
+
+  case 100:
+#line 392 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 102:
+#line 399 "scripts/genksyms/parse.y"
+    { remove_list((yyvsp[0]), &(*(yyvsp[-1]))->next); (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 103:
+#line 403 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 104:
+#line 404 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 105:
+#line 408 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 108:
+#line 414 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 109:
+#line 419 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 110:
+#line 421 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 111:
+#line 425 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 114:
+#line 431 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 115:
+#line 435 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]) ? (yyvsp[0]) : (yyvsp[-1]); ;}
+    break;
+
+  case 116:
+#line 436 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 118:
+#line 441 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 119:
+#line 445 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 121:
+#line 450 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[0]); ;}
+    break;
+
+  case 122:
+#line 454 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 124:
+#line 460 "scripts/genksyms/parse.y"
+    { export_symbol((*(yyvsp[-2]))->string); (yyval) = (yyvsp[0]); ;}
+    break;
+
+
+    }
+
+/* Line 1037 of yacc.c.  */
+#line 1816 "scripts/genksyms/parse.c"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+
+
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  YYSIZE_T yysize = 0;
+	  int yytype = YYTRANSLATE (yychar);
+	  const char* yyprefix;
+	  char *yymsg;
+	  int yyx;
+
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	  /* Stay within bounds of both yycheck and yytname.  */
+	  int yychecklim = YYLAST - yyn;
+	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+	  int yycount = 0;
+
+	  yyprefix = ", expecting ";
+	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      {
+		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
+		yycount += 1;
+		if (yycount == 5)
+		  {
+		    yysize = 0;
+		    break;
+		  }
+	      }
+	  yysize += (sizeof ("syntax error, unexpected ")
+		     + yystrlen (yytname[yytype]));
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
+	    {
+	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[yytype]);
+
+	      if (yycount < 5)
+		{
+		  yyprefix = ", expecting ";
+		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+		      {
+			yyp = yystpcpy (yyp, yyprefix);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yyprefix = " or ";
+		      }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    yyerror ("syntax error; also virtual memory exhausted");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror ("syntax error");
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* If at end of input, pop the error token,
+	     then the rest of the stack, then return failure.  */
+	  if (yychar == YYEOF)
+	     for (;;)
+	       {
+
+		 YYPOPSTACK;
+		 if (yyssp == yyss)
+		   YYABORT;
+		 yydestruct ("Error: popping",
+                             yystos[*yyssp], yyvsp);
+	       }
+        }
+      else
+	{
+	  yydestruct ("Error: discarding", yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+#ifdef __GNUC__
+  /* Pacify GCC when the user code never invokes YYERROR and the label
+     yyerrorlab therefore never appears in user code.  */
+  if (0)
+     goto yyerrorlab;
+#endif
+
+yyvsp -= yylen;
+  yyssp -= yylen;
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping", yystos[yystate], yyvsp);
+      YYPOPSTACK;
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token. */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yydestruct ("Error: discarding lookahead",
+              yytoken, &yylval);
+  yychar = YYEMPTY;
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*----------------------------------------------.
+| yyoverflowlab -- parser overflow comes here.  |
+`----------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+}
+
+
+#line 464 "scripts/genksyms/parse.y"
+
+
+static void
+yyerror(const char *e)
+{
+  error_with_pos("%s", e);
+}
+
Index: build_tree/linux/scripts/genksyms/parse.h
diff -u /dev/null build_tree/linux/scripts/genksyms/parse.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/scripts/genksyms/parse.h	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,128 @@
+/* A Bison parser, made by GNU Bison 2.0.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     FLOAT_KEYW = 267,
+     INLINE_KEYW = 268,
+     INT_KEYW = 269,
+     LONG_KEYW = 270,
+     REGISTER_KEYW = 271,
+     RESTRICT_KEYW = 272,
+     SHORT_KEYW = 273,
+     SIGNED_KEYW = 274,
+     STATIC_KEYW = 275,
+     STRUCT_KEYW = 276,
+     TYPEDEF_KEYW = 277,
+     UNION_KEYW = 278,
+     UNSIGNED_KEYW = 279,
+     VOID_KEYW = 280,
+     VOLATILE_KEYW = 281,
+     TYPEOF_KEYW = 282,
+     EXPORT_SYMBOL_KEYW = 283,
+     ASM_PHRASE = 284,
+     ATTRIBUTE_PHRASE = 285,
+     BRACE_PHRASE = 286,
+     BRACKET_PHRASE = 287,
+     EXPRESSION_PHRASE = 288,
+     CHAR = 289,
+     DOTS = 290,
+     IDENT = 291,
+     INT = 292,
+     REAL = 293,
+     STRING = 294,
+     TYPE = 295,
+     OTHER = 296,
+     FILENAME = 297
+   };
+#endif
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define FLOAT_KEYW 267
+#define INLINE_KEYW 268
+#define INT_KEYW 269
+#define LONG_KEYW 270
+#define REGISTER_KEYW 271
+#define RESTRICT_KEYW 272
+#define SHORT_KEYW 273
+#define SIGNED_KEYW 274
+#define STATIC_KEYW 275
+#define STRUCT_KEYW 276
+#define TYPEDEF_KEYW 277
+#define UNION_KEYW 278
+#define UNSIGNED_KEYW 279
+#define VOID_KEYW 280
+#define VOLATILE_KEYW 281
+#define TYPEOF_KEYW 282
+#define EXPORT_SYMBOL_KEYW 283
+#define ASM_PHRASE 284
+#define ATTRIBUTE_PHRASE 285
+#define BRACE_PHRASE 286
+#define BRACKET_PHRASE 287
+#define EXPRESSION_PHRASE 288
+#define CHAR 289
+#define DOTS 290
+#define IDENT 291
+#define INT 292
+#define REAL 293
+#define STRING 294
+#define TYPE 295
+#define OTHER 296
+#define FILENAME 297
+
+
+
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
+
+
Index: build_tree/linux/scripts/kconfig/lex.zconf.c
diff -u /dev/null build_tree/linux/scripts/kconfig/lex.zconf.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/scripts/kconfig/lex.zconf.c	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,2350 @@
+
+#line 3 "scripts/kconfig/lex.zconf.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types.
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap() 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( zconftext, zconfleng, 1, zconfout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	if (file->flags & FILE_BUSY) {
+		printf("recursive scan (%s)?\n", name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("file %s already scanned?\n", name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
Index: build_tree/linux/scripts/kconfig/zconf.hash.c
diff -u /dev/null build_tree/linux/scripts/kconfig/zconf.hash.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/scripts/kconfig/zconf.hash.c	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,242 @@
+/* ANSI-C code produced by gperf version 3.0.1 */
+/* Command-line: gperf  */
+/* Computed positions: -k'1,3' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+struct kconf_id;
+/* maximum key range = 45, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 25, 30, 15,
+       0, 15,  0, 47,  5, 15, 47, 47, 30, 20,
+       5,  0, 25, 15,  0,  0, 10, 35, 47, 47,
+       5, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval;
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("on")];
+    char kconf_id_strings_str6[sizeof("string")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("def_bool")];
+    char kconf_id_strings_str10[sizeof("range")];
+    char kconf_id_strings_str11[sizeof("def_boolean")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
+    char kconf_id_strings_str13[sizeof("hex")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str16[sizeof("option")];
+    char kconf_id_strings_str17[sizeof("if")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str20[sizeof("endif")];
+    char kconf_id_strings_str21[sizeof("choice")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("requires")];
+    char kconf_id_strings_str24[sizeof("endchoice")];
+    char kconf_id_strings_str26[sizeof("config")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str28[sizeof("int")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("prompt")];
+    char kconf_id_strings_str32[sizeof("depends")];
+    char kconf_id_strings_str33[sizeof("tristate")];
+    char kconf_id_strings_str34[sizeof("bool")];
+    char kconf_id_strings_str35[sizeof("menuconfig")];
+    char kconf_id_strings_str36[sizeof("select")];
+    char kconf_id_strings_str37[sizeof("boolean")];
+    char kconf_id_strings_str39[sizeof("help")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("comment")];
+    char kconf_id_strings_str43[sizeof("mainmenu")];
+    char kconf_id_strings_str46[sizeof("enable")];
+  };
+static struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "on",
+    "string",
+    "default",
+    "def_bool",
+    "range",
+    "def_boolean",
+    "def_tristate",
+    "hex",
+    "defconfig_list",
+    "option",
+    "if",
+    "optional",
+    "endif",
+    "choice",
+    "endmenu",
+    "requires",
+    "endchoice",
+    "config",
+    "modules",
+    "int",
+    "menu",
+    "prompt",
+    "depends",
+    "tristate",
+    "bool",
+    "menuconfig",
+    "select",
+    "boolean",
+    "help",
+    "source",
+    "comment",
+    "mainmenu",
+    "enable"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#endif
+struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 33,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 46
+    };
+
+  static struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
+      {-1}, {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_TYPE,		TF_COMMAND, S_STRING},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,		T_TYPE,		TF_COMMAND, S_HEX},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_OPTION,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_IF,		TF_COMMAND|TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str20,		T_ENDIF,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_CHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_REQUIRES,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str24,	T_ENDCHOICE,	TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str26,		T_CONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,		T_TYPE,		TF_COMMAND, S_INT},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_PROMPT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_DEPENDS,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str34,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_SELECT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_HELP,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_COMMENT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,	T_MAINMENU,	TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_SELECT,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+
Index: build_tree/linux/scripts/kconfig/zconf.tab.c
diff -u /dev/null build_tree/linux/scripts/kconfig/zconf.tab.c:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:45 2008
+++ build_tree/linux/scripts/kconfig/zconf.tab.c	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,2345 @@
+/* A Bison parser, made by GNU Bison 2.1.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse zconfparse
+#define yylex   zconflex
+#define yyerror zconferror
+#define yylval  zconflval
+#define yychar  zconfchar
+#define yydebug zconfdebug
+#define yynerrs zconfnerrs
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_REQUIRES = 272,
+     T_OPTIONAL = 273,
+     T_PROMPT = 274,
+     T_TYPE = 275,
+     T_DEFAULT = 276,
+     T_SELECT = 277,
+     T_RANGE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+/* Tokens.  */
+#define T_MAINMENU 258
+#define T_MENU 259
+#define T_ENDMENU 260
+#define T_SOURCE 261
+#define T_CHOICE 262
+#define T_ENDCHOICE 263
+#define T_COMMENT 264
+#define T_CONFIG 265
+#define T_MENUCONFIG 266
+#define T_HELP 267
+#define T_HELPTEXT 268
+#define T_IF 269
+#define T_ENDIF 270
+#define T_DEPENDS 271
+#define T_REQUIRES 272
+#define T_OPTIONAL 273
+#define T_PROMPT 274
+#define T_TYPE 275
+#define T_DEFAULT 276
+#define T_SELECT 277
+#define T_RANGE 278
+#define T_OPTION 279
+#define T_ON 280
+#define T_WORD 281
+#define T_WORD_QUOTE 282
+#define T_UNEQUAL 283
+#define T_CLOSE_PAREN 284
+#define T_OPEN_PAREN 285
+#define T_EOL 286
+#define T_OR 287
+#define T_AND 288
+#define T_EQUAL 289
+#define T_NOT 290
+
+
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#include "zconf.hash.c"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+static struct menu *current_menu, *current_entry;
+
+#define YYDEBUG 0
+#if YYDEBUG
+#define YYERROR_VERBOSE
+#endif
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+
+typedef union YYSTYPE {
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	struct kconf_id *id;
+} YYSTYPE;
+/* Line 196 of yacc.c.  */
+
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 219 of yacc.c.  */
+
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T) && (defined (__STDC__) || defined (__cplusplus))
+# include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if defined (__STDC__) || defined (__cplusplus)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     define YYINCLUDED_STDLIB_H
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2005 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM ((YYSIZE_T) -1)
+#  endif
+#  ifdef __cplusplus
+extern "C" {
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if (! defined (free) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifdef __cplusplus
+}
+#  endif
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short int yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short int) + sizeof (YYSTYPE))			\
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined (__GNUC__) && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short int yysigned_char;
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   275
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  45
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  110
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  183
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned short int yyprhs[] =
+{
+       0,     0,     3,     5,     6,     9,    12,    15,    20,    23,
+      28,    33,    37,    39,    41,    43,    45,    47,    49,    51,
+      53,    55,    57,    59,    61,    63,    67,    70,    74,    77,
+      81,    84,    85,    88,    91,    94,    97,   100,   103,   107,
+     112,   117,   122,   128,   132,   133,   137,   138,   141,   144,
+     147,   149,   153,   154,   157,   160,   163,   166,   169,   174,
+     178,   181,   186,   187,   190,   194,   196,   200,   201,   204,
+     207,   210,   214,   217,   219,   223,   224,   227,   230,   233,
+     237,   241,   244,   247,   250,   251,   254,   257,   260,   265,
+     269,   273,   274,   277,   279,   281,   284,   287,   290,   292,
+     295,   296,   299,   301,   305,   309,   313,   316,   320,   324,
+     326
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      37,     0,    -1,    38,    -1,    -1,    38,    40,    -1,    38,
+      54,    -1,    38,    65,    -1,    38,     3,    75,    77,    -1,
+      38,    76,    -1,    38,    26,     1,    31,    -1,    38,    39,
+       1,    31,    -1,    38,     1,    31,    -1,    16,    -1,    19,
+      -1,    20,    -1,    22,    -1,    18,    -1,    23,    -1,    21,
+      -1,    31,    -1,    60,    -1,    69,    -1,    43,    -1,    45,
+      -1,    67,    -1,    26,     1,    31,    -1,     1,    31,    -1,
+      10,    26,    31,    -1,    42,    46,    -1,    11,    26,    31,
+      -1,    44,    46,    -1,    -1,    46,    47,    -1,    46,    48,
+      -1,    46,    73,    -1,    46,    71,    -1,    46,    41,    -1,
+      46,    31,    -1,    20,    74,    31,    -1,    19,    75,    78,
+      31,    -1,    21,    79,    78,    31,    -1,    22,    26,    78,
+      31,    -1,    23,    80,    80,    78,    31,    -1,    24,    49,
+      31,    -1,    -1,    49,    26,    50,    -1,    -1,    34,    75,
+      -1,     7,    31,    -1,    51,    55,    -1,    76,    -1,    52,
+      57,    53,    -1,    -1,    55,    56,    -1,    55,    73,    -1,
+      55,    71,    -1,    55,    31,    -1,    55,    41,    -1,    19,
+      75,    78,    31,    -1,    20,    74,    31,    -1,    18,    31,
+      -1,    21,    26,    78,    31,    -1,    -1,    57,    40,    -1,
+      14,    79,    77,    -1,    76,    -1,    58,    61,    59,    -1,
+      -1,    61,    40,    -1,    61,    65,    -1,    61,    54,    -1,
+       4,    75,    31,    -1,    62,    72,    -1,    76,    -1,    63,
+      66,    64,    -1,    -1,    66,    40,    -1,    66,    65,    -1,
+      66,    54,    -1,     6,    75,    31,    -1,     9,    75,    31,
+      -1,    68,    72,    -1,    12,    31,    -1,    70,    13,    -1,
+      -1,    72,    73,    -1,    72,    31,    -1,    72,    41,    -1,
+      16,    25,    79,    31,    -1,    16,    79,    31,    -1,    17,
+      79,    31,    -1,    -1,    75,    78,    -1,    26,    -1,    27,
+      -1,     5,    31,    -1,     8,    31,    -1,    15,    31,    -1,
+      31,    -1,    77,    31,    -1,    -1,    14,    79,    -1,    80,
+      -1,    80,    34,    80,    -1,    80,    28,    80,    -1,    30,
+      79,    29,    -1,    35,    79,    -1,    79,    32,    79,    -1,
+      79,    33,    79,    -1,    26,    -1,    27,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short int yyrline[] =
+{
+       0,   105,   105,   107,   109,   110,   111,   112,   113,   114,
+     115,   119,   123,   123,   123,   123,   123,   123,   123,   127,
+     128,   129,   130,   131,   132,   136,   137,   143,   151,   157,
+     165,   175,   177,   178,   179,   180,   181,   182,   185,   193,
+     199,   209,   215,   221,   224,   226,   237,   238,   243,   252,
+     257,   265,   268,   270,   271,   272,   273,   274,   277,   283,
+     294,   300,   310,   312,   317,   325,   333,   336,   338,   339,
+     340,   345,   352,   357,   365,   368,   370,   371,   372,   375,
+     383,   390,   397,   403,   410,   412,   413,   414,   417,   422,
+     427,   435,   437,   442,   443,   446,   447,   448,   452,   453,
+     456,   457,   460,   461,   462,   463,   464,   465,   466,   469,
+     470
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_REQUIRES", "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT",
+  "T_SELECT", "T_RANGE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE",
+  "T_UNEQUAL", "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND",
+  "T_EQUAL", "T_NOT", "$accept", "input", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "menu", "menu_entry",
+  "menu_end", "menu_stmt", "menu_block", "source_stmt", "comment",
+  "comment_stmt", "help_start", "help", "depends_list", "depends",
+  "prompt_stmt_opt", "prompt", "end", "nl", "if_expr", "expr", "symbol", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short int yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    36,    37,    38,    38,    38,    38,    38,    38,    38,
+      38,    38,    39,    39,    39,    39,    39,    39,    39,    40,
+      40,    40,    40,    40,    40,    41,    41,    42,    43,    44,
+      45,    46,    46,    46,    46,    46,    46,    46,    47,    47,
+      47,    47,    47,    48,    49,    49,    50,    50,    51,    52,
+      53,    54,    55,    55,    55,    55,    55,    55,    56,    56,
+      56,    56,    57,    57,    58,    59,    60,    61,    61,    61,
+      61,    62,    63,    64,    65,    66,    66,    66,    66,    67,
+      68,    69,    70,    71,    72,    72,    72,    72,    73,    73,
+      73,    74,    74,    75,    75,    76,    76,    76,    77,    77,
+      78,    78,    79,    79,    79,    79,    79,    79,    79,    80,
+      80
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     1,     0,     2,     2,     2,     4,     2,     4,
+       4,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     3,     2,     3,     2,     3,
+       2,     0,     2,     2,     2,     2,     2,     2,     3,     4,
+       4,     4,     5,     3,     0,     3,     0,     2,     2,     2,
+       1,     3,     0,     2,     2,     2,     2,     2,     4,     3,
+       2,     4,     0,     2,     3,     1,     3,     0,     2,     2,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     3,
+       3,     2,     2,     2,     0,     2,     2,     2,     4,     3,
+       3,     0,     2,     1,     1,     2,     2,     2,     1,     2,
+       0,     2,     1,     3,     3,     3,     2,     3,     3,     1,
+       1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       3,     0,     0,     1,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    12,    16,    13,    14,
+      18,    15,    17,     0,    19,     0,     4,    31,    22,    31,
+      23,    52,    62,     5,    67,    20,    84,    75,     6,    24,
+      84,    21,     8,    11,    93,    94,     0,     0,    95,     0,
+      48,    96,     0,     0,     0,   109,   110,     0,     0,     0,
+     102,    97,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    98,     7,    71,    79,    80,    27,    29,     0,
+     106,     0,     0,    64,     0,     0,     9,    10,     0,     0,
+       0,     0,     0,    91,     0,     0,     0,    44,     0,    37,
+      36,    32,    33,     0,    35,    34,     0,     0,    91,     0,
+      56,    57,    53,    55,    54,    63,    51,    50,    68,    70,
+      66,    69,    65,    86,    87,    85,    76,    78,    74,    77,
+      73,    99,   105,   107,   108,   104,   103,    26,    82,     0,
+       0,     0,   100,     0,   100,   100,   100,     0,     0,     0,
+      83,    60,   100,     0,   100,     0,    89,    90,     0,     0,
+      38,    92,     0,     0,   100,    46,    43,    25,     0,    59,
+       0,    88,   101,    39,    40,    41,     0,     0,    45,    58,
+      61,    42,    47
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const short int yydefgoto[] =
+{
+      -1,     1,     2,    25,    26,   100,    27,    28,    29,    30,
+      64,   101,   102,   148,   178,    31,    32,   116,    33,    66,
+     112,    67,    34,   120,    35,    68,    36,    37,   128,    38,
+      70,    39,    40,    41,   103,   104,    69,   105,   143,   144,
+      42,    73,   159,    59,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -135
+static const short int yypact[] =
+{
+    -135,     2,   170,  -135,   -14,    56,    56,    -8,    56,    24,
+      67,    56,     7,    14,    62,    97,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,   156,  -135,   166,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,   138,   151,  -135,   152,
+    -135,  -135,   163,   167,   176,  -135,  -135,    62,    62,   185,
+     -19,  -135,   188,   190,    42,   103,   194,    85,    70,   222,
+      70,   132,  -135,   191,  -135,  -135,  -135,  -135,  -135,   127,
+    -135,    62,    62,   191,   104,   104,  -135,  -135,   193,   203,
+       9,    62,    56,    56,    62,   161,   104,  -135,   196,  -135,
+    -135,  -135,  -135,   233,  -135,  -135,   204,    56,    56,   221,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,   219,  -135,  -135,  -135,  -135,  -135,    62,
+     209,   212,   240,   224,   240,    -1,   240,   104,    41,   225,
+    -135,  -135,   240,   226,   240,   218,  -135,  -135,    62,   227,
+    -135,  -135,   228,   229,   240,   230,  -135,  -135,   231,  -135,
+     232,  -135,   112,  -135,  -135,  -135,   234,    56,  -135,  -135,
+    -135,  -135,  -135
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const short int yypgoto[] =
+{
+    -135,  -135,  -135,  -135,    94,   -45,  -135,  -135,  -135,  -135,
+     237,  -135,  -135,  -135,  -135,  -135,  -135,  -135,   -54,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,     1,
+    -135,  -135,  -135,  -135,  -135,   195,   235,   -44,   159,    -5,
+      98,   210,  -134,   -53,   -77
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -82
+static const short int yytable[] =
+{
+      46,    47,     3,    49,    79,    80,    52,   135,   136,    84,
+     161,   162,   163,   158,   119,    85,   127,    43,   168,   147,
+     170,   111,   114,    48,   124,   125,   124,   125,   133,   134,
+     176,    81,    82,    53,   139,    55,    56,   140,   141,    57,
+      54,   145,   -28,    88,    58,   -28,   -28,   -28,   -28,   -28,
+     -28,   -28,   -28,   -28,    89,    50,   -28,   -28,    90,    91,
+     -28,    92,    93,    94,    95,    96,    97,   165,    98,   121,
+     164,   129,   166,    99,     6,     7,     8,     9,    10,    11,
+      12,    13,    44,    45,    14,    15,   155,   142,    55,    56,
+       7,     8,    57,    10,    11,    12,    13,    58,    51,    14,
+      15,    24,   152,   -30,    88,   172,   -30,   -30,   -30,   -30,
+     -30,   -30,   -30,   -30,   -30,    89,    24,   -30,   -30,    90,
+      91,   -30,    92,    93,    94,    95,    96,    97,    61,    98,
+      55,    56,   -81,    88,    99,   -81,   -81,   -81,   -81,   -81,
+     -81,   -81,   -81,   -81,    81,    82,   -81,   -81,    90,    91,
+     -81,   -81,   -81,   -81,   -81,   -81,   132,    62,    98,    81,
+      82,   115,   118,   123,   126,   117,   122,    63,   130,    72,
+      -2,     4,   182,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    74,    75,    14,    15,    16,   146,    17,    18,
+      19,    20,    21,    22,    76,    88,    23,   149,    77,   -49,
+     -49,    24,   -49,   -49,   -49,   -49,    89,    78,   -49,   -49,
+      90,    91,   106,   107,   108,   109,    72,    81,    82,    86,
+      98,    87,   131,    88,   137,   110,   -72,   -72,   -72,   -72,
+     -72,   -72,   -72,   -72,   138,   151,   -72,   -72,    90,    91,
+     156,    81,    82,   157,    81,    82,   150,   154,    98,   171,
+      81,    82,    82,   123,   158,   160,   167,   169,   173,   174,
+     175,   113,   179,   180,   177,   181,    65,   153,     0,    83,
+       0,     0,     0,     0,     0,    71
+};
+
+static const short int yycheck[] =
+{
+       5,     6,     0,     8,    57,    58,    11,    84,    85,    28,
+     144,   145,   146,    14,    68,    34,    70,    31,   152,    96,
+     154,    66,    66,    31,    69,    69,    71,    71,    81,    82,
+     164,    32,    33,    26,    25,    26,    27,    90,    91,    30,
+      26,    94,     0,     1,    35,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    31,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    26,    26,    68,
+     147,    70,    31,    31,     4,     5,     6,     7,     8,     9,
+      10,    11,    26,    27,    14,    15,   139,    92,    26,    27,
+       5,     6,    30,     8,     9,    10,    11,    35,    31,    14,
+      15,    31,   107,     0,     1,   158,     3,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    31,    26,
+      26,    27,     0,     1,    31,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    32,    33,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    29,     1,    26,    32,
+      33,    67,    68,    31,    70,    67,    68,     1,    70,    31,
+       0,     1,   177,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    31,    31,    14,    15,    16,    26,    18,    19,
+      20,    21,    22,    23,    31,     1,    26,     1,    31,     5,
+       6,    31,     8,     9,    10,    11,    12,    31,    14,    15,
+      16,    17,    18,    19,    20,    21,    31,    32,    33,    31,
+      26,    31,    31,     1,    31,    31,     4,     5,     6,     7,
+       8,     9,    10,    11,    31,    31,    14,    15,    16,    17,
+      31,    32,    33,    31,    32,    33,    13,    26,    26,    31,
+      32,    33,    33,    31,    14,    31,    31,    31,    31,    31,
+      31,    66,    31,    31,    34,    31,    29,   108,    -1,    59,
+      -1,    -1,    -1,    -1,    -1,    40
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    37,    38,     0,     1,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    14,    15,    16,    18,    19,    20,
+      21,    22,    23,    26,    31,    39,    40,    42,    43,    44,
+      45,    51,    52,    54,    58,    60,    62,    63,    65,    67,
+      68,    69,    76,    31,    26,    27,    75,    75,    31,    75,
+      31,    31,    75,    26,    26,    26,    27,    30,    35,    79,
+      80,    31,     1,     1,    46,    46,    55,    57,    61,    72,
+      66,    72,    31,    77,    31,    31,    31,    31,    31,    79,
+      79,    32,    33,    77,    28,    34,    31,    31,     1,    12,
+      16,    17,    19,    20,    21,    22,    23,    24,    26,    31,
+      41,    47,    48,    70,    71,    73,    18,    19,    20,    21,
+      31,    41,    56,    71,    73,    40,    53,    76,    40,    54,
+      59,    65,    76,    31,    41,    73,    40,    54,    64,    65,
+      76,    31,    29,    79,    79,    80,    80,    31,    31,    25,
+      79,    79,    75,    74,    75,    79,    26,    80,    49,     1,
+      13,    31,    75,    74,    26,    79,    31,    31,    14,    78,
+      31,    78,    78,    78,    80,    26,    31,    31,    78,    31,
+      78,    31,    79,    31,    31,    31,    78,    34,    50,    31,
+      31,    31,    75
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (0)
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (N)								\
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (0)
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+              (Loc).first_line, (Loc).first_column,	\
+              (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr,					\
+                  Type, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short int *bottom, short int *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    short int *bottom;
+    short int *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
+#endif
+{
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu), ",
+             yyrule - 1, yylno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname[yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      size_t yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+#endif /* YYERROR_VERBOSE */
+
+
+
+#if YYDEBUG
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF (yyoutput, ")");
+}
+
+#endif /* ! YYDEBUG */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 52: /* "choice_entry" */
+
+        {
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+        break;
+      case 58: /* "if_entry" */
+
+        {
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+        break;
+      case 63: /* "menu_entry" */
+
+        {
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+        break;
+
+      default:
+        break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM);
+# else
+int yyparse ();
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+    ;
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short int yyssa[YYINITDEPTH];
+  short int *yyss = yyssa;
+  short int *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short int *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short int *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a look-ahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 8:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 9:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[-2].string)); ;}
+    break;
+
+  case 10:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[-2].id)->name);
+;}
+    break;
+
+  case 11:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 25:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[-2].string)); ;}
+    break;
+
+  case 26:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 27:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[-1].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[-1].string));
+;}
+    break;
+
+  case 28:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 29:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[-1].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[-1].string));
+;}
+    break;
+
+  case 30:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 38:
+
+    {
+	menu_set_type((yyvsp[-2].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[-2].id)->stype);
+;}
+    break;
+
+  case 39:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[-2].string), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 40:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[-2].expr), (yyvsp[-1].expr));
+	if ((yyvsp[-3].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[-3].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[-3].id)->stype);
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[-2].string), 0), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[-3].symbol), (yyvsp[-2].symbol)), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	struct kconf_id *id = kconf_id_lookup((yyvsp[-1].string), strlen((yyvsp[-1].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[0].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[-1].string));
+	free((yyvsp[-1].string));
+;}
+    break;
+
+  case 46:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 47:
+
+    { (yyval.string) = (yyvsp[0].string); ;}
+    break;
+
+  case 48:
+
+    {
+	struct symbol *sym = sym_lookup(NULL, 0);
+	sym->flags |= SYMBOL_CHOICE;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 49:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 50:
+
+    {
+	if (zconf_endtoken((yyvsp[0].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 58:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[-2].string), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 59:
+
+    {
+	if ((yyvsp[-2].id)->stype == S_BOOLEAN || (yyvsp[-2].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[-2].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[-2].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 60:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 61:
+
+    {
+	if ((yyvsp[-3].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[-2].string), 0), (yyvsp[-1].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 64:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[-1].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 65:
+
+    {
+	if (zconf_endtoken((yyvsp[0].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 71:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[-1].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 72:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 73:
+
+    {
+	if (zconf_endtoken((yyvsp[0].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 79:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[-1].string));
+	zconf_nextfile((yyvsp[-1].string));
+;}
+    break;
+
+  case 80:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[-1].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 81:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 82:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 83:
+
+    {
+	current_entry->sym->help = (yyvsp[0].string);
+;}
+    break;
+
+  case 88:
+
+    {
+	menu_add_dep((yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 89:
+
+    {
+	menu_add_dep((yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 90:
+
+    {
+	menu_add_dep((yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[-1].string), (yyvsp[0].expr));
+;}
+    break;
+
+  case 95:
+
+    { (yyval.id) = (yyvsp[-1].id); ;}
+    break;
+
+  case 96:
+
+    { (yyval.id) = (yyvsp[-1].id); ;}
+    break;
+
+  case 97:
+
+    { (yyval.id) = (yyvsp[-1].id); ;}
+    break;
+
+  case 100:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 101:
+
+    { (yyval.expr) = (yyvsp[0].expr); ;}
+    break;
+
+  case 102:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[0].symbol)); ;}
+    break;
+
+  case 103:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[-2].symbol), (yyvsp[0].symbol)); ;}
+    break;
+
+  case 104:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[-2].symbol), (yyvsp[0].symbol)); ;}
+    break;
+
+  case 105:
+
+    { (yyval.expr) = (yyvsp[-1].expr); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[0].expr)); ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[-2].expr), (yyvsp[0].expr)); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[-2].expr), (yyvsp[0].expr)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[0].string), 0); free((yyvsp[0].string)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[0].string), 1); free((yyvsp[0].string)); ;}
+    break;
+
+
+      default: break;
+    }
+
+/* Line 1126 of yacc.c.  */
+
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+
+
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  int yytype = YYTRANSLATE (yychar);
+	  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+	  YYSIZE_T yysize = yysize0;
+	  YYSIZE_T yysize1;
+	  int yysize_overflow = 0;
+	  char *yymsg = 0;
+#	  define YYERROR_VERBOSE_ARGS_MAXIMUM 5
+	  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+	  int yyx;
+
+#if 0
+	  /* This is so xgettext sees the translatable formats that are
+	     constructed on the fly.  */
+	  YY_("syntax error, unexpected %s");
+	  YY_("syntax error, unexpected %s, expecting %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+#endif
+	  char *yyfmt;
+	  char const *yyf;
+	  static char const yyunexpected[] = "syntax error, unexpected %s";
+	  static char const yyexpecting[] = ", expecting %s";
+	  static char const yyor[] = " or %s";
+	  char yyformat[sizeof yyunexpected
+			+ sizeof yyexpecting - 1
+			+ ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+			   * (sizeof yyor - 1))];
+	  char const *yyprefix = yyexpecting;
+
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	  /* Stay within bounds of both yycheck and yytname.  */
+	  int yychecklim = YYLAST - yyn;
+	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+	  int yycount = 1;
+
+	  yyarg[0] = yytname[yytype];
+	  yyfmt = yystpcpy (yyformat, yyunexpected);
+
+	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      {
+		if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+		  {
+		    yycount = 1;
+		    yysize = yysize0;
+		    yyformat[sizeof yyunexpected - 1] = '\0';
+		    break;
+		  }
+		yyarg[yycount++] = yytname[yyx];
+		yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+		yysize_overflow |= yysize1 < yysize;
+		yysize = yysize1;
+		yyfmt = yystpcpy (yyfmt, yyprefix);
+		yyprefix = yyor;
+	      }
+
+	  yyf = YY_(yyformat);
+	  yysize1 = yysize + yystrlen (yyf);
+	  yysize_overflow |= yysize1 < yysize;
+	  yysize = yysize1;
+
+	  if (!yysize_overflow && yysize <= YYSTACK_ALLOC_MAXIMUM)
+	    yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg)
+	    {
+	      /* Avoid sprintf, as that infringes on the user's name space.
+		 Don't have undefined behavior even if the translation
+		 produced a string with the wrong number of "%s"s.  */
+	      char *yyp = yymsg;
+	      int yyi = 0;
+	      while ((*yyp = *yyf))
+		{
+		  if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		    {
+		      yyp += yytnamerr (yyp, yyarg[yyi++]);
+		      yyf += 2;
+		    }
+		  else
+		    {
+		      yyp++;
+		      yyf++;
+		    }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    {
+	      yyerror (YY_("syntax error"));
+	      goto yyexhaustedlab;
+	    }
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror (YY_("syntax error"));
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+        }
+      else
+	{
+	  yydestruct ("Error: discarding", yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (0)
+     goto yyerrorlab;
+
+yyvsp -= yylen;
+  yyssp -= yylen;
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping", yystos[yystate], yyvsp);
+      YYPOPSTACK;
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token. */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK;
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+#if YYDEBUG
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+#endif
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		sym_check_deps(sym);
+        }
+
+	sym_set_change_count(1);
+}
+
+const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+#if YYDEBUG
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+#endif
+}
+
+void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "  help\n%s\n", sym->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
+
Index: build_tree/linux/scripts/mod/elfconfig.h
diff -u /dev/null build_tree/linux/scripts/mod/elfconfig.h:1.1.1.1
--- /dev/null	Tue Jan  8 14:21:46 2008
+++ build_tree/linux/scripts/mod/elfconfig.h	Fri Nov  9 13:48:02 2007
@@ -0,0 +1,5 @@
+#define KERNEL_ELFCLASS ELFCLASS32
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS32
+#define HOST_ELFDATA ELFDATA2LSB
+#define MODULE_SYMBOL_PREFIX ""
